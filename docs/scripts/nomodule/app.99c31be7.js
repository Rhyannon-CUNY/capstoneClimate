!(function () {
  'use strict';
  function t({ id: t, step: e, marginTop: i }) {
    const { index: r, height: n } = e,
      o = `scrollama__debug-step--${t}-${r}`;
    let a = document.querySelector(`.${o}`);
    a ||
      (a = (function (t) {
        const e = document.createElement('div');
        (e.className = `scrollama__debug-step ${t}`),
          (e.style.position = 'fixed'),
          (e.style.left = '0'),
          (e.style.width = '100%'),
          (e.style.zIndex = '9999'),
          (e.style.borderTop = '2px solid black'),
          (e.style.borderBottom = '2px solid black');
        const i = document.createElement('p');
        return (
          (i.style.position = 'absolute'),
          (i.style.left = '0'),
          (i.style.height = '1px'),
          (i.style.width = '100%'),
          (i.style.borderTop = '1px dashed black'),
          e.appendChild(i),
          document.body.appendChild(e),
          e
        );
      })(o)),
      (a.style.top = -1 * i + 'px'),
      (a.style.height = `${n}px`),
      (a.querySelector('p').style.top = n / 2 + 'px');
  }
  function e(t) {
    console.error(`scrollama error: ${t}`);
  }
  function i(t) {
    return +t.getAttribute('data-scrollama-index');
  }
  function r(t) {
    if ('string' == typeof t && t.indexOf('px') > 0) {
      const e = +t.replace('px', '');
      return isNaN(e)
        ? (err("offset value must be in 'px' format. Fallback to 0.5."),
          { format: 'percent', value: 0.5 })
        : { format: 'pixels', value: e };
    }
    return 'number' != typeof t && isNaN(+t)
      ? null
      : (t > 1 && err('offset value is greater than 1. Fallback to 1.'),
        t < 0 && err('offset value is lower than 0. Fallback to 0.'),
        { format: 'percent', value: Math.min(Math.max(0, t), 1) });
  }
  function n(t) {
    const { top: e } = t.getBoundingClientRect();
    return e + window.pageYOffset - (document.body.clientTop || 0);
  }
  let o, a, s;
  function l(t) {
    const e = t ? t.scrollTop : window.pageYOffset;
    o !== e && ((o = e), o > a ? (s = 'down') : o < a && (s = 'up'), (a = o));
  }
  function c() {
    let c,
      h,
      u,
      d = {},
      p = (function () {
        const t = 'abcdefghijklmnopqrstuvwxyz',
          e = Date.now(),
          i = [];
        for (let r = 0; r < 6; r += 1) {
          const e = t[Math.floor(Math.random() * t.length)];
          i.push(e);
        }
        return `${i.join('')}${e}`;
      })(),
      f = [],
      m = 0,
      _ = !1,
      g = !1,
      y = !1,
      x = !1,
      v = [];
    function b() {
      (d = { stepEnter: () => {}, stepExit: () => {}, stepProgress: () => {} }),
        (v = []);
    }
    function w(t) {
      t && !_ && k(), !t && _ && C(), (_ = t);
    }
    function T(t, e) {
      const r = i(t),
        n = f[r];
      void 0 !== e && (n.progress = e);
      const o = { element: t, index: r, progress: e, direction: s };
      'enter' === n.state && d.stepProgress(o);
    }
    function P([t]) {
      const e = i(t.target),
        r = f[e],
        n = t.target.offsetHeight;
      n !== r.height && ((r.height = n), I(r), E(r), A(r));
    }
    function S([t]) {
      l(h);
      const { isIntersecting: e, target: r } = t;
      e
        ? (function (t, e = !0) {
            const r = i(t),
              n = f[r],
              o = { element: t, index: r, direction: s };
            (n.direction = s),
              (n.state = 'enter'),
              v[r] || d.stepEnter(o),
              x && (v[r] = !0);
          })(r)
        : (function (t, e = !0) {
            const r = i(t),
              n = f[r];
            if (!n.state) return !1;
            const o = { element: t, index: r, direction: s };
            g &&
              ('down' === s && n.progress < 1
                ? T(t, 1)
                : 'up' === s && n.progress > 0 && T(t, 0)),
              (n.direction = s),
              (n.state = 'exit'),
              d.stepExit(o);
          })(r);
    }
    function M([t]) {
      const e = i(t.target),
        r = f[e],
        { isIntersecting: n, intersectionRatio: o, target: a } = t;
      n && 'enter' === r.state && T(a, o);
    }
    function I({ observers: t }) {
      Object.keys(t).map((e) => {
        t[e].disconnect();
      });
    }
    function C() {
      f.forEach(I);
    }
    function A(t) {
      const e = new ResizeObserver(P);
      e.observe(t.node), (t.observers.resize = e);
    }
    function E(e) {
      const i = window.innerHeight,
        r = e.offset || c,
        n = 'pixels' === r.format ? 1 : i,
        o = r.value * n,
        a = e.height / 2 - o,
        s = e.height / 2 - (i - o),
        l = new IntersectionObserver(S, {
          rootMargin: `${a}px 0px ${s}px 0px`,
          threshold: 0.5,
          root: u,
        });
      l.observe(e.node),
        (e.observers.step = l),
        y && t({ id: p, step: e, marginTop: a, marginBottom: s });
    }
    function z(t) {
      const e = window.innerHeight,
        i = t.offset || c,
        r = 'pixels' === i.format ? 1 : e,
        n = i.value * r,
        o = `${-n + t.height}px 0px ${n - e}px 0px`,
        a = (function (t, e) {
          const i = Math.ceil(t / e),
            r = [],
            n = 1 / i;
          for (let o = 0; o < i + 1; o += 1) r.push(o * n);
          return r;
        })(t.height, m),
        s = new IntersectionObserver(M, { rootMargin: o, threshold: a });
      s.observe(t.node), (t.observers.progress = s);
    }
    function k() {
      C(), f.forEach(A), f.forEach(E), g && f.forEach(z);
    }
    const D = {};
    return (
      (D.setup = ({
        step: t,
        parent: i,
        offset: s = 0.5,
        threshold: d = 4,
        progress: p = !1,
        once: _ = !1,
        debug: v = !1,
        container: T,
        root: P = null,
      }) => (
        (function (t) {
          (o = 0), (a = 0), document.addEventListener('scroll', () => l(t));
        })(T),
        (f = (function (t, e = document) {
          return 'string' == typeof t
            ? Array.from(e.querySelectorAll(t))
            : t instanceof Element
            ? [t]
            : t instanceof NodeList
            ? Array.from(t)
            : t instanceof Array
            ? t
            : [];
        })(t, i).map((t, e) => ({
          index: e,
          direction: void 0,
          height: t.offsetHeight,
          node: t,
          observers: {},
          offset: r(t.dataset.offset),
          top: n(t),
          progress: 0,
          state: void 0,
        }))),
        f.length
          ? ((g = p),
            (x = _),
            (y = v),
            (m = Math.max(1, +d)),
            (c = r(s)),
            (h = T),
            (u = P),
            b(),
            (function (t) {
              t.forEach((t) =>
                t.node.setAttribute('data-scrollama-index', t.index)
              );
            })(f),
            w(!0),
            D)
          : (e('no step elements'), D)
      )),
      (D.enable = () => (w(!0), D)),
      (D.disable = () => (w(!1), D)),
      (D.destroy = () => (w(!1), b(), D)),
      (D.resize = () => (k(), D)),
      (D.offset = (t) => (null == t ? c.value : ((c = r(t)), k(), D))),
      (D.onStepEnter = (t) => (
        'function' == typeof t
          ? (d.stepEnter = t)
          : e('onStepEnter requires a function'),
        D
      )),
      (D.onStepExit = (t) => (
        'function' == typeof t
          ? (d.stepExit = t)
          : e('onStepExit requires a function'),
        D
      )),
      (D.onStepProgress = (t) => (
        'function' == typeof t
          ? (d.stepProgress = t)
          : e('onStepProgress requires a function'),
        D
      )),
      D
    );
  }
  var h = { value: () => {} };
  function u() {
    for (var t, e = 0, i = arguments.length, r = {}; e < i; ++e) {
      if (!(t = arguments[e] + '') || t in r || /[\s.]/.test(t))
        throw new Error('illegal type: ' + t);
      r[t] = [];
    }
    return new d(r);
  }
  function d(t) {
    this._ = t;
  }
  function p(t, e) {
    return t
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var i = '',
          r = t.indexOf('.');
        if (
          (r >= 0 && ((i = t.slice(r + 1)), (t = t.slice(0, r))),
          t && !e.hasOwnProperty(t))
        )
          throw new Error('unknown type: ' + t);
        return { type: t, name: i };
      });
  }
  function f(t, e) {
    for (var i, r = 0, n = t.length; r < n; ++r)
      if ((i = t[r]).name === e) return i.value;
  }
  function m(t, e, i) {
    for (var r = 0, n = t.length; r < n; ++r)
      if (t[r].name === e) {
        (t[r] = h), (t = t.slice(0, r).concat(t.slice(r + 1)));
        break;
      }
    return null != i && t.push({ name: e, value: i }), t;
  }
  d.prototype = u.prototype = {
    constructor: d,
    on: function (t, e) {
      var i,
        r = this._,
        n = p(t + '', r),
        o = -1,
        a = n.length;
      if (!(arguments.length < 2)) {
        if (null != e && 'function' != typeof e)
          throw new Error('invalid callback: ' + e);
        for (; ++o < a; )
          if ((i = (t = n[o]).type)) r[i] = m(r[i], t.name, e);
          else if (null == e) for (i in r) r[i] = m(r[i], t.name, null);
        return this;
      }
      for (; ++o < a; )
        if ((i = (t = n[o]).type) && (i = f(r[i], t.name))) return i;
    },
    copy: function () {
      var t = {},
        e = this._;
      for (var i in e) t[i] = e[i].slice();
      return new d(t);
    },
    call: function (t, e) {
      if ((i = arguments.length - 2) > 0)
        for (var i, r, n = new Array(i), o = 0; o < i; ++o)
          n[o] = arguments[o + 2];
      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
      for (o = 0, i = (r = this._[t]).length; o < i; ++o)
        r[o].value.apply(e, n);
    },
    apply: function (t, e, i) {
      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
      for (var r = this._[t], n = 0, o = r.length; n < o; ++n)
        r[n].value.apply(e, i);
    },
  };
  var _ = 'http://www.w3.org/1999/xhtml',
    g = {
      svg: 'http://www.w3.org/2000/svg',
      xhtml: _,
      xlink: 'http://www.w3.org/1999/xlink',
      xml: 'http://www.w3.org/XML/1998/namespace',
      xmlns: 'http://www.w3.org/2000/xmlns/',
    };
  function y(t) {
    var e = (t += ''),
      i = e.indexOf(':');
    return (
      i >= 0 && 'xmlns' !== (e = t.slice(0, i)) && (t = t.slice(i + 1)),
      g.hasOwnProperty(e) ? { space: g[e], local: t } : t
    );
  }
  function x(t) {
    return function () {
      var e = this.ownerDocument,
        i = this.namespaceURI;
      return i === _ && e.documentElement.namespaceURI === _
        ? e.createElement(t)
        : e.createElementNS(i, t);
    };
  }
  function v(t) {
    return function () {
      return this.ownerDocument.createElementNS(t.space, t.local);
    };
  }
  function b(t) {
    var e = y(t);
    return (e.local ? v : x)(e);
  }
  function w() {}
  function T(t) {
    return null == t
      ? w
      : function () {
          return this.querySelector(t);
        };
  }
  function P(t) {
    return null == t ? [] : Array.isArray(t) ? t : Array.from(t);
  }
  function S() {
    return [];
  }
  function M(t) {
    return null == t
      ? S
      : function () {
          return this.querySelectorAll(t);
        };
  }
  function I(t) {
    return function () {
      return this.matches(t);
    };
  }
  function C(t) {
    return function (e) {
      return e.matches(t);
    };
  }
  var A = Array.prototype.find;
  function E() {
    return this.firstElementChild;
  }
  var z = Array.prototype.filter;
  function k() {
    return Array.from(this.children);
  }
  function D(t) {
    return new Array(t.length);
  }
  function R(t, e) {
    (this.ownerDocument = t.ownerDocument),
      (this.namespaceURI = t.namespaceURI),
      (this._next = null),
      (this._parent = t),
      (this.__data__ = e);
  }
  function L(t) {
    return function () {
      return t;
    };
  }
  function F(t, e, i, r, n, o) {
    for (var a, s = 0, l = e.length, c = o.length; s < c; ++s)
      (a = e[s]) ? ((a.__data__ = o[s]), (r[s] = a)) : (i[s] = new R(t, o[s]));
    for (; s < l; ++s) (a = e[s]) && (n[s] = a);
  }
  function B(t, e, i, r, n, o, a) {
    var s,
      l,
      c,
      h = new Map(),
      u = e.length,
      d = o.length,
      p = new Array(u);
    for (s = 0; s < u; ++s)
      (l = e[s]) &&
        ((p[s] = c = a.call(l, l.__data__, s, e) + ''),
        h.has(c) ? (n[s] = l) : h.set(c, l));
    for (s = 0; s < d; ++s)
      (c = a.call(t, o[s], s, o) + ''),
        (l = h.get(c))
          ? ((r[s] = l), (l.__data__ = o[s]), h.delete(c))
          : (i[s] = new R(t, o[s]));
    for (s = 0; s < u; ++s) (l = e[s]) && h.get(p[s]) === l && (n[s] = l);
  }
  function O(t) {
    return t.__data__;
  }
  function j(t) {
    return 'object' == typeof t && 'length' in t ? t : Array.from(t);
  }
  function N(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function V(t) {
    return function () {
      this.removeAttribute(t);
    };
  }
  function U(t) {
    return function () {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function G(t, e) {
    return function () {
      this.setAttribute(t, e);
    };
  }
  function Z(t, e) {
    return function () {
      this.setAttributeNS(t.space, t.local, e);
    };
  }
  function $(t, e) {
    return function () {
      var i = e.apply(this, arguments);
      null == i ? this.removeAttribute(t) : this.setAttribute(t, i);
    };
  }
  function q(t, e) {
    return function () {
      var i = e.apply(this, arguments);
      null == i
        ? this.removeAttributeNS(t.space, t.local)
        : this.setAttributeNS(t.space, t.local, i);
    };
  }
  function W(t) {
    return (
      (t.ownerDocument && t.ownerDocument.defaultView) ||
      (t.document && t) ||
      t.defaultView
    );
  }
  function Y(t) {
    return function () {
      this.style.removeProperty(t);
    };
  }
  function H(t, e, i) {
    return function () {
      this.style.setProperty(t, e, i);
    };
  }
  function X(t, e, i) {
    return function () {
      var r = e.apply(this, arguments);
      null == r
        ? this.style.removeProperty(t)
        : this.style.setProperty(t, r, i);
    };
  }
  function K(t, e) {
    return (
      t.style.getPropertyValue(e) ||
      W(t).getComputedStyle(t, null).getPropertyValue(e)
    );
  }
  function J(t) {
    return function () {
      delete this[t];
    };
  }
  function Q(t, e) {
    return function () {
      this[t] = e;
    };
  }
  function tt(t, e) {
    return function () {
      var i = e.apply(this, arguments);
      null == i ? delete this[t] : (this[t] = i);
    };
  }
  function et(t) {
    return t.trim().split(/^|\s+/);
  }
  function it(t) {
    return t.classList || new rt(t);
  }
  function rt(t) {
    (this._node = t), (this._names = et(t.getAttribute('class') || ''));
  }
  function nt(t, e) {
    for (var i = it(t), r = -1, n = e.length; ++r < n; ) i.add(e[r]);
  }
  function ot(t, e) {
    for (var i = it(t), r = -1, n = e.length; ++r < n; ) i.remove(e[r]);
  }
  function at(t) {
    return function () {
      nt(this, t);
    };
  }
  function st(t) {
    return function () {
      ot(this, t);
    };
  }
  function lt(t, e) {
    return function () {
      (e.apply(this, arguments) ? nt : ot)(this, t);
    };
  }
  function ct() {
    this.textContent = '';
  }
  function ht(t) {
    return function () {
      this.textContent = t;
    };
  }
  function ut(t) {
    return function () {
      var e = t.apply(this, arguments);
      this.textContent = null == e ? '' : e;
    };
  }
  function dt() {
    this.innerHTML = '';
  }
  function pt(t) {
    return function () {
      this.innerHTML = t;
    };
  }
  function ft(t) {
    return function () {
      var e = t.apply(this, arguments);
      this.innerHTML = null == e ? '' : e;
    };
  }
  function mt() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function _t() {
    this.previousSibling &&
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function gt() {
    return null;
  }
  function yt() {
    var t = this.parentNode;
    t && t.removeChild(this);
  }
  function xt() {
    var t = this.cloneNode(!1),
      e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t;
  }
  function vt() {
    var t = this.cloneNode(!0),
      e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t;
  }
  function bt(t) {
    return t
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var e = '',
          i = t.indexOf('.');
        return (
          i >= 0 && ((e = t.slice(i + 1)), (t = t.slice(0, i))),
          { type: t, name: e }
        );
      });
  }
  function wt(t) {
    return function () {
      var e = this.__on;
      if (e) {
        for (var i, r = 0, n = -1, o = e.length; r < o; ++r)
          (i = e[r]),
            (t.type && i.type !== t.type) || i.name !== t.name
              ? (e[++n] = i)
              : this.removeEventListener(i.type, i.listener, i.options);
        ++n ? (e.length = n) : delete this.__on;
      }
    };
  }
  function Tt(t, e, i) {
    return function () {
      var r,
        n = this.__on,
        o = (function (t) {
          return function (e) {
            t.call(this, e, this.__data__);
          };
        })(e);
      if (n)
        for (var a = 0, s = n.length; a < s; ++a)
          if ((r = n[a]).type === t.type && r.name === t.name)
            return (
              this.removeEventListener(r.type, r.listener, r.options),
              this.addEventListener(r.type, (r.listener = o), (r.options = i)),
              void (r.value = e)
            );
      this.addEventListener(t.type, o, i),
        (r = { type: t.type, name: t.name, value: e, listener: o, options: i }),
        n ? n.push(r) : (this.__on = [r]);
    };
  }
  function Pt(t, e, i) {
    var r = W(t),
      n = r.CustomEvent;
    'function' == typeof n
      ? (n = new n(e, i))
      : ((n = r.document.createEvent('Event')),
        i
          ? (n.initEvent(e, i.bubbles, i.cancelable), (n.detail = i.detail))
          : n.initEvent(e, !1, !1)),
      t.dispatchEvent(n);
  }
  function St(t, e) {
    return function () {
      return Pt(this, t, e);
    };
  }
  function Mt(t, e) {
    return function () {
      return Pt(this, t, e.apply(this, arguments));
    };
  }
  (R.prototype = {
    constructor: R,
    appendChild: function (t) {
      return this._parent.insertBefore(t, this._next);
    },
    insertBefore: function (t, e) {
      return this._parent.insertBefore(t, e);
    },
    querySelector: function (t) {
      return this._parent.querySelector(t);
    },
    querySelectorAll: function (t) {
      return this._parent.querySelectorAll(t);
    },
  }),
    (rt.prototype = {
      add: function (t) {
        this._names.indexOf(t) < 0 &&
          (this._names.push(t),
          this._node.setAttribute('class', this._names.join(' ')));
      },
      remove: function (t) {
        var e = this._names.indexOf(t);
        e >= 0 &&
          (this._names.splice(e, 1),
          this._node.setAttribute('class', this._names.join(' ')));
      },
      contains: function (t) {
        return this._names.indexOf(t) >= 0;
      },
    });
  var It = [null];
  function Ct(t, e) {
    (this._groups = t), (this._parents = e);
  }
  function At() {
    return new Ct([[document.documentElement]], It);
  }
  function Et(t, e, i) {
    (t.prototype = e.prototype = i), (i.constructor = t);
  }
  function zt(t, e) {
    var i = Object.create(t.prototype);
    for (var r in e) i[r] = e[r];
    return i;
  }
  function kt() {}
  Ct.prototype = At.prototype = {
    constructor: Ct,
    select: function (t) {
      'function' != typeof t && (t = T(t));
      for (
        var e = this._groups, i = e.length, r = new Array(i), n = 0;
        n < i;
        ++n
      )
        for (
          var o, a, s = e[n], l = s.length, c = (r[n] = new Array(l)), h = 0;
          h < l;
          ++h
        )
          (o = s[h]) &&
            (a = t.call(o, o.__data__, h, s)) &&
            ('__data__' in o && (a.__data__ = o.__data__), (c[h] = a));
      return new Ct(r, this._parents);
    },
    selectAll: function (t) {
      t =
        'function' == typeof t
          ? (function (t) {
              return function () {
                return P(t.apply(this, arguments));
              };
            })(t)
          : M(t);
      for (
        var e = this._groups, i = e.length, r = [], n = [], o = 0;
        o < i;
        ++o
      )
        for (var a, s = e[o], l = s.length, c = 0; c < l; ++c)
          (a = s[c]) && (r.push(t.call(a, a.__data__, c, s)), n.push(a));
      return new Ct(r, n);
    },
    selectChild: function (t) {
      return this.select(
        null == t
          ? E
          : (function (t) {
              return function () {
                return A.call(this.children, t);
              };
            })('function' == typeof t ? t : C(t))
      );
    },
    selectChildren: function (t) {
      return this.selectAll(
        null == t
          ? k
          : (function (t) {
              return function () {
                return z.call(this.children, t);
              };
            })('function' == typeof t ? t : C(t))
      );
    },
    filter: function (t) {
      'function' != typeof t && (t = I(t));
      for (
        var e = this._groups, i = e.length, r = new Array(i), n = 0;
        n < i;
        ++n
      )
        for (var o, a = e[n], s = a.length, l = (r[n] = []), c = 0; c < s; ++c)
          (o = a[c]) && t.call(o, o.__data__, c, a) && l.push(o);
      return new Ct(r, this._parents);
    },
    data: function (t, e) {
      if (!arguments.length) return Array.from(this, O);
      var i = e ? B : F,
        r = this._parents,
        n = this._groups;
      'function' != typeof t && (t = L(t));
      for (
        var o = n.length,
          a = new Array(o),
          s = new Array(o),
          l = new Array(o),
          c = 0;
        c < o;
        ++c
      ) {
        var h = r[c],
          u = n[c],
          d = u.length,
          p = j(t.call(h, h && h.__data__, c, r)),
          f = p.length,
          m = (s[c] = new Array(f)),
          _ = (a[c] = new Array(f)),
          g = (l[c] = new Array(d));
        i(h, u, m, _, g, p, e);
        for (var y, x, v = 0, b = 0; v < f; ++v)
          if ((y = m[v])) {
            for (v >= b && (b = v + 1); !(x = _[b]) && ++b < f; );
            y._next = x || null;
          }
      }
      return ((a = new Ct(a, r))._enter = s), (a._exit = l), a;
    },
    enter: function () {
      return new Ct(this._enter || this._groups.map(D), this._parents);
    },
    exit: function () {
      return new Ct(this._exit || this._groups.map(D), this._parents);
    },
    join: function (t, e, i) {
      var r = this.enter(),
        n = this,
        o = this.exit();
      return (
        'function' == typeof t
          ? (r = t(r)) && (r = r.selection())
          : (r = r.append(t + '')),
        null != e && (n = e(n)) && (n = n.selection()),
        null == i ? o.remove() : i(o),
        r && n ? r.merge(n).order() : n
      );
    },
    merge: function (t) {
      for (
        var e = t.selection ? t.selection() : t,
          i = this._groups,
          r = e._groups,
          n = i.length,
          o = r.length,
          a = Math.min(n, o),
          s = new Array(n),
          l = 0;
        l < a;
        ++l
      )
        for (
          var c,
            h = i[l],
            u = r[l],
            d = h.length,
            p = (s[l] = new Array(d)),
            f = 0;
          f < d;
          ++f
        )
          (c = h[f] || u[f]) && (p[f] = c);
      for (; l < n; ++l) s[l] = i[l];
      return new Ct(s, this._parents);
    },
    selection: function () {
      return this;
    },
    order: function () {
      for (var t = this._groups, e = -1, i = t.length; ++e < i; )
        for (var r, n = t[e], o = n.length - 1, a = n[o]; --o >= 0; )
          (r = n[o]) &&
            (a &&
              4 ^ r.compareDocumentPosition(a) &&
              a.parentNode.insertBefore(r, a),
            (a = r));
      return this;
    },
    sort: function (t) {
      function e(e, i) {
        return e && i ? t(e.__data__, i.__data__) : !e - !i;
      }
      t || (t = N);
      for (
        var i = this._groups, r = i.length, n = new Array(r), o = 0;
        o < r;
        ++o
      ) {
        for (
          var a, s = i[o], l = s.length, c = (n[o] = new Array(l)), h = 0;
          h < l;
          ++h
        )
          (a = s[h]) && (c[h] = a);
        c.sort(e);
      }
      return new Ct(n, this._parents).order();
    },
    call: function () {
      var t = arguments[0];
      return (arguments[0] = this), t.apply(null, arguments), this;
    },
    nodes: function () {
      return Array.from(this);
    },
    node: function () {
      for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
        for (var r = t[e], n = 0, o = r.length; n < o; ++n) {
          var a = r[n];
          if (a) return a;
        }
      return null;
    },
    size: function () {
      let t = 0;
      for (const e of this) ++t;
      return t;
    },
    empty: function () {
      return !this.node();
    },
    each: function (t) {
      for (var e = this._groups, i = 0, r = e.length; i < r; ++i)
        for (var n, o = e[i], a = 0, s = o.length; a < s; ++a)
          (n = o[a]) && t.call(n, n.__data__, a, o);
      return this;
    },
    attr: function (t, e) {
      var i = y(t);
      if (arguments.length < 2) {
        var r = this.node();
        return i.local ? r.getAttributeNS(i.space, i.local) : r.getAttribute(i);
      }
      return this.each(
        (null == e
          ? i.local
            ? U
            : V
          : 'function' == typeof e
          ? i.local
            ? q
            : $
          : i.local
          ? Z
          : G)(i, e)
      );
    },
    style: function (t, e, i) {
      return arguments.length > 1
        ? this.each(
            (null == e ? Y : 'function' == typeof e ? X : H)(
              t,
              e,
              null == i ? '' : i
            )
          )
        : K(this.node(), t);
    },
    property: function (t, e) {
      return arguments.length > 1
        ? this.each((null == e ? J : 'function' == typeof e ? tt : Q)(t, e))
        : this.node()[t];
    },
    classed: function (t, e) {
      var i = et(t + '');
      if (arguments.length < 2) {
        for (var r = it(this.node()), n = -1, o = i.length; ++n < o; )
          if (!r.contains(i[n])) return !1;
        return !0;
      }
      return this.each(('function' == typeof e ? lt : e ? at : st)(i, e));
    },
    text: function (t) {
      return arguments.length
        ? this.each(null == t ? ct : ('function' == typeof t ? ut : ht)(t))
        : this.node().textContent;
    },
    html: function (t) {
      return arguments.length
        ? this.each(null == t ? dt : ('function' == typeof t ? ft : pt)(t))
        : this.node().innerHTML;
    },
    raise: function () {
      return this.each(mt);
    },
    lower: function () {
      return this.each(_t);
    },
    append: function (t) {
      var e = 'function' == typeof t ? t : b(t);
      return this.select(function () {
        return this.appendChild(e.apply(this, arguments));
      });
    },
    insert: function (t, e) {
      var i = 'function' == typeof t ? t : b(t),
        r = null == e ? gt : 'function' == typeof e ? e : T(e);
      return this.select(function () {
        return this.insertBefore(
          i.apply(this, arguments),
          r.apply(this, arguments) || null
        );
      });
    },
    remove: function () {
      return this.each(yt);
    },
    clone: function (t) {
      return this.select(t ? vt : xt);
    },
    datum: function (t) {
      return arguments.length
        ? this.property('__data__', t)
        : this.node().__data__;
    },
    on: function (t, e, i) {
      var r,
        n,
        o = bt(t + ''),
        a = o.length;
      if (!(arguments.length < 2)) {
        for (s = e ? Tt : wt, r = 0; r < a; ++r) this.each(s(o[r], e, i));
        return this;
      }
      var s = this.node().__on;
      if (s)
        for (var l, c = 0, h = s.length; c < h; ++c)
          for (r = 0, l = s[c]; r < a; ++r)
            if ((n = o[r]).type === l.type && n.name === l.name) return l.value;
    },
    dispatch: function (t, e) {
      return this.each(('function' == typeof e ? Mt : St)(t, e));
    },
    [Symbol.iterator]: function* () {
      for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
        for (var r, n = t[e], o = 0, a = n.length; o < a; ++o)
          (r = n[o]) && (yield r);
    },
  };
  var Dt = 0.7,
    Rt = 1 / Dt,
    Lt = '\\s*([+-]?\\d+)\\s*',
    Ft = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
    Bt = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
    Ot = /^#([0-9a-f]{3,8})$/,
    jt = new RegExp(`^rgb\\(${Lt},${Lt},${Lt}\\)$`),
    Nt = new RegExp(`^rgb\\(${Bt},${Bt},${Bt}\\)$`),
    Vt = new RegExp(`^rgba\\(${Lt},${Lt},${Lt},${Ft}\\)$`),
    Ut = new RegExp(`^rgba\\(${Bt},${Bt},${Bt},${Ft}\\)$`),
    Gt = new RegExp(`^hsl\\(${Ft},${Bt},${Bt}\\)$`),
    Zt = new RegExp(`^hsla\\(${Ft},${Bt},${Bt},${Ft}\\)$`),
    $t = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    };
  function qt() {
    return this.rgb().formatHex();
  }
  function Wt() {
    return this.rgb().formatRgb();
  }
  function Yt(t) {
    var e, i;
    return (
      (t = (t + '').trim().toLowerCase()),
      (e = Ot.exec(t))
        ? ((i = e[1].length),
          (e = parseInt(e[1], 16)),
          6 === i
            ? Ht(e)
            : 3 === i
            ? new Qt(
                ((e >> 8) & 15) | ((e >> 4) & 240),
                ((e >> 4) & 15) | (240 & e),
                ((15 & e) << 4) | (15 & e),
                1
              )
            : 8 === i
            ? Xt(
                (e >> 24) & 255,
                (e >> 16) & 255,
                (e >> 8) & 255,
                (255 & e) / 255
              )
            : 4 === i
            ? Xt(
                ((e >> 12) & 15) | ((e >> 8) & 240),
                ((e >> 8) & 15) | ((e >> 4) & 240),
                ((e >> 4) & 15) | (240 & e),
                (((15 & e) << 4) | (15 & e)) / 255
              )
            : null)
        : (e = jt.exec(t))
        ? new Qt(e[1], e[2], e[3], 1)
        : (e = Nt.exec(t))
        ? new Qt((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, 1)
        : (e = Vt.exec(t))
        ? Xt(e[1], e[2], e[3], e[4])
        : (e = Ut.exec(t))
        ? Xt((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, e[4])
        : (e = Gt.exec(t))
        ? oe(e[1], e[2] / 100, e[3] / 100, 1)
        : (e = Zt.exec(t))
        ? oe(e[1], e[2] / 100, e[3] / 100, e[4])
        : $t.hasOwnProperty(t)
        ? Ht($t[t])
        : 'transparent' === t
        ? new Qt(NaN, NaN, NaN, 0)
        : null
    );
  }
  function Ht(t) {
    return new Qt((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
  }
  function Xt(t, e, i, r) {
    return r <= 0 && (t = e = i = NaN), new Qt(t, e, i, r);
  }
  function Kt(t) {
    return (
      t instanceof kt || (t = Yt(t)),
      t ? new Qt((t = t.rgb()).r, t.g, t.b, t.opacity) : new Qt()
    );
  }
  function Jt(t, e, i, r) {
    return 1 === arguments.length ? Kt(t) : new Qt(t, e, i, null == r ? 1 : r);
  }
  function Qt(t, e, i, r) {
    (this.r = +t), (this.g = +e), (this.b = +i), (this.opacity = +r);
  }
  function te() {
    return `#${ne(this.r)}${ne(this.g)}${ne(this.b)}`;
  }
  function ee() {
    const t = ie(this.opacity);
    return `${1 === t ? 'rgb(' : 'rgba('}${re(this.r)}, ${re(this.g)}, ${re(
      this.b
    )}${1 === t ? ')' : `, ${t})`}`;
  }
  function ie(t) {
    return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
  }
  function re(t) {
    return Math.max(0, Math.min(255, Math.round(t) || 0));
  }
  function ne(t) {
    return ((t = re(t)) < 16 ? '0' : '') + t.toString(16);
  }
  function oe(t, e, i, r) {
    return (
      r <= 0
        ? (t = e = i = NaN)
        : i <= 0 || i >= 1
        ? (t = e = NaN)
        : e <= 0 && (t = NaN),
      new se(t, e, i, r)
    );
  }
  function ae(t) {
    if (t instanceof se) return new se(t.h, t.s, t.l, t.opacity);
    if ((t instanceof kt || (t = Yt(t)), !t)) return new se();
    if (t instanceof se) return t;
    var e = (t = t.rgb()).r / 255,
      i = t.g / 255,
      r = t.b / 255,
      n = Math.min(e, i, r),
      o = Math.max(e, i, r),
      a = NaN,
      s = o - n,
      l = (o + n) / 2;
    return (
      s
        ? ((a =
            e === o
              ? (i - r) / s + 6 * (i < r)
              : i === o
              ? (r - e) / s + 2
              : (e - i) / s + 4),
          (s /= l < 0.5 ? o + n : 2 - o - n),
          (a *= 60))
        : (s = l > 0 && l < 1 ? 0 : a),
      new se(a, s, l, t.opacity)
    );
  }
  function se(t, e, i, r) {
    (this.h = +t), (this.s = +e), (this.l = +i), (this.opacity = +r);
  }
  function le(t) {
    return (t = (t || 0) % 360) < 0 ? t + 360 : t;
  }
  function ce(t) {
    return Math.max(0, Math.min(1, t || 0));
  }
  function he(t, e, i) {
    return (
      255 *
      (t < 60
        ? e + ((i - e) * t) / 60
        : t < 180
        ? i
        : t < 240
        ? e + ((i - e) * (240 - t)) / 60
        : e)
    );
  }
  Et(kt, Yt, {
    copy(t) {
      return Object.assign(new this.constructor(), this, t);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: qt,
    formatHex: qt,
    formatHex8: function () {
      return this.rgb().formatHex8();
    },
    formatHsl: function () {
      return ae(this).formatHsl();
    },
    formatRgb: Wt,
    toString: Wt,
  }),
    Et(
      Qt,
      Jt,
      zt(kt, {
        brighter(t) {
          return (
            (t = null == t ? Rt : Math.pow(Rt, t)),
            new Qt(this.r * t, this.g * t, this.b * t, this.opacity)
          );
        },
        darker(t) {
          return (
            (t = null == t ? Dt : Math.pow(Dt, t)),
            new Qt(this.r * t, this.g * t, this.b * t, this.opacity)
          );
        },
        rgb() {
          return this;
        },
        clamp() {
          return new Qt(re(this.r), re(this.g), re(this.b), ie(this.opacity));
        },
        displayable() {
          return (
            -0.5 <= this.r &&
            this.r < 255.5 &&
            -0.5 <= this.g &&
            this.g < 255.5 &&
            -0.5 <= this.b &&
            this.b < 255.5 &&
            0 <= this.opacity &&
            this.opacity <= 1
          );
        },
        hex: te,
        formatHex: te,
        formatHex8: function () {
          return `#${ne(this.r)}${ne(this.g)}${ne(this.b)}${ne(
            255 * (isNaN(this.opacity) ? 1 : this.opacity)
          )}`;
        },
        formatRgb: ee,
        toString: ee,
      })
    ),
    Et(
      se,
      function (t, e, i, r) {
        return 1 === arguments.length
          ? ae(t)
          : new se(t, e, i, null == r ? 1 : r);
      },
      zt(kt, {
        brighter(t) {
          return (
            (t = null == t ? Rt : Math.pow(Rt, t)),
            new se(this.h, this.s, this.l * t, this.opacity)
          );
        },
        darker(t) {
          return (
            (t = null == t ? Dt : Math.pow(Dt, t)),
            new se(this.h, this.s, this.l * t, this.opacity)
          );
        },
        rgb() {
          var t = (this.h % 360) + 360 * (this.h < 0),
            e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
            i = this.l,
            r = i + (i < 0.5 ? i : 1 - i) * e,
            n = 2 * i - r;
          return new Qt(
            he(t >= 240 ? t - 240 : t + 120, n, r),
            he(t, n, r),
            he(t < 120 ? t + 240 : t - 120, n, r),
            this.opacity
          );
        },
        clamp() {
          return new se(le(this.h), ce(this.s), ce(this.l), ie(this.opacity));
        },
        displayable() {
          return (
            ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
            0 <= this.l &&
            this.l <= 1 &&
            0 <= this.opacity &&
            this.opacity <= 1
          );
        },
        formatHsl() {
          const t = ie(this.opacity);
          return `${1 === t ? 'hsl(' : 'hsla('}${le(this.h)}, ${
            100 * ce(this.s)
          }%, ${100 * ce(this.l)}%${1 === t ? ')' : `, ${t})`}`;
        },
      })
    );
  var ue = (t) => () => t;
  function de(t) {
    return 1 == (t = +t)
      ? pe
      : function (e, i) {
          return i - e
            ? (function (t, e, i) {
                return (
                  (t = Math.pow(t, i)),
                  (e = Math.pow(e, i) - t),
                  (i = 1 / i),
                  function (r) {
                    return Math.pow(t + r * e, i);
                  }
                );
              })(e, i, t)
            : ue(isNaN(e) ? i : e);
        };
  }
  function pe(t, e) {
    var i = e - t;
    return i
      ? (function (t, e) {
          return function (i) {
            return t + i * e;
          };
        })(t, i)
      : ue(isNaN(t) ? e : t);
  }
  var fe = (function t(e) {
    var i = de(e);
    function r(t, e) {
      var r = i((t = Jt(t)).r, (e = Jt(e)).r),
        n = i(t.g, e.g),
        o = i(t.b, e.b),
        a = pe(t.opacity, e.opacity);
      return function (e) {
        return (
          (t.r = r(e)), (t.g = n(e)), (t.b = o(e)), (t.opacity = a(e)), t + ''
        );
      };
    }
    return (r.gamma = t), r;
  })(1);
  function me(t, e) {
    return (
      (t = +t),
      (e = +e),
      function (i) {
        return t * (1 - i) + e * i;
      }
    );
  }
  var _e = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    ge = new RegExp(_e.source, 'g');
  function ye(t, e) {
    var i,
      r,
      n,
      o = (_e.lastIndex = ge.lastIndex = 0),
      a = -1,
      s = [],
      l = [];
    for (t += '', e += ''; (i = _e.exec(t)) && (r = ge.exec(e)); )
      (n = r.index) > o &&
        ((n = e.slice(o, n)), s[a] ? (s[a] += n) : (s[++a] = n)),
        (i = i[0]) === (r = r[0])
          ? s[a]
            ? (s[a] += r)
            : (s[++a] = r)
          : ((s[++a] = null), l.push({ i: a, x: me(i, r) })),
        (o = ge.lastIndex);
    return (
      o < e.length && ((n = e.slice(o)), s[a] ? (s[a] += n) : (s[++a] = n)),
      s.length < 2
        ? l[0]
          ? (function (t) {
              return function (e) {
                return t(e) + '';
              };
            })(l[0].x)
          : (function (t) {
              return function () {
                return t;
              };
            })(e)
        : ((e = l.length),
          function (t) {
            for (var i, r = 0; r < e; ++r) s[(i = l[r]).i] = i.x(t);
            return s.join('');
          })
    );
  }
  var xe,
    ve = 180 / Math.PI,
    be = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1,
    };
  function we(t, e, i, r, n, o) {
    var a, s, l;
    return (
      (a = Math.sqrt(t * t + e * e)) && ((t /= a), (e /= a)),
      (l = t * i + e * r) && ((i -= t * l), (r -= e * l)),
      (s = Math.sqrt(i * i + r * r)) && ((i /= s), (r /= s), (l /= s)),
      t * r < e * i && ((t = -t), (e = -e), (l = -l), (a = -a)),
      {
        translateX: n,
        translateY: o,
        rotate: Math.atan2(e, t) * ve,
        skewX: Math.atan(l) * ve,
        scaleX: a,
        scaleY: s,
      }
    );
  }
  function Te(t, e, i, r) {
    function n(t) {
      return t.length ? t.pop() + ' ' : '';
    }
    return function (o, a) {
      var s = [],
        l = [];
      return (
        (o = t(o)),
        (a = t(a)),
        (function (t, r, n, o, a, s) {
          if (t !== n || r !== o) {
            var l = a.push('translate(', null, e, null, i);
            s.push({ i: l - 4, x: me(t, n) }, { i: l - 2, x: me(r, o) });
          } else (n || o) && a.push('translate(' + n + e + o + i);
        })(o.translateX, o.translateY, a.translateX, a.translateY, s, l),
        (function (t, e, i, o) {
          t !== e
            ? (t - e > 180 ? (e += 360) : e - t > 180 && (t += 360),
              o.push({ i: i.push(n(i) + 'rotate(', null, r) - 2, x: me(t, e) }))
            : e && i.push(n(i) + 'rotate(' + e + r);
        })(o.rotate, a.rotate, s, l),
        (function (t, e, i, o) {
          t !== e
            ? o.push({ i: i.push(n(i) + 'skewX(', null, r) - 2, x: me(t, e) })
            : e && i.push(n(i) + 'skewX(' + e + r);
        })(o.skewX, a.skewX, s, l),
        (function (t, e, i, r, o, a) {
          if (t !== i || e !== r) {
            var s = o.push(n(o) + 'scale(', null, ',', null, ')');
            a.push({ i: s - 4, x: me(t, i) }, { i: s - 2, x: me(e, r) });
          } else
            (1 === i && 1 === r) || o.push(n(o) + 'scale(' + i + ',' + r + ')');
        })(o.scaleX, o.scaleY, a.scaleX, a.scaleY, s, l),
        (o = a = null),
        function (t) {
          for (var e, i = -1, r = l.length; ++i < r; ) s[(e = l[i]).i] = e.x(t);
          return s.join('');
        }
      );
    };
  }
  var Pe,
    Se,
    Me = Te(
      function (t) {
        const e = new (
          'function' == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix
        )(t + '');
        return e.isIdentity ? be : we(e.a, e.b, e.c, e.d, e.e, e.f);
      },
      'px, ',
      'px)',
      'deg)'
    ),
    Ie = Te(
      function (t) {
        return null == t
          ? be
          : (xe ||
              (xe = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'g'
              )),
            xe.setAttribute('transform', t),
            (t = xe.transform.baseVal.consolidate())
              ? we((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f)
              : be);
      },
      ', ',
      ')',
      ')'
    ),
    Ce = 0,
    Ae = 0,
    Ee = 0,
    ze = 0,
    ke = 0,
    De = 0,
    Re = 'object' == typeof performance && performance.now ? performance : Date,
    Le =
      'object' == typeof window && window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : function (t) {
            setTimeout(t, 17);
          };
  function Fe() {
    return ke || (Le(Be), (ke = Re.now() + De));
  }
  function Be() {
    ke = 0;
  }
  function Oe() {
    this._call = this._time = this._next = null;
  }
  function je(t, e, i) {
    var r = new Oe();
    return r.restart(t, e, i), r;
  }
  function Ne() {
    (ke = (ze = Re.now()) + De), (Ce = Ae = 0);
    try {
      !(function () {
        Fe(), ++Ce;
        for (var t, e = Pe; e; )
          (t = ke - e._time) >= 0 && e._call.call(void 0, t), (e = e._next);
        --Ce;
      })();
    } finally {
      (Ce = 0),
        (function () {
          var t,
            e,
            i = Pe,
            r = 1 / 0;
          for (; i; )
            i._call
              ? (r > i._time && (r = i._time), (t = i), (i = i._next))
              : ((e = i._next),
                (i._next = null),
                (i = t ? (t._next = e) : (Pe = e)));
          (Se = t), Ue(r);
        })(),
        (ke = 0);
    }
  }
  function Ve() {
    var t = Re.now(),
      e = t - ze;
    e > 1e3 && ((De -= e), (ze = t));
  }
  function Ue(t) {
    Ce ||
      (Ae && (Ae = clearTimeout(Ae)),
      t - ke > 24
        ? (t < 1 / 0 && (Ae = setTimeout(Ne, t - Re.now() - De)),
          Ee && (Ee = clearInterval(Ee)))
        : (Ee || ((ze = Re.now()), (Ee = setInterval(Ve, 1e3))),
          (Ce = 1),
          Le(Ne)));
  }
  function Ge(t, e, i) {
    var r = new Oe();
    return (
      (e = null == e ? 0 : +e),
      r.restart(
        (i) => {
          r.stop(), t(i + e);
        },
        e,
        i
      ),
      r
    );
  }
  Oe.prototype = je.prototype = {
    constructor: Oe,
    restart: function (t, e, i) {
      if ('function' != typeof t)
        throw new TypeError('callback is not a function');
      (i = (null == i ? Fe() : +i) + (null == e ? 0 : +e)),
        this._next ||
          Se === this ||
          (Se ? (Se._next = this) : (Pe = this), (Se = this)),
        (this._call = t),
        (this._time = i),
        Ue();
    },
    stop: function () {
      this._call && ((this._call = null), (this._time = 1 / 0), Ue());
    },
  };
  var Ze = u('start', 'end', 'cancel', 'interrupt'),
    $e = [];
  function qe(t, e, i, r, n, o) {
    var a = t.__transition;
    if (a) {
      if (i in a) return;
    } else t.__transition = {};
    !(function (t, e, i) {
      var r,
        n = t.__transition;
      function o(t) {
        (i.state = 1),
          i.timer.restart(a, i.delay, i.time),
          i.delay <= t && a(t - i.delay);
      }
      function a(o) {
        var c, h, u, d;
        if (1 !== i.state) return l();
        for (c in n)
          if ((d = n[c]).name === i.name) {
            if (3 === d.state) return Ge(a);
            4 === d.state
              ? ((d.state = 6),
                d.timer.stop(),
                d.on.call('interrupt', t, t.__data__, d.index, d.group),
                delete n[c])
              : +c < e &&
                ((d.state = 6),
                d.timer.stop(),
                d.on.call('cancel', t, t.__data__, d.index, d.group),
                delete n[c]);
          }
        if (
          (Ge(function () {
            3 === i.state &&
              ((i.state = 4), i.timer.restart(s, i.delay, i.time), s(o));
          }),
          (i.state = 2),
          i.on.call('start', t, t.__data__, i.index, i.group),
          2 === i.state)
        ) {
          for (
            i.state = 3, r = new Array((u = i.tween.length)), c = 0, h = -1;
            c < u;
            ++c
          )
            (d = i.tween[c].value.call(t, t.__data__, i.index, i.group)) &&
              (r[++h] = d);
          r.length = h + 1;
        }
      }
      function s(e) {
        for (
          var n =
              e < i.duration
                ? i.ease.call(null, e / i.duration)
                : (i.timer.restart(l), (i.state = 5), 1),
            o = -1,
            a = r.length;
          ++o < a;

        )
          r[o].call(t, n);
        5 === i.state &&
          (i.on.call('end', t, t.__data__, i.index, i.group), l());
      }
      function l() {
        for (var r in ((i.state = 6), i.timer.stop(), delete n[e], n)) return;
        delete t.__transition;
      }
      (n[e] = i), (i.timer = je(o, 0, i.time));
    })(t, i, {
      name: e,
      index: r,
      group: n,
      on: Ze,
      tween: $e,
      time: o.time,
      delay: o.delay,
      duration: o.duration,
      ease: o.ease,
      timer: null,
      state: 0,
    });
  }
  function We(t, e) {
    var i = He(t, e);
    if (i.state > 0) throw new Error('too late; already scheduled');
    return i;
  }
  function Ye(t, e) {
    var i = He(t, e);
    if (i.state > 3) throw new Error('too late; already running');
    return i;
  }
  function He(t, e) {
    var i = t.__transition;
    if (!i || !(i = i[e])) throw new Error('transition not found');
    return i;
  }
  function Xe(t, e) {
    var i, r;
    return function () {
      var n = Ye(this, t),
        o = n.tween;
      if (o !== i)
        for (var a = 0, s = (r = i = o).length; a < s; ++a)
          if (r[a].name === e) {
            (r = r.slice()).splice(a, 1);
            break;
          }
      n.tween = r;
    };
  }
  function Ke(t, e, i) {
    var r, n;
    if ('function' != typeof i) throw new Error();
    return function () {
      var o = Ye(this, t),
        a = o.tween;
      if (a !== r) {
        n = (r = a).slice();
        for (var s = { name: e, value: i }, l = 0, c = n.length; l < c; ++l)
          if (n[l].name === e) {
            n[l] = s;
            break;
          }
        l === c && n.push(s);
      }
      o.tween = n;
    };
  }
  function Je(t, e, i) {
    var r = t._id;
    return (
      t.each(function () {
        var t = Ye(this, r);
        (t.value || (t.value = {}))[e] = i.apply(this, arguments);
      }),
      function (t) {
        return He(t, r).value[e];
      }
    );
  }
  function Qe(t, e) {
    var i;
    return (
      'number' == typeof e
        ? me
        : e instanceof Yt
        ? fe
        : (i = Yt(e))
        ? ((e = i), fe)
        : ye
    )(t, e);
  }
  function ti(t) {
    return function () {
      this.removeAttribute(t);
    };
  }
  function ei(t) {
    return function () {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function ii(t, e, i) {
    var r,
      n,
      o = i + '';
    return function () {
      var a = this.getAttribute(t);
      return a === o ? null : a === r ? n : (n = e((r = a), i));
    };
  }
  function ri(t, e, i) {
    var r,
      n,
      o = i + '';
    return function () {
      var a = this.getAttributeNS(t.space, t.local);
      return a === o ? null : a === r ? n : (n = e((r = a), i));
    };
  }
  function ni(t, e, i) {
    var r, n, o;
    return function () {
      var a,
        s,
        l = i(this);
      if (null != l)
        return (a = this.getAttribute(t)) === (s = l + '')
          ? null
          : a === r && s === n
          ? o
          : ((n = s), (o = e((r = a), l)));
      this.removeAttribute(t);
    };
  }
  function oi(t, e, i) {
    var r, n, o;
    return function () {
      var a,
        s,
        l = i(this);
      if (null != l)
        return (a = this.getAttributeNS(t.space, t.local)) === (s = l + '')
          ? null
          : a === r && s === n
          ? o
          : ((n = s), (o = e((r = a), l)));
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function ai(t, e) {
    return function (i) {
      this.setAttribute(t, e.call(this, i));
    };
  }
  function si(t, e) {
    return function (i) {
      this.setAttributeNS(t.space, t.local, e.call(this, i));
    };
  }
  function li(t, e) {
    var i, r;
    function n() {
      var n = e.apply(this, arguments);
      return n !== r && (i = (r = n) && si(t, n)), i;
    }
    return (n._value = e), n;
  }
  function ci(t, e) {
    var i, r;
    function n() {
      var n = e.apply(this, arguments);
      return n !== r && (i = (r = n) && ai(t, n)), i;
    }
    return (n._value = e), n;
  }
  function hi(t, e) {
    return function () {
      We(this, t).delay = +e.apply(this, arguments);
    };
  }
  function ui(t, e) {
    return (
      (e = +e),
      function () {
        We(this, t).delay = e;
      }
    );
  }
  function di(t, e) {
    return function () {
      Ye(this, t).duration = +e.apply(this, arguments);
    };
  }
  function pi(t, e) {
    return (
      (e = +e),
      function () {
        Ye(this, t).duration = e;
      }
    );
  }
  function fi(t, e) {
    if ('function' != typeof e) throw new Error();
    return function () {
      Ye(this, t).ease = e;
    };
  }
  function mi(t, e, i) {
    var r,
      n,
      o = (function (t) {
        return (t + '')
          .trim()
          .split(/^|\s+/)
          .every(function (t) {
            var e = t.indexOf('.');
            return e >= 0 && (t = t.slice(0, e)), !t || 'start' === t;
          });
      })(e)
        ? We
        : Ye;
    return function () {
      var a = o(this, t),
        s = a.on;
      s !== r && (n = (r = s).copy()).on(e, i), (a.on = n);
    };
  }
  var _i = At.prototype.constructor;
  function gi(t) {
    return function () {
      this.style.removeProperty(t);
    };
  }
  function yi(t, e, i) {
    return function (r) {
      this.style.setProperty(t, e.call(this, r), i);
    };
  }
  function xi(t, e, i) {
    var r, n;
    function o() {
      var o = e.apply(this, arguments);
      return o !== n && (r = (n = o) && yi(t, o, i)), r;
    }
    return (o._value = e), o;
  }
  function vi(t) {
    return function (e) {
      this.textContent = t.call(this, e);
    };
  }
  function bi(t) {
    var e, i;
    function r() {
      var r = t.apply(this, arguments);
      return r !== i && (e = (i = r) && vi(r)), e;
    }
    return (r._value = t), r;
  }
  var wi = 0;
  function Ti(t, e, i, r) {
    (this._groups = t), (this._parents = e), (this._name = i), (this._id = r);
  }
  function Pi() {
    return ++wi;
  }
  var Si = At.prototype;
  Ti.prototype = {
    constructor: Ti,
    select: function (t) {
      var e = this._name,
        i = this._id;
      'function' != typeof t && (t = T(t));
      for (
        var r = this._groups, n = r.length, o = new Array(n), a = 0;
        a < n;
        ++a
      )
        for (
          var s, l, c = r[a], h = c.length, u = (o[a] = new Array(h)), d = 0;
          d < h;
          ++d
        )
          (s = c[d]) &&
            (l = t.call(s, s.__data__, d, c)) &&
            ('__data__' in s && (l.__data__ = s.__data__),
            (u[d] = l),
            qe(u[d], e, i, d, u, He(s, i)));
      return new Ti(o, this._parents, e, i);
    },
    selectAll: function (t) {
      var e = this._name,
        i = this._id;
      'function' != typeof t && (t = M(t));
      for (
        var r = this._groups, n = r.length, o = [], a = [], s = 0;
        s < n;
        ++s
      )
        for (var l, c = r[s], h = c.length, u = 0; u < h; ++u)
          if ((l = c[u])) {
            for (
              var d,
                p = t.call(l, l.__data__, u, c),
                f = He(l, i),
                m = 0,
                _ = p.length;
              m < _;
              ++m
            )
              (d = p[m]) && qe(d, e, i, m, p, f);
            o.push(p), a.push(l);
          }
      return new Ti(o, a, e, i);
    },
    selectChild: Si.selectChild,
    selectChildren: Si.selectChildren,
    filter: function (t) {
      'function' != typeof t && (t = I(t));
      for (
        var e = this._groups, i = e.length, r = new Array(i), n = 0;
        n < i;
        ++n
      )
        for (var o, a = e[n], s = a.length, l = (r[n] = []), c = 0; c < s; ++c)
          (o = a[c]) && t.call(o, o.__data__, c, a) && l.push(o);
      return new Ti(r, this._parents, this._name, this._id);
    },
    merge: function (t) {
      if (t._id !== this._id) throw new Error();
      for (
        var e = this._groups,
          i = t._groups,
          r = e.length,
          n = i.length,
          o = Math.min(r, n),
          a = new Array(r),
          s = 0;
        s < o;
        ++s
      )
        for (
          var l,
            c = e[s],
            h = i[s],
            u = c.length,
            d = (a[s] = new Array(u)),
            p = 0;
          p < u;
          ++p
        )
          (l = c[p] || h[p]) && (d[p] = l);
      for (; s < r; ++s) a[s] = e[s];
      return new Ti(a, this._parents, this._name, this._id);
    },
    selection: function () {
      return new _i(this._groups, this._parents);
    },
    transition: function () {
      for (
        var t = this._name,
          e = this._id,
          i = Pi(),
          r = this._groups,
          n = r.length,
          o = 0;
        o < n;
        ++o
      )
        for (var a, s = r[o], l = s.length, c = 0; c < l; ++c)
          if ((a = s[c])) {
            var h = He(a, e);
            qe(a, t, i, c, s, {
              time: h.time + h.delay + h.duration,
              delay: 0,
              duration: h.duration,
              ease: h.ease,
            });
          }
      return new Ti(r, this._parents, t, i);
    },
    call: Si.call,
    nodes: Si.nodes,
    node: Si.node,
    size: Si.size,
    empty: Si.empty,
    each: Si.each,
    on: function (t, e) {
      var i = this._id;
      return arguments.length < 2
        ? He(this.node(), i).on.on(t)
        : this.each(mi(i, t, e));
    },
    attr: function (t, e) {
      var i = y(t),
        r = 'transform' === i ? Ie : Qe;
      return this.attrTween(
        t,
        'function' == typeof e
          ? (i.local ? oi : ni)(i, r, Je(this, 'attr.' + t, e))
          : null == e
          ? (i.local ? ei : ti)(i)
          : (i.local ? ri : ii)(i, r, e)
      );
    },
    attrTween: function (t, e) {
      var i = 'attr.' + t;
      if (arguments.length < 2) return (i = this.tween(i)) && i._value;
      if (null == e) return this.tween(i, null);
      if ('function' != typeof e) throw new Error();
      var r = y(t);
      return this.tween(i, (r.local ? li : ci)(r, e));
    },
    style: function (t, e, i) {
      var r = 'transform' == (t += '') ? Me : Qe;
      return null == e
        ? this.styleTween(
            t,
            (function (t, e) {
              var i, r, n;
              return function () {
                var o = K(this, t),
                  a = (this.style.removeProperty(t), K(this, t));
                return o === a
                  ? null
                  : o === i && a === r
                  ? n
                  : (n = e((i = o), (r = a)));
              };
            })(t, r)
          ).on('end.style.' + t, gi(t))
        : 'function' == typeof e
        ? this.styleTween(
            t,
            (function (t, e, i) {
              var r, n, o;
              return function () {
                var a = K(this, t),
                  s = i(this),
                  l = s + '';
                return (
                  null == s &&
                    (this.style.removeProperty(t), (l = s = K(this, t))),
                  a === l
                    ? null
                    : a === r && l === n
                    ? o
                    : ((n = l), (o = e((r = a), s)))
                );
              };
            })(t, r, Je(this, 'style.' + t, e))
          ).each(
            (function (t, e) {
              var i,
                r,
                n,
                o,
                a = 'style.' + e,
                s = 'end.' + a;
              return function () {
                var l = Ye(this, t),
                  c = l.on,
                  h = null == l.value[a] ? o || (o = gi(e)) : void 0;
                (c === i && n === h) || (r = (i = c).copy()).on(s, (n = h)),
                  (l.on = r);
              };
            })(this._id, t)
          )
        : this.styleTween(
            t,
            (function (t, e, i) {
              var r,
                n,
                o = i + '';
              return function () {
                var a = K(this, t);
                return a === o ? null : a === r ? n : (n = e((r = a), i));
              };
            })(t, r, e),
            i
          ).on('end.style.' + t, null);
    },
    styleTween: function (t, e, i) {
      var r = 'style.' + (t += '');
      if (arguments.length < 2) return (r = this.tween(r)) && r._value;
      if (null == e) return this.tween(r, null);
      if ('function' != typeof e) throw new Error();
      return this.tween(r, xi(t, e, null == i ? '' : i));
    },
    text: function (t) {
      return this.tween(
        'text',
        'function' == typeof t
          ? (function (t) {
              return function () {
                var e = t(this);
                this.textContent = null == e ? '' : e;
              };
            })(Je(this, 'text', t))
          : (function (t) {
              return function () {
                this.textContent = t;
              };
            })(null == t ? '' : t + '')
      );
    },
    textTween: function (t) {
      var e = 'text';
      if (arguments.length < 1) return (e = this.tween(e)) && e._value;
      if (null == t) return this.tween(e, null);
      if ('function' != typeof t) throw new Error();
      return this.tween(e, bi(t));
    },
    remove: function () {
      return this.on(
        'end.remove',
        (function (t) {
          return function () {
            var e = this.parentNode;
            for (var i in this.__transition) if (+i !== t) return;
            e && e.removeChild(this);
          };
        })(this._id)
      );
    },
    tween: function (t, e) {
      var i = this._id;
      if (((t += ''), arguments.length < 2)) {
        for (
          var r, n = He(this.node(), i).tween, o = 0, a = n.length;
          o < a;
          ++o
        )
          if ((r = n[o]).name === t) return r.value;
        return null;
      }
      return this.each((null == e ? Xe : Ke)(i, t, e));
    },
    delay: function (t) {
      var e = this._id;
      return arguments.length
        ? this.each(('function' == typeof t ? hi : ui)(e, t))
        : He(this.node(), e).delay;
    },
    duration: function (t) {
      var e = this._id;
      return arguments.length
        ? this.each(('function' == typeof t ? di : pi)(e, t))
        : He(this.node(), e).duration;
    },
    ease: function (t) {
      var e = this._id;
      return arguments.length ? this.each(fi(e, t)) : He(this.node(), e).ease;
    },
    easeVarying: function (t) {
      if ('function' != typeof t) throw new Error();
      return this.each(
        (function (t, e) {
          return function () {
            var i = e.apply(this, arguments);
            if ('function' != typeof i) throw new Error();
            Ye(this, t).ease = i;
          };
        })(this._id, t)
      );
    },
    end: function () {
      var t,
        e,
        i = this,
        r = i._id,
        n = i.size();
      return new Promise(function (o, a) {
        var s = { value: a },
          l = {
            value: function () {
              0 == --n && o();
            },
          };
        i.each(function () {
          var i = Ye(this, r),
            n = i.on;
          n !== t &&
            ((e = (t = n).copy())._.cancel.push(s),
            e._.interrupt.push(s),
            e._.end.push(l)),
            (i.on = e);
        }),
          0 === n && o();
      });
    },
    [Symbol.iterator]: Si[Symbol.iterator],
  };
  var Mi = {
    time: null,
    delay: 0,
    duration: 250,
    ease: function (t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    },
  };
  function Ii(t, e) {
    for (var i; !(i = t.__transition) || !(i = i[e]); )
      if (!(t = t.parentNode)) throw new Error(`transition ${e} not found`);
    return i;
  }
  function Ci(t, e, i) {
    (this.k = t), (this.x = e), (this.y = i);
  }
  (At.prototype.interrupt = function (t) {
    return this.each(function () {
      !(function (t, e) {
        var i,
          r,
          n,
          o = t.__transition,
          a = !0;
        if (o) {
          for (n in ((e = null == e ? null : e + ''), o))
            (i = o[n]).name === e
              ? ((r = i.state > 2 && i.state < 5),
                (i.state = 6),
                i.timer.stop(),
                i.on.call(
                  r ? 'interrupt' : 'cancel',
                  t,
                  t.__data__,
                  i.index,
                  i.group
                ),
                delete o[n])
              : (a = !1);
          a && delete t.__transition;
        }
      })(this, t);
    });
  }),
    (At.prototype.transition = function (t) {
      var e, i;
      t instanceof Ti
        ? ((e = t._id), (t = t._name))
        : ((e = Pi()), ((i = Mi).time = Fe()), (t = null == t ? null : t + ''));
      for (var r = this._groups, n = r.length, o = 0; o < n; ++o)
        for (var a, s = r[o], l = s.length, c = 0; c < l; ++c)
          (a = s[c]) && qe(a, t, e, c, s, i || Ii(a, e));
      return new Ti(r, this._parents, t, e);
    }),
    (Ci.prototype = {
      constructor: Ci,
      scale: function (t) {
        return 1 === t ? this : new Ci(this.k * t, this.x, this.y);
      },
      translate: function (t, e) {
        return (0 === t) & (0 === e)
          ? this
          : new Ci(this.k, this.x + this.k * t, this.y + this.k * e);
      },
      apply: function (t) {
        return [t[0] * this.k + this.x, t[1] * this.k + this.y];
      },
      applyX: function (t) {
        return t * this.k + this.x;
      },
      applyY: function (t) {
        return t * this.k + this.y;
      },
      invert: function (t) {
        return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
      },
      invertX: function (t) {
        return (t - this.x) / this.k;
      },
      invertY: function (t) {
        return (t - this.y) / this.k;
      },
      rescaleX: function (t) {
        return t
          .copy()
          .domain(t.range().map(this.invertX, this).map(t.invert, t));
      },
      rescaleY: function (t) {
        return t
          .copy()
          .domain(t.range().map(this.invertY, this).map(t.invert, t));
      },
      toString: function () {
        return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')';
      },
    }),
    new Ci(1, 0, 0),
    Ci.prototype;
  'undefined' != typeof globalThis
    ? globalThis
    : 'undefined' != typeof window
    ? window
    : 'undefined' != typeof global
    ? global
    : 'undefined' != typeof self && self;
  function Ai(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, 'default')
      ? t.default
      : t;
  }
  var Ei = { exports: {} };
  /**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
   */ Ei.exports = (function () {
    var t = {},
      e = {};
    function i(i, r, n) {
      if (((e[i] = n), 'index' === i)) {
        var o =
            'var sharedModule = {}; (' +
            e.shared +
            ')(sharedModule); (' +
            e.worker +
            ')(sharedModule);',
          a = {};
        return (
          e.shared(a),
          e.index(t, a),
          'undefined' != typeof window &&
            t.setWorkerUrl(
              window.URL.createObjectURL(
                new Blob([o], { type: 'text/javascript' })
              )
            ),
          t
        );
      }
    }
    i('shared', ['exports'], function (t) {
      function e(t, e, i, r) {
        return new (i || (i = Promise))(function (n, o) {
          function a(t) {
            try {
              l(r.next(t));
            } catch (t) {
              o(t);
            }
          }
          function s(t) {
            try {
              l(r.throw(t));
            } catch (t) {
              o(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? n(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(a, s);
          }
          l((r = r.apply(t, e || [])).next());
        });
      }
      function i(t, e) {
        (this.x = t), (this.y = e);
      }
      function r(t) {
        return t &&
          t.__esModule &&
          Object.prototype.hasOwnProperty.call(t, 'default')
          ? t.default
          : t;
      }
      var n, o;
      'function' == typeof SuppressedError && SuppressedError,
        (i.prototype = {
          clone() {
            return new i(this.x, this.y);
          },
          add(t) {
            return this.clone()._add(t);
          },
          sub(t) {
            return this.clone()._sub(t);
          },
          multByPoint(t) {
            return this.clone()._multByPoint(t);
          },
          divByPoint(t) {
            return this.clone()._divByPoint(t);
          },
          mult(t) {
            return this.clone()._mult(t);
          },
          div(t) {
            return this.clone()._div(t);
          },
          rotate(t) {
            return this.clone()._rotate(t);
          },
          rotateAround(t, e) {
            return this.clone()._rotateAround(t, e);
          },
          matMult(t) {
            return this.clone()._matMult(t);
          },
          unit() {
            return this.clone()._unit();
          },
          perp() {
            return this.clone()._perp();
          },
          round() {
            return this.clone()._round();
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          },
          equals(t) {
            return this.x === t.x && this.y === t.y;
          },
          dist(t) {
            return Math.sqrt(this.distSqr(t));
          },
          distSqr(t) {
            const e = t.x - this.x,
              i = t.y - this.y;
            return e * e + i * i;
          },
          angle() {
            return Math.atan2(this.y, this.x);
          },
          angleTo(t) {
            return Math.atan2(this.y - t.y, this.x - t.x);
          },
          angleWith(t) {
            return this.angleWithSep(t.x, t.y);
          },
          angleWithSep(t, e) {
            return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
          },
          _matMult(t) {
            const e = t[2] * this.x + t[3] * this.y;
            return (this.x = t[0] * this.x + t[1] * this.y), (this.y = e), this;
          },
          _add(t) {
            return (this.x += t.x), (this.y += t.y), this;
          },
          _sub(t) {
            return (this.x -= t.x), (this.y -= t.y), this;
          },
          _mult(t) {
            return (this.x *= t), (this.y *= t), this;
          },
          _div(t) {
            return (this.x /= t), (this.y /= t), this;
          },
          _multByPoint(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          },
          _divByPoint(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          },
          _unit() {
            return this._div(this.mag()), this;
          },
          _perp() {
            const t = this.y;
            return (this.y = this.x), (this.x = -t), this;
          },
          _rotate(t) {
            const e = Math.cos(t),
              i = Math.sin(t),
              r = i * this.x + e * this.y;
            return (this.x = e * this.x - i * this.y), (this.y = r), this;
          },
          _rotateAround(t, e) {
            const i = Math.cos(t),
              r = Math.sin(t),
              n = e.y + r * (this.x - e.x) + i * (this.y - e.y);
            return (
              (this.x = e.x + i * (this.x - e.x) - r * (this.y - e.y)),
              (this.y = n),
              this
            );
          },
          _round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          },
          constructor: i,
        }),
        (i.convert = function (t) {
          if (t instanceof i) return t;
          if (Array.isArray(t)) return new i(+t[0], +t[1]);
          if (void 0 !== t.x && void 0 !== t.y) return new i(+t.x, +t.y);
          throw new Error('Expected [x, y] or {x, y} point format');
        });
      var a = (function () {
          if (o) return n;
          function t(t, e, i, r) {
            (this.cx = 3 * t),
              (this.bx = 3 * (i - t) - this.cx),
              (this.ax = 1 - this.cx - this.bx),
              (this.cy = 3 * e),
              (this.by = 3 * (r - e) - this.cy),
              (this.ay = 1 - this.cy - this.by),
              (this.p1x = t),
              (this.p1y = e),
              (this.p2x = i),
              (this.p2y = r);
          }
          return (
            (o = 1),
            (n = t),
            (t.prototype = {
              sampleCurveX: function (t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t;
              },
              sampleCurveY: function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
              },
              sampleCurveDerivativeX: function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
              },
              solveCurveX: function (t, e) {
                if ((void 0 === e && (e = 1e-6), t < 0)) return 0;
                if (t > 1) return 1;
                for (var i = t, r = 0; r < 8; r++) {
                  var n = this.sampleCurveX(i) - t;
                  if (Math.abs(n) < e) return i;
                  var o = this.sampleCurveDerivativeX(i);
                  if (Math.abs(o) < 1e-6) break;
                  i -= n / o;
                }
                var a = 0,
                  s = 1;
                for (
                  i = t, r = 0;
                  r < 20 &&
                  ((n = this.sampleCurveX(i)), !(Math.abs(n - t) < e));
                  r++
                )
                  t > n ? (a = i) : (s = i), (i = 0.5 * (s - a) + a);
                return i;
              },
              solve: function (t, e) {
                return this.sampleCurveY(this.solveCurveX(t, e));
              },
            }),
            n
          );
        })(),
        s = r(a);
      let l, c;
      function h() {
        return (
          null == l &&
            (l =
              'undefined' != typeof OffscreenCanvas &&
              new OffscreenCanvas(1, 1).getContext('2d') &&
              'function' == typeof createImageBitmap),
          l
        );
      }
      function u() {
        if (null == c && ((c = !1), h())) {
          const t = 5,
            e = new OffscreenCanvas(t, t).getContext('2d', {
              willReadFrequently: !0,
            });
          if (e) {
            for (let r = 0; r < t * t; r++) {
              const i = 4 * r;
              (e.fillStyle = `rgb(${i},${i + 1},${i + 2})`),
                e.fillRect(r % t, Math.floor(r / t), 1, 1);
            }
            const i = e.getImageData(0, 0, t, t).data;
            for (let e = 0; e < t * t * 4; e++)
              if (e % 4 != 3 && i[e] !== e) {
                c = !0;
                break;
              }
          }
        }
        return c || !1;
      }
      var d = 1e-6,
        p = 'undefined' != typeof Float32Array ? Float32Array : Array;
      function f() {
        var t = new p(9);
        return (
          p != Float32Array &&
            ((t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[5] = 0),
            (t[6] = 0),
            (t[7] = 0)),
          (t[0] = 1),
          (t[4] = 1),
          (t[8] = 1),
          t
        );
      }
      function m(t) {
        return (
          (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = 1),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[10] = 1),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          t
        );
      }
      function _() {
        var t = new p(3);
        return p != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
      }
      function g(t) {
        var e = t[0],
          i = t[1],
          r = t[2];
        return Math.sqrt(e * e + i * i + r * r);
      }
      function y(t, e, i) {
        var r = new p(3);
        return (r[0] = t), (r[1] = e), (r[2] = i), r;
      }
      function x(t, e, i) {
        return (
          (t[0] = e[0] + i[0]), (t[1] = e[1] + i[1]), (t[2] = e[2] + i[2]), t
        );
      }
      function v(t, e, i) {
        return (t[0] = e[0] * i), (t[1] = e[1] * i), (t[2] = e[2] * i), t;
      }
      function b(t, e, i) {
        var r = e[0],
          n = e[1],
          o = e[2],
          a = i[0],
          s = i[1],
          l = i[2];
        return (
          (t[0] = n * l - o * s),
          (t[1] = o * a - r * l),
          (t[2] = r * s - n * a),
          t
        );
      }
      var w,
        T = g;
      function P(t, e, i) {
        var r = e[0],
          n = e[1],
          o = e[2],
          a = e[3];
        return (
          (t[0] = i[0] * r + i[4] * n + i[8] * o + i[12] * a),
          (t[1] = i[1] * r + i[5] * n + i[9] * o + i[13] * a),
          (t[2] = i[2] * r + i[6] * n + i[10] * o + i[14] * a),
          (t[3] = i[3] * r + i[7] * n + i[11] * o + i[15] * a),
          t
        );
      }
      function S() {
        var t = new p(4);
        return (
          p != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)),
          (t[3] = 1),
          t
        );
      }
      function M(t, e, i, r) {
        var n =
            arguments.length > 4 && void 0 !== arguments[4]
              ? arguments[4]
              : 'zyx',
          o = Math.PI / 360;
        (e *= o), (r *= o), (i *= o);
        var a = Math.sin(e),
          s = Math.cos(e),
          l = Math.sin(i),
          c = Math.cos(i),
          h = Math.sin(r),
          u = Math.cos(r);
        switch (n) {
          case 'xyz':
            (t[0] = a * c * u + s * l * h),
              (t[1] = s * l * u - a * c * h),
              (t[2] = s * c * h + a * l * u),
              (t[3] = s * c * u - a * l * h);
            break;
          case 'xzy':
            (t[0] = a * c * u - s * l * h),
              (t[1] = s * l * u - a * c * h),
              (t[2] = s * c * h + a * l * u),
              (t[3] = s * c * u + a * l * h);
            break;
          case 'yxz':
            (t[0] = a * c * u + s * l * h),
              (t[1] = s * l * u - a * c * h),
              (t[2] = s * c * h - a * l * u),
              (t[3] = s * c * u + a * l * h);
            break;
          case 'yzx':
            (t[0] = a * c * u + s * l * h),
              (t[1] = s * l * u + a * c * h),
              (t[2] = s * c * h - a * l * u),
              (t[3] = s * c * u - a * l * h);
            break;
          case 'zxy':
            (t[0] = a * c * u - s * l * h),
              (t[1] = s * l * u + a * c * h),
              (t[2] = s * c * h + a * l * u),
              (t[3] = s * c * u - a * l * h);
            break;
          case 'zyx':
            (t[0] = a * c * u - s * l * h),
              (t[1] = s * l * u + a * c * h),
              (t[2] = s * c * h - a * l * u),
              (t[3] = s * c * u + a * l * h);
            break;
          default:
            throw new Error('Unknown angle order ' + n);
        }
        return t;
      }
      function I() {
        var t = new p(2);
        return p != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
      }
      function C(t, e) {
        var i = new p(2);
        return (i[0] = t), (i[1] = e), i;
      }
      _(),
        (w = new p(4)),
        p != Float32Array && ((w[0] = 0), (w[1] = 0), (w[2] = 0), (w[3] = 0)),
        _(),
        y(1, 0, 0),
        y(0, 1, 0),
        S(),
        S(),
        f(),
        I();
      const A = 8192;
      function E(t, e, i) {
        return e * (A / (t.tileSize * Math.pow(2, i - t.tileID.overscaledZ)));
      }
      function z(t, e) {
        return ((t % e) + e) % e;
      }
      function k(t, e, i) {
        return t * (1 - i) + e * i;
      }
      function D(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        const e = t * t,
          i = e * t;
        return 4 * (t < 0.5 ? i : 3 * (t - e) + i - 0.75);
      }
      function R(t, e, i, r) {
        const n = new s(t, e, i, r);
        return (t) => n.solve(t);
      }
      const L = R(0.25, 0.1, 0.25, 1);
      function F(t, e, i) {
        return Math.min(i, Math.max(e, t));
      }
      function B(t, e, i) {
        const r = i - e,
          n = ((((t - e) % r) + r) % r) + e;
        return n === e ? i : n;
      }
      function O(t, ...e) {
        for (const i of e) for (const e in i) t[e] = i[e];
        return t;
      }
      let j = 1;
      function N(t, e, i) {
        const r = {};
        for (const n in t) r[n] = e.call(this, t[n], n, t);
        return r;
      }
      function V(t, e, i) {
        const r = {};
        for (const n in t) e.call(this, t[n], n, t) && (r[n] = t[n]);
        return r;
      }
      function U(t) {
        return Array.isArray(t)
          ? t.map(U)
          : 'object' == typeof t && t
          ? N(t, U)
          : t;
      }
      const G = {};
      function Z(t) {
        G[t] || ('undefined' != typeof console && console.warn(t), (G[t] = !0));
      }
      function $(t, e, i) {
        return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x);
      }
      function q(t) {
        return (
          'undefined' != typeof WorkerGlobalScope &&
          void 0 !== t &&
          t instanceof WorkerGlobalScope
        );
      }
      let W = null;
      function Y(t) {
        if (null == W) {
          const e = t.navigator ? t.navigator.userAgent : null;
          W =
            !!t.safari ||
            !(
              !e ||
              !(
                /\b(iPad|iPhone|iPod)\b/.test(e) ||
                (e.match('Safari') && !e.match('Chrome'))
              )
            );
        }
        return W;
      }
      function H(t) {
        return 'undefined' != typeof ImageBitmap && t instanceof ImageBitmap;
      }
      const X =
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
      function K(t, i, r, n, o) {
        return e(this, void 0, void 0, function* () {
          if ('undefined' == typeof VideoFrame)
            throw new Error('VideoFrame not supported');
          const e = new VideoFrame(t, { timestamp: 0 });
          try {
            const a = null == e ? void 0 : e.format;
            if (!a || (!a.startsWith('BGR') && !a.startsWith('RGB')))
              throw new Error(`Unrecognized format ${a}`);
            const s = a.startsWith('BGR'),
              l = new Uint8ClampedArray(n * o * 4);
            if (
              (yield e.copyTo(
                l,
                (function (t, e, i, r, n) {
                  const o = 4 * Math.max(-e, 0),
                    a = (Math.max(0, i) - i) * r * 4 + o,
                    s = 4 * r,
                    l = Math.max(0, e),
                    c = Math.max(0, i);
                  return {
                    rect: {
                      x: l,
                      y: c,
                      width: Math.min(t.width, e + r) - l,
                      height: Math.min(t.height, i + n) - c,
                    },
                    layout: [{ offset: a, stride: s }],
                  };
                })(t, i, r, n, o)
              ),
              s)
            )
              for (let t = 0; t < l.length; t += 4) {
                const e = l[t];
                (l[t] = l[t + 2]), (l[t + 2] = e);
              }
            return l;
          } finally {
            e.close();
          }
        });
      }
      let J, Q;
      function tt(t, e, i, r) {
        return (
          t.addEventListener(e, i, r),
          {
            unsubscribe: () => {
              t.removeEventListener(e, i, r);
            },
          }
        );
      }
      function et(t) {
        return (t * Math.PI) / 180;
      }
      function it(t) {
        return (t / Math.PI) * 180;
      }
      const rt = {
          touchstart: !0,
          touchmove: !0,
          touchmoveWindow: !0,
          touchend: !0,
          touchcancel: !0,
        },
        nt = {
          dblclick: !0,
          click: !0,
          mouseover: !0,
          mouseout: !0,
          mousedown: !0,
          mousemove: !0,
          mousemoveWindow: !0,
          mouseup: !0,
          mouseupWindow: !0,
          contextmenu: !0,
          wheel: !0,
        },
        ot = 'AbortError';
      function at() {
        return new Error(ot);
      }
      const st = {
        MAX_PARALLEL_IMAGE_REQUESTS: 16,
        MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
        MAX_TILE_CACHE_ZOOM_LEVELS: 5,
        REGISTERED_PROTOCOLS: {},
        WORKER_URL: '',
      };
      function lt(t) {
        return st.REGISTERED_PROTOCOLS[t.substring(0, t.indexOf('://'))];
      }
      const ct = 'global-dispatcher';
      class ht extends Error {
        constructor(t, e, i, r) {
          super(`AJAXError: ${e} (${t}): ${i}`),
            (this.status = t),
            (this.statusText = e),
            (this.url = i),
            (this.body = r);
        }
      }
      const ut = () =>
          q(self)
            ? self.worker && self.worker.referrer
            : ('blob:' === window.location.protocol ? window.parent : window)
                .location.href,
        dt = function (t, i) {
          if (/:\/\//.test(t.url) && !/^https?:|^file:/.test(t.url)) {
            const e = lt(t.url);
            if (e) return e(t, i);
            if (q(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync(
                { type: 'GR', data: t, targetMapId: ct },
                i
              );
          }
          if (
            !(
              /^file:/.test((r = t.url)) ||
              (/^file:/.test(ut()) && !/^\w+:/.test(r))
            )
          ) {
            if (
              fetch &&
              Request &&
              AbortController &&
              Object.prototype.hasOwnProperty.call(Request.prototype, 'signal')
            )
              return (function (t, i) {
                return e(this, void 0, void 0, function* () {
                  const e = new Request(t.url, {
                    method: t.method || 'GET',
                    body: t.body,
                    credentials: t.credentials,
                    headers: t.headers,
                    cache: t.cache,
                    referrer: ut(),
                    signal: i.signal,
                  });
                  let r, n;
                  'json' !== t.type ||
                    e.headers.has('Accept') ||
                    e.headers.set('Accept', 'application/json');
                  try {
                    r = yield fetch(e);
                  } catch (e) {
                    throw new ht(0, e.message, t.url, new Blob());
                  }
                  if (!r.ok) {
                    const e = yield r.blob();
                    throw new ht(r.status, r.statusText, t.url, e);
                  }
                  n =
                    'arrayBuffer' === t.type || 'image' === t.type
                      ? r.arrayBuffer()
                      : 'json' === t.type
                      ? r.json()
                      : r.text();
                  const o = yield n;
                  if (i.signal.aborted) throw at();
                  return {
                    data: o,
                    cacheControl: r.headers.get('Cache-Control'),
                    expires: r.headers.get('Expires'),
                  };
                });
              })(t, i);
            if (q(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync(
                { type: 'GR', data: t, mustQueue: !0, targetMapId: ct },
                i
              );
          }
          var r;
          return (function (t, e) {
            return new Promise((i, r) => {
              var n;
              const o = new XMLHttpRequest();
              o.open(t.method || 'GET', t.url, !0),
                ('arrayBuffer' !== t.type && 'image' !== t.type) ||
                  (o.responseType = 'arraybuffer');
              for (const e in t.headers) o.setRequestHeader(e, t.headers[e]);
              'json' === t.type &&
                ((o.responseType = 'text'),
                (null === (n = t.headers) || void 0 === n
                  ? void 0
                  : n.Accept) ||
                  o.setRequestHeader('Accept', 'application/json')),
                (o.withCredentials = 'include' === t.credentials),
                (o.onerror = () => {
                  r(new Error(o.statusText));
                }),
                (o.onload = () => {
                  if (!e.signal.aborted)
                    if (
                      ((o.status >= 200 && o.status < 300) || 0 === o.status) &&
                      null !== o.response
                    ) {
                      let e = o.response;
                      if ('json' === t.type)
                        try {
                          e = JSON.parse(o.response);
                        } catch (t) {
                          return void r(t);
                        }
                      i({
                        data: e,
                        cacheControl: o.getResponseHeader('Cache-Control'),
                        expires: o.getResponseHeader('Expires'),
                      });
                    } else {
                      const e = new Blob([o.response], {
                        type: o.getResponseHeader('Content-Type'),
                      });
                      r(new ht(o.status, o.statusText, t.url, e));
                    }
                }),
                e.signal.addEventListener('abort', () => {
                  o.abort(), r(at());
                }),
                o.send(t.body);
            });
          })(t, i);
        };
      function pt(t) {
        if (
          !t ||
          t.indexOf('://') <= 0 ||
          0 === t.indexOf('data:image/') ||
          0 === t.indexOf('blob:')
        )
          return !0;
        const e = new URL(t),
          i = window.location;
        return e.protocol === i.protocol && e.host === i.host;
      }
      function ft(t, e, i) {
        (i[t] && -1 !== i[t].indexOf(e)) || ((i[t] = i[t] || []), i[t].push(e));
      }
      function mt(t, e, i) {
        if (i && i[t]) {
          const r = i[t].indexOf(e);
          -1 !== r && i[t].splice(r, 1);
        }
      }
      class _t {
        constructor(t, e = {}) {
          O(this, e), (this.type = t);
        }
      }
      class gt extends _t {
        constructor(t, e = {}) {
          super('error', O({ error: t }, e));
        }
      }
      class yt {
        on(t, e) {
          return (
            (this._listeners = this._listeners || {}),
            ft(t, e, this._listeners),
            {
              unsubscribe: () => {
                this.off(t, e);
              },
            }
          );
        }
        off(t, e) {
          return (
            mt(t, e, this._listeners), mt(t, e, this._oneTimeListeners), this
          );
        }
        once(t, e) {
          return e
            ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
              ft(t, e, this._oneTimeListeners),
              this)
            : new Promise((e) => this.once(t, e));
        }
        fire(t, e) {
          'string' == typeof t && (t = new _t(t, e || {}));
          const i = t.type;
          if (this.listens(i)) {
            t.target = this;
            const e =
              this._listeners && this._listeners[i]
                ? this._listeners[i].slice()
                : [];
            for (const i of e) i.call(this, t);
            const r =
              this._oneTimeListeners && this._oneTimeListeners[i]
                ? this._oneTimeListeners[i].slice()
                : [];
            for (const o of r)
              mt(i, o, this._oneTimeListeners), o.call(this, t);
            const n = this._eventedParent;
            n &&
              (O(
                t,
                'function' == typeof this._eventedParentData
                  ? this._eventedParentData()
                  : this._eventedParentData
              ),
              n.fire(t));
          } else t instanceof gt && console.error(t.error);
          return this;
        }
        listens(t) {
          return (
            (this._listeners &&
              this._listeners[t] &&
              this._listeners[t].length > 0) ||
            (this._oneTimeListeners &&
              this._oneTimeListeners[t] &&
              this._oneTimeListeners[t].length > 0) ||
            (this._eventedParent && this._eventedParent.listens(t))
          );
        }
        setEventedParent(t, e) {
          return (this._eventedParent = t), (this._eventedParentData = e), this;
        }
      }
      var xt = {
        '$version': 8,
        '$root': {
          'version': { required: !0, type: 'enum', values: [8] },
          'name': { type: 'string' },
          'metadata': { type: '*' },
          'center': { type: 'array', value: 'number' },
          'centerAltitude': { type: 'number' },
          'zoom': { type: 'number' },
          'bearing': {
            type: 'number',
            default: 0,
            period: 360,
            units: 'degrees',
          },
          'pitch': { type: 'number', default: 0, units: 'degrees' },
          'roll': { type: 'number', default: 0, units: 'degrees' },
          'state': { type: 'state', default: {} },
          'light': { type: 'light' },
          'sky': { type: 'sky' },
          'projection': { type: 'projection' },
          'terrain': { type: 'terrain' },
          'sources': { required: !0, type: 'sources' },
          'sprite': { type: 'sprite' },
          'glyphs': { type: 'string' },
          'font-faces': { type: 'array', value: 'fontFaces' },
          'transition': { type: 'transition' },
          'layers': { required: !0, type: 'array', value: 'layer' },
        },
        'sources': { '*': { type: 'source' } },
        'source': [
          'source_vector',
          'source_raster',
          'source_raster_dem',
          'source_geojson',
          'source_video',
          'source_image',
        ],
        'source_vector': {
          'type': { required: !0, type: 'enum', values: { vector: {} } },
          'url': { type: 'string' },
          'tiles': { type: 'array', value: 'string' },
          'bounds': {
            type: 'array',
            value: 'number',
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          'scheme': {
            type: 'enum',
            values: { xyz: {}, tms: {} },
            default: 'xyz',
          },
          'minzoom': { type: 'number', default: 0 },
          'maxzoom': { type: 'number', default: 22 },
          'attribution': { type: 'string' },
          'promoteId': { type: 'promoteId' },
          'volatile': { type: 'boolean', default: !1 },
          'encoding': {
            type: 'enum',
            values: { mvt: {}, mlt: {} },
            default: 'mvt',
          },
          '*': { type: '*' },
        },
        'source_raster': {
          'type': { required: !0, type: 'enum', values: { raster: {} } },
          'url': { type: 'string' },
          'tiles': { type: 'array', value: 'string' },
          'bounds': {
            type: 'array',
            value: 'number',
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          'minzoom': { type: 'number', default: 0 },
          'maxzoom': { type: 'number', default: 22 },
          'tileSize': { type: 'number', default: 512, units: 'pixels' },
          'scheme': {
            type: 'enum',
            values: { xyz: {}, tms: {} },
            default: 'xyz',
          },
          'attribution': { type: 'string' },
          'volatile': { type: 'boolean', default: !1 },
          '*': { type: '*' },
        },
        'source_raster_dem': {
          'type': { required: !0, type: 'enum', values: { 'raster-dem': {} } },
          'url': { type: 'string' },
          'tiles': { type: 'array', value: 'string' },
          'bounds': {
            type: 'array',
            value: 'number',
            length: 4,
            default: [-180, -85.051129, 180, 85.051129],
          },
          'minzoom': { type: 'number', default: 0 },
          'maxzoom': { type: 'number', default: 22 },
          'tileSize': { type: 'number', default: 512, units: 'pixels' },
          'attribution': { type: 'string' },
          'encoding': {
            type: 'enum',
            values: { terrarium: {}, mapbox: {}, custom: {} },
            default: 'mapbox',
          },
          'redFactor': { type: 'number', default: 1 },
          'blueFactor': { type: 'number', default: 1 },
          'greenFactor': { type: 'number', default: 1 },
          'baseShift': { type: 'number', default: 0 },
          'volatile': { type: 'boolean', default: !1 },
          '*': { type: '*' },
        },
        'source_geojson': {
          type: { required: !0, type: 'enum', values: { geojson: {} } },
          data: { required: !0, type: '*' },
          maxzoom: { type: 'number', default: 18 },
          attribution: { type: 'string' },
          buffer: { type: 'number', default: 128, maximum: 512, minimum: 0 },
          filter: { type: '*' },
          tolerance: { type: 'number', default: 0.375 },
          cluster: { type: 'boolean', default: !1 },
          clusterRadius: { type: 'number', default: 50, minimum: 0 },
          clusterMaxZoom: { type: 'number' },
          clusterMinPoints: { type: 'number' },
          clusterProperties: { type: '*' },
          lineMetrics: { type: 'boolean', default: !1 },
          generateId: { type: 'boolean', default: !1 },
          promoteId: { type: 'promoteId' },
        },
        'source_video': {
          type: { required: !0, type: 'enum', values: { video: {} } },
          urls: { required: !0, type: 'array', value: 'string' },
          coordinates: {
            required: !0,
            type: 'array',
            length: 4,
            value: { type: 'array', length: 2, value: 'number' },
          },
        },
        'source_image': {
          type: { required: !0, type: 'enum', values: { image: {} } },
          url: { required: !0, type: 'string' },
          coordinates: {
            required: !0,
            type: 'array',
            length: 4,
            value: { type: 'array', length: 2, value: 'number' },
          },
        },
        'layer': {
          'id': { type: 'string', required: !0 },
          'type': {
            type: 'enum',
            values: {
              'fill': {},
              'line': {},
              'symbol': {},
              'circle': {},
              'heatmap': {},
              'fill-extrusion': {},
              'raster': {},
              'hillshade': {},
              'color-relief': {},
              'background': {},
            },
            required: !0,
          },
          'metadata': { type: '*' },
          'source': { type: 'string' },
          'source-layer': { type: 'string' },
          'minzoom': { type: 'number', minimum: 0, maximum: 24 },
          'maxzoom': { type: 'number', minimum: 0, maximum: 24 },
          'filter': { type: 'filter' },
          'layout': { type: 'layout' },
          'paint': { type: 'paint' },
        },
        'layout': [
          'layout_fill',
          'layout_line',
          'layout_circle',
          'layout_heatmap',
          'layout_fill-extrusion',
          'layout_symbol',
          'layout_raster',
          'layout_hillshade',
          'layout_color-relief',
          'layout_background',
        ],
        'layout_background': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_fill': {
          'fill-sort-key': {
            'type': 'number',
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'visibility': {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_circle': {
          'circle-sort-key': {
            'type': 'number',
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'visibility': {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_heatmap': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_fill-extrusion': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_line': {
          'line-cap': {
            'type': 'enum',
            'values': { butt: {}, round: {}, square: {} },
            'default': 'butt',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'line-join': {
            'type': 'enum',
            'values': { bevel: {}, round: {}, miter: {} },
            'default': 'miter',
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'line-miter-limit': {
            'type': 'number',
            'default': 2,
            'requires': [{ 'line-join': 'miter' }],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'line-round-limit': {
            'type': 'number',
            'default': 1.05,
            'requires': [{ 'line-join': 'round' }],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'line-sort-key': {
            'type': 'number',
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'visibility': {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_symbol': {
          'symbol-placement': {
            'type': 'enum',
            'values': { 'point': {}, 'line': {}, 'line-center': {} },
            'default': 'point',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'symbol-spacing': {
            'type': 'number',
            'default': 250,
            'minimum': 1,
            'units': 'pixels',
            'requires': [{ 'symbol-placement': 'line' }],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'symbol-avoid-edges': {
            'type': 'boolean',
            'default': !1,
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'symbol-sort-key': {
            'type': 'number',
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'symbol-z-order': {
            'type': 'enum',
            'values': { 'auto': {}, 'viewport-y': {}, 'source': {} },
            'default': 'auto',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-allow-overlap': {
            'type': 'boolean',
            'default': !1,
            'requires': ['icon-image', { '!': 'icon-overlap' }],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-overlap': {
            'type': 'enum',
            'values': { never: {}, always: {}, cooperative: {} },
            'requires': ['icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-ignore-placement': {
            'type': 'boolean',
            'default': !1,
            'requires': ['icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-optional': {
            'type': 'boolean',
            'default': !1,
            'requires': ['icon-image', 'text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-rotation-alignment': {
            'type': 'enum',
            'values': { map: {}, viewport: {}, auto: {} },
            'default': 'auto',
            'requires': ['icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-size': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'units': 'factor of the original icon size',
            'requires': ['icon-image'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-text-fit': {
            'type': 'enum',
            'values': { none: {}, width: {}, height: {}, both: {} },
            'default': 'none',
            'requires': ['icon-image', 'text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-text-fit-padding': {
            'type': 'array',
            'value': 'number',
            'length': 4,
            'default': [0, 0, 0, 0],
            'units': 'pixels',
            'requires': [
              'icon-image',
              'text-field',
              { 'icon-text-fit': ['both', 'width', 'height'] },
            ],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-image': {
            'type': 'resolvedImage',
            'tokens': !0,
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-rotate': {
            'type': 'number',
            'default': 0,
            'period': 360,
            'units': 'degrees',
            'requires': ['icon-image'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-padding': {
            'type': 'padding',
            'default': [2],
            'units': 'pixels',
            'requires': ['icon-image'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-keep-upright': {
            'type': 'boolean',
            'default': !1,
            'requires': [
              'icon-image',
              { 'icon-rotation-alignment': 'map' },
              { 'symbol-placement': ['line', 'line-center'] },
            ],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-offset': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'requires': ['icon-image'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-anchor': {
            'type': 'enum',
            'values': {
              'center': {},
              'left': {},
              'right': {},
              'top': {},
              'bottom': {},
              'top-left': {},
              'top-right': {},
              'bottom-left': {},
              'bottom-right': {},
            },
            'default': 'center',
            'requires': ['icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'icon-pitch-alignment': {
            'type': 'enum',
            'values': { map: {}, viewport: {}, auto: {} },
            'default': 'auto',
            'requires': ['icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-pitch-alignment': {
            'type': 'enum',
            'values': { map: {}, viewport: {}, auto: {} },
            'default': 'auto',
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-rotation-alignment': {
            'type': 'enum',
            'values': {
              'map': {},
              'viewport': {},
              'viewport-glyph': {},
              'auto': {},
            },
            'default': 'auto',
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-field': {
            'type': 'formatted',
            'default': '',
            'tokens': !0,
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-font': {
            'type': 'array',
            'value': 'string',
            'default': ['Open Sans Regular', 'Arial Unicode MS Regular'],
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-size': {
            'type': 'number',
            'default': 16,
            'minimum': 0,
            'units': 'pixels',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-max-width': {
            'type': 'number',
            'default': 10,
            'minimum': 0,
            'units': 'ems',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-line-height': {
            'type': 'number',
            'default': 1.2,
            'units': 'ems',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-letter-spacing': {
            'type': 'number',
            'default': 0,
            'units': 'ems',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-justify': {
            'type': 'enum',
            'values': { auto: {}, left: {}, center: {}, right: {} },
            'default': 'center',
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-radial-offset': {
            'type': 'number',
            'units': 'ems',
            'default': 0,
            'requires': ['text-field'],
            'property-type': 'data-driven',
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
          },
          'text-variable-anchor': {
            'type': 'array',
            'value': 'enum',
            'values': {
              'center': {},
              'left': {},
              'right': {},
              'top': {},
              'bottom': {},
              'top-left': {},
              'top-right': {},
              'bottom-left': {},
              'bottom-right': {},
            },
            'requires': ['text-field', { 'symbol-placement': ['point'] }],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-variable-anchor-offset': {
            'type': 'variableAnchorOffsetCollection',
            'requires': ['text-field', { 'symbol-placement': ['point'] }],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-anchor': {
            'type': 'enum',
            'values': {
              'center': {},
              'left': {},
              'right': {},
              'top': {},
              'bottom': {},
              'top-left': {},
              'top-right': {},
              'bottom-left': {},
              'bottom-right': {},
            },
            'default': 'center',
            'requires': ['text-field', { '!': 'text-variable-anchor' }],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-max-angle': {
            'type': 'number',
            'default': 45,
            'units': 'degrees',
            'requires': [
              'text-field',
              { 'symbol-placement': ['line', 'line-center'] },
            ],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-writing-mode': {
            'type': 'array',
            'value': 'enum',
            'values': { horizontal: {}, vertical: {} },
            'requires': ['text-field', { 'symbol-placement': ['point'] }],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-rotate': {
            'type': 'number',
            'default': 0,
            'period': 360,
            'units': 'degrees',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-padding': {
            'type': 'number',
            'default': 2,
            'minimum': 0,
            'units': 'pixels',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-keep-upright': {
            'type': 'boolean',
            'default': !0,
            'requires': [
              'text-field',
              { 'text-rotation-alignment': 'map' },
              { 'symbol-placement': ['line', 'line-center'] },
            ],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-transform': {
            'type': 'enum',
            'values': { none: {}, uppercase: {}, lowercase: {} },
            'default': 'none',
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-offset': {
            'type': 'array',
            'value': 'number',
            'units': 'ems',
            'length': 2,
            'default': [0, 0],
            'requires': ['text-field', { '!': 'text-radial-offset' }],
            'expression': { interpolated: !0, parameters: ['zoom', 'feature'] },
            'property-type': 'data-driven',
          },
          'text-allow-overlap': {
            'type': 'boolean',
            'default': !1,
            'requires': ['text-field', { '!': 'text-overlap' }],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-overlap': {
            'type': 'enum',
            'values': { never: {}, always: {}, cooperative: {} },
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-ignore-placement': {
            'type': 'boolean',
            'default': !1,
            'requires': ['text-field'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-optional': {
            'type': 'boolean',
            'default': !1,
            'requires': ['text-field', 'icon-image'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'visibility': {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_raster': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_hillshade': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'layout_color-relief': {
          visibility: {
            'type': 'enum',
            'values': { visible: {}, none: {} },
            'default': 'visible',
            'property-type': 'constant',
          },
        },
        'filter': { type: 'array', value: '*' },
        'filter_operator': {
          type: 'enum',
          values: {
            '==': {},
            '!=': {},
            '>': {},
            '>=': {},
            '<': {},
            '<=': {},
            'in': {},
            '!in': {},
            'all': {},
            'any': {},
            'none': {},
            'has': {},
            '!has': {},
          },
        },
        'geometry_type': {
          type: 'enum',
          values: { Point: {}, LineString: {}, Polygon: {} },
        },
        'function': {
          expression: { type: 'expression' },
          stops: { type: 'array', value: 'function_stop' },
          base: { type: 'number', default: 1, minimum: 0 },
          property: { type: 'string', default: '$zoom' },
          type: {
            type: 'enum',
            values: {
              identity: {},
              exponential: {},
              interval: {},
              categorical: {},
            },
            default: 'exponential',
          },
          colorSpace: {
            type: 'enum',
            values: { rgb: {}, lab: {}, hcl: {} },
            default: 'rgb',
          },
          default: { type: '*', required: !1 },
        },
        'function_stop': {
          type: 'array',
          minimum: 0,
          maximum: 24,
          value: ['number', 'color'],
          length: 2,
        },
        'expression': { type: 'array', value: '*', minimum: 1 },
        'light': {
          anchor: {
            'type': 'enum',
            'default': 'viewport',
            'values': { map: {}, viewport: {} },
            'property-type': 'data-constant',
            'transition': !1,
            'expression': { interpolated: !1, parameters: ['zoom'] },
          },
          position: {
            'type': 'array',
            'default': [1.15, 210, 30],
            'length': 3,
            'value': 'number',
            'property-type': 'data-constant',
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
          },
          color: {
            'type': 'color',
            'property-type': 'data-constant',
            'default': '#ffffff',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          intensity: {
            'type': 'number',
            'property-type': 'data-constant',
            'default': 0.5,
            'minimum': 0,
            'maximum': 1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
        },
        'sky': {
          'sky-color': {
            'type': 'color',
            'property-type': 'data-constant',
            'default': '#88C6FC',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'horizon-color': {
            'type': 'color',
            'property-type': 'data-constant',
            'default': '#ffffff',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'fog-color': {
            'type': 'color',
            'property-type': 'data-constant',
            'default': '#ffffff',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'fog-ground-blend': {
            'type': 'number',
            'property-type': 'data-constant',
            'default': 0.5,
            'minimum': 0,
            'maximum': 1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'horizon-fog-blend': {
            'type': 'number',
            'property-type': 'data-constant',
            'default': 0.8,
            'minimum': 0,
            'maximum': 1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'sky-horizon-blend': {
            'type': 'number',
            'property-type': 'data-constant',
            'default': 0.8,
            'minimum': 0,
            'maximum': 1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
          'atmosphere-blend': {
            'type': 'number',
            'property-type': 'data-constant',
            'default': 0.8,
            'minimum': 0,
            'maximum': 1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'transition': !0,
          },
        },
        'terrain': {
          source: { type: 'string', required: !0 },
          exaggeration: { type: 'number', minimum: 0, default: 1 },
        },
        'projection': {
          type: {
            'type': 'projectionDefinition',
            'default': 'mercator',
            'property-type': 'data-constant',
            'transition': !1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
          },
        },
        'paint': [
          'paint_fill',
          'paint_line',
          'paint_circle',
          'paint_heatmap',
          'paint_fill-extrusion',
          'paint_symbol',
          'paint_raster',
          'paint_hillshade',
          'paint_color-relief',
          'paint_background',
        ],
        'paint_fill': {
          'fill-antialias': {
            'type': 'boolean',
            'default': !0,
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'requires': [{ '!': 'fill-pattern' }],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-outline-color': {
            'type': 'color',
            'transition': !0,
            'requires': [{ '!': 'fill-pattern' }, { 'fill-antialias': !0 }],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['fill-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-pattern': {
            'type': 'resolvedImage',
            'transition': !0,
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'cross-faded-data-driven',
          },
        },
        'paint_fill-extrusion': {
          'fill-extrusion-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-extrusion-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'requires': [{ '!': 'fill-extrusion-pattern' }],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-extrusion-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-extrusion-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['fill-extrusion-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'fill-extrusion-pattern': {
            'type': 'resolvedImage',
            'transition': !0,
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'cross-faded-data-driven',
          },
          'fill-extrusion-height': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'units': 'meters',
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-extrusion-base': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'units': 'meters',
            'transition': !0,
            'requires': ['fill-extrusion-height'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'fill-extrusion-vertical-gradient': {
            'type': 'boolean',
            'default': !0,
            'transition': !1,
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'paint_line': {
          'line-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'requires': [{ '!': 'line-pattern' }],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'line-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['line-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'line-width': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-gap-width': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-offset': {
            'type': 'number',
            'default': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-blur': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'line-dasharray': {
            'type': 'array',
            'value': 'number',
            'minimum': 0,
            'transition': !0,
            'units': 'line widths',
            'requires': [{ '!': 'line-pattern' }],
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'cross-faded-data-driven',
          },
          'line-pattern': {
            'type': 'resolvedImage',
            'transition': !0,
            'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
            'property-type': 'cross-faded-data-driven',
          },
          'line-gradient': {
            'type': 'color',
            'transition': !1,
            'requires': [
              { '!': 'line-dasharray' },
              { '!': 'line-pattern' },
              { source: 'geojson', has: { lineMetrics: !0 } },
            ],
            'expression': { interpolated: !0, parameters: ['line-progress'] },
            'property-type': 'color-ramp',
          },
        },
        'paint_circle': {
          'circle-radius': {
            'type': 'number',
            'default': 5,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-blur': {
            'type': 'number',
            'default': 0,
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'circle-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['circle-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'circle-pitch-scale': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'circle-pitch-alignment': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'viewport',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'circle-stroke-width': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-stroke-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'circle-stroke-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
        },
        'paint_heatmap': {
          'heatmap-radius': {
            'type': 'number',
            'default': 30,
            'minimum': 1,
            'transition': !0,
            'units': 'pixels',
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'heatmap-weight': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'transition': !1,
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'heatmap-intensity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'heatmap-color': {
            'type': 'color',
            'default': [
              'interpolate',
              ['linear'],
              ['heatmap-density'],
              0,
              'rgba(0, 0, 255, 0)',
              0.1,
              'royalblue',
              0.3,
              'cyan',
              0.5,
              'lime',
              0.7,
              'yellow',
              1,
              'red',
            ],
            'transition': !1,
            'expression': { interpolated: !0, parameters: ['heatmap-density'] },
            'property-type': 'color-ramp',
          },
          'heatmap-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'paint_symbol': {
          'icon-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'requires': ['icon-image'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'icon-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'requires': ['icon-image'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'icon-halo-color': {
            'type': 'color',
            'default': 'rgba(0, 0, 0, 0)',
            'transition': !0,
            'requires': ['icon-image'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'icon-halo-width': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'requires': ['icon-image'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'icon-halo-blur': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'requires': ['icon-image'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'icon-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'requires': ['icon-image'],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'icon-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['icon-image', 'icon-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'requires': ['text-field'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'text-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'overridable': !0,
            'requires': ['text-field'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'text-halo-color': {
            'type': 'color',
            'default': 'rgba(0, 0, 0, 0)',
            'transition': !0,
            'requires': ['text-field'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'text-halo-width': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'requires': ['text-field'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'text-halo-blur': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'transition': !0,
            'units': 'pixels',
            'requires': ['text-field'],
            'expression': {
              interpolated: !0,
              parameters: ['zoom', 'feature', 'feature-state'],
            },
            'property-type': 'data-driven',
          },
          'text-translate': {
            'type': 'array',
            'value': 'number',
            'length': 2,
            'default': [0, 0],
            'transition': !0,
            'units': 'pixels',
            'requires': ['text-field'],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'text-translate-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'map',
            'requires': ['text-field', 'text-translate'],
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'paint_raster': {
          'raster-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-hue-rotate': {
            'type': 'number',
            'default': 0,
            'period': 360,
            'transition': !0,
            'units': 'degrees',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-brightness-min': {
            'type': 'number',
            'default': 0,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-brightness-max': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-saturation': {
            'type': 'number',
            'default': 0,
            'minimum': -1,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-contrast': {
            'type': 'number',
            'default': 0,
            'minimum': -1,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-resampling': {
            'type': 'enum',
            'values': { linear: {}, nearest: {} },
            'default': 'linear',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'raster-fade-duration': {
            'type': 'number',
            'default': 300,
            'minimum': 0,
            'transition': !1,
            'units': 'milliseconds',
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'paint_hillshade': {
          'hillshade-illumination-direction': {
            'type': 'numberArray',
            'default': 335,
            'minimum': 0,
            'maximum': 359,
            'transition': !1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-illumination-altitude': {
            'type': 'numberArray',
            'default': 45,
            'minimum': 0,
            'maximum': 90,
            'transition': !1,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-illumination-anchor': {
            'type': 'enum',
            'values': { map: {}, viewport: {} },
            'default': 'viewport',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-exaggeration': {
            'type': 'number',
            'default': 0.5,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-shadow-color': {
            'type': 'colorArray',
            'default': '#000000',
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-highlight-color': {
            'type': 'colorArray',
            'default': '#FFFFFF',
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-accent-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'hillshade-method': {
            'type': 'enum',
            'values': {
              standard: {},
              basic: {},
              combined: {},
              igor: {},
              multidirectional: {},
            },
            'default': 'standard',
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'paint_color-relief': {
          'color-relief-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'color-relief-color': {
            'type': 'color',
            'transition': !1,
            'expression': { interpolated: !0, parameters: ['elevation'] },
            'property-type': 'color-ramp',
          },
        },
        'paint_background': {
          'background-color': {
            'type': 'color',
            'default': '#000000',
            'transition': !0,
            'requires': [{ '!': 'background-pattern' }],
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
          'background-pattern': {
            'type': 'resolvedImage',
            'transition': !0,
            'expression': { interpolated: !1, parameters: ['zoom'] },
            'property-type': 'cross-faded',
          },
          'background-opacity': {
            'type': 'number',
            'default': 1,
            'minimum': 0,
            'maximum': 1,
            'transition': !0,
            'expression': { interpolated: !0, parameters: ['zoom'] },
            'property-type': 'data-constant',
          },
        },
        'transition': {
          duration: {
            type: 'number',
            default: 300,
            minimum: 0,
            units: 'milliseconds',
          },
          delay: {
            type: 'number',
            default: 0,
            minimum: 0,
            units: 'milliseconds',
          },
        },
        'property-type': {
          'data-driven': { type: 'property-type' },
          'cross-faded': { type: 'property-type' },
          'cross-faded-data-driven': { type: 'property-type' },
          'color-ramp': { type: 'property-type' },
          'data-constant': { type: 'property-type' },
          'constant': { type: 'property-type' },
        },
        'promoteId': { '*': { type: 'string' } },
      };
      const vt = [
        'type',
        'source',
        'source-layer',
        'minzoom',
        'maxzoom',
        'filter',
        'layout',
      ];
      function bt(t, e) {
        const i = {};
        for (const r in t) 'ref' !== r && (i[r] = t[r]);
        return (
          vt.forEach((t) => {
            t in e && (i[t] = e[t]);
          }),
          i
        );
      }
      function wt(t, e) {
        if (Array.isArray(t)) {
          if (!Array.isArray(e) || t.length !== e.length) return !1;
          for (let i = 0; i < t.length; i++) if (!wt(t[i], e[i])) return !1;
          return !0;
        }
        if ('object' == typeof t && null !== t && null !== e) {
          if ('object' != typeof e) return !1;
          if (Object.keys(t).length !== Object.keys(e).length) return !1;
          for (const i in t) if (!wt(t[i], e[i])) return !1;
          return !0;
        }
        return t === e;
      }
      function Tt(t, e) {
        t.push(e);
      }
      function Pt(t, e, i) {
        Tt(i, { command: 'addSource', args: [t, e[t]] });
      }
      function St(t, e, i) {
        Tt(e, { command: 'removeSource', args: [t] }), (i[t] = !0);
      }
      function Mt(t, e, i, r) {
        St(t, i, r), Pt(t, e, i);
      }
      function It(t, e, i) {
        let r;
        for (r in t[i])
          if (
            Object.prototype.hasOwnProperty.call(t[i], r) &&
            'data' !== r &&
            !wt(t[i][r], e[i][r])
          )
            return !1;
        for (r in e[i])
          if (
            Object.prototype.hasOwnProperty.call(e[i], r) &&
            'data' !== r &&
            !wt(t[i][r], e[i][r])
          )
            return !1;
        return !0;
      }
      function Ct(t, e, i, r, n, o) {
        (t = t || {}), (e = e || {});
        for (const a in t)
          Object.prototype.hasOwnProperty.call(t, a) &&
            (wt(t[a], e[a]) || i.push({ command: o, args: [r, a, e[a], n] }));
        for (const a in e)
          Object.prototype.hasOwnProperty.call(e, a) &&
            !Object.prototype.hasOwnProperty.call(t, a) &&
            (wt(t[a], e[a]) || i.push({ command: o, args: [r, a, e[a], n] }));
      }
      function At(t) {
        return t.id;
      }
      function Et(t, e) {
        return (t[e.id] = e), t;
      }
      class zt {
        constructor(t, e, i, r) {
          (this.message = (t ? `${t}: ` : '') + i),
            r && (this.identifier = r),
            null != e && e.__line__ && (this.line = e.__line__);
        }
      }
      function kt(t, ...e) {
        for (const i of e) for (const e in i) t[e] = i[e];
        return t;
      }
      class Dt extends Error {
        constructor(t, e) {
          super(e), (this.message = e), (this.key = t);
        }
      }
      class Rt {
        constructor(t, e = []) {
          (this.parent = t), (this.bindings = {});
          for (const [i, r] of e) this.bindings[i] = r;
        }
        concat(t) {
          return new Rt(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || (!!this.parent && this.parent.has(t));
        }
      }
      const Lt = { kind: 'null' },
        Ft = { kind: 'number' },
        Bt = { kind: 'string' },
        Ot = { kind: 'boolean' },
        jt = { kind: 'color' },
        Nt = { kind: 'projectionDefinition' },
        Vt = { kind: 'object' },
        Ut = { kind: 'value' },
        Gt = { kind: 'collator' },
        Zt = { kind: 'formatted' },
        $t = { kind: 'padding' },
        qt = { kind: 'colorArray' },
        Wt = { kind: 'numberArray' },
        Yt = { kind: 'resolvedImage' },
        Ht = { kind: 'variableAnchorOffsetCollection' };
      function Xt(t, e) {
        return { kind: 'array', itemType: t, N: e };
      }
      function Kt(t) {
        if ('array' === t.kind) {
          const e = Kt(t.itemType);
          return 'number' == typeof t.N
            ? `array<${e}, ${t.N}>`
            : 'value' === t.itemType.kind
            ? 'array'
            : `array<${e}>`;
        }
        return t.kind;
      }
      const Jt = [Lt, Ft, Bt, Ot, jt, Nt, Zt, Vt, Xt(Ut), $t, Wt, qt, Yt, Ht];
      function Qt(t, e) {
        if ('error' === e.kind) return null;
        if ('array' === t.kind) {
          if (
            'array' === e.kind &&
            ((0 === e.N && 'value' === e.itemType.kind) ||
              !Qt(t.itemType, e.itemType)) &&
            ('number' != typeof t.N || t.N === e.N)
          )
            return null;
        } else {
          if (t.kind === e.kind) return null;
          if ('value' === t.kind)
            for (const t of Jt) if (!Qt(t, e)) return null;
        }
        return `Expected ${Kt(t)} but found ${Kt(e)} instead.`;
      }
      function te(t, e) {
        return e.some((e) => e.kind === t.kind);
      }
      function ee(t, e) {
        return e.some((e) =>
          'null' === e
            ? null === t
            : 'array' === e
            ? Array.isArray(t)
            : 'object' === e
            ? t && !Array.isArray(t) && 'object' == typeof t
            : e === typeof t
        );
      }
      function ie(t, e) {
        return 'array' === t.kind && 'array' === e.kind
          ? t.itemType.kind === e.itemType.kind && 'number' == typeof t.N
          : t.kind === e.kind;
      }
      const re = 0.96422,
        ne = 0.82521,
        oe = 4 / 29,
        ae = 6 / 29,
        se = 3 * ae * ae,
        le = ae * ae * ae,
        ce = Math.PI / 180,
        he = 180 / Math.PI;
      function ue(t) {
        return (t %= 360) < 0 && (t += 360), t;
      }
      function de([t, e, i, r]) {
        let n, o;
        const a = fe(
          (0.2225045 * (t = pe(t)) +
            0.7168786 * (e = pe(e)) +
            0.0606169 * (i = pe(i))) /
            1
        );
        t === e && e === i
          ? (n = o = a)
          : ((n = fe((0.4360747 * t + 0.3850649 * e + 0.1430804 * i) / re)),
            (o = fe((0.0139322 * t + 0.0971045 * e + 0.7141733 * i) / ne)));
        const s = 116 * a - 16;
        return [s < 0 ? 0 : s, 500 * (n - a), 200 * (a - o), r];
      }
      function pe(t) {
        return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
      }
      function fe(t) {
        return t > le ? Math.pow(t, 1 / 3) : t / se + oe;
      }
      function me([t, e, i, r]) {
        let n = (t + 16) / 116,
          o = isNaN(e) ? n : n + e / 500,
          a = isNaN(i) ? n : n - i / 200;
        return (
          (n = 1 * ge(n)),
          (o = re * ge(o)),
          (a = ne * ge(a)),
          [
            _e(3.1338561 * o - 1.6168667 * n - 0.4906146 * a),
            _e(-0.9787684 * o + 1.9161415 * n + 0.033454 * a),
            _e(0.0719453 * o - 0.2289914 * n + 1.4052427 * a),
            r,
          ]
        );
      }
      function _e(t) {
        return (t =
          t <= 0.00304 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055) < 0
          ? 0
          : t > 1
          ? 1
          : t;
      }
      function ge(t) {
        return t > ae ? t * t * t : se * (t - oe);
      }
      const ye =
        Object.hasOwn ||
        function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        };
      function xe(t, e) {
        return ye(t, e) ? t[e] : void 0;
      }
      function ve(t) {
        return parseInt(t.padEnd(2, t), 16) / 255;
      }
      function be(t, e) {
        return we(e ? t / 100 : t, 0, 1);
      }
      function we(t, e, i) {
        return Math.min(Math.max(e, t), i);
      }
      function Te(t) {
        return !t.some(Number.isNaN);
      }
      const Pe = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
      function Se(t, e, i) {
        return t + i * (e - t);
      }
      function Me(t, e, i) {
        return t.map((t, r) => Se(t, e[r], i));
      }
      class Ie {
        constructor(t, e, i, r = 1, n = !0) {
          (this.r = t),
            (this.g = e),
            (this.b = i),
            (this.a = r),
            n ||
              ((this.r *= r),
              (this.g *= r),
              (this.b *= r),
              r || this.overwriteGetter('rgb', [t, e, i, r]));
        }
        static parse(t) {
          if (t instanceof Ie) return t;
          if ('string' != typeof t) return;
          const e = (function (t) {
            if ('transparent' === (t = t.toLowerCase().trim()))
              return [0, 0, 0, 0];
            const e = xe(Pe, t);
            if (e) {
              const [t, i, r] = e;
              return [t / 255, i / 255, r / 255, 1];
            }
            if (
              t.startsWith('#') &&
              /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)
            ) {
              const e = t.length < 6 ? 1 : 2;
              let i = 1;
              return [
                ve(t.slice(i, (i += e))),
                ve(t.slice(i, (i += e))),
                ve(t.slice(i, (i += e))),
                ve(t.slice(i, i + e) || 'ff'),
              ];
            }
            if (t.startsWith('rgb')) {
              const e = t.match(
                /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
              );
              if (e) {
                const [t, i, r, n, o, a, s, l, c, h, u, d] = e,
                  p = [n || ' ', s || ' ', h].join('');
                if ('  ' === p || '  /' === p || ',,' === p || ',,,' === p) {
                  const t = [r, a, c].join(''),
                    e = '%%%' === t ? 100 : '' === t ? 255 : 0;
                  if (e) {
                    const t = [
                      we(+i / e, 0, 1),
                      we(+o / e, 0, 1),
                      we(+l / e, 0, 1),
                      u ? be(+u, d) : 1,
                    ];
                    if (Te(t)) return t;
                  }
                }
                return;
              }
            }
            const i = t.match(
              /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
            );
            if (i) {
              const [t, e, r, n, o, a, s, l, c] = i,
                h = [r || ' ', o || ' ', s].join('');
              if ('  ' === h || '  /' === h || ',,' === h || ',,,' === h) {
                const t = [
                  +e,
                  we(+n, 0, 100),
                  we(+a, 0, 100),
                  l ? be(+l, c) : 1,
                ];
                if (Te(t))
                  return (function ([t, e, i, r]) {
                    function n(r) {
                      const n = (r + t / 30) % 12,
                        o = e * Math.min(i, 1 - i);
                      return i - o * Math.max(-1, Math.min(n - 3, 9 - n, 1));
                    }
                    return (
                      (t = ue(t)), (e /= 100), (i /= 100), [n(0), n(8), n(4), r]
                    );
                  })(t);
              }
            }
          })(t);
          return e ? new Ie(...e, !1) : void 0;
        }
        get rgb() {
          const { r: t, g: e, b: i, a: r } = this,
            n = r || 1 / 0;
          return this.overwriteGetter('rgb', [t / n, e / n, i / n, r]);
        }
        get hcl() {
          return this.overwriteGetter(
            'hcl',
            (function (t) {
              const [e, i, r, n] = de(t),
                o = Math.sqrt(i * i + r * r);
              return [
                Math.round(1e4 * o) ? ue(Math.atan2(r, i) * he) : NaN,
                o,
                e,
                n,
              ];
            })(this.rgb)
          );
        }
        get lab() {
          return this.overwriteGetter('lab', de(this.rgb));
        }
        overwriteGetter(t, e) {
          return Object.defineProperty(this, t, { value: e }), e;
        }
        toString() {
          const [t, e, i, r] = this.rgb;
          return `rgba(${[t, e, i]
            .map((t) => Math.round(255 * t))
            .join(',')},${r})`;
        }
        static interpolate(t, e, i, r = 'rgb') {
          switch (r) {
            case 'rgb': {
              const [r, n, o, a] = Me(t.rgb, e.rgb, i);
              return new Ie(r, n, o, a, !1);
            }
            case 'hcl': {
              const [r, n, o, a] = t.hcl,
                [s, l, c, h] = e.hcl;
              let u, d;
              if (isNaN(r) || isNaN(s))
                isNaN(r)
                  ? isNaN(s)
                    ? (u = NaN)
                    : ((u = s), (1 !== o && 0 !== o) || (d = l))
                  : ((u = r), (1 !== c && 0 !== c) || (d = n));
              else {
                let t = s - r;
                s > r && t > 180
                  ? (t -= 360)
                  : s < r && r - s > 180 && (t += 360),
                  (u = r + i * t);
              }
              const [p, f, m, _] = (function ([t, e, i, r]) {
                return (
                  (t = isNaN(t) ? 0 : t * ce),
                  me([i, Math.cos(t) * e, Math.sin(t) * e, r])
                );
              })([u, null != d ? d : Se(n, l, i), Se(o, c, i), Se(a, h, i)]);
              return new Ie(p, f, m, _, !1);
            }
            case 'lab': {
              const [r, n, o, a] = me(Me(t.lab, e.lab, i));
              return new Ie(r, n, o, a, !1);
            }
          }
        }
      }
      (Ie.black = new Ie(0, 0, 0, 1)),
        (Ie.white = new Ie(1, 1, 1, 1)),
        (Ie.transparent = new Ie(0, 0, 0, 0)),
        (Ie.red = new Ie(1, 0, 0, 1));
      class Ce {
        constructor(t, e, i) {
          (this.sensitivity = t
            ? e
              ? 'variant'
              : 'case'
            : e
            ? 'accent'
            : 'base'),
            (this.locale = i),
            (this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: 'search',
            }));
        }
        compare(t, e) {
          return this.collator.compare(t, e);
        }
        resolvedLocale() {
          return new Intl.Collator(
            this.locale ? this.locale : []
          ).resolvedOptions().locale;
        }
      }
      const Ae = ['bottom', 'center', 'top'];
      class Ee {
        constructor(t, e, i, r, n, o) {
          (this.text = t),
            (this.image = e),
            (this.scale = i),
            (this.fontStack = r),
            (this.textColor = n),
            (this.verticalAlign = o);
        }
      }
      class ze {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new ze([new Ee(t, null, null, null, null, null)]);
        }
        isEmpty() {
          return (
            0 === this.sections.length ||
            !this.sections.some(
              (t) =>
                0 !== t.text.length || (t.image && 0 !== t.image.name.length)
            )
          );
        }
        static factory(t) {
          return t instanceof ze ? t : ze.fromString(t);
        }
        toString() {
          return 0 === this.sections.length
            ? ''
            : this.sections.map((t) => t.text).join('');
        }
      }
      class ke {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof ke) return t;
          if ('number' == typeof t) return new ke([t, t, t, t]);
          if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
            for (const e of t) if ('number' != typeof e) return;
            switch (t.length) {
              case 1:
                t = [t[0], t[0], t[0], t[0]];
                break;
              case 2:
                t = [t[0], t[1], t[0], t[1]];
                break;
              case 3:
                t = [t[0], t[1], t[2], t[1]];
            }
            return new ke(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, e, i) {
          return new ke(Me(t.values, e.values, i));
        }
      }
      class De {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof De) return t;
          if ('number' == typeof t) return new De([t]);
          if (Array.isArray(t)) {
            for (const e of t) if ('number' != typeof e) return;
            return new De(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, e, i) {
          return new De(Me(t.values, e.values, i));
        }
      }
      class Re {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof Re) return t;
          if ('string' == typeof t) {
            const e = Ie.parse(t);
            if (!e) return;
            return new Re([e]);
          }
          if (!Array.isArray(t)) return;
          const e = [];
          for (const i of t) {
            if ('string' != typeof i) return;
            const t = Ie.parse(i);
            if (!t) return;
            e.push(t);
          }
          return new Re(e);
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, e, i, r = 'rgb') {
          const n = [];
          if (t.values.length != e.values.length)
            throw new Error(
              `colorArray: Arrays have mismatched length (${t.values.length} vs. ${e.values.length}), cannot interpolate.`
            );
          for (let o = 0; o < t.values.length; o++)
            n.push(Ie.interpolate(t.values[o], e.values[o], i, r));
          return new Re(n);
        }
      }
      class Le extends Error {
        constructor(t) {
          super(t), (this.name = 'RuntimeError');
        }
        toJSON() {
          return this.message;
        }
      }
      const Fe = new Set([
        'center',
        'left',
        'right',
        'top',
        'bottom',
        'top-left',
        'top-right',
        'bottom-left',
        'bottom-right',
      ]);
      class Be {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof Be) return t;
          if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
            for (let e = 0; e < t.length; e += 2) {
              const i = t[e],
                r = t[e + 1];
              if ('string' != typeof i || !Fe.has(i)) return;
              if (
                !Array.isArray(r) ||
                2 !== r.length ||
                'number' != typeof r[0] ||
                'number' != typeof r[1]
              )
                return;
            }
            return new Be(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(t, e, i) {
          const r = t.values,
            n = e.values;
          if (r.length !== n.length)
            throw new Le(
              `Cannot interpolate values of different length. from: ${t.toString()}, to: ${e.toString()}`
            );
          const o = [];
          for (let a = 0; a < r.length; a += 2) {
            if (r[a] !== n[a])
              throw new Le(
                `Cannot interpolate values containing mismatched anchors. from[${a}]: ${r[a]}, to[${a}]: ${n[a]}`
              );
            o.push(r[a]);
            const [t, e] = r[a + 1],
              [s, l] = n[a + 1];
            o.push([Se(t, s, i), Se(e, l, i)]);
          }
          return new Be(o);
        }
      }
      class Oe {
        constructor(t) {
          (this.name = t.name), (this.available = t.available);
        }
        toString() {
          return this.name;
        }
        static fromString(t) {
          return t ? new Oe({ name: t, available: !1 }) : null;
        }
      }
      class je {
        constructor(t, e, i) {
          (this.from = t), (this.to = e), (this.transition = i);
        }
        static interpolate(t, e, i) {
          return new je(t, e, i);
        }
        static parse(t) {
          return t instanceof je
            ? t
            : Array.isArray(t) &&
              3 === t.length &&
              'string' == typeof t[0] &&
              'string' == typeof t[1] &&
              'number' == typeof t[2]
            ? new je(t[0], t[1], t[2])
            : 'object' == typeof t &&
              'string' == typeof t.from &&
              'string' == typeof t.to &&
              'number' == typeof t.transition
            ? new je(t.from, t.to, t.transition)
            : 'string' == typeof t
            ? new je(t, t, 1)
            : void 0;
        }
      }
      function Ne(t, e, i, r) {
        return 'number' == typeof t &&
          t >= 0 &&
          t <= 255 &&
          'number' == typeof e &&
          e >= 0 &&
          e <= 255 &&
          'number' == typeof i &&
          i >= 0 &&
          i <= 255
          ? void 0 === r || ('number' == typeof r && r >= 0 && r <= 1)
            ? null
            : `Invalid rgba value [${[t, e, i, r].join(
                ', '
              )}]: 'a' must be between 0 and 1.`
          : `Invalid rgba value [${('number' == typeof r
              ? [t, e, i, r]
              : [t, e, i]
            ).join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Ve(t) {
        if (
          null === t ||
          'string' == typeof t ||
          'boolean' == typeof t ||
          'number' == typeof t ||
          t instanceof je ||
          t instanceof Ie ||
          t instanceof Ce ||
          t instanceof ze ||
          t instanceof ke ||
          t instanceof De ||
          t instanceof Re ||
          t instanceof Be ||
          t instanceof Oe
        )
          return !0;
        if (Array.isArray(t)) {
          for (const e of t) if (!Ve(e)) return !1;
          return !0;
        }
        if ('object' == typeof t) {
          for (const e in t) if (!Ve(t[e])) return !1;
          return !0;
        }
        return !1;
      }
      function Ue(t) {
        if (null === t) return Lt;
        if ('string' == typeof t) return Bt;
        if ('boolean' == typeof t) return Ot;
        if ('number' == typeof t) return Ft;
        if (t instanceof Ie) return jt;
        if (t instanceof je) return Nt;
        if (t instanceof Ce) return Gt;
        if (t instanceof ze) return Zt;
        if (t instanceof ke) return $t;
        if (t instanceof De) return Wt;
        if (t instanceof Re) return qt;
        if (t instanceof Be) return Ht;
        if (t instanceof Oe) return Yt;
        if (Array.isArray(t)) {
          const e = t.length;
          let i;
          for (const r of t) {
            const t = Ue(r);
            if (i) {
              if (i === t) continue;
              i = Ut;
              break;
            }
            i = t;
          }
          return Xt(i || Ut, e);
        }
        return Vt;
      }
      function Ge(t) {
        const e = typeof t;
        return null === t
          ? ''
          : 'string' === e || 'number' === e || 'boolean' === e
          ? String(t)
          : t instanceof Ie ||
            t instanceof je ||
            t instanceof ze ||
            t instanceof ke ||
            t instanceof De ||
            t instanceof Re ||
            t instanceof Be ||
            t instanceof Oe
          ? t.toString()
          : JSON.stringify(t);
      }
      class Ze {
        constructor(t, e) {
          (this.type = t), (this.value = e);
        }
        static parse(t, e) {
          if (2 !== t.length)
            return e.error(
              `'literal' expression requires exactly one argument, but found ${
                t.length - 1
              } instead.`
            );
          if (!Ve(t[1])) return e.error('invalid value');
          const i = t[1];
          let r = Ue(i);
          const n = e.expectedType;
          return (
            'array' !== r.kind ||
              0 !== r.N ||
              !n ||
              'array' !== n.kind ||
              ('number' == typeof n.N && 0 !== n.N) ||
              (r = n),
            new Ze(r, i)
          );
        }
        evaluate() {
          return this.value;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      const $e = { string: Bt, number: Ft, boolean: Ot, object: Vt };
      class qe {
        constructor(t, e) {
          (this.type = t), (this.args = e);
        }
        static parse(t, e) {
          if (t.length < 2) return e.error('Expected at least one argument.');
          let i,
            r = 1;
          const n = t[0];
          if ('array' === n) {
            let n, o;
            if (t.length > 2) {
              const i = t[1];
              if ('string' != typeof i || !(i in $e) || 'object' === i)
                return e.error(
                  'The item type argument of "array" must be one of string, number, boolean',
                  1
                );
              (n = $e[i]), r++;
            } else n = Ut;
            if (t.length > 3) {
              if (
                null !== t[2] &&
                ('number' != typeof t[2] ||
                  t[2] < 0 ||
                  t[2] !== Math.floor(t[2]))
              )
                return e.error(
                  'The length argument to "array" must be a positive integer literal',
                  2
                );
              (o = t[2]), r++;
            }
            i = Xt(n, o);
          } else {
            if (!$e[n]) throw new Error(`Types doesn't contain name = ${n}`);
            i = $e[n];
          }
          const o = [];
          for (; r < t.length; r++) {
            const i = e.parse(t[r], r, Ut);
            if (!i) return null;
            o.push(i);
          }
          return new qe(i, o);
        }
        evaluate(t) {
          for (let e = 0; e < this.args.length; e++) {
            const i = this.args[e].evaluate(t);
            if (!Qt(this.type, Ue(i))) return i;
            if (e === this.args.length - 1)
              throw new Le(
                `Expected value to be of type ${Kt(this.type)}, but found ${Kt(
                  Ue(i)
                )} instead.`
              );
          }
          throw new Error();
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const We = {
        'to-boolean': Ot,
        'to-color': jt,
        'to-number': Ft,
        'to-string': Bt,
      };
      class Ye {
        constructor(t, e) {
          (this.type = t), (this.args = e);
        }
        static parse(t, e) {
          if (t.length < 2) return e.error('Expected at least one argument.');
          const i = t[0];
          if (!We[i])
            throw new Error(
              `Can't parse ${i} as it is not part of the known types`
            );
          if (('to-boolean' === i || 'to-string' === i) && 2 !== t.length)
            return e.error('Expected one argument.');
          const r = We[i],
            n = [];
          for (let o = 1; o < t.length; o++) {
            const i = e.parse(t[o], o, Ut);
            if (!i) return null;
            n.push(i);
          }
          return new Ye(r, n);
        }
        evaluate(t) {
          switch (this.type.kind) {
            case 'boolean':
              return Boolean(this.args[0].evaluate(t));
            case 'color': {
              let e, i;
              for (const r of this.args) {
                if (((e = r.evaluate(t)), (i = null), e instanceof Ie))
                  return e;
                if ('string' == typeof e) {
                  const i = t.parseColor(e);
                  if (i) return i;
                } else if (
                  Array.isArray(e) &&
                  ((i =
                    e.length < 3 || e.length > 4
                      ? `Invalid rgba value ${JSON.stringify(
                          e
                        )}: expected an array containing either three or four numeric values.`
                      : Ne(e[0], e[1], e[2], e[3])),
                  !i)
                )
                  return new Ie(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
              }
              throw new Le(
                i ||
                  `Could not parse color from value '${
                    'string' == typeof e ? e : JSON.stringify(e)
                  }'`
              );
            }
            case 'padding': {
              let e;
              for (const i of this.args) {
                e = i.evaluate(t);
                const r = ke.parse(e);
                if (r) return r;
              }
              throw new Le(
                `Could not parse padding from value '${
                  'string' == typeof e ? e : JSON.stringify(e)
                }'`
              );
            }
            case 'numberArray': {
              let e;
              for (const i of this.args) {
                e = i.evaluate(t);
                const r = De.parse(e);
                if (r) return r;
              }
              throw new Le(
                `Could not parse numberArray from value '${
                  'string' == typeof e ? e : JSON.stringify(e)
                }'`
              );
            }
            case 'colorArray': {
              let e;
              for (const i of this.args) {
                e = i.evaluate(t);
                const r = Re.parse(e);
                if (r) return r;
              }
              throw new Le(
                `Could not parse colorArray from value '${
                  'string' == typeof e ? e : JSON.stringify(e)
                }'`
              );
            }
            case 'variableAnchorOffsetCollection': {
              let e;
              for (const i of this.args) {
                e = i.evaluate(t);
                const r = Be.parse(e);
                if (r) return r;
              }
              throw new Le(
                `Could not parse variableAnchorOffsetCollection from value '${
                  'string' == typeof e ? e : JSON.stringify(e)
                }'`
              );
            }
            case 'number': {
              let e = null;
              for (const i of this.args) {
                if (((e = i.evaluate(t)), null === e)) return 0;
                const r = Number(e);
                if (!isNaN(r)) return r;
              }
              throw new Le(`Could not convert ${JSON.stringify(e)} to number.`);
            }
            case 'formatted':
              return ze.fromString(Ge(this.args[0].evaluate(t)));
            case 'resolvedImage':
              return Oe.fromString(Ge(this.args[0].evaluate(t)));
            case 'projectionDefinition':
              return this.args[0].evaluate(t);
            default:
              return Ge(this.args[0].evaluate(t));
          }
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const He = ['Unknown', 'Point', 'LineString', 'Polygon'];
      class Xe {
        constructor() {
          (this.globals = null),
            (this.feature = null),
            (this.featureState = null),
            (this.formattedSection = null),
            (this._parseColorCache = new Map()),
            (this.availableImages = null),
            (this.canonical = null);
        }
        id() {
          return this.feature && 'id' in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature
            ? 'number' == typeof this.feature.type
              ? He[this.feature.type]
              : this.feature.type
            : null;
        }
        geometry() {
          return this.feature && 'geometry' in this.feature
            ? this.feature.geometry
            : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return (this.feature && this.feature.properties) || {};
        }
        parseColor(t) {
          let e = this._parseColorCache.get(t);
          return e || ((e = Ie.parse(t)), this._parseColorCache.set(t, e)), e;
        }
      }
      class Ke {
        constructor(t, e, i = [], r, n = new Rt(), o = []) {
          (this.registry = t),
            (this.path = i),
            (this.key = i.map((t) => `[${t}]`).join('')),
            (this.scope = n),
            (this.errors = o),
            (this.expectedType = r),
            (this._isConstant = e);
        }
        parse(t, e, i, r, n = {}) {
          return e ? this.concat(e, i, r)._parse(t, n) : this._parse(t, n);
        }
        _parse(t, e) {
          function i(t, e, i) {
            return 'assert' === i
              ? new qe(e, [t])
              : 'coerce' === i
              ? new Ye(e, [t])
              : t;
          }
          if (
            ((null !== t &&
              'string' != typeof t &&
              'boolean' != typeof t &&
              'number' != typeof t) ||
              (t = ['literal', t]),
            Array.isArray(t))
          ) {
            if (0 === t.length)
              return this.error(
                'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
              );
            const r = t[0];
            if ('string' != typeof r)
              return (
                this.error(
                  `Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`,
                  0
                ),
                null
              );
            const n = this.registry[r];
            if (n) {
              let r = n.parse(t, this);
              if (!r) return null;
              if (this.expectedType) {
                const t = this.expectedType,
                  n = r.type;
                if (
                  ('string' !== t.kind &&
                    'number' !== t.kind &&
                    'boolean' !== t.kind &&
                    'object' !== t.kind &&
                    'array' !== t.kind) ||
                  'value' !== n.kind
                ) {
                  if (
                    ('projectionDefinition' === t.kind &&
                      ['string', 'array'].includes(n.kind)) ||
                    (['color', 'formatted', 'resolvedImage'].includes(t.kind) &&
                      ['value', 'string'].includes(n.kind)) ||
                    (['padding', 'numberArray'].includes(t.kind) &&
                      ['value', 'number', 'array'].includes(n.kind)) ||
                    ('colorArray' === t.kind &&
                      ['value', 'string', 'array'].includes(n.kind)) ||
                    ('variableAnchorOffsetCollection' === t.kind &&
                      ['value', 'array'].includes(n.kind))
                  )
                    r = i(r, t, e.typeAnnotation || 'coerce');
                  else if (this.checkSubtype(t, n)) return null;
                } else r = i(r, t, e.typeAnnotation || 'assert');
              }
              if (
                !(r instanceof Ze) &&
                'resolvedImage' !== r.type.kind &&
                this._isConstant(r)
              ) {
                const e = new Xe();
                try {
                  r = new Ze(r.type, r.evaluate(e));
                } catch (t) {
                  return this.error(t.message), null;
                }
              }
              return r;
            }
            return this.error(
              `Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,
              0
            );
          }
          return this.error(
            void 0 === t
              ? "'undefined' value invalid. Use null instead."
              : 'object' == typeof t
              ? 'Bare objects invalid. Use ["literal", {...}] instead.'
              : `Expected an array, but found ${typeof t} instead.`
          );
        }
        concat(t, e, i) {
          const r = 'number' == typeof t ? this.path.concat(t) : this.path,
            n = i ? this.scope.concat(i) : this.scope;
          return new Ke(
            this.registry,
            this._isConstant,
            r,
            e || null,
            n,
            this.errors
          );
        }
        error(t, ...e) {
          const i = `${this.key}${e.map((t) => `[${t}]`).join('')}`;
          this.errors.push(new Dt(i, t));
        }
        checkSubtype(t, e) {
          const i = Qt(t, e);
          return i && this.error(i), i;
        }
      }
      class Je {
        constructor(t, e) {
          (this.type = e.type),
            (this.bindings = [].concat(t)),
            (this.result = e);
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const e of this.bindings) t(e[1]);
          t(this.result);
        }
        static parse(t, e) {
          if (t.length < 4)
            return e.error(
              `Expected at least 3 arguments, but found ${
                t.length - 1
              } instead.`
            );
          const i = [];
          for (let n = 1; n < t.length - 1; n += 2) {
            const r = t[n];
            if ('string' != typeof r)
              return e.error(
                `Expected string, but found ${typeof r} instead.`,
                n
              );
            if (/[^a-zA-Z0-9_]/.test(r))
              return e.error(
                "Variable names must contain only alphanumeric characters or '_'.",
                n
              );
            const o = e.parse(t[n + 1], n + 1);
            if (!o) return null;
            i.push([r, o]);
          }
          const r = e.parse(t[t.length - 1], t.length - 1, e.expectedType, i);
          return r ? new Je(i, r) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Qe {
        constructor(t, e) {
          (this.type = e.type), (this.name = t), (this.boundExpression = e);
        }
        static parse(t, e) {
          if (2 !== t.length || 'string' != typeof t[1])
            return e.error(
              "'var' expression requires exactly one string literal argument."
            );
          const i = t[1];
          return e.scope.has(i)
            ? new Qe(i, e.scope.get(i))
            : e.error(
                `Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`,
                1
              );
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {}
        outputDefined() {
          return !1;
        }
      }
      class ti {
        constructor(t, e, i) {
          (this.type = t), (this.index = e), (this.input = i);
        }
        static parse(t, e) {
          if (3 !== t.length)
            return e.error(
              `Expected 2 arguments, but found ${t.length - 1} instead.`
            );
          const i = e.parse(t[1], 1, Ft),
            r = e.parse(t[2], 2, Xt(e.expectedType || Ut));
          return i && r ? new ti(r.type.itemType, i, r) : null;
        }
        evaluate(t) {
          const e = this.index.evaluate(t),
            i = this.input.evaluate(t);
          if (e < 0) throw new Le(`Array index out of bounds: ${e} < 0.`);
          if (e >= i.length)
            throw new Le(`Array index out of bounds: ${e} > ${i.length - 1}.`);
          if (e !== Math.floor(e))
            throw new Le(
              `Array index must be an integer, but found ${e} instead.`
            );
          return i[e];
        }
        eachChild(t) {
          t(this.index), t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class ei {
        constructor(t, e) {
          (this.type = Ot), (this.needle = t), (this.haystack = e);
        }
        static parse(t, e) {
          if (3 !== t.length)
            return e.error(
              `Expected 2 arguments, but found ${t.length - 1} instead.`
            );
          const i = e.parse(t[1], 1, Ut),
            r = e.parse(t[2], 2, Ut);
          return i && r
            ? te(i.type, [Ot, Bt, Ft, Lt, Ut])
              ? new ei(i, r)
              : e.error(
                  `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
                    i.type
                  )} instead`
                )
            : null;
        }
        evaluate(t) {
          const e = this.needle.evaluate(t),
            i = this.haystack.evaluate(t);
          if (!i) return !1;
          if (!ee(e, ['boolean', 'string', 'number', 'null']))
            throw new Le(
              `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
                Ue(e)
              )} instead.`
            );
          if (!ee(i, ['string', 'array']))
            throw new Le(
              `Expected second argument to be of type array or string, but found ${Kt(
                Ue(i)
              )} instead.`
            );
          return i.indexOf(e) >= 0;
        }
        eachChild(t) {
          t(this.needle), t(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ii {
        constructor(t, e, i) {
          (this.type = Ft),
            (this.needle = t),
            (this.haystack = e),
            (this.fromIndex = i);
        }
        static parse(t, e) {
          if (t.length <= 2 || t.length >= 5)
            return e.error(
              `Expected 2 or 3 arguments, but found ${t.length - 1} instead.`
            );
          const i = e.parse(t[1], 1, Ut),
            r = e.parse(t[2], 2, Ut);
          if (!i || !r) return null;
          if (!te(i.type, [Ot, Bt, Ft, Lt, Ut]))
            return e.error(
              `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
                i.type
              )} instead`
            );
          if (4 === t.length) {
            const n = e.parse(t[3], 3, Ft);
            return n ? new ii(i, r, n) : null;
          }
          return new ii(i, r);
        }
        evaluate(t) {
          const e = this.needle.evaluate(t),
            i = this.haystack.evaluate(t);
          if (!ee(e, ['boolean', 'string', 'number', 'null']))
            throw new Le(
              `Expected first argument to be of type boolean, string, number or null, but found ${Kt(
                Ue(e)
              )} instead.`
            );
          let r;
          if (
            (this.fromIndex && (r = this.fromIndex.evaluate(t)),
            ee(i, ['string']))
          ) {
            const t = i.indexOf(e, r);
            return -1 === t ? -1 : [...i.slice(0, t)].length;
          }
          if (ee(i, ['array'])) return i.indexOf(e, r);
          throw new Le(
            `Expected second argument to be of type array or string, but found ${Kt(
              Ue(i)
            )} instead.`
          );
        }
        eachChild(t) {
          t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class ri {
        constructor(t, e, i, r, n, o) {
          (this.inputType = t),
            (this.type = e),
            (this.input = i),
            (this.cases = r),
            (this.outputs = n),
            (this.otherwise = o);
        }
        static parse(t, e) {
          if (t.length < 5)
            return e.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`
            );
          if (t.length % 2 != 1)
            return e.error('Expected an even number of arguments.');
          let i, r;
          e.expectedType &&
            'value' !== e.expectedType.kind &&
            (r = e.expectedType);
          const n = {},
            o = [];
          for (let l = 2; l < t.length - 1; l += 2) {
            let a = t[l];
            const s = t[l + 1];
            Array.isArray(a) || (a = [a]);
            const c = e.concat(l);
            if (0 === a.length)
              return c.error('Expected at least one branch label.');
            for (const t of a) {
              if ('number' != typeof t && 'string' != typeof t)
                return c.error('Branch labels must be numbers or strings.');
              if ('number' == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER)
                return c.error(
                  `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
                );
              if ('number' == typeof t && Math.floor(t) !== t)
                return c.error('Numeric branch labels must be integer values.');
              if (i) {
                if (c.checkSubtype(i, Ue(t))) return null;
              } else i = Ue(t);
              if (void 0 !== n[String(t)])
                return c.error('Branch labels must be unique.');
              n[String(t)] = o.length;
            }
            const h = e.parse(s, l, r);
            if (!h) return null;
            (r = r || h.type), o.push(h);
          }
          const a = e.parse(t[1], 1, Ut);
          if (!a) return null;
          const s = e.parse(t[t.length - 1], t.length - 1, r);
          return s
            ? 'value' !== a.type.kind && e.concat(1).checkSubtype(i, a.type)
              ? null
              : new ri(i, r, a, n, o, s)
            : null;
        }
        evaluate(t) {
          const e = this.input.evaluate(t);
          return (
            (Ue(e) === this.inputType && this.outputs[this.cases[e]]) ||
            this.otherwise
          ).evaluate(t);
        }
        eachChild(t) {
          t(this.input), this.outputs.forEach(t), t(this.otherwise);
        }
        outputDefined() {
          return (
            this.outputs.every((t) => t.outputDefined()) &&
            this.otherwise.outputDefined()
          );
        }
      }
      class ni {
        constructor(t, e, i) {
          (this.type = t), (this.branches = e), (this.otherwise = i);
        }
        static parse(t, e) {
          if (t.length < 4)
            return e.error(
              `Expected at least 3 arguments, but found only ${t.length - 1}.`
            );
          if (t.length % 2 != 0)
            return e.error('Expected an odd number of arguments.');
          let i;
          e.expectedType &&
            'value' !== e.expectedType.kind &&
            (i = e.expectedType);
          const r = [];
          for (let o = 1; o < t.length - 1; o += 2) {
            const n = e.parse(t[o], o, Ot);
            if (!n) return null;
            const a = e.parse(t[o + 1], o + 1, i);
            if (!a) return null;
            r.push([n, a]), (i = i || a.type);
          }
          const n = e.parse(t[t.length - 1], t.length - 1, i);
          if (!n) return null;
          if (!i) throw new Error("Can't infer output type");
          return new ni(i, r, n);
        }
        evaluate(t) {
          for (const [e, i] of this.branches)
            if (e.evaluate(t)) return i.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [e, i] of this.branches) t(e), t(i);
          t(this.otherwise);
        }
        outputDefined() {
          return (
            this.branches.every(([t, e]) => e.outputDefined()) &&
            this.otherwise.outputDefined()
          );
        }
      }
      class oi {
        constructor(t, e, i, r) {
          (this.type = t),
            (this.input = e),
            (this.beginIndex = i),
            (this.endIndex = r);
        }
        static parse(t, e) {
          if (t.length <= 2 || t.length >= 5)
            return e.error(
              `Expected 2 or 3 arguments, but found ${t.length - 1} instead.`
            );
          const i = e.parse(t[1], 1, Ut),
            r = e.parse(t[2], 2, Ft);
          if (!i || !r) return null;
          if (!te(i.type, [Xt(Ut), Bt, Ut]))
            return e.error(
              `Expected first argument to be of type array or string, but found ${Kt(
                i.type
              )} instead`
            );
          if (4 === t.length) {
            const n = e.parse(t[3], 3, Ft);
            return n ? new oi(i.type, i, r, n) : null;
          }
          return new oi(i.type, i, r);
        }
        evaluate(t) {
          const e = this.input.evaluate(t),
            i = this.beginIndex.evaluate(t);
          let r;
          if (
            (this.endIndex && (r = this.endIndex.evaluate(t)),
            ee(e, ['string']))
          )
            return [...e].slice(i, r).join('');
          if (ee(e, ['array'])) return e.slice(i, r);
          throw new Le(
            `Expected first argument to be of type array or string, but found ${Kt(
              Ue(e)
            )} instead.`
          );
        }
        eachChild(t) {
          t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function ai(t, e) {
        const i = t.length - 1;
        let r,
          n,
          o = 0,
          a = i,
          s = 0;
        for (; o <= a; )
          if (
            ((s = Math.floor((o + a) / 2)), (r = t[s]), (n = t[s + 1]), r <= e)
          ) {
            if (s === i || e < n) return s;
            o = s + 1;
          } else {
            if (!(r > e)) throw new Le('Input is not a number.');
            a = s - 1;
          }
        return 0;
      }
      class si {
        constructor(t, e, i) {
          (this.type = t),
            (this.input = e),
            (this.labels = []),
            (this.outputs = []);
          for (const [r, n] of i) this.labels.push(r), this.outputs.push(n);
        }
        static parse(t, e) {
          if (t.length - 1 < 4)
            return e.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`
            );
          if ((t.length - 1) % 2 != 0)
            return e.error('Expected an even number of arguments.');
          const i = e.parse(t[1], 1, Ft);
          if (!i) return null;
          const r = [];
          let n = null;
          e.expectedType &&
            'value' !== e.expectedType.kind &&
            (n = e.expectedType);
          for (let o = 1; o < t.length; o += 2) {
            const i = 1 === o ? -1 / 0 : t[o],
              a = t[o + 1],
              s = o,
              l = o + 1;
            if ('number' != typeof i)
              return e.error(
                'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                s
              );
            if (r.length && r[r.length - 1][0] >= i)
              return e.error(
                'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                s
              );
            const c = e.parse(a, l, n);
            if (!c) return null;
            (n = n || c.type), r.push([i, c]);
          }
          return new si(n, i, r);
        }
        evaluate(t) {
          const e = this.labels,
            i = this.outputs;
          if (1 === e.length) return i[0].evaluate(t);
          const r = this.input.evaluate(t);
          if (r <= e[0]) return i[0].evaluate(t);
          const n = e.length;
          return r >= e[n - 1] ? i[n - 1].evaluate(t) : i[ai(e, r)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const e of this.outputs) t(e);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function li(t) {
        return t &&
          t.__esModule &&
          Object.prototype.hasOwnProperty.call(t, 'default')
          ? t.default
          : t;
      }
      var ci,
        hi,
        ui = (function () {
          if (hi) return ci;
          function t(t, e, i, r) {
            (this.cx = 3 * t),
              (this.bx = 3 * (i - t) - this.cx),
              (this.ax = 1 - this.cx - this.bx),
              (this.cy = 3 * e),
              (this.by = 3 * (r - e) - this.cy),
              (this.ay = 1 - this.cy - this.by),
              (this.p1x = t),
              (this.p1y = e),
              (this.p2x = i),
              (this.p2y = r);
          }
          return (
            (hi = 1),
            (ci = t),
            (t.prototype = {
              sampleCurveX: function (t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t;
              },
              sampleCurveY: function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
              },
              sampleCurveDerivativeX: function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
              },
              solveCurveX: function (t, e) {
                if ((void 0 === e && (e = 1e-6), t < 0)) return 0;
                if (t > 1) return 1;
                for (var i = t, r = 0; r < 8; r++) {
                  var n = this.sampleCurveX(i) - t;
                  if (Math.abs(n) < e) return i;
                  var o = this.sampleCurveDerivativeX(i);
                  if (Math.abs(o) < 1e-6) break;
                  i -= n / o;
                }
                var a = 0,
                  s = 1;
                for (
                  i = t, r = 0;
                  r < 20 &&
                  ((n = this.sampleCurveX(i)), !(Math.abs(n - t) < e));
                  r++
                )
                  t > n ? (a = i) : (s = i), (i = 0.5 * (s - a) + a);
                return i;
              },
              solve: function (t, e) {
                return this.sampleCurveY(this.solveCurveX(t, e));
              },
            }),
            ci
          );
        })(),
        di = li(ui);
      class pi {
        constructor(t, e, i, r, n) {
          (this.type = t),
            (this.operator = e),
            (this.interpolation = i),
            (this.input = r),
            (this.labels = []),
            (this.outputs = []);
          for (const [o, a] of n) this.labels.push(o), this.outputs.push(a);
        }
        static interpolationFactor(t, e, i, r) {
          let n = 0;
          if ('exponential' === t.name) n = fi(e, t.base, i, r);
          else if ('linear' === t.name) n = fi(e, 1, i, r);
          else if ('cubic-bezier' === t.name) {
            const o = t.controlPoints;
            n = new di(o[0], o[1], o[2], o[3]).solve(fi(e, 1, i, r));
          }
          return n;
        }
        static parse(t, e) {
          let [i, r, n, ...o] = t;
          if (!Array.isArray(r) || 0 === r.length)
            return e.error('Expected an interpolation type expression.', 1);
          if ('linear' === r[0]) r = { name: 'linear' };
          else if ('exponential' === r[0]) {
            const t = r[1];
            if ('number' != typeof t)
              return e.error(
                'Exponential interpolation requires a numeric base.',
                1,
                1
              );
            r = { name: 'exponential', base: t };
          } else {
            if ('cubic-bezier' !== r[0])
              return e.error(
                `Unknown interpolation type ${String(r[0])}`,
                1,
                0
              );
            {
              const t = r.slice(1);
              if (
                4 !== t.length ||
                t.some((t) => 'number' != typeof t || t < 0 || t > 1)
              )
                return e.error(
                  'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.',
                  1
                );
              r = { name: 'cubic-bezier', controlPoints: t };
            }
          }
          if (t.length - 1 < 4)
            return e.error(
              `Expected at least 4 arguments, but found only ${t.length - 1}.`
            );
          if ((t.length - 1) % 2 != 0)
            return e.error('Expected an even number of arguments.');
          if (((n = e.parse(n, 2, Ft)), !n)) return null;
          const a = [];
          let s = null;
          ('interpolate-hcl' !== i && 'interpolate-lab' !== i) ||
          e.expectedType == qt
            ? e.expectedType &&
              'value' !== e.expectedType.kind &&
              (s = e.expectedType)
            : (s = jt);
          for (let l = 0; l < o.length; l += 2) {
            const t = o[l],
              i = o[l + 1],
              r = l + 3,
              n = l + 4;
            if ('number' != typeof t)
              return e.error(
                'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                r
              );
            if (a.length && a[a.length - 1][0] >= t)
              return e.error(
                'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                r
              );
            const c = e.parse(i, n, s);
            if (!c) return null;
            (s = s || c.type), a.push([t, c]);
          }
          return ie(s, Ft) ||
            ie(s, Nt) ||
            ie(s, jt) ||
            ie(s, $t) ||
            ie(s, Wt) ||
            ie(s, qt) ||
            ie(s, Ht) ||
            ie(s, Xt(Ft))
            ? new pi(s, i, r, n, a)
            : e.error(`Type ${Kt(s)} is not interpolatable.`);
        }
        evaluate(t) {
          const e = this.labels,
            i = this.outputs;
          if (1 === e.length) return i[0].evaluate(t);
          const r = this.input.evaluate(t);
          if (r <= e[0]) return i[0].evaluate(t);
          const n = e.length;
          if (r >= e[n - 1]) return i[n - 1].evaluate(t);
          const o = ai(e, r),
            a = pi.interpolationFactor(this.interpolation, r, e[o], e[o + 1]),
            s = i[o].evaluate(t),
            l = i[o + 1].evaluate(t);
          switch (this.operator) {
            case 'interpolate':
              switch (this.type.kind) {
                case 'number':
                  return Se(s, l, a);
                case 'color':
                  return Ie.interpolate(s, l, a);
                case 'padding':
                  return ke.interpolate(s, l, a);
                case 'colorArray':
                  return Re.interpolate(s, l, a);
                case 'numberArray':
                  return De.interpolate(s, l, a);
                case 'variableAnchorOffsetCollection':
                  return Be.interpolate(s, l, a);
                case 'array':
                  return Me(s, l, a);
                case 'projectionDefinition':
                  return je.interpolate(s, l, a);
              }
            case 'interpolate-hcl':
              switch (this.type.kind) {
                case 'color':
                  return Ie.interpolate(s, l, a, 'hcl');
                case 'colorArray':
                  return Re.interpolate(s, l, a, 'hcl');
              }
            case 'interpolate-lab':
              switch (this.type.kind) {
                case 'color':
                  return Ie.interpolate(s, l, a, 'lab');
                case 'colorArray':
                  return Re.interpolate(s, l, a, 'lab');
              }
          }
        }
        eachChild(t) {
          t(this.input);
          for (const e of this.outputs) t(e);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function fi(t, e, i, r) {
        const n = r - i,
          o = t - i;
        return 0 === n
          ? 0
          : 1 === e
          ? o / n
          : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
      }
      const mi = {
        color: Ie.interpolate,
        number: Se,
        padding: ke.interpolate,
        numberArray: De.interpolate,
        colorArray: Re.interpolate,
        variableAnchorOffsetCollection: Be.interpolate,
        array: Me,
      };
      class _i {
        constructor(t, e) {
          (this.type = t), (this.args = e);
        }
        static parse(t, e) {
          if (t.length < 2) return e.error('Expected at least one argument.');
          let i = null;
          const r = e.expectedType;
          r && 'value' !== r.kind && (i = r);
          const n = [];
          for (const a of t.slice(1)) {
            const t = e.parse(a, 1 + n.length, i, void 0, {
              typeAnnotation: 'omit',
            });
            if (!t) return null;
            (i = i || t.type), n.push(t);
          }
          if (!i) throw new Error('No output type');
          const o = r && n.some((t) => Qt(r, t.type));
          return new _i(o ? Ut : i, n);
        }
        evaluate(t) {
          let e,
            i = null,
            r = 0;
          for (const n of this.args)
            if (
              (r++,
              (i = n.evaluate(t)),
              i &&
                i instanceof Oe &&
                !i.available &&
                (e || (e = i.name),
                (i = null),
                r === this.args.length && (i = e)),
              null !== i)
            )
              break;
          return i;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function gi(t, e) {
        return '==' === t || '!=' === t
          ? 'boolean' === e.kind ||
              'string' === e.kind ||
              'number' === e.kind ||
              'null' === e.kind ||
              'value' === e.kind
          : 'string' === e.kind || 'number' === e.kind || 'value' === e.kind;
      }
      function yi(t, e, i, r) {
        return 0 === r.compare(e, i);
      }
      function xi(t, e, i) {
        const r = '==' !== t && '!=' !== t;
        return class n {
          constructor(t, e, i) {
            (this.type = Ot),
              (this.lhs = t),
              (this.rhs = e),
              (this.collator = i),
              (this.hasUntypedArgument =
                'value' === t.type.kind || 'value' === e.type.kind);
          }
          static parse(t, e) {
            if (3 !== t.length && 4 !== t.length)
              return e.error('Expected two or three arguments.');
            const i = t[0];
            let o = e.parse(t[1], 1, Ut);
            if (!o) return null;
            if (!gi(i, o.type))
              return e
                .concat(1)
                .error(
                  `"${i}" comparisons are not supported for type '${Kt(
                    o.type
                  )}'.`
                );
            let a = e.parse(t[2], 2, Ut);
            if (!a) return null;
            if (!gi(i, a.type))
              return e
                .concat(2)
                .error(
                  `"${i}" comparisons are not supported for type '${Kt(
                    a.type
                  )}'.`
                );
            if (
              o.type.kind !== a.type.kind &&
              'value' !== o.type.kind &&
              'value' !== a.type.kind
            )
              return e.error(
                `Cannot compare types '${Kt(o.type)}' and '${Kt(a.type)}'.`
              );
            r &&
              ('value' === o.type.kind && 'value' !== a.type.kind
                ? (o = new qe(a.type, [o]))
                : 'value' !== o.type.kind &&
                  'value' === a.type.kind &&
                  (a = new qe(o.type, [a])));
            let s = null;
            if (4 === t.length) {
              if (
                'string' !== o.type.kind &&
                'string' !== a.type.kind &&
                'value' !== o.type.kind &&
                'value' !== a.type.kind
              )
                return e.error(
                  'Cannot use collator to compare non-string types.'
                );
              if (((s = e.parse(t[3], 3, Gt)), !s)) return null;
            }
            return new n(o, a, s);
          }
          evaluate(n) {
            const o = this.lhs.evaluate(n),
              a = this.rhs.evaluate(n);
            if (r && this.hasUntypedArgument) {
              const e = Ue(o),
                i = Ue(a);
              if (
                e.kind !== i.kind ||
                ('string' !== e.kind && 'number' !== e.kind)
              )
                throw new Le(
                  `Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${i.kind}) instead.`
                );
            }
            if (this.collator && !r && this.hasUntypedArgument) {
              const t = Ue(o),
                i = Ue(a);
              if ('string' !== t.kind || 'string' !== i.kind) return e(n, o, a);
            }
            return this.collator
              ? i(n, o, a, this.collator.evaluate(n))
              : e(n, o, a);
          }
          eachChild(t) {
            t(this.lhs), t(this.rhs), this.collator && t(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const vi = xi(
          '==',
          function (t, e, i) {
            return e === i;
          },
          yi
        ),
        bi = xi(
          '!=',
          function (t, e, i) {
            return e !== i;
          },
          function (t, e, i, r) {
            return !yi(0, e, i, r);
          }
        ),
        wi = xi(
          '<',
          function (t, e, i) {
            return e < i;
          },
          function (t, e, i, r) {
            return r.compare(e, i) < 0;
          }
        ),
        Ti = xi(
          '>',
          function (t, e, i) {
            return e > i;
          },
          function (t, e, i, r) {
            return r.compare(e, i) > 0;
          }
        ),
        Pi = xi(
          '<=',
          function (t, e, i) {
            return e <= i;
          },
          function (t, e, i, r) {
            return r.compare(e, i) <= 0;
          }
        ),
        Si = xi(
          '>=',
          function (t, e, i) {
            return e >= i;
          },
          function (t, e, i, r) {
            return r.compare(e, i) >= 0;
          }
        );
      class Mi {
        constructor(t, e, i) {
          (this.type = Gt),
            (this.locale = i),
            (this.caseSensitive = t),
            (this.diacriticSensitive = e);
        }
        static parse(t, e) {
          if (2 !== t.length) return e.error('Expected one argument.');
          const i = t[1];
          if ('object' != typeof i || Array.isArray(i))
            return e.error('Collator options argument must be an object.');
          const r = e.parse(
            void 0 !== i['case-sensitive'] && i['case-sensitive'],
            1,
            Ot
          );
          if (!r) return null;
          const n = e.parse(
            void 0 !== i['diacritic-sensitive'] && i['diacritic-sensitive'],
            1,
            Ot
          );
          if (!n) return null;
          let o = null;
          return i.locale && ((o = e.parse(i.locale, 1, Bt)), !o)
            ? null
            : new Mi(r, n, o);
        }
        evaluate(t) {
          return new Ce(
            this.caseSensitive.evaluate(t),
            this.diacriticSensitive.evaluate(t),
            this.locale ? this.locale.evaluate(t) : null
          );
        }
        eachChild(t) {
          t(this.caseSensitive),
            t(this.diacriticSensitive),
            this.locale && t(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ii {
        constructor(t, e, i, r, n) {
          (this.type = Bt),
            (this.number = t),
            (this.locale = e),
            (this.currency = i),
            (this.minFractionDigits = r),
            (this.maxFractionDigits = n);
        }
        static parse(t, e) {
          if (3 !== t.length) return e.error('Expected two arguments.');
          const i = e.parse(t[1], 1, Ft);
          if (!i) return null;
          const r = t[2];
          if ('object' != typeof r || Array.isArray(r))
            return e.error('NumberFormat options argument must be an object.');
          let n = null;
          if (r.locale && ((n = e.parse(r.locale, 1, Bt)), !n)) return null;
          let o = null;
          if (r.currency && ((o = e.parse(r.currency, 1, Bt)), !o)) return null;
          let a = null;
          if (
            r['min-fraction-digits'] &&
            ((a = e.parse(r['min-fraction-digits'], 1, Ft)), !a)
          )
            return null;
          let s = null;
          return r['max-fraction-digits'] &&
            ((s = e.parse(r['max-fraction-digits'], 1, Ft)), !s)
            ? null
            : new Ii(i, n, o, a, s);
        }
        evaluate(t) {
          return new Intl.NumberFormat(
            this.locale ? this.locale.evaluate(t) : [],
            {
              style: this.currency ? 'currency' : 'decimal',
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits
                ? this.minFractionDigits.evaluate(t)
                : void 0,
              maximumFractionDigits: this.maxFractionDigits
                ? this.maxFractionDigits.evaluate(t)
                : void 0,
            }
          ).format(this.number.evaluate(t));
        }
        eachChild(t) {
          t(this.number),
            this.locale && t(this.locale),
            this.currency && t(this.currency),
            this.minFractionDigits && t(this.minFractionDigits),
            this.maxFractionDigits && t(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ci {
        constructor(t) {
          (this.type = Zt), (this.sections = t);
        }
        static parse(t, e) {
          if (t.length < 2) return e.error('Expected at least one argument.');
          const i = t[1];
          if (!Array.isArray(i) && 'object' == typeof i)
            return e.error('First argument must be an image or text section.');
          const r = [];
          let n = !1;
          for (let o = 1; o <= t.length - 1; ++o) {
            const i = t[o];
            if (n && 'object' == typeof i && !Array.isArray(i)) {
              n = !1;
              let t = null;
              if (
                i['font-scale'] &&
                ((t = e.parse(i['font-scale'], 1, Ft)), !t)
              )
                return null;
              let o = null;
              if (
                i['text-font'] &&
                ((o = e.parse(i['text-font'], 1, Xt(Bt))), !o)
              )
                return null;
              let a = null;
              if (
                i['text-color'] &&
                ((a = e.parse(i['text-color'], 1, jt)), !a)
              )
                return null;
              let s = null;
              if (i['vertical-align']) {
                if (
                  'string' == typeof i['vertical-align'] &&
                  !Ae.includes(i['vertical-align'])
                )
                  return e.error(
                    `'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${i['vertical-align']}' instead.`
                  );
                if (((s = e.parse(i['vertical-align'], 1, Bt)), !s))
                  return null;
              }
              const l = r[r.length - 1];
              (l.scale = t),
                (l.font = o),
                (l.textColor = a),
                (l.verticalAlign = s);
            } else {
              const i = e.parse(t[o], 1, Ut);
              if (!i) return null;
              const a = i.type.kind;
              if (
                'string' !== a &&
                'value' !== a &&
                'null' !== a &&
                'resolvedImage' !== a
              )
                return e.error(
                  "Formatted text type must be 'string', 'value', 'image' or 'null'."
                );
              (n = !0),
                r.push({
                  content: i,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null,
                });
            }
          }
          return new Ci(r);
        }
        evaluate(t) {
          return new ze(
            this.sections.map((e) => {
              const i = e.content.evaluate(t);
              return Ue(i) === Yt
                ? new Ee(
                    '',
                    i,
                    null,
                    null,
                    null,
                    e.verticalAlign ? e.verticalAlign.evaluate(t) : null
                  )
                : new Ee(
                    Ge(i),
                    null,
                    e.scale ? e.scale.evaluate(t) : null,
                    e.font ? e.font.evaluate(t).join(',') : null,
                    e.textColor ? e.textColor.evaluate(t) : null,
                    e.verticalAlign ? e.verticalAlign.evaluate(t) : null
                  );
            })
          );
        }
        eachChild(t) {
          for (const e of this.sections)
            t(e.content),
              e.scale && t(e.scale),
              e.font && t(e.font),
              e.textColor && t(e.textColor),
              e.verticalAlign && t(e.verticalAlign);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ai {
        constructor(t) {
          (this.type = Yt), (this.input = t);
        }
        static parse(t, e) {
          if (2 !== t.length) return e.error('Expected two arguments.');
          const i = e.parse(t[1], 1, Bt);
          return i ? new Ai(i) : e.error('No image name provided.');
        }
        evaluate(t) {
          const e = this.input.evaluate(t),
            i = Oe.fromString(e);
          return (
            i &&
              t.availableImages &&
              (i.available = t.availableImages.indexOf(e) > -1),
            i
          );
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ei {
        constructor(t) {
          (this.type = Ft), (this.input = t);
        }
        static parse(t, e) {
          if (2 !== t.length)
            return e.error(
              `Expected 1 argument, but found ${t.length - 1} instead.`
            );
          const i = e.parse(t[1], 1);
          return i
            ? 'array' !== i.type.kind &&
              'string' !== i.type.kind &&
              'value' !== i.type.kind
              ? e.error(
                  `Expected argument of type string or array, but found ${Kt(
                    i.type
                  )} instead.`
                )
              : new Ei(i)
            : null;
        }
        evaluate(t) {
          const e = this.input.evaluate(t);
          if ('string' == typeof e) return [...e].length;
          if (Array.isArray(e)) return e.length;
          throw new Le(
            `Expected value to be of type string or array, but found ${Kt(
              Ue(e)
            )} instead.`
          );
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const zi = 8192;
      function ki(t, e) {
        const i = (180 + t[0]) / 360,
          r =
            (180 -
              (180 / Math.PI) *
                Math.log(Math.tan(Math.PI / 4 + (t[1] * Math.PI) / 360))) /
            360,
          n = Math.pow(2, e.z);
        return [Math.round(i * n * zi), Math.round(r * n * zi)];
      }
      function Di(t, e) {
        const i = Math.pow(2, e.z);
        return [
          ((n = (t[0] / zi + e.x) / i), 360 * n - 180),
          ((r = (t[1] / zi + e.y) / i),
          (360 / Math.PI) *
            Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) -
            90),
        ];
        var r, n;
      }
      function Ri(t, e) {
        (t[0] = Math.min(t[0], e[0])),
          (t[1] = Math.min(t[1], e[1])),
          (t[2] = Math.max(t[2], e[0])),
          (t[3] = Math.max(t[3], e[1]));
      }
      function Li(t, e) {
        return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
      }
      function Fi(t, e, i) {
        const r = t[0] - e[0],
          n = t[1] - e[1],
          o = t[0] - i[0],
          a = t[1] - i[1];
        return r * a - o * n == 0 && r * o <= 0 && n * a <= 0;
      }
      function Bi(t, e, i, r) {
        return (
          0 !=
            (n = [r[0] - i[0], r[1] - i[1]])[0] *
              (o = [e[0] - t[0], e[1] - t[1]])[1] -
              n[1] * o[0] && !(!Gi(t, e, i, r) || !Gi(i, r, t, e))
        );
        var n, o;
      }
      function Oi(t, e, i) {
        for (const r of i)
          for (let i = 0; i < r.length - 1; ++i)
            if (Bi(t, e, r[i], r[i + 1])) return !0;
        return !1;
      }
      function ji(t, e, i = !1) {
        let r = !1;
        for (const s of e)
          for (let e = 0; e < s.length - 1; e++) {
            if (Fi(t, s[e], s[e + 1])) return i;
            (o = s[e])[1] > (n = t)[1] != (a = s[e + 1])[1] > n[1] &&
              n[0] < ((a[0] - o[0]) * (n[1] - o[1])) / (a[1] - o[1]) + o[0] &&
              (r = !r);
          }
        var n, o, a;
        return r;
      }
      function Ni(t, e) {
        for (const i of e) if (ji(t, i)) return !0;
        return !1;
      }
      function Vi(t, e) {
        for (const i of t) if (!ji(i, e)) return !1;
        for (let i = 0; i < t.length - 1; ++i)
          if (Oi(t[i], t[i + 1], e)) return !1;
        return !0;
      }
      function Ui(t, e) {
        for (const i of e) if (Vi(t, i)) return !0;
        return !1;
      }
      function Gi(t, e, i, r) {
        const n = r[0] - i[0],
          o = r[1] - i[1],
          a = (t[0] - i[0]) * o - n * (t[1] - i[1]),
          s = (e[0] - i[0]) * o - n * (e[1] - i[1]);
        return (a > 0 && s < 0) || (a < 0 && s > 0);
      }
      function Zi(t, e, i) {
        const r = [];
        for (let n = 0; n < t.length; n++) {
          const o = [];
          for (let r = 0; r < t[n].length; r++) {
            const a = ki(t[n][r], i);
            Ri(e, a), o.push(a);
          }
          r.push(o);
        }
        return r;
      }
      function $i(t, e, i) {
        const r = [];
        for (let n = 0; n < t.length; n++) {
          const o = Zi(t[n], e, i);
          r.push(o);
        }
        return r;
      }
      function qi(t, e, i, r) {
        if (t[0] < i[0] || t[0] > i[2]) {
          const e = 0.5 * r;
          let n = t[0] - i[0] > e ? -r : i[0] - t[0] > e ? r : 0;
          0 === n && (n = t[0] - i[2] > e ? -r : i[2] - t[0] > e ? r : 0),
            (t[0] += n);
        }
        Ri(e, t);
      }
      function Wi(t, e, i, r) {
        const n = Math.pow(2, r.z) * zi,
          o = [r.x * zi, r.y * zi],
          a = [];
        for (const s of t)
          for (const t of s) {
            const r = [t.x + o[0], t.y + o[1]];
            qi(r, e, i, n), a.push(r);
          }
        return a;
      }
      function Yi(t, e, i, r) {
        const n = Math.pow(2, r.z) * zi,
          o = [r.x * zi, r.y * zi],
          a = [];
        for (const l of t) {
          const t = [];
          for (const i of l) {
            const r = [i.x + o[0], i.y + o[1]];
            Ri(e, r), t.push(r);
          }
          a.push(t);
        }
        if (e[2] - e[0] <= n / 2) {
          ((s = e)[0] = s[1] = 1 / 0), (s[2] = s[3] = -1 / 0);
          for (const t of a) for (const r of t) qi(r, e, i, n);
        }
        var s;
        return a;
      }
      class Hi {
        constructor(t, e) {
          (this.type = Ot), (this.geojson = t), (this.geometries = e);
        }
        static parse(t, e) {
          if (2 !== t.length)
            return e.error(
              `'within' expression requires exactly one argument, but found ${
                t.length - 1
              } instead.`
            );
          if (Ve(t[1])) {
            const e = t[1];
            if ('FeatureCollection' === e.type) {
              const t = [];
              for (const i of e.features) {
                const { type: e, coordinates: r } = i.geometry;
                'Polygon' === e && t.push(r),
                  'MultiPolygon' === e && t.push(...r);
              }
              if (t.length)
                return new Hi(e, { type: 'MultiPolygon', coordinates: t });
            } else if ('Feature' === e.type) {
              const t = e.geometry.type;
              if ('Polygon' === t || 'MultiPolygon' === t)
                return new Hi(e, e.geometry);
            } else if ('Polygon' === e.type || 'MultiPolygon' === e.type)
              return new Hi(e, e);
          }
          return e.error(
            "'within' expression requires valid geojson object that contains polygon geometry type."
          );
        }
        evaluate(t) {
          if (null != t.geometry() && null != t.canonicalID()) {
            if ('Point' === t.geometryType())
              return (function (t, e) {
                const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  n = t.canonicalID();
                if ('Polygon' === e.type) {
                  const o = Zi(e.coordinates, r, n),
                    a = Wi(t.geometry(), i, r, n);
                  if (!Li(i, r)) return !1;
                  for (const t of a) if (!ji(t, o)) return !1;
                }
                if ('MultiPolygon' === e.type) {
                  const o = $i(e.coordinates, r, n),
                    a = Wi(t.geometry(), i, r, n);
                  if (!Li(i, r)) return !1;
                  for (const t of a) if (!Ni(t, o)) return !1;
                }
                return !0;
              })(t, this.geometries);
            if ('LineString' === t.geometryType())
              return (function (t, e) {
                const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  n = t.canonicalID();
                if ('Polygon' === e.type) {
                  const o = Zi(e.coordinates, r, n),
                    a = Yi(t.geometry(), i, r, n);
                  if (!Li(i, r)) return !1;
                  for (const t of a) if (!Vi(t, o)) return !1;
                }
                if ('MultiPolygon' === e.type) {
                  const o = $i(e.coordinates, r, n),
                    a = Yi(t.geometry(), i, r, n);
                  if (!Li(i, r)) return !1;
                  for (const t of a) if (!Ui(t, o)) return !1;
                }
                return !0;
              })(t, this.geometries);
          }
          return !1;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      let Xi = class {
        constructor(t = [], e = (t, e) => (t < e ? -1 : t > e ? 1 : 0)) {
          if (
            ((this.data = t),
            (this.length = this.data.length),
            (this.compare = e),
            this.length > 0)
          )
            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
        }
        push(t) {
          this.data.push(t), this._up(this.length++);
        }
        pop() {
          if (0 === this.length) return;
          const t = this.data[0],
            e = this.data.pop();
          return --this.length > 0 && ((this.data[0] = e), this._down(0)), t;
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: e, compare: i } = this,
            r = e[t];
          for (; t > 0; ) {
            const n = (t - 1) >> 1,
              o = e[n];
            if (i(r, o) >= 0) break;
            (e[t] = o), (t = n);
          }
          e[t] = r;
        }
        _down(t) {
          const { data: e, compare: i } = this,
            r = this.length >> 1,
            n = e[t];
          for (; t < r; ) {
            let r = 1 + (t << 1);
            const o = r + 1;
            if (
              (o < this.length && i(e[o], e[r]) < 0 && (r = o), i(e[r], n) >= 0)
            )
              break;
            (e[t] = e[r]), (t = r);
          }
          e[t] = n;
        }
      };
      function Ki(t, e, i = 0, r = t.length - 1, n = Qi) {
        for (; r > i; ) {
          if (r - i > 600) {
            const o = r - i + 1,
              a = e - i + 1,
              s = Math.log(o),
              l = 0.5 * Math.exp((2 * s) / 3),
              c =
                0.5 *
                Math.sqrt((s * l * (o - l)) / o) *
                (a - o / 2 < 0 ? -1 : 1);
            Ki(
              t,
              e,
              Math.max(i, Math.floor(e - (a * l) / o + c)),
              Math.min(r, Math.floor(e + ((o - a) * l) / o + c)),
              n
            );
          }
          const o = t[e];
          let a = i,
            s = r;
          for (Ji(t, i, e), n(t[r], o) > 0 && Ji(t, i, r); a < s; ) {
            for (Ji(t, a, s), a++, s--; n(t[a], o) < 0; ) a++;
            for (; n(t[s], o) > 0; ) s--;
          }
          0 === n(t[i], o) ? Ji(t, i, s) : (s++, Ji(t, s, r)),
            s <= e && (i = s + 1),
            e <= s && (r = s - 1);
        }
      }
      function Ji(t, e, i) {
        const r = t[e];
        (t[e] = t[i]), (t[i] = r);
      }
      function Qi(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
      function tr(t, e) {
        if (t.length <= 1) return [t];
        const i = [];
        let r, n;
        for (const o of t) {
          const t = ir(o);
          0 !== t &&
            ((o.area = Math.abs(t)),
            void 0 === n && (n = t < 0),
            n === t < 0 ? (r && i.push(r), (r = [o])) : r.push(o));
        }
        if ((r && i.push(r), e > 1))
          for (let o = 0; o < i.length; o++)
            i[o].length <= e ||
              (Ki(i[o], e, 1, i[o].length - 1, er), (i[o] = i[o].slice(0, e)));
        return i;
      }
      function er(t, e) {
        return e.area - t.area;
      }
      function ir(t) {
        let e = 0;
        for (let i, r, n = 0, o = t.length, a = o - 1; n < o; a = n++)
          (i = t[n]), (r = t[a]), (e += (r.x - i.x) * (i.y + r.y));
        return e;
      }
      const rr = 1 / 298.257223563,
        nr = rr * (2 - rr),
        or = Math.PI / 180;
      class ar {
        constructor(t) {
          const e = 6378.137 * or * 1e3,
            i = Math.cos(t * or),
            r = 1 / (1 - nr * (1 - i * i)),
            n = Math.sqrt(r);
          (this.kx = e * n * i), (this.ky = e * n * r * (1 - nr));
        }
        distance(t, e) {
          const i = this.wrap(t[0] - e[0]) * this.kx,
            r = (t[1] - e[1]) * this.ky;
          return Math.sqrt(i * i + r * r);
        }
        pointOnLine(t, e) {
          let i,
            r,
            n,
            o,
            a = 1 / 0;
          for (let s = 0; s < t.length - 1; s++) {
            let l = t[s][0],
              c = t[s][1],
              h = this.wrap(t[s + 1][0] - l) * this.kx,
              u = (t[s + 1][1] - c) * this.ky,
              d = 0;
            (0 === h && 0 === u) ||
              ((d =
                (this.wrap(e[0] - l) * this.kx * h + (e[1] - c) * this.ky * u) /
                (h * h + u * u)),
              d > 1
                ? ((l = t[s + 1][0]), (c = t[s + 1][1]))
                : d > 0 &&
                  ((l += (h / this.kx) * d), (c += (u / this.ky) * d))),
              (h = this.wrap(e[0] - l) * this.kx),
              (u = (e[1] - c) * this.ky);
            const p = h * h + u * u;
            p < a && ((a = p), (i = l), (r = c), (n = s), (o = d));
          }
          return { point: [i, r], index: n, t: Math.max(0, Math.min(1, o)) };
        }
        wrap(t) {
          for (; t < -180; ) t += 360;
          for (; t > 180; ) t -= 360;
          return t;
        }
      }
      function sr(t, e) {
        return e[0] - t[0];
      }
      function lr(t) {
        return t[1] - t[0] + 1;
      }
      function cr(t, e) {
        return t[1] >= t[0] && t[1] < e;
      }
      function hr(t, e) {
        if (t[0] > t[1]) return [null, null];
        const i = lr(t);
        if (e) {
          if (2 === i) return [t, null];
          const e = Math.floor(i / 2);
          return [
            [t[0], t[0] + e],
            [t[0] + e, t[1]],
          ];
        }
        if (1 === i) return [t, null];
        const r = Math.floor(i / 2) - 1;
        return [
          [t[0], t[0] + r],
          [t[0] + r + 1, t[1]],
        ];
      }
      function ur(t, e) {
        if (!cr(e, t.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let r = e[0]; r <= e[1]; ++r) Ri(i, t[r]);
        return i;
      }
      function dr(t) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const i of t) for (const t of i) Ri(e, t);
        return e;
      }
      function pr(t) {
        return (
          t[0] !== -1 / 0 && t[1] !== -1 / 0 && t[2] !== 1 / 0 && t[3] !== 1 / 0
        );
      }
      function fr(t, e, i) {
        if (!pr(t) || !pr(e)) return NaN;
        let r = 0,
          n = 0;
        return (
          t[2] < e[0] && (r = e[0] - t[2]),
          t[0] > e[2] && (r = t[0] - e[2]),
          t[1] > e[3] && (n = t[1] - e[3]),
          t[3] < e[1] && (n = e[1] - t[3]),
          i.distance([0, 0], [r, n])
        );
      }
      function mr(t, e, i) {
        const r = i.pointOnLine(e, t);
        return i.distance(t, r.point);
      }
      function _r(t, e, i, r, n) {
        const o = Math.min(mr(t, [i, r], n), mr(e, [i, r], n)),
          a = Math.min(mr(i, [t, e], n), mr(r, [t, e], n));
        return Math.min(o, a);
      }
      function gr(t, e, i, r, n) {
        if (!cr(e, t.length) || !cr(r, i.length)) return 1 / 0;
        let o = 1 / 0;
        for (let a = e[0]; a < e[1]; ++a) {
          const e = t[a],
            s = t[a + 1];
          for (let t = r[0]; t < r[1]; ++t) {
            const r = i[t],
              a = i[t + 1];
            if (Bi(e, s, r, a)) return 0;
            o = Math.min(o, _r(e, s, r, a, n));
          }
        }
        return o;
      }
      function yr(t, e, i, r, n) {
        if (!cr(e, t.length) || !cr(r, i.length)) return NaN;
        let o = 1 / 0;
        for (let a = e[0]; a <= e[1]; ++a)
          for (let e = r[0]; e <= r[1]; ++e)
            if (((o = Math.min(o, n.distance(t[a], i[e]))), 0 === o)) return o;
        return o;
      }
      function xr(t, e, i) {
        if (ji(t, e, !0)) return 0;
        let r = 1 / 0;
        for (const n of e) {
          const e = n[0],
            o = n[n.length - 1];
          if (e !== o && ((r = Math.min(r, mr(t, [o, e], i))), 0 === r))
            return r;
          const a = i.pointOnLine(n, t);
          if (((r = Math.min(r, i.distance(t, a.point))), 0 === r)) return r;
        }
        return r;
      }
      function vr(t, e, i, r) {
        if (!cr(e, t.length)) return NaN;
        for (let o = e[0]; o <= e[1]; ++o) if (ji(t[o], i, !0)) return 0;
        let n = 1 / 0;
        for (let o = e[0]; o < e[1]; ++o) {
          const e = t[o],
            a = t[o + 1];
          for (const t of i)
            for (let i = 0, o = t.length, s = o - 1; i < o; s = i++) {
              const o = t[s],
                l = t[i];
              if (Bi(e, a, o, l)) return 0;
              n = Math.min(n, _r(e, a, o, l, r));
            }
        }
        return n;
      }
      function br(t, e) {
        for (const i of t) for (const t of i) if (ji(t, e, !0)) return !0;
        return !1;
      }
      function wr(t, e, i, r = 1 / 0) {
        const n = dr(t),
          o = dr(e);
        if (r !== 1 / 0 && fr(n, o, i) >= r) return r;
        if (Li(n, o)) {
          if (br(t, e)) return 0;
        } else if (br(e, t)) return 0;
        let a = 1 / 0;
        for (const s of t)
          for (let t = 0, r = s.length, n = r - 1; t < r; n = t++) {
            const r = s[n],
              o = s[t];
            for (const t of e)
              for (let e = 0, n = t.length, s = n - 1; e < n; s = e++) {
                const n = t[s],
                  l = t[e];
                if (Bi(r, o, n, l)) return 0;
                a = Math.min(a, _r(r, o, n, l, i));
              }
          }
        return a;
      }
      function Tr(t, e, i, r, n, o) {
        if (!o) return;
        const a = fr(ur(r, o), n, i);
        a < e && t.push([a, o, [0, 0]]);
      }
      function Pr(t, e, i, r, n, o, a) {
        if (!o || !a) return;
        const s = fr(ur(r, o), ur(n, a), i);
        s < e && t.push([s, o, a]);
      }
      function Sr(t, e, i, r, n = 1 / 0) {
        let o = Math.min(r.distance(t[0], i[0][0]), n);
        if (0 === o) return o;
        const a = new Xi([[0, [0, t.length - 1], [0, 0]]], sr),
          s = dr(i);
        for (; a.length > 0; ) {
          const n = a.pop();
          if (n[0] >= o) continue;
          const l = n[1],
            c = e ? 50 : 100;
          if (lr(l) <= c) {
            if (!cr(l, t.length)) return NaN;
            if (e) {
              const e = vr(t, l, i, r);
              if (isNaN(e) || 0 === e) return e;
              o = Math.min(o, e);
            } else
              for (let e = l[0]; e <= l[1]; ++e) {
                const n = xr(t[e], i, r);
                if (((o = Math.min(o, n)), 0 === o)) return 0;
              }
          } else {
            const i = hr(l, e);
            Tr(a, o, r, t, s, i[0]), Tr(a, o, r, t, s, i[1]);
          }
        }
        return o;
      }
      function Mr(t, e, i, r, n, o = 1 / 0) {
        let a = Math.min(o, n.distance(t[0], i[0]));
        if (0 === a) return a;
        const s = new Xi([[0, [0, t.length - 1], [0, i.length - 1]]], sr);
        for (; s.length > 0; ) {
          const o = s.pop();
          if (o[0] >= a) continue;
          const l = o[1],
            c = o[2],
            h = e ? 50 : 100,
            u = r ? 50 : 100;
          if (lr(l) <= h && lr(c) <= u) {
            if (!cr(l, t.length) && cr(c, i.length)) return NaN;
            let o;
            if (e && r) (o = gr(t, l, i, c, n)), (a = Math.min(a, o));
            else if (e && !r) {
              const e = t.slice(l[0], l[1] + 1);
              for (let t = c[0]; t <= c[1]; ++t)
                if (((o = mr(i[t], e, n)), (a = Math.min(a, o)), 0 === a))
                  return a;
            } else if (!e && r) {
              const e = i.slice(c[0], c[1] + 1);
              for (let i = l[0]; i <= l[1]; ++i)
                if (((o = mr(t[i], e, n)), (a = Math.min(a, o)), 0 === a))
                  return a;
            } else (o = yr(t, l, i, c, n)), (a = Math.min(a, o));
          } else {
            const o = hr(l, e),
              h = hr(c, r);
            Pr(s, a, n, t, i, o[0], h[0]),
              Pr(s, a, n, t, i, o[0], h[1]),
              Pr(s, a, n, t, i, o[1], h[0]),
              Pr(s, a, n, t, i, o[1], h[1]);
          }
        }
        return a;
      }
      function Ir(t) {
        return 'MultiPolygon' === t.type
          ? t.coordinates.map((t) => ({ type: 'Polygon', coordinates: t }))
          : 'MultiLineString' === t.type
          ? t.coordinates.map((t) => ({ type: 'LineString', coordinates: t }))
          : 'MultiPoint' === t.type
          ? t.coordinates.map((t) => ({ type: 'Point', coordinates: t }))
          : [t];
      }
      class Cr {
        constructor(t, e) {
          (this.type = Ft), (this.geojson = t), (this.geometries = e);
        }
        static parse(t, e) {
          if (2 !== t.length)
            return e.error(
              `'distance' expression requires exactly one argument, but found ${
                t.length - 1
              } instead.`
            );
          if (Ve(t[1])) {
            const e = t[1];
            if ('FeatureCollection' === e.type)
              return new Cr(e, e.features.map((t) => Ir(t.geometry)).flat());
            if ('Feature' === e.type) return new Cr(e, Ir(e.geometry));
            if ('type' in e && 'coordinates' in e) return new Cr(e, Ir(e));
          }
          return e.error(
            "'distance' expression requires valid geojson object that contains polygon geometry type."
          );
        }
        evaluate(t) {
          if (null != t.geometry() && null != t.canonicalID()) {
            if ('Point' === t.geometryType())
              return (function (t, e) {
                const i = t.geometry(),
                  r = i.flat().map((e) => Di([e.x, e.y], t.canonical));
                if (0 === i.length) return NaN;
                const n = new ar(r[0][1]);
                let o = 1 / 0;
                for (const a of e) {
                  switch (a.type) {
                    case 'Point':
                      o = Math.min(o, Mr(r, !1, [a.coordinates], !1, n, o));
                      break;
                    case 'LineString':
                      o = Math.min(o, Mr(r, !1, a.coordinates, !0, n, o));
                      break;
                    case 'Polygon':
                      o = Math.min(o, Sr(r, !1, a.coordinates, n, o));
                  }
                  if (0 === o) return o;
                }
                return o;
              })(t, this.geometries);
            if ('LineString' === t.geometryType())
              return (function (t, e) {
                const i = t.geometry(),
                  r = i.flat().map((e) => Di([e.x, e.y], t.canonical));
                if (0 === i.length) return NaN;
                const n = new ar(r[0][1]);
                let o = 1 / 0;
                for (const a of e) {
                  switch (a.type) {
                    case 'Point':
                      o = Math.min(o, Mr(r, !0, [a.coordinates], !1, n, o));
                      break;
                    case 'LineString':
                      o = Math.min(o, Mr(r, !0, a.coordinates, !0, n, o));
                      break;
                    case 'Polygon':
                      o = Math.min(o, Sr(r, !0, a.coordinates, n, o));
                  }
                  if (0 === o) return o;
                }
                return o;
              })(t, this.geometries);
            if ('Polygon' === t.geometryType())
              return (function (t, e) {
                const i = t.geometry();
                if (0 === i.length || 0 === i[0].length) return NaN;
                const r = tr(i, 0).map((e) =>
                    e.map((e) => e.map((e) => Di([e.x, e.y], t.canonical)))
                  ),
                  n = new ar(r[0][0][0][1]);
                let o = 1 / 0;
                for (const a of e)
                  for (const t of r) {
                    switch (a.type) {
                      case 'Point':
                        o = Math.min(o, Sr([a.coordinates], !1, t, n, o));
                        break;
                      case 'LineString':
                        o = Math.min(o, Sr(a.coordinates, !0, t, n, o));
                        break;
                      case 'Polygon':
                        o = Math.min(o, wr(t, a.coordinates, n, o));
                    }
                    if (0 === o) return o;
                  }
                return o;
              })(t, this.geometries);
          }
          return NaN;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
      }
      class Ar {
        constructor(t) {
          (this.type = Ut), (this.key = t);
        }
        static parse(t, e) {
          if (2 !== t.length)
            return e.error(
              `Expected 1 argument, but found ${t.length - 1} instead.`
            );
          const i = t[1];
          return null == i
            ? e.error('Global state property must be defined.')
            : 'string' != typeof i
            ? e.error(
                `Global state property must be string, but found ${typeof t[1]} instead.`
              )
            : new Ar(i);
        }
        evaluate(t) {
          var e;
          const i =
            null === (e = t.globals) || void 0 === e ? void 0 : e.globalState;
          return i && 0 !== Object.keys(i).length ? xe(i, this.key) : null;
        }
        eachChild() {}
        outputDefined() {
          return !1;
        }
      }
      const Er = {
        '==': vi,
        '!=': bi,
        '>': Ti,
        '<': wi,
        '>=': Si,
        '<=': Pi,
        'array': qe,
        'at': ti,
        'boolean': qe,
        'case': ni,
        'coalesce': _i,
        'collator': Mi,
        'format': Ci,
        'image': Ai,
        'in': ei,
        'index-of': ii,
        'interpolate': pi,
        'interpolate-hcl': pi,
        'interpolate-lab': pi,
        'length': Ei,
        'let': Je,
        'literal': Ze,
        'match': ri,
        'number': qe,
        'number-format': Ii,
        'object': qe,
        'slice': oi,
        'step': si,
        'string': qe,
        'to-boolean': Ye,
        'to-color': Ye,
        'to-number': Ye,
        'to-string': Ye,
        'var': Qe,
        'within': Hi,
        'distance': Cr,
        'global-state': Ar,
      };
      class zr {
        constructor(t, e, i, r) {
          (this.name = t),
            (this.type = e),
            (this._evaluate = i),
            (this.args = r);
        }
        evaluate(t) {
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        static parse(t, e) {
          const i = t[0],
            r = zr.definitions[i];
          if (!r)
            return e.error(
              `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
              0
            );
          const n = Array.isArray(r) ? r[0] : r.type,
            o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads,
            a = o.filter(
              ([e]) => !Array.isArray(e) || e.length === t.length - 1
            );
          let s = null;
          for (const [l, c] of a) {
            s = new Ke(e.registry, Fr, e.path, null, e.scope);
            const r = [];
            let o = !1;
            for (let e = 1; e < t.length; e++) {
              const i = t[e],
                n = Array.isArray(l) ? l[e - 1] : l.type,
                a = s.parse(i, 1 + r.length, n);
              if (!a) {
                o = !0;
                break;
              }
              r.push(a);
            }
            if (!o)
              if (Array.isArray(l) && l.length !== r.length)
                s.error(
                  `Expected ${l.length} arguments, but found ${r.length} instead.`
                );
              else {
                for (let t = 0; t < r.length; t++) {
                  const e = Array.isArray(l) ? l[t] : l.type,
                    i = r[t];
                  s.concat(t + 1).checkSubtype(e, i.type);
                }
                if (0 === s.errors.length) return new zr(i, n, c, r);
              }
          }
          if (1 === a.length) e.errors.push(...s.errors);
          else {
            const i = (a.length ? a : o)
                .map(([t]) => {
                  return (
                    (e = t),
                    Array.isArray(e)
                      ? `(${e.map(Kt).join(', ')})`
                      : `(${Kt(e.type)}...)`
                  );
                  var e;
                })
                .join(' | '),
              r = [];
            for (let n = 1; n < t.length; n++) {
              const i = e.parse(t[n], 1 + r.length);
              if (!i) return null;
              r.push(Kt(i.type));
            }
            e.error(
              `Expected arguments of type ${i}, but found (${r.join(
                ', '
              )}) instead.`
            );
          }
          return null;
        }
        static register(t, e) {
          zr.definitions = e;
          for (const i in e) t[i] = zr;
        }
      }
      function kr(t, [e, i, r, n]) {
        (e = e.evaluate(t)), (i = i.evaluate(t)), (r = r.evaluate(t));
        const o = n ? n.evaluate(t) : 1,
          a = Ne(e, i, r, o);
        if (a) throw new Le(a);
        return new Ie(e / 255, i / 255, r / 255, o, !1);
      }
      function Dr(t, e) {
        return t in e;
      }
      function Rr(t, e) {
        const i = e[t];
        return void 0 === i ? null : i;
      }
      function Lr(t) {
        return { type: t };
      }
      function Fr(t) {
        if (t instanceof Qe) return Fr(t.boundExpression);
        if (t instanceof zr && 'error' === t.name) return !1;
        if (t instanceof Mi) return !1;
        if (t instanceof Hi) return !1;
        if (t instanceof Cr) return !1;
        if (t instanceof Ar) return !1;
        const e = t instanceof Ye || t instanceof qe;
        let i = !0;
        return (
          t.eachChild((t) => {
            i = e ? i && Fr(t) : i && t instanceof Ze;
          }),
          !!i &&
            Br(t) &&
            jr(t, [
              'zoom',
              'heatmap-density',
              'elevation',
              'line-progress',
              'accumulated',
              'is-supported-script',
            ])
        );
      }
      function Br(t) {
        if (t instanceof zr) {
          if ('get' === t.name && 1 === t.args.length) return !1;
          if ('feature-state' === t.name) return !1;
          if ('has' === t.name && 1 === t.args.length) return !1;
          if (
            'properties' === t.name ||
            'geometry-type' === t.name ||
            'id' === t.name
          )
            return !1;
          if (/^filter-/.test(t.name)) return !1;
        }
        if (t instanceof Hi) return !1;
        if (t instanceof Cr) return !1;
        let e = !0;
        return (
          t.eachChild((t) => {
            e && !Br(t) && (e = !1);
          }),
          e
        );
      }
      function Or(t) {
        if (t instanceof zr && 'feature-state' === t.name) return !1;
        let e = !0;
        return (
          t.eachChild((t) => {
            e && !Or(t) && (e = !1);
          }),
          e
        );
      }
      function jr(t, e) {
        if (t instanceof zr && e.indexOf(t.name) >= 0) return !1;
        let i = !0;
        return (
          t.eachChild((t) => {
            i && !jr(t, e) && (i = !1);
          }),
          i
        );
      }
      function Nr(t) {
        return { result: 'success', value: t };
      }
      function Vr(t) {
        return { result: 'error', value: t };
      }
      function Ur(t) {
        return (
          'data-driven' === t['property-type'] ||
          'cross-faded-data-driven' === t['property-type']
        );
      }
      function Gr(t) {
        return !!t.expression && t.expression.parameters.indexOf('zoom') > -1;
      }
      function Zr(t) {
        return !!t.expression && t.expression.interpolated;
      }
      function $r(t) {
        return t instanceof Number
          ? 'number'
          : t instanceof String
          ? 'string'
          : t instanceof Boolean
          ? 'boolean'
          : Array.isArray(t)
          ? 'array'
          : null === t
          ? 'null'
          : typeof t;
      }
      function qr(t) {
        return (
          'object' == typeof t &&
          null !== t &&
          !Array.isArray(t) &&
          Ue(t) === Vt
        );
      }
      function Wr(t) {
        return t;
      }
      function Yr(t, e) {
        const i = t.stops && 'object' == typeof t.stops[0][0],
          r = i || !(i || void 0 !== t.property),
          n = t.type || (Zr(e) ? 'exponential' : 'interval'),
          o = (function (t) {
            switch (t.type) {
              case 'color':
                return Ie.parse;
              case 'padding':
                return ke.parse;
              case 'numberArray':
                return De.parse;
              case 'colorArray':
                return Re.parse;
              default:
                return null;
            }
          })(e);
        if (
          (o &&
            ((t = kt({}, t)).stops &&
              (t.stops = t.stops.map((t) => [t[0], o(t[1])])),
            (t.default = o(t.default ? t.default : e.default))),
          t.colorSpace &&
            'rgb' !== (a = t.colorSpace) &&
            'hcl' !== a &&
            'lab' !== a)
        )
          throw new Error(`Unknown color space: "${t.colorSpace}"`);
        var a;
        const s = (function (t) {
          switch (t) {
            case 'exponential':
              return Jr;
            case 'interval':
              return Kr;
            case 'categorical':
              return Xr;
            case 'identity':
              return Qr;
            default:
              throw new Error(`Unknown function type "${t}"`);
          }
        })(n);
        let l, c;
        if ('categorical' === n) {
          l = Object.create(null);
          for (const e of t.stops) l[e[0]] = e[1];
          c = typeof t.stops[0][0];
        }
        if (i) {
          const i = {},
            r = [];
          for (let e = 0; e < t.stops.length; e++) {
            const n = t.stops[e],
              o = n[0].zoom;
            void 0 === i[o] &&
              ((i[o] = {
                zoom: o,
                type: t.type,
                property: t.property,
                default: t.default,
                stops: [],
              }),
              r.push(o)),
              i[o].stops.push([n[0].value, n[1]]);
          }
          const n = [];
          for (const t of r) n.push([i[t].zoom, Yr(i[t], e)]);
          const o = { name: 'linear' };
          return {
            kind: 'composite',
            interpolationType: o,
            interpolationFactor: pi.interpolationFactor.bind(void 0, o),
            zoomStops: n.map((t) => t[0]),
            evaluate: ({ zoom: i }, r) =>
              Jr({ stops: n, base: t.base }, e, i).evaluate(i, r),
          };
        }
        if (r) {
          const i =
            'exponential' === n
              ? { name: 'exponential', base: void 0 !== t.base ? t.base : 1 }
              : null;
          return {
            kind: 'camera',
            interpolationType: i,
            interpolationFactor: pi.interpolationFactor.bind(void 0, i),
            zoomStops: t.stops.map((t) => t[0]),
            evaluate: ({ zoom: i }) => s(t, e, i, l, c),
          };
        }
        return {
          kind: 'source',
          evaluate(i, r) {
            const n = r && r.properties ? r.properties[t.property] : void 0;
            return void 0 === n ? Hr(t.default, e.default) : s(t, e, n, l, c);
          },
        };
      }
      function Hr(t, e, i) {
        return void 0 !== t ? t : void 0 !== e ? e : void 0 !== i ? i : void 0;
      }
      function Xr(t, e, i, r, n) {
        return Hr(typeof i === n ? r[i] : void 0, t.default, e.default);
      }
      function Kr(t, e, i) {
        if ('number' !== $r(i)) return Hr(t.default, e.default);
        const r = t.stops.length;
        if (1 === r) return t.stops[0][1];
        if (i <= t.stops[0][0]) return t.stops[0][1];
        if (i >= t.stops[r - 1][0]) return t.stops[r - 1][1];
        const n = ai(
          t.stops.map((t) => t[0]),
          i
        );
        return t.stops[n][1];
      }
      function Jr(t, e, i) {
        const r = void 0 !== t.base ? t.base : 1;
        if ('number' !== $r(i)) return Hr(t.default, e.default);
        const n = t.stops.length;
        if (1 === n) return t.stops[0][1];
        if (i <= t.stops[0][0]) return t.stops[0][1];
        if (i >= t.stops[n - 1][0]) return t.stops[n - 1][1];
        const o = ai(
            t.stops.map((t) => t[0]),
            i
          ),
          a = (function (t, e, i, r) {
            const n = r - i,
              o = t - i;
            return 0 === n
              ? 0
              : 1 === e
              ? o / n
              : (Math.pow(e, o) - 1) / (Math.pow(e, n) - 1);
          })(i, r, t.stops[o][0], t.stops[o + 1][0]),
          s = t.stops[o][1],
          l = t.stops[o + 1][1],
          c = mi[e.type] || Wr;
        return 'function' == typeof s.evaluate
          ? {
              evaluate(...e) {
                const i = s.evaluate.apply(void 0, e),
                  r = l.evaluate.apply(void 0, e);
                if (void 0 !== i && void 0 !== r)
                  return c(i, r, a, t.colorSpace);
              },
            }
          : c(s, l, a, t.colorSpace);
      }
      function Qr(t, e, i) {
        switch (e.type) {
          case 'color':
            i = Ie.parse(i);
            break;
          case 'formatted':
            i = ze.fromString(i.toString());
            break;
          case 'resolvedImage':
            i = Oe.fromString(i.toString());
            break;
          case 'padding':
            i = ke.parse(i);
            break;
          case 'colorArray':
            i = Re.parse(i);
            break;
          case 'numberArray':
            i = De.parse(i);
            break;
          default:
            $r(i) === e.type ||
              ('enum' === e.type && e.values[i]) ||
              (i = void 0);
        }
        return Hr(i, t.default, e.default);
      }
      zr.register(Er, {
        'error': [
          { kind: 'error' },
          [Bt],
          (t, [e]) => {
            throw new Le(e.evaluate(t));
          },
        ],
        'typeof': [Bt, [Ut], (t, [e]) => Kt(Ue(e.evaluate(t)))],
        'to-rgba': [
          Xt(Ft, 4),
          [jt],
          (t, [e]) => {
            const [i, r, n, o] = e.evaluate(t).rgb;
            return [255 * i, 255 * r, 255 * n, o];
          },
        ],
        'rgb': [jt, [Ft, Ft, Ft], kr],
        'rgba': [jt, [Ft, Ft, Ft, Ft], kr],
        'has': {
          type: Ot,
          overloads: [
            [[Bt], (t, [e]) => Dr(e.evaluate(t), t.properties())],
            [[Bt, Vt], (t, [e, i]) => Dr(e.evaluate(t), i.evaluate(t))],
          ],
        },
        'get': {
          type: Ut,
          overloads: [
            [[Bt], (t, [e]) => Rr(e.evaluate(t), t.properties())],
            [[Bt, Vt], (t, [e, i]) => Rr(e.evaluate(t), i.evaluate(t))],
          ],
        },
        'feature-state': [
          Ut,
          [Bt],
          (t, [e]) => Rr(e.evaluate(t), t.featureState || {}),
        ],
        'properties': [Vt, [], (t) => t.properties()],
        'geometry-type': [Bt, [], (t) => t.geometryType()],
        'id': [Ut, [], (t) => t.id()],
        'zoom': [Ft, [], (t) => t.globals.zoom],
        'heatmap-density': [Ft, [], (t) => t.globals.heatmapDensity || 0],
        'elevation': [Ft, [], (t) => t.globals.elevation || 0],
        'line-progress': [Ft, [], (t) => t.globals.lineProgress || 0],
        'accumulated': [
          Ut,
          [],
          (t) =>
            void 0 === t.globals.accumulated ? null : t.globals.accumulated,
        ],
        '+': [
          Ft,
          Lr(Ft),
          (t, e) => {
            let i = 0;
            for (const r of e) i += r.evaluate(t);
            return i;
          },
        ],
        '*': [
          Ft,
          Lr(Ft),
          (t, e) => {
            let i = 1;
            for (const r of e) i *= r.evaluate(t);
            return i;
          },
        ],
        '-': {
          type: Ft,
          overloads: [
            [[Ft, Ft], (t, [e, i]) => e.evaluate(t) - i.evaluate(t)],
            [[Ft], (t, [e]) => -e.evaluate(t)],
          ],
        },
        '/': [Ft, [Ft, Ft], (t, [e, i]) => e.evaluate(t) / i.evaluate(t)],
        '%': [Ft, [Ft, Ft], (t, [e, i]) => e.evaluate(t) % i.evaluate(t)],
        'ln2': [Ft, [], () => Math.LN2],
        'pi': [Ft, [], () => Math.PI],
        'e': [Ft, [], () => Math.E],
        '^': [
          Ft,
          [Ft, Ft],
          (t, [e, i]) => Math.pow(e.evaluate(t), i.evaluate(t)),
        ],
        'sqrt': [Ft, [Ft], (t, [e]) => Math.sqrt(e.evaluate(t))],
        'log10': [Ft, [Ft], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
        'ln': [Ft, [Ft], (t, [e]) => Math.log(e.evaluate(t))],
        'log2': [Ft, [Ft], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
        'sin': [Ft, [Ft], (t, [e]) => Math.sin(e.evaluate(t))],
        'cos': [Ft, [Ft], (t, [e]) => Math.cos(e.evaluate(t))],
        'tan': [Ft, [Ft], (t, [e]) => Math.tan(e.evaluate(t))],
        'asin': [Ft, [Ft], (t, [e]) => Math.asin(e.evaluate(t))],
        'acos': [Ft, [Ft], (t, [e]) => Math.acos(e.evaluate(t))],
        'atan': [Ft, [Ft], (t, [e]) => Math.atan(e.evaluate(t))],
        'min': [Ft, Lr(Ft), (t, e) => Math.min(...e.map((e) => e.evaluate(t)))],
        'max': [Ft, Lr(Ft), (t, e) => Math.max(...e.map((e) => e.evaluate(t)))],
        'abs': [Ft, [Ft], (t, [e]) => Math.abs(e.evaluate(t))],
        'round': [
          Ft,
          [Ft],
          (t, [e]) => {
            const i = e.evaluate(t);
            return i < 0 ? -Math.round(-i) : Math.round(i);
          },
        ],
        'floor': [Ft, [Ft], (t, [e]) => Math.floor(e.evaluate(t))],
        'ceil': [Ft, [Ft], (t, [e]) => Math.ceil(e.evaluate(t))],
        'filter-==': [
          Ot,
          [Bt, Ut],
          (t, [e, i]) => t.properties()[e.value] === i.value,
        ],
        'filter-id-==': [Ot, [Ut], (t, [e]) => t.id() === e.value],
        'filter-type-==': [Ot, [Bt], (t, [e]) => t.geometryType() === e.value],
        'filter-<': [
          Ot,
          [Bt, Ut],
          (t, [e, i]) => {
            const r = t.properties()[e.value],
              n = i.value;
            return typeof r == typeof n && r < n;
          },
        ],
        'filter-id-<': [
          Ot,
          [Ut],
          (t, [e]) => {
            const i = t.id(),
              r = e.value;
            return typeof i == typeof r && i < r;
          },
        ],
        'filter->': [
          Ot,
          [Bt, Ut],
          (t, [e, i]) => {
            const r = t.properties()[e.value],
              n = i.value;
            return typeof r == typeof n && r > n;
          },
        ],
        'filter-id->': [
          Ot,
          [Ut],
          (t, [e]) => {
            const i = t.id(),
              r = e.value;
            return typeof i == typeof r && i > r;
          },
        ],
        'filter-<=': [
          Ot,
          [Bt, Ut],
          (t, [e, i]) => {
            const r = t.properties()[e.value],
              n = i.value;
            return typeof r == typeof n && r <= n;
          },
        ],
        'filter-id-<=': [
          Ot,
          [Ut],
          (t, [e]) => {
            const i = t.id(),
              r = e.value;
            return typeof i == typeof r && i <= r;
          },
        ],
        'filter->=': [
          Ot,
          [Bt, Ut],
          (t, [e, i]) => {
            const r = t.properties()[e.value],
              n = i.value;
            return typeof r == typeof n && r >= n;
          },
        ],
        'filter-id->=': [
          Ot,
          [Ut],
          (t, [e]) => {
            const i = t.id(),
              r = e.value;
            return typeof i == typeof r && i >= r;
          },
        ],
        'filter-has': [Ot, [Ut], (t, [e]) => e.value in t.properties()],
        'filter-has-id': [Ot, [], (t) => null !== t.id() && void 0 !== t.id()],
        'filter-type-in': [
          Ot,
          [Xt(Bt)],
          (t, [e]) => e.value.indexOf(t.geometryType()) >= 0,
        ],
        'filter-id-in': [
          Ot,
          [Xt(Ut)],
          (t, [e]) => e.value.indexOf(t.id()) >= 0,
        ],
        'filter-in-small': [
          Ot,
          [Bt, Xt(Ut)],
          (t, [e, i]) => i.value.indexOf(t.properties()[e.value]) >= 0,
        ],
        'filter-in-large': [
          Ot,
          [Bt, Xt(Ut)],
          (t, [e, i]) =>
            (function (t, e, i, r) {
              for (; i <= r; ) {
                const n = (i + r) >> 1;
                if (e[n] === t) return !0;
                e[n] > t ? (r = n - 1) : (i = n + 1);
              }
              return !1;
            })(t.properties()[e.value], i.value, 0, i.value.length - 1),
        ],
        'all': {
          type: Ot,
          overloads: [
            [[Ot, Ot], (t, [e, i]) => e.evaluate(t) && i.evaluate(t)],
            [
              Lr(Ot),
              (t, e) => {
                for (const i of e) if (!i.evaluate(t)) return !1;
                return !0;
              },
            ],
          ],
        },
        'any': {
          type: Ot,
          overloads: [
            [[Ot, Ot], (t, [e, i]) => e.evaluate(t) || i.evaluate(t)],
            [
              Lr(Ot),
              (t, e) => {
                for (const i of e) if (i.evaluate(t)) return !0;
                return !1;
              },
            ],
          ],
        },
        '!': [Ot, [Ot], (t, [e]) => !e.evaluate(t)],
        'is-supported-script': [
          Ot,
          [Bt],
          (t, [e]) => {
            const i = t.globals && t.globals.isSupportedScript;
            return !i || i(e.evaluate(t));
          },
        ],
        'upcase': [Bt, [Bt], (t, [e]) => e.evaluate(t).toUpperCase()],
        'downcase': [Bt, [Bt], (t, [e]) => e.evaluate(t).toLowerCase()],
        'concat': [
          Bt,
          Lr(Ut),
          (t, e) => e.map((e) => Ge(e.evaluate(t))).join(''),
        ],
        'resolved-locale': [
          Bt,
          [Gt],
          (t, [e]) => e.evaluate(t).resolvedLocale(),
        ],
      });
      class tn {
        constructor(t, e, i) {
          (this.expression = t),
            (this._warningHistory = {}),
            (this._evaluator = new Xe()),
            (this._defaultValue = e
              ? (function (t) {
                  if ('color' === t.type && qr(t.default))
                    return new Ie(0, 0, 0, 0);
                  switch (t.type) {
                    case 'color':
                      return Ie.parse(t.default) || null;
                    case 'padding':
                      return ke.parse(t.default) || null;
                    case 'numberArray':
                      return De.parse(t.default) || null;
                    case 'colorArray':
                      return Re.parse(t.default) || null;
                    case 'variableAnchorOffsetCollection':
                      return Be.parse(t.default) || null;
                    case 'projectionDefinition':
                      return je.parse(t.default) || null;
                    default:
                      return void 0 === t.default ? null : t.default;
                  }
                })(e)
              : null),
            (this._enumValues = e && 'enum' === e.type ? e.values : null),
            (this._globalState = i);
        }
        evaluateWithoutErrorHandling(t, e, i, r, n, o) {
          return (
            this._globalState && (t = hn(t, this._globalState)),
            (this._evaluator.globals = t),
            (this._evaluator.feature = e),
            (this._evaluator.featureState = i),
            (this._evaluator.canonical = r),
            (this._evaluator.availableImages = n || null),
            (this._evaluator.formattedSection = o),
            this.expression.evaluate(this._evaluator)
          );
        }
        evaluate(t, e, i, r, n, o) {
          this._globalState && (t = hn(t, this._globalState)),
            (this._evaluator.globals = t),
            (this._evaluator.feature = e || null),
            (this._evaluator.featureState = i || null),
            (this._evaluator.canonical = r),
            (this._evaluator.availableImages = n || null),
            (this._evaluator.formattedSection = o || null);
          try {
            const t = this.expression.evaluate(this._evaluator);
            if (null == t || ('number' == typeof t && t != t))
              return this._defaultValue;
            if (this._enumValues && !(t in this._enumValues))
              throw new Le(
                `Expected value to be one of ${Object.keys(this._enumValues)
                  .map((t) => JSON.stringify(t))
                  .join(', ')}, but found ${JSON.stringify(t)} instead.`
              );
            return t;
          } catch (t) {
            return (
              this._warningHistory[t.message] ||
                ((this._warningHistory[t.message] = !0),
                'undefined' != typeof console && console.warn(t.message)),
              this._defaultValue
            );
          }
        }
      }
      function en(t) {
        return (
          Array.isArray(t) &&
          t.length > 0 &&
          'string' == typeof t[0] &&
          t[0] in Er
        );
      }
      function rn(t, e, i) {
        const r = new Ke(
            Er,
            Fr,
            [],
            e
              ? (function (t) {
                  const e = {
                    color: jt,
                    string: Bt,
                    number: Ft,
                    enum: Bt,
                    boolean: Ot,
                    formatted: Zt,
                    padding: $t,
                    numberArray: Wt,
                    colorArray: qt,
                    projectionDefinition: Nt,
                    resolvedImage: Yt,
                    variableAnchorOffsetCollection: Ht,
                  };
                  return 'array' === t.type
                    ? Xt(e[t.value] || Ut, t.length)
                    : e[t.type];
                })(e)
              : void 0
          ),
          n = r.parse(
            t,
            void 0,
            void 0,
            void 0,
            e && 'string' === e.type ? { typeAnnotation: 'coerce' } : void 0
          );
        return n ? Nr(new tn(n, e, i)) : Vr(r.errors);
      }
      class nn {
        constructor(t, e, i) {
          (this.kind = t),
            (this._styleExpression = e),
            (this.isStateDependent = 'constant' !== t && !Or(e.expression)),
            (this.globalStateRefs = cn(e.expression)),
            (this._globalState = i);
        }
        evaluateWithoutErrorHandling(t, e, i, r, n, o) {
          return (
            this._globalState && (t = hn(t, this._globalState)),
            this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, o)
          );
        }
        evaluate(t, e, i, r, n, o) {
          return (
            this._globalState && (t = hn(t, this._globalState)),
            this._styleExpression.evaluate(t, e, i, r, n, o)
          );
        }
      }
      class on {
        constructor(t, e, i, r, n) {
          (this.kind = t),
            (this.zoomStops = i),
            (this._styleExpression = e),
            (this.isStateDependent = 'camera' !== t && !Or(e.expression)),
            (this.globalStateRefs = cn(e.expression)),
            (this.interpolationType = r),
            (this._globalState = n);
        }
        evaluateWithoutErrorHandling(t, e, i, r, n, o) {
          return (
            this._globalState && (t = hn(t, this._globalState)),
            this._styleExpression.evaluateWithoutErrorHandling(t, e, i, r, n, o)
          );
        }
        evaluate(t, e, i, r, n, o) {
          return (
            this._globalState && (t = hn(t, this._globalState)),
            this._styleExpression.evaluate(t, e, i, r, n, o)
          );
        }
        interpolationFactor(t, e, i) {
          return this.interpolationType
            ? pi.interpolationFactor(this.interpolationType, t, e, i)
            : 0;
        }
      }
      function an(t, e, i) {
        const r = rn(t, e, i);
        if ('error' === r.result) return r;
        const n = r.value.expression,
          o = Br(n);
        if (!o && !Ur(e))
          return Vr([new Dt('', 'data expressions not supported')]);
        const a = jr(n, ['zoom']);
        if (!a && !Gr(e))
          return Vr([new Dt('', 'zoom expressions not supported')]);
        const s = ln(n);
        return s || a
          ? s instanceof Dt
            ? Vr([s])
            : s instanceof pi && !Zr(e)
            ? Vr([
                new Dt(
                  '',
                  '"interpolate" expressions cannot be used with this property'
                ),
              ])
            : Nr(
                s
                  ? new on(
                      o ? 'camera' : 'composite',
                      r.value,
                      s.labels,
                      s instanceof pi ? s.interpolation : void 0,
                      i
                    )
                  : new nn(o ? 'constant' : 'source', r.value, i)
              )
          : Vr([
              new Dt(
                '',
                '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
              ),
            ]);
      }
      class sn {
        constructor(t, e) {
          (this._parameters = t),
            (this._specification = e),
            kt(this, Yr(this._parameters, this._specification));
        }
        static deserialize(t) {
          return new sn(t._parameters, t._specification);
        }
        static serialize(t) {
          return {
            _parameters: t._parameters,
            _specification: t._specification,
          };
        }
      }
      function ln(t) {
        let e = null;
        if (t instanceof Je) e = ln(t.result);
        else if (t instanceof _i) {
          for (const i of t.args) if (((e = ln(i)), e)) break;
        } else
          (t instanceof si || t instanceof pi) &&
            t.input instanceof zr &&
            'zoom' === t.input.name &&
            (e = t);
        return (
          e instanceof Dt ||
            t.eachChild((t) => {
              const i = ln(t);
              i instanceof Dt
                ? (e = i)
                : !e && i
                ? (e = new Dt(
                    '',
                    '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                  ))
                : e &&
                  i &&
                  e !== i &&
                  (e = new Dt(
                    '',
                    'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                  ));
            }),
          e
        );
      }
      function cn(t, e = new Set()) {
        return (
          t instanceof Ar && e.add(t.key),
          t.eachChild((t) => {
            cn(t, e);
          }),
          e
        );
      }
      function hn(t, e) {
        const {
          zoom: i,
          heatmapDensity: r,
          elevation: n,
          lineProgress: o,
          isSupportedScript: a,
          accumulated: s,
        } = null != t ? t : {};
        return {
          zoom: i,
          heatmapDensity: r,
          elevation: n,
          lineProgress: o,
          isSupportedScript: a,
          accumulated: s,
          globalState: e,
        };
      }
      function un(t) {
        if (!0 === t || !1 === t) return !0;
        if (!Array.isArray(t) || 0 === t.length) return !1;
        switch (t[0]) {
          case 'has':
            return t.length >= 2 && '$id' !== t[1] && '$type' !== t[1];
          case 'in':
            return (
              t.length >= 3 && ('string' != typeof t[1] || Array.isArray(t[2]))
            );
          case '!in':
          case '!has':
          case 'none':
            return !1;
          case '==':
          case '!=':
          case '>':
          case '>=':
          case '<':
          case '<=':
            return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
          case 'any':
          case 'all':
            for (const e of t.slice(1))
              if (!un(e) && 'boolean' != typeof e) return !1;
            return !0;
          default:
            return !0;
        }
      }
      const dn = {
        'type': 'boolean',
        'default': !1,
        'transition': !1,
        'property-type': 'data-driven',
        'expression': { interpolated: !1, parameters: ['zoom', 'feature'] },
      };
      function pn(t, e) {
        if (null == t)
          return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set(),
          };
        un(t) || (t = _n(t));
        const i = rn(t, dn, e);
        if ('error' === i.result)
          throw new Error(
            i.value.map((t) => `${t.key}: ${t.message}`).join(', ')
          );
        return {
          filter: (t, e, r) => i.value.evaluate(t, e, {}, r),
          needGeometry: mn(t),
          getGlobalStateRefs: () => cn(i.value.expression),
        };
      }
      function fn(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
      function mn(t) {
        if (!Array.isArray(t)) return !1;
        if ('within' === t[0] || 'distance' === t[0]) return !0;
        for (let e = 1; e < t.length; e++) if (mn(t[e])) return !0;
        return !1;
      }
      function _n(t) {
        if (!t) return !0;
        const e = t[0];
        return t.length <= 1
          ? 'any' !== e
          : '==' === e
          ? gn(t[1], t[2], '==')
          : '!=' === e
          ? vn(gn(t[1], t[2], '=='))
          : '<' === e || '>' === e || '<=' === e || '>=' === e
          ? gn(t[1], t[2], e)
          : 'any' === e
          ? ((i = t.slice(1)), ['any'].concat(i.map(_n)))
          : 'all' === e
          ? ['all'].concat(t.slice(1).map(_n))
          : 'none' === e
          ? ['all'].concat(t.slice(1).map(_n).map(vn))
          : 'in' === e
          ? yn(t[1], t.slice(2))
          : '!in' === e
          ? vn(yn(t[1], t.slice(2)))
          : 'has' === e
          ? xn(t[1])
          : '!has' !== e || vn(xn(t[1]));
        var i;
      }
      function gn(t, e, i) {
        switch (t) {
          case '$type':
            return [`filter-type-${i}`, e];
          case '$id':
            return [`filter-id-${i}`, e];
          default:
            return [`filter-${i}`, t, e];
        }
      }
      function yn(t, e) {
        if (0 === e.length) return !1;
        switch (t) {
          case '$type':
            return ['filter-type-in', ['literal', e]];
          case '$id':
            return ['filter-id-in', ['literal', e]];
          default:
            return e.length > 200 && !e.some((t) => typeof t != typeof e[0])
              ? ['filter-in-large', t, ['literal', e.sort(fn)]]
              : ['filter-in-small', t, ['literal', e]];
        }
      }
      function xn(t) {
        switch (t) {
          case '$type':
            return !0;
          case '$id':
            return ['filter-has-id'];
          default:
            return ['filter-has', t];
        }
      }
      function vn(t) {
        return ['!', t];
      }
      function bn(t) {
        const e = typeof t;
        if ('number' === e || 'boolean' === e || 'string' === e || null == t)
          return JSON.stringify(t);
        if (Array.isArray(t)) {
          let e = '[';
          for (const i of t) e += `${bn(i)},`;
          return `${e}]`;
        }
        const i = Object.keys(t).sort();
        let r = '{';
        for (let n = 0; n < i.length; n++)
          r += `${JSON.stringify(i[n])}:${bn(t[i[n]])},`;
        return `${r}}`;
      }
      function wn(t) {
        let e = '';
        for (const i of vt) e += `/${bn(t[i])}`;
        return e;
      }
      function Tn(t) {
        const e = t.value;
        return e
          ? [new zt(t.key, e, 'constants have been deprecated as of v8')]
          : [];
      }
      function Pn(t) {
        return t instanceof Number ||
          t instanceof String ||
          t instanceof Boolean
          ? t.valueOf()
          : t;
      }
      function Sn(t) {
        if (Array.isArray(t)) return t.map(Sn);
        if (
          t instanceof Object &&
          !(t instanceof Number || t instanceof String || t instanceof Boolean)
        ) {
          const e = {};
          for (const i in t) e[i] = Sn(t[i]);
          return e;
        }
        return Pn(t);
      }
      function Mn(t) {
        const e = t.key,
          i = t.value,
          r = t.valueSpec || {},
          n = t.objectElementValidators || {},
          o = t.style,
          a = t.styleSpec,
          s = t.validateSpec;
        let l = [];
        const c = $r(i);
        if ('object' !== c)
          return [new zt(e, i, `object expected, ${c} found`)];
        for (const h in i) {
          const t = h.split('.')[0],
            c = xe(r, t) || r['*'];
          let u;
          if (xe(n, t)) u = n[t];
          else if (xe(r, t)) u = s;
          else if (n['*']) u = n['*'];
          else {
            if (!r['*']) {
              l.push(new zt(e, i[h], `unknown property "${h}"`));
              continue;
            }
            u = s;
          }
          l = l.concat(
            u(
              {
                key: (e ? `${e}.` : e) + h,
                value: i[h],
                valueSpec: c,
                style: o,
                styleSpec: a,
                object: i,
                objectKey: h,
                validateSpec: s,
              },
              i
            )
          );
        }
        for (const h in r)
          n[h] ||
            (r[h].required &&
              void 0 === r[h].default &&
              void 0 === i[h] &&
              l.push(new zt(e, i, `missing required property "${h}"`)));
        return l;
      }
      function In(t) {
        const e = t.value,
          i = t.valueSpec,
          r = t.style,
          n = t.styleSpec,
          o = t.key,
          a = t.arrayElementValidator || t.validateSpec;
        if ('array' !== $r(e))
          return [new zt(o, e, `array expected, ${$r(e)} found`)];
        if (i.length && e.length !== i.length)
          return [
            new zt(
              o,
              e,
              `array length ${i.length} expected, length ${e.length} found`
            ),
          ];
        if (i['min-length'] && e.length < i['min-length'])
          return [
            new zt(
              o,
              e,
              `array length at least ${i['min-length']} expected, length ${e.length} found`
            ),
          ];
        let s = { type: i.value, values: i.values };
        n.$version < 7 && (s.function = i.function),
          'object' === $r(i.value) && (s = i.value);
        let l = [];
        for (let c = 0; c < e.length; c++)
          l = l.concat(
            a({
              array: e,
              arrayIndex: c,
              value: e[c],
              valueSpec: s,
              validateSpec: t.validateSpec,
              style: r,
              styleSpec: n,
              key: `${o}[${c}]`,
            })
          );
        return l;
      }
      function Cn(t) {
        const e = t.key,
          i = t.value,
          r = t.valueSpec;
        let n = $r(i);
        return (
          'number' === n && i != i && (n = 'NaN'),
          'number' !== n
            ? [new zt(e, i, `number expected, ${n} found`)]
            : 'minimum' in r && i < r.minimum
            ? [new zt(e, i, `${i} is less than the minimum value ${r.minimum}`)]
            : 'maximum' in r && i > r.maximum
            ? [
                new zt(
                  e,
                  i,
                  `${i} is greater than the maximum value ${r.maximum}`
                ),
              ]
            : []
        );
      }
      function An(t) {
        const e = t.valueSpec,
          i = Pn(t.value.type);
        let r,
          n,
          o,
          a = {};
        const s = 'categorical' !== i && void 0 === t.value.property,
          l = !s,
          c =
            'array' === $r(t.value.stops) &&
            'array' === $r(t.value.stops[0]) &&
            'object' === $r(t.value.stops[0][0]),
          h = Mn({
            key: t.key,
            value: t.value,
            valueSpec: t.styleSpec.function,
            validateSpec: t.validateSpec,
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              stops: function (t) {
                if ('identity' === i)
                  return [
                    new zt(
                      t.key,
                      t.value,
                      'identity function may not have a "stops" property'
                    ),
                  ];
                let e = [];
                const r = t.value;
                return (
                  (e = e.concat(
                    In({
                      key: t.key,
                      value: r,
                      valueSpec: t.valueSpec,
                      validateSpec: t.validateSpec,
                      style: t.style,
                      styleSpec: t.styleSpec,
                      arrayElementValidator: u,
                    })
                  )),
                  'array' === $r(r) &&
                    0 === r.length &&
                    e.push(
                      new zt(t.key, r, 'array must have at least one stop')
                    ),
                  e
                );
              },
              default: function (t) {
                return t.validateSpec({
                  key: t.key,
                  value: t.value,
                  valueSpec: e,
                  validateSpec: t.validateSpec,
                  style: t.style,
                  styleSpec: t.styleSpec,
                });
              },
            },
          });
        return (
          'identity' === i &&
            s &&
            h.push(
              new zt(t.key, t.value, 'missing required property "property"')
            ),
          'identity' === i ||
            t.value.stops ||
            h.push(new zt(t.key, t.value, 'missing required property "stops"')),
          'exponential' === i &&
            t.valueSpec.expression &&
            !Zr(t.valueSpec) &&
            h.push(
              new zt(t.key, t.value, 'exponential functions not supported')
            ),
          t.styleSpec.$version >= 8 &&
            (l && !Ur(t.valueSpec)
              ? h.push(
                  new zt(t.key, t.value, 'property functions not supported')
                )
              : s &&
                !Gr(t.valueSpec) &&
                h.push(new zt(t.key, t.value, 'zoom functions not supported'))),
          ('categorical' !== i && !c) ||
            void 0 !== t.value.property ||
            h.push(new zt(t.key, t.value, '"property" property is required')),
          h
        );
        function u(t) {
          let i = [];
          const r = t.value,
            s = t.key;
          if ('array' !== $r(r))
            return [new zt(s, r, `array expected, ${$r(r)} found`)];
          if (2 !== r.length)
            return [
              new zt(s, r, `array length 2 expected, length ${r.length} found`),
            ];
          if (c) {
            if ('object' !== $r(r[0]))
              return [new zt(s, r, `object expected, ${$r(r[0])} found`)];
            if (void 0 === r[0].zoom)
              return [new zt(s, r, 'object stop key must have zoom')];
            if (void 0 === r[0].value)
              return [new zt(s, r, 'object stop key must have value')];
            if (o && o > Pn(r[0].zoom))
              return [
                new zt(
                  s,
                  r[0].zoom,
                  'stop zoom values must appear in ascending order'
                ),
              ];
            Pn(r[0].zoom) !== o &&
              ((o = Pn(r[0].zoom)), (n = void 0), (a = {})),
              (i = i.concat(
                Mn({
                  key: `${s}[0]`,
                  value: r[0],
                  valueSpec: { zoom: {} },
                  validateSpec: t.validateSpec,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  objectElementValidators: { zoom: Cn, value: d },
                })
              ));
          } else i = i.concat(d({ key: `${s}[0]`, value: r[0], validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec }, r));
          return en(Sn(r[1]))
            ? i.concat([
                new zt(
                  `${s}[1]`,
                  r[1],
                  'expressions are not allowed in function stops.'
                ),
              ])
            : i.concat(
                t.validateSpec({
                  key: `${s}[1]`,
                  value: r[1],
                  valueSpec: e,
                  validateSpec: t.validateSpec,
                  style: t.style,
                  styleSpec: t.styleSpec,
                })
              );
        }
        function d(t, o) {
          const s = $r(t.value),
            l = Pn(t.value),
            c = null !== t.value ? t.value : o;
          if (r) {
            if (s !== r)
              return [
                new zt(
                  t.key,
                  c,
                  `${s} stop domain type must match previous stop domain type ${r}`
                ),
              ];
          } else r = s;
          if ('number' !== s && 'string' !== s && 'boolean' !== s)
            return [
              new zt(
                t.key,
                c,
                'stop domain value must be a number, string, or boolean'
              ),
            ];
          if ('number' !== s && 'categorical' !== i) {
            let r = `number expected, ${s} found`;
            return (
              Ur(e) &&
                void 0 === i &&
                (r +=
                  '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
              [new zt(t.key, c, r)]
            );
          }
          return 'categorical' !== i ||
            'number' !== s ||
            (isFinite(l) && Math.floor(l) === l)
            ? 'categorical' !== i && 'number' === s && void 0 !== n && l < n
              ? [
                  new zt(
                    t.key,
                    c,
                    'stop domain values must appear in ascending order'
                  ),
                ]
              : ((n = l),
                'categorical' === i && l in a
                  ? [new zt(t.key, c, 'stop domain values must be unique')]
                  : ((a[l] = !0), []))
            : [new zt(t.key, c, `integer expected, found ${l}`)];
        }
      }
      function En(t) {
        const e = ('property' === t.expressionContext ? an : rn)(
          Sn(t.value),
          t.valueSpec
        );
        if ('error' === e.result)
          return e.value.map(
            (e) => new zt(`${t.key}${e.key}`, t.value, e.message)
          );
        const i = e.value.expression || e.value._styleExpression.expression;
        if (
          'property' === t.expressionContext &&
          'text-font' === t.propertyKey &&
          !i.outputDefined()
        )
          return [
            new zt(
              t.key,
              t.value,
              `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`
            ),
          ];
        if (
          'property' === t.expressionContext &&
          'layout' === t.propertyType &&
          !Or(i)
        )
          return [
            new zt(
              t.key,
              t.value,
              '"feature-state" data expressions are not supported with layout properties.'
            ),
          ];
        if ('filter' === t.expressionContext && !Or(i))
          return [
            new zt(
              t.key,
              t.value,
              '"feature-state" data expressions are not supported with filters.'
            ),
          ];
        if (
          t.expressionContext &&
          0 === t.expressionContext.indexOf('cluster')
        ) {
          if (!jr(i, ['zoom', 'feature-state']))
            return [
              new zt(
                t.key,
                t.value,
                '"zoom" and "feature-state" expressions are not supported with cluster properties.'
              ),
            ];
          if ('cluster-initial' === t.expressionContext && !Br(i))
            return [
              new zt(
                t.key,
                t.value,
                'Feature data expressions are not supported with initial expression part of cluster properties.'
              ),
            ];
        }
        return [];
      }
      function zn(t) {
        const e = t.key,
          i = t.value,
          r = $r(i);
        return 'string' !== r
          ? [new zt(e, i, `color expected, ${r} found`)]
          : Ie.parse(String(i))
          ? []
          : [new zt(e, i, `color expected, "${i}" found`)];
      }
      function kn(t) {
        const e = t.key,
          i = t.value,
          r = t.valueSpec,
          n = [];
        return (
          Array.isArray(r.values)
            ? -1 === r.values.indexOf(Pn(i)) &&
              n.push(
                new zt(
                  e,
                  i,
                  `expected one of [${r.values.join(', ')}], ${JSON.stringify(
                    i
                  )} found`
                )
              )
            : -1 === Object.keys(r.values).indexOf(Pn(i)) &&
              n.push(
                new zt(
                  e,
                  i,
                  `expected one of [${Object.keys(r.values).join(
                    ', '
                  )}], ${JSON.stringify(i)} found`
                )
              ),
          n
        );
      }
      function Dn(t) {
        return un(Sn(t.value))
          ? En(
              kt({}, t, {
                expressionContext: 'filter',
                valueSpec: { value: 'boolean' },
              })
            )
          : Rn(t);
      }
      function Rn(t) {
        const e = t.value,
          i = t.key;
        if ('array' !== $r(e))
          return [new zt(i, e, `array expected, ${$r(e)} found`)];
        const r = t.styleSpec;
        let n,
          o = [];
        if (e.length < 1)
          return [new zt(i, e, 'filter array must have at least 1 element')];
        switch (
          ((o = o.concat(
            kn({
              key: `${i}[0]`,
              value: e[0],
              valueSpec: r.filter_operator,
              style: t.style,
              styleSpec: t.styleSpec,
            })
          )),
          Pn(e[0]))
        ) {
          case '<':
          case '<=':
          case '>':
          case '>=':
            e.length >= 2 &&
              '$type' === Pn(e[1]) &&
              o.push(
                new zt(i, e, `"$type" cannot be use with operator "${e[0]}"`)
              );
          case '==':
          case '!=':
            3 !== e.length &&
              o.push(
                new zt(
                  i,
                  e,
                  `filter array for operator "${e[0]}" must have 3 elements`
                )
              );
          case 'in':
          case '!in':
            e.length >= 2 &&
              ((n = $r(e[1])),
              'string' !== n &&
                o.push(new zt(`${i}[1]`, e[1], `string expected, ${n} found`)));
            for (let a = 2; a < e.length; a++)
              (n = $r(e[a])),
                '$type' === Pn(e[1])
                  ? (o = o.concat(
                      kn({
                        key: `${i}[${a}]`,
                        value: e[a],
                        valueSpec: r.geometry_type,
                        style: t.style,
                        styleSpec: t.styleSpec,
                      })
                    ))
                  : 'string' !== n &&
                    'number' !== n &&
                    'boolean' !== n &&
                    o.push(
                      new zt(
                        `${i}[${a}]`,
                        e[a],
                        `string, number, or boolean expected, ${n} found`
                      )
                    );
            break;
          case 'any':
          case 'all':
          case 'none':
            for (let r = 1; r < e.length; r++)
              o = o.concat(
                Rn({
                  key: `${i}[${r}]`,
                  value: e[r],
                  style: t.style,
                  styleSpec: t.styleSpec,
                })
              );
            break;
          case 'has':
          case '!has':
            (n = $r(e[1])),
              2 !== e.length
                ? o.push(
                    new zt(
                      i,
                      e,
                      `filter array for "${e[0]}" operator must have 2 elements`
                    )
                  )
                : 'string' !== n &&
                  o.push(
                    new zt(`${i}[1]`, e[1], `string expected, ${n} found`)
                  );
        }
        return o;
      }
      function Ln(t, e) {
        const i = t.key,
          r = t.validateSpec,
          n = t.style,
          o = t.styleSpec,
          a = t.value,
          s = t.objectKey,
          l = o[`${e}_${t.layerType}`];
        if (!l) return [];
        const c = s.match(/^(.*)-transition$/);
        if ('paint' === e && c && l[c[1]] && l[c[1]].transition)
          return r({
            key: i,
            value: a,
            valueSpec: o.transition,
            style: n,
            styleSpec: o,
          });
        const h = t.valueSpec || l[s];
        if (!h) return [new zt(i, a, `unknown property "${s}"`)];
        let u;
        if (
          'string' === $r(a) &&
          Ur(h) &&
          !h.tokens &&
          (u = /^{([^}]+)}$/.exec(a))
        )
          return [
            new zt(
              i,
              a,
              `"${s}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
                u[1]
              )} }\`.`
            ),
          ];
        const d = [];
        return (
          'symbol' === t.layerType &&
            'text-font' === s &&
            qr(Sn(a)) &&
            'identity' === Pn(a.type) &&
            d.push(
              new zt(i, a, '"text-font" does not support identity functions')
            ),
          d.concat(
            r({
              key: t.key,
              value: a,
              valueSpec: h,
              style: n,
              styleSpec: o,
              expressionContext: 'property',
              propertyType: e,
              propertyKey: s,
            })
          )
        );
      }
      function Fn(t) {
        return Ln(t, 'paint');
      }
      function Bn(t) {
        return Ln(t, 'layout');
      }
      function On(t) {
        let e = [];
        const i = t.value,
          r = t.key,
          n = t.style,
          o = t.styleSpec;
        if ('object' !== $r(i))
          return [new zt(r, i, `object expected, ${$r(i)} found`)];
        i.type ||
          i.ref ||
          e.push(new zt(r, i, 'either "type" or "ref" is required'));
        let a = Pn(i.type);
        const s = Pn(i.ref);
        if (i.id) {
          const o = Pn(i.id);
          for (let a = 0; a < t.arrayIndex; a++) {
            const t = n.layers[a];
            Pn(t.id) === o &&
              e.push(
                new zt(
                  r,
                  i.id,
                  `duplicate layer id "${i.id}", previously used at line ${t.id.__line__}`
                )
              );
          }
        }
        if ('ref' in i) {
          let t;
          ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(
            (t) => {
              t in i &&
                e.push(new zt(r, i[t], `"${t}" is prohibited for ref layers`));
            }
          ),
            n.layers.forEach((e) => {
              Pn(e.id) === s && (t = e);
            }),
            t
              ? t.ref
                ? e.push(
                    new zt(r, i.ref, 'ref cannot reference another ref layer')
                  )
                : (a = Pn(t.type))
              : e.push(new zt(r, i.ref, `ref layer "${s}" not found`));
        } else if ('background' !== a)
          if (i.source) {
            const t = n.sources && n.sources[i.source],
              o = t && Pn(t.type);
            t
              ? 'vector' === o && 'raster' === a
                ? e.push(
                    new zt(
                      r,
                      i.source,
                      `layer "${i.id}" requires a raster source`
                    )
                  )
                : ('raster-dem' !== o && 'hillshade' === a) ||
                  ('raster-dem' !== o && 'color-relief' === a)
                ? e.push(
                    new zt(
                      r,
                      i.source,
                      `layer "${i.id}" requires a raster-dem source`
                    )
                  )
                : 'raster' === o && 'raster' !== a
                ? e.push(
                    new zt(
                      r,
                      i.source,
                      `layer "${i.id}" requires a vector source`
                    )
                  )
                : 'vector' !== o || i['source-layer']
                ? 'raster-dem' === o &&
                  'hillshade' !== a &&
                  'color-relief' !== a
                  ? e.push(
                      new zt(
                        r,
                        i.source,
                        "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'."
                      )
                    )
                  : 'line' !== a ||
                    !i.paint ||
                    !i.paint['line-gradient'] ||
                    ('geojson' === o && t.lineMetrics) ||
                    e.push(
                      new zt(
                        r,
                        i,
                        `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                      )
                    )
                : e.push(
                    new zt(
                      r,
                      i,
                      `layer "${i.id}" must specify a "source-layer"`
                    )
                  )
              : e.push(new zt(r, i.source, `source "${i.source}" not found`));
          } else e.push(new zt(r, i, 'missing required property "source"'));
        return (
          (e = e.concat(
            Mn({
              key: r,
              value: i,
              valueSpec: o.layer,
              style: t.style,
              styleSpec: t.styleSpec,
              validateSpec: t.validateSpec,
              objectElementValidators: {
                '*': () => [],
                'type': () =>
                  t.validateSpec({
                    key: `${r}.type`,
                    value: i.type,
                    valueSpec: o.layer.type,
                    style: t.style,
                    styleSpec: t.styleSpec,
                    validateSpec: t.validateSpec,
                    object: i,
                    objectKey: 'type',
                  }),
                'filter': Dn,
                'layout': (t) =>
                  Mn({
                    layer: i,
                    key: t.key,
                    value: t.value,
                    style: t.style,
                    styleSpec: t.styleSpec,
                    validateSpec: t.validateSpec,
                    objectElementValidators: {
                      '*': (t) => Bn(kt({ layerType: a }, t)),
                    },
                  }),
                'paint': (t) =>
                  Mn({
                    layer: i,
                    key: t.key,
                    value: t.value,
                    style: t.style,
                    styleSpec: t.styleSpec,
                    validateSpec: t.validateSpec,
                    objectElementValidators: {
                      '*': (t) => Fn(kt({ layerType: a }, t)),
                    },
                  }),
              },
            })
          )),
          e
        );
      }
      function jn(t) {
        const e = t.value,
          i = t.key,
          r = $r(e);
        return 'string' !== r
          ? [new zt(i, e, `string expected, ${r} found`)]
          : [];
      }
      const Nn = {
        promoteId: function ({ key: t, value: e }) {
          if ('string' === $r(e)) return jn({ key: t, value: e });
          {
            const i = [];
            for (const r in e) i.push(...jn({ key: `${t}.${r}`, value: e[r] }));
            return i;
          }
        },
      };
      function Vn(t) {
        const e = t.value,
          i = t.key,
          r = t.styleSpec,
          n = t.style,
          o = t.validateSpec;
        if (!e.type) return [new zt(i, e, '"type" is required')];
        const a = Pn(e.type);
        let s;
        switch (a) {
          case 'vector':
          case 'raster':
            return (
              (s = Mn({
                key: i,
                value: e,
                valueSpec: r[`source_${a.replace('-', '_')}`],
                style: t.style,
                styleSpec: r,
                objectElementValidators: Nn,
                validateSpec: o,
              })),
              s
            );
          case 'raster-dem':
            return (
              (s = (function (t) {
                var e;
                const i = null !== (e = t.sourceName) && void 0 !== e ? e : '',
                  r = t.value,
                  n = t.styleSpec,
                  o = n.source_raster_dem,
                  a = t.style;
                let s = [];
                const l = $r(r);
                if (void 0 === r) return s;
                if ('object' !== l)
                  return (
                    s.push(
                      new zt(
                        'source_raster_dem',
                        r,
                        `object expected, ${l} found`
                      )
                    ),
                    s
                  );
                const c = 'custom' === Pn(r.encoding),
                  h = ['redFactor', 'greenFactor', 'blueFactor', 'baseShift'],
                  u = t.value.encoding ? `"${t.value.encoding}"` : 'Default';
                for (const d in r)
                  !c && h.includes(d)
                    ? s.push(
                        new zt(
                          d,
                          r[d],
                          `In "${i}": "${d}" is only valid when "encoding" is set to "custom". ${u} encoding found`
                        )
                      )
                    : o[d]
                    ? (s = s.concat(
                        t.validateSpec({
                          key: d,
                          value: r[d],
                          valueSpec: o[d],
                          validateSpec: t.validateSpec,
                          style: a,
                          styleSpec: n,
                        })
                      ))
                    : s.push(new zt(d, r[d], `unknown property "${d}"`));
                return s;
              })({
                sourceName: i,
                value: e,
                style: t.style,
                styleSpec: r,
                validateSpec: o,
              })),
              s
            );
          case 'geojson':
            if (
              ((s = Mn({
                key: i,
                value: e,
                valueSpec: r.source_geojson,
                style: n,
                styleSpec: r,
                validateSpec: o,
                objectElementValidators: Nn,
              })),
              e.cluster)
            )
              for (const t in e.clusterProperties) {
                const [r, n] = e.clusterProperties[t],
                  o =
                    'string' == typeof r ? [r, ['accumulated'], ['get', t]] : r;
                s.push(
                  ...En({
                    key: `${i}.${t}.map`,
                    value: n,
                    expressionContext: 'cluster-map',
                  })
                ),
                  s.push(
                    ...En({
                      key: `${i}.${t}.reduce`,
                      value: o,
                      expressionContext: 'cluster-reduce',
                    })
                  );
              }
            return s;
          case 'video':
            return Mn({
              key: i,
              value: e,
              valueSpec: r.source_video,
              style: n,
              validateSpec: o,
              styleSpec: r,
            });
          case 'image':
            return Mn({
              key: i,
              value: e,
              valueSpec: r.source_image,
              style: n,
              validateSpec: o,
              styleSpec: r,
            });
          case 'canvas':
            return [
              new zt(
                i,
                null,
                'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.',
                'source.canvas'
              ),
            ];
          default:
            return kn({
              key: `${i}.type`,
              value: e.type,
              valueSpec: {
                values: [
                  'vector',
                  'raster',
                  'raster-dem',
                  'geojson',
                  'video',
                  'image',
                ],
              },
            });
        }
      }
      function Un(t) {
        const e = t.value,
          i = t.styleSpec,
          r = i.light,
          n = t.style;
        let o = [];
        const a = $r(e);
        if (void 0 === e) return o;
        if ('object' !== a)
          return (
            (o = o.concat([new zt('light', e, `object expected, ${a} found`)])),
            o
          );
        for (const s in e) {
          const a = s.match(/^(.*)-transition$/);
          o = o.concat(
            a && r[a[1]] && r[a[1]].transition
              ? t.validateSpec({
                  key: s,
                  value: e[s],
                  valueSpec: i.transition,
                  validateSpec: t.validateSpec,
                  style: n,
                  styleSpec: i,
                })
              : r[s]
              ? t.validateSpec({
                  key: s,
                  value: e[s],
                  valueSpec: r[s],
                  validateSpec: t.validateSpec,
                  style: n,
                  styleSpec: i,
                })
              : [new zt(s, e[s], `unknown property "${s}"`)]
          );
        }
        return o;
      }
      function Gn(t) {
        const e = t.value,
          i = t.styleSpec,
          r = i.sky,
          n = t.style,
          o = $r(e);
        if (void 0 === e) return [];
        if ('object' !== o)
          return [new zt('sky', e, `object expected, ${o} found`)];
        let a = [];
        for (const s in e)
          a = a.concat(
            r[s]
              ? t.validateSpec({
                  key: s,
                  value: e[s],
                  valueSpec: r[s],
                  style: n,
                  styleSpec: i,
                })
              : [new zt(s, e[s], `unknown property "${s}"`)]
          );
        return a;
      }
      function Zn(t) {
        const e = t.value,
          i = t.styleSpec,
          r = i.terrain,
          n = t.style;
        let o = [];
        const a = $r(e);
        if (void 0 === e) return o;
        if ('object' !== a)
          return (
            (o = o.concat([
              new zt('terrain', e, `object expected, ${a} found`),
            ])),
            o
          );
        for (const s in e)
          o = o.concat(
            r[s]
              ? t.validateSpec({
                  key: s,
                  value: e[s],
                  valueSpec: r[s],
                  validateSpec: t.validateSpec,
                  style: n,
                  styleSpec: i,
                })
              : [new zt(s, e[s], `unknown property "${s}"`)]
          );
        return o;
      }
      function $n(t) {
        let e = [];
        const i = t.value,
          r = t.key;
        if (Array.isArray(i)) {
          const n = [],
            o = [];
          for (const a in i)
            i[a].id &&
              n.includes(i[a].id) &&
              e.push(
                new zt(
                  r,
                  i,
                  `all the sprites' ids must be unique, but ${i[a].id} is duplicated`
                )
              ),
              n.push(i[a].id),
              i[a].url &&
                o.includes(i[a].url) &&
                e.push(
                  new zt(
                    r,
                    i,
                    `all the sprites' URLs must be unique, but ${i[a].url} is duplicated`
                  )
                ),
              o.push(i[a].url),
              (e = e.concat(
                Mn({
                  key: `${r}[${a}]`,
                  value: i[a],
                  valueSpec: {
                    id: { type: 'string', required: !0 },
                    url: { type: 'string', required: !0 },
                  },
                  validateSpec: t.validateSpec,
                })
              ));
          return e;
        }
        return jn({ key: r, value: i });
      }
      function qn(t) {
        return (
          (e = t.value),
          Boolean(e) && e.constructor === Object
            ? []
            : [new zt(t.key, t.value, `object expected, ${$r(t.value)} found`)]
        );
        var e;
      }
      const Wn = {
        '*': () => [],
        'array': In,
        'boolean': function (t) {
          const e = t.value,
            i = t.key,
            r = $r(e);
          return 'boolean' !== r
            ? [new zt(i, e, `boolean expected, ${r} found`)]
            : [];
        },
        'number': Cn,
        'color': zn,
        'constants': Tn,
        'enum': kn,
        'filter': Dn,
        'function': An,
        'layer': On,
        'object': Mn,
        'source': Vn,
        'light': Un,
        'sky': Gn,
        'terrain': Zn,
        'projection': function (t) {
          const e = t.value,
            i = t.styleSpec,
            r = i.projection,
            n = t.style,
            o = $r(e);
          if (void 0 === e) return [];
          if ('object' !== o)
            return [new zt('projection', e, `object expected, ${o} found`)];
          let a = [];
          for (const s in e)
            a = a.concat(
              r[s]
                ? t.validateSpec({
                    key: s,
                    value: e[s],
                    valueSpec: r[s],
                    style: n,
                    styleSpec: i,
                  })
                : [new zt(s, e[s], `unknown property "${s}"`)]
            );
          return a;
        },
        'projectionDefinition': function (t) {
          const e = t.key;
          let i = t.value;
          i = i instanceof String ? i.valueOf() : i;
          const r = $r(i);
          return 'array' !== r ||
            (function (t) {
              return (
                Array.isArray(t) &&
                3 === t.length &&
                'string' == typeof t[0] &&
                'string' == typeof t[1] &&
                'number' == typeof t[2]
              );
            })(i) ||
            (function (t) {
              return !!['interpolate', 'step', 'literal'].includes(t[0]);
            })(i)
            ? ['array', 'string'].includes(r)
              ? []
              : [new zt(e, i, `projection expected, invalid type "${r}" found`)]
            : [
                new zt(
                  e,
                  i,
                  `projection expected, invalid array ${JSON.stringify(
                    i
                  )} found`
                ),
              ];
        },
        'string': jn,
        'formatted': function (t) {
          return 0 === jn(t).length ? [] : En(t);
        },
        'resolvedImage': function (t) {
          return 0 === jn(t).length ? [] : En(t);
        },
        'padding': function (t) {
          const e = t.key,
            i = t.value;
          if ('array' === $r(i)) {
            if (i.length < 1 || i.length > 4)
              return [
                new zt(
                  e,
                  i,
                  `padding requires 1 to 4 values; ${i.length} values found`
                ),
              ];
            const r = { type: 'number' };
            let n = [];
            for (let o = 0; o < i.length; o++)
              n = n.concat(
                t.validateSpec({
                  key: `${e}[${o}]`,
                  value: i[o],
                  validateSpec: t.validateSpec,
                  valueSpec: r,
                })
              );
            return n;
          }
          return Cn({ key: e, value: i, valueSpec: {} });
        },
        'numberArray': function (t) {
          const e = t.key,
            i = t.value;
          if ('array' === $r(i)) {
            const r = { type: 'number' };
            if (i.length < 1)
              return [
                new zt(
                  e,
                  i,
                  'array length at least 1 expected, length 0 found'
                ),
              ];
            let n = [];
            for (let o = 0; o < i.length; o++)
              n = n.concat(
                t.validateSpec({
                  key: `${e}[${o}]`,
                  value: i[o],
                  validateSpec: t.validateSpec,
                  valueSpec: r,
                })
              );
            return n;
          }
          return Cn({ key: e, value: i, valueSpec: {} });
        },
        'colorArray': function (t) {
          const e = t.key,
            i = t.value;
          if ('array' === $r(i)) {
            if (i.length < 1)
              return [
                new zt(
                  e,
                  i,
                  'array length at least 1 expected, length 0 found'
                ),
              ];
            let t = [];
            for (let r = 0; r < i.length; r++)
              t = t.concat(zn({ key: `${e}[${r}]`, value: i[r] }));
            return t;
          }
          return zn({ key: e, value: i });
        },
        'variableAnchorOffsetCollection': function (t) {
          const e = t.key,
            i = t.value,
            r = $r(i),
            n = t.styleSpec;
          if ('array' !== r || i.length < 1 || i.length % 2 != 0)
            return [
              new zt(
                e,
                i,
                'variableAnchorOffsetCollection requires a non-empty array of even length'
              ),
            ];
          let o = [];
          for (let a = 0; a < i.length; a += 2)
            (o = o.concat(
              kn({
                key: `${e}[${a}]`,
                value: i[a],
                valueSpec: n.layout_symbol['text-anchor'],
              })
            )),
              (o = o.concat(
                In({
                  key: `${e}[${a + 1}]`,
                  value: i[a + 1],
                  valueSpec: { length: 2, value: 'number' },
                  validateSpec: t.validateSpec,
                  style: t.style,
                  styleSpec: n,
                })
              ));
          return o;
        },
        'sprite': $n,
        'state': qn,
      };
      function Yn(t) {
        const e = t.value,
          i = t.valueSpec,
          r = t.styleSpec;
        return (
          (t.validateSpec = Yn),
          i.expression && qr(Pn(e))
            ? An(t)
            : i.expression && en(Sn(e))
            ? En(t)
            : i.type && Wn[i.type]
            ? Wn[i.type](t)
            : Mn(kt({}, t, { valueSpec: i.type ? r[i.type] : i }))
        );
      }
      function Hn(t) {
        const e = t.value,
          i = t.key,
          r = jn(t);
        return (
          r.length ||
            (-1 === e.indexOf('{fontstack}') &&
              r.push(
                new zt(i, e, '"glyphs" url must include a "{fontstack}" token')
              ),
            -1 === e.indexOf('{range}') &&
              r.push(
                new zt(i, e, '"glyphs" url must include a "{range}" token')
              )),
          r
        );
      }
      function Xn(t, e = xt) {
        let i = [];
        return (
          (i = i.concat(
            Yn({
              key: '',
              value: t,
              valueSpec: e.$root,
              styleSpec: e,
              style: t,
              validateSpec: Yn,
              objectElementValidators: { 'glyphs': Hn, '*': () => [] },
            })
          )),
          t.constants &&
            (i = i.concat(Tn({ key: 'constants', value: t.constants }))),
          Jn(i)
        );
      }
      function Kn(t) {
        return function (e) {
          return t(Object.assign({}, e, { validateSpec: Yn }));
        };
      }
      function Jn(t) {
        return [].concat(t).sort((t, e) => t.line - e.line);
      }
      function Qn(t) {
        return function (...e) {
          return Jn(t.apply(this, e));
        };
      }
      (Xn.source = Qn(Kn(Vn))),
        (Xn.sprite = Qn(Kn($n))),
        (Xn.glyphs = Qn(Kn(Hn))),
        (Xn.light = Qn(Kn(Un))),
        (Xn.sky = Qn(Kn(Gn))),
        (Xn.terrain = Qn(Kn(Zn))),
        (Xn.state = Qn(Kn(qn))),
        (Xn.layer = Qn(Kn(On))),
        (Xn.filter = Qn(Kn(Dn))),
        (Xn.paintProperty = Qn(Kn(Fn))),
        (Xn.layoutProperty = Qn(Kn(Bn)));
      const to = xt,
        eo = Xn,
        io = eo.light,
        ro = eo.sky,
        no = eo.paintProperty,
        oo = eo.layoutProperty;
      function ao(t, e) {
        let i = !1;
        if (e && e.length)
          for (const r of e) t.fire(new gt(new Error(r.message))), (i = !0);
        return i;
      }
      class so {
        constructor(t, e, i) {
          const r = (this.cells = []);
          if (t instanceof ArrayBuffer) {
            this.arrayBuffer = t;
            const n = new Int32Array(this.arrayBuffer);
            (t = n[0]), (this.d = (e = n[1]) + 2 * (i = n[2]));
            for (let t = 0; t < this.d * this.d; t++) {
              const e = n[3 + t],
                i = n[3 + t + 1];
              r.push(e === i ? null : n.subarray(e, i));
            }
            const o = n[3 + r.length + 1];
            (this.keys = n.subarray(n[3 + r.length], o)),
              (this.bboxes = n.subarray(o)),
              (this.insert = this._insertReadonly);
          } else {
            this.d = e + 2 * i;
            for (let t = 0; t < this.d * this.d; t++) r.push([]);
            (this.keys = []), (this.bboxes = []);
          }
          (this.n = e),
            (this.extent = t),
            (this.padding = i),
            (this.scale = e / t),
            (this.uid = 0);
          const n = (i / e) * t;
          (this.min = -n), (this.max = t + n);
        }
        insert(t, e, i, r, n) {
          this._forEachCell(
            e,
            i,
            r,
            n,
            this._insertCell,
            this.uid++,
            void 0,
            void 0
          ),
            this.keys.push(t),
            this.bboxes.push(e),
            this.bboxes.push(i),
            this.bboxes.push(r),
            this.bboxes.push(n);
        }
        _insertReadonly() {
          throw new Error(
            'Cannot insert into a GridIndex created from an ArrayBuffer.'
          );
        }
        _insertCell(t, e, i, r, n, o) {
          this.cells[n].push(o);
        }
        query(t, e, i, r, n) {
          const o = this.min,
            a = this.max;
          if (t <= o && e <= o && a <= i && a <= r && !n)
            return Array.prototype.slice.call(this.keys);
          {
            const o = [];
            return this._forEachCell(t, e, i, r, this._queryCell, o, {}, n), o;
          }
        }
        _queryCell(t, e, i, r, n, o, a, s) {
          const l = this.cells[n];
          if (null !== l) {
            const n = this.keys,
              c = this.bboxes;
            for (let h = 0; h < l.length; h++) {
              const u = l[h];
              if (void 0 === a[u]) {
                const l = 4 * u;
                (
                  s
                    ? s(c[l + 0], c[l + 1], c[l + 2], c[l + 3])
                    : t <= c[l + 2] &&
                      e <= c[l + 3] &&
                      i >= c[l + 0] &&
                      r >= c[l + 1]
                )
                  ? ((a[u] = !0), o.push(n[u]))
                  : (a[u] = !1);
              }
            }
          }
        }
        _forEachCell(t, e, i, r, n, o, a, s) {
          const l = this._convertToCellCoord(t),
            c = this._convertToCellCoord(e),
            h = this._convertToCellCoord(i),
            u = this._convertToCellCoord(r);
          for (let d = l; d <= h; d++)
            for (let l = c; l <= u; l++) {
              const c = this.d * l + d;
              if (
                (!s ||
                  s(
                    this._convertFromCellCoord(d),
                    this._convertFromCellCoord(l),
                    this._convertFromCellCoord(d + 1),
                    this._convertFromCellCoord(l + 1)
                  )) &&
                n.call(this, t, e, i, r, c, o, a, s)
              )
                return;
            }
        }
        _convertFromCellCoord(t) {
          return (t - this.padding) / this.scale;
        }
        _convertToCellCoord(t) {
          return Math.max(
            0,
            Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)
          );
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t = this.cells,
            e = 3 + this.cells.length + 1 + 1;
          let i = 0;
          for (let o = 0; o < this.cells.length; o++) i += this.cells[o].length;
          const r = new Int32Array(
            e + i + this.keys.length + this.bboxes.length
          );
          (r[0] = this.extent), (r[1] = this.n), (r[2] = this.padding);
          let n = e;
          for (let o = 0; o < t.length; o++) {
            const e = t[o];
            (r[3 + o] = n), r.set(e, n), (n += e.length);
          }
          return (
            (r[3 + t.length] = n),
            r.set(this.keys, n),
            (n += this.keys.length),
            (r[3 + t.length + 1] = n),
            r.set(this.bboxes, n),
            (n += this.bboxes.length),
            r.buffer
          );
        }
        static serialize(t, e) {
          const i = t.toArrayBuffer();
          return e && e.push(i), { buffer: i };
        }
        static deserialize(t) {
          return new so(t.buffer);
        }
      }
      const lo = {};
      function co(t, e, i = {}) {
        if (lo[t]) throw new Error(`${t} is already registered.`);
        Object.defineProperty(e, '_classRegistryKey', {
          value: t,
          writeable: !1,
        }),
          (lo[t] = { klass: e, omit: i.omit || [], shallow: i.shallow || [] });
      }
      co('Object', Object),
        co('Set', Set),
        co('TransferableGridIndex', so),
        co('Color', Ie),
        co('Error', Error),
        co('AJAXError', ht),
        co('ResolvedImage', Oe),
        co('StylePropertyFunction', sn),
        co('StyleExpression', tn, { omit: ['_evaluator'] }),
        co('ZoomDependentExpression', on),
        co('ZoomConstantExpression', nn),
        co('CompoundExpression', zr, { omit: ['_evaluate'] });
      for (const Rd in Er)
        Er[Rd]._classRegistryKey || co(`Expression_${Rd}`, Er[Rd]);
      function ho(t) {
        return (
          t &&
          'undefined' != typeof ArrayBuffer &&
          (t instanceof ArrayBuffer ||
            (t.constructor && 'ArrayBuffer' === t.constructor.name))
        );
      }
      function uo(t) {
        return t.$name || t.constructor._classRegistryKey;
      }
      function po(t) {
        return (
          !(function (t) {
            if (null === t || 'object' != typeof t) return !1;
            const e = uo(t);
            return !(!e || 'Object' === e);
          })(t) &&
          (null == t ||
            'boolean' == typeof t ||
            'number' == typeof t ||
            'string' == typeof t ||
            t instanceof Boolean ||
            t instanceof Number ||
            t instanceof String ||
            t instanceof Date ||
            t instanceof RegExp ||
            t instanceof Blob ||
            t instanceof Error ||
            ho(t) ||
            H(t) ||
            ArrayBuffer.isView(t) ||
            t instanceof ImageData)
        );
      }
      function fo(t, e) {
        if (po(t))
          return (
            (ho(t) || H(t)) && e && e.push(t),
            ArrayBuffer.isView(t) && e && e.push(t.buffer),
            t instanceof ImageData && e && e.push(t.data.buffer),
            t
          );
        if (Array.isArray(t)) {
          const i = [];
          for (const r of t) i.push(fo(r, e));
          return i;
        }
        if ('object' != typeof t)
          throw new Error("can't serialize object of type " + typeof t);
        const i = uo(t);
        if (!i)
          throw new Error(
            `can't serialize object of unregistered class ${t.constructor.name}`
          );
        if (!lo[i]) throw new Error(`${i} is not registered.`);
        const { klass: r } = lo[i],
          n = r.serialize ? r.serialize(t, e) : {};
        if (r.serialize) {
          if (e && n === e[e.length - 1])
            throw new Error(
              "statically serialized object won't survive transfer of $name property"
            );
        } else {
          for (const r in t) {
            if (!t.hasOwnProperty(r)) continue;
            if (lo[i].omit.indexOf(r) >= 0) continue;
            const o = t[r];
            n[r] = lo[i].shallow.indexOf(r) >= 0 ? o : fo(o, e);
          }
          t instanceof Error && (n.message = t.message);
        }
        if (n.$name)
          throw new Error(
            '$name property is reserved for worker serialization logic.'
          );
        return 'Object' !== i && (n.$name = i), n;
      }
      function mo(t) {
        if (po(t)) return t;
        if (Array.isArray(t)) return t.map(mo);
        if ('object' != typeof t)
          throw new Error("can't deserialize object of type " + typeof t);
        const e = uo(t) || 'Object';
        if (!lo[e])
          throw new Error(`can't deserialize unregistered class ${e}`);
        const { klass: i } = lo[e];
        if (!i) throw new Error(`can't deserialize unregistered class ${e}`);
        if (i.deserialize) return i.deserialize(t);
        const r = Object.create(i.prototype);
        for (const n of Object.keys(t)) {
          if ('$name' === n) continue;
          const i = t[n];
          r[n] = lo[e].shallow.indexOf(n) >= 0 ? i : mo(i);
        }
        return r;
      }
      class _o {
        constructor() {
          this.first = !0;
        }
        update(t, e) {
          const i = Math.floor(t);
          return this.first
            ? ((this.first = !1),
              (this.lastIntegerZoom = i),
              (this.lastIntegerZoomTime = 0),
              (this.lastZoom = t),
              (this.lastFloorZoom = i),
              !0)
            : (this.lastFloorZoom > i
                ? ((this.lastIntegerZoom = i + 1),
                  (this.lastIntegerZoomTime = e))
                : this.lastFloorZoom < i &&
                  ((this.lastIntegerZoom = i), (this.lastIntegerZoomTime = e)),
              t !== this.lastZoom &&
                ((this.lastZoom = t), (this.lastFloorZoom = i), !0));
        }
      }
      const go = {
        'Latin-1 Supplement': (t) => t >= 128 && t <= 255,
        'Hangul Jamo': (t) => t >= 4352 && t <= 4607,
        'Khmer': (t) => t >= 6016 && t <= 6143,
        'General Punctuation': (t) => t >= 8192 && t <= 8303,
        'Letterlike Symbols': (t) => t >= 8448 && t <= 8527,
        'Number Forms': (t) => t >= 8528 && t <= 8591,
        'Miscellaneous Technical': (t) => t >= 8960 && t <= 9215,
        'Control Pictures': (t) => t >= 9216 && t <= 9279,
        'Optical Character Recognition': (t) => t >= 9280 && t <= 9311,
        'Enclosed Alphanumerics': (t) => t >= 9312 && t <= 9471,
        'Geometric Shapes': (t) => t >= 9632 && t <= 9727,
        'Miscellaneous Symbols': (t) => t >= 9728 && t <= 9983,
        'Miscellaneous Symbols and Arrows': (t) => t >= 11008 && t <= 11263,
        'Ideographic Description Characters': (t) => t >= 12272 && t <= 12287,
        'CJK Symbols and Punctuation': (t) => t >= 12288 && t <= 12351,
        'Hiragana': (t) => t >= 12352 && t <= 12447,
        'Katakana': (t) => t >= 12448 && t <= 12543,
        'Kanbun': (t) => t >= 12688 && t <= 12703,
        'CJK Strokes': (t) => t >= 12736 && t <= 12783,
        'Enclosed CJK Letters and Months': (t) => t >= 12800 && t <= 13055,
        'CJK Compatibility': (t) => t >= 13056 && t <= 13311,
        'Yijing Hexagram Symbols': (t) => t >= 19904 && t <= 19967,
        'CJK Unified Ideographs': (t) => t >= 19968 && t <= 40959,
        'Hangul Syllables': (t) => t >= 44032 && t <= 55215,
        'Private Use Area': (t) => t >= 57344 && t <= 63743,
        'Vertical Forms': (t) => t >= 65040 && t <= 65055,
        'CJK Compatibility Forms': (t) => t >= 65072 && t <= 65103,
        'Small Form Variants': (t) => t >= 65104 && t <= 65135,
        'Halfwidth and Fullwidth Forms': (t) => t >= 65280 && t <= 65519,
      };
      function yo(t) {
        for (const e of t) if (Po(e.charCodeAt(0))) return !0;
        return !1;
      }
      function xo(t) {
        for (const e of t) if (!wo(e.charCodeAt(0))) return !1;
        return !0;
      }
      function vo(t) {
        const e = t
          .map((t) => {
            try {
              return new RegExp(`\\p{sc=${t}}`, 'u').source;
            } catch (t) {
              return null;
            }
          })
          .filter((t) => t);
        return new RegExp(e.join('|'), 'u');
      }
      const bo = vo(['Arab', 'Dupl', 'Mong', 'Ougr', 'Syrc']);
      function wo(t) {
        return !bo.test(String.fromCodePoint(t));
      }
      const To = vo([
        'Bopo',
        'Hani',
        'Hira',
        'Kana',
        'Kits',
        'Nshu',
        'Tang',
        'Yiii',
      ]);
      function Po(t) {
        return !(
          746 !== t &&
          747 !== t &&
          (t < 4352 ||
            !(
              (go['CJK Compatibility Forms'](t) &&
                !(t >= 65097 && t <= 65103)) ||
              go['CJK Compatibility'](t) ||
              go['CJK Strokes'](t) ||
              !(
                !go['CJK Symbols and Punctuation'](t) ||
                (t >= 12296 && t <= 12305) ||
                (t >= 12308 && t <= 12319) ||
                12336 === t
              ) ||
              go['Enclosed CJK Letters and Months'](t) ||
              go['Ideographic Description Characters'](t) ||
              go.Kanbun(t) ||
              (go.Katakana(t) && 12540 !== t) ||
              !(
                !go['Halfwidth and Fullwidth Forms'](t) ||
                65288 === t ||
                65289 === t ||
                65293 === t ||
                (t >= 65306 && t <= 65310) ||
                65339 === t ||
                65341 === t ||
                65343 === t ||
                (t >= 65371 && t <= 65503) ||
                65507 === t ||
                (t >= 65512 && t <= 65519)
              ) ||
              !(
                !go['Small Form Variants'](t) ||
                (t >= 65112 && t <= 65118) ||
                (t >= 65123 && t <= 65126)
              ) ||
              go['Vertical Forms'](t) ||
              go['Yijing Hexagram Symbols'](t) ||
              /\p{sc=Cans}/u.test(String.fromCodePoint(t)) ||
              /\p{sc=Hang}/u.test(String.fromCodePoint(t)) ||
              To.test(String.fromCodePoint(t))
            ))
        );
      }
      function So(t) {
        return !(
          Po(t) ||
          (function (t) {
            return !!(
              (go['Latin-1 Supplement'](t) &&
                (167 === t ||
                  169 === t ||
                  174 === t ||
                  177 === t ||
                  188 === t ||
                  189 === t ||
                  190 === t ||
                  215 === t ||
                  247 === t)) ||
              (go['General Punctuation'](t) &&
                (8214 === t ||
                  8224 === t ||
                  8225 === t ||
                  8240 === t ||
                  8241 === t ||
                  8251 === t ||
                  8252 === t ||
                  8258 === t ||
                  8263 === t ||
                  8264 === t ||
                  8265 === t ||
                  8273 === t)) ||
              go['Letterlike Symbols'](t) ||
              go['Number Forms'](t) ||
              (go['Miscellaneous Technical'](t) &&
                ((t >= 8960 && t <= 8967) ||
                  (t >= 8972 && t <= 8991) ||
                  (t >= 8996 && t <= 9e3) ||
                  9003 === t ||
                  (t >= 9085 && t <= 9114) ||
                  (t >= 9150 && t <= 9165) ||
                  9167 === t ||
                  (t >= 9169 && t <= 9179) ||
                  (t >= 9186 && t <= 9215))) ||
              (go['Control Pictures'](t) && 9251 !== t) ||
              go['Optical Character Recognition'](t) ||
              go['Enclosed Alphanumerics'](t) ||
              go['Geometric Shapes'](t) ||
              (go['Miscellaneous Symbols'](t) && !(t >= 9754 && t <= 9759)) ||
              (go['Miscellaneous Symbols and Arrows'](t) &&
                ((t >= 11026 && t <= 11055) ||
                  (t >= 11088 && t <= 11097) ||
                  (t >= 11192 && t <= 11243))) ||
              go['CJK Symbols and Punctuation'](t) ||
              go.Katakana(t) ||
              go['Private Use Area'](t) ||
              go['CJK Compatibility Forms'](t) ||
              go['Small Form Variants'](t) ||
              go['Halfwidth and Fullwidth Forms'](t) ||
              8734 === t ||
              8756 === t ||
              8757 === t ||
              (t >= 9984 && t <= 10087) ||
              (t >= 10102 && t <= 10131) ||
              65532 === t ||
              65533 === t
            );
          })(t)
        );
      }
      const Mo = vo([
        'Adlm',
        'Arab',
        'Armi',
        'Avst',
        'Chrs',
        'Cprt',
        'Egyp',
        'Elym',
        'Gara',
        'Hatr',
        'Hebr',
        'Hung',
        'Khar',
        'Lydi',
        'Mand',
        'Mani',
        'Mend',
        'Merc',
        'Mero',
        'Narb',
        'Nbat',
        'Nkoo',
        'Orkh',
        'Palm',
        'Phli',
        'Phlp',
        'Phnx',
        'Prti',
        'Rohg',
        'Samr',
        'Sarb',
        'Sogo',
        'Syrc',
        'Thaa',
        'Todr',
        'Yezi',
      ]);
      function Io(t) {
        return Mo.test(String.fromCodePoint(t));
      }
      function Co(t, e) {
        return !(
          (!e && Io(t)) ||
          (t >= 2304 && t <= 3583) ||
          (t >= 3840 && t <= 4255) ||
          go.Khmer(t)
        );
      }
      function Ao(t) {
        for (const e of t) if (Io(e.charCodeAt(0))) return !0;
        return !1;
      }
      const Eo = new (class {
        constructor() {
          (this.TIMEOUT = 5e3),
            (this.applyArabicShaping = null),
            (this.processBidirectionalText = null),
            (this.processStyledBidirectionalText = null),
            (this.pluginStatus = 'unavailable'),
            (this.pluginURL = null),
            (this.loadScriptResolve = () => {});
        }
        setState(t) {
          (this.pluginStatus = t.pluginStatus), (this.pluginURL = t.pluginURL);
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(t) {
          if (Eo.isParsed())
            throw new Error('RTL text plugin already registered.');
          (this.applyArabicShaping = t.applyArabicShaping),
            (this.processBidirectionalText = t.processBidirectionalText),
            (this.processStyledBidirectionalText =
              t.processStyledBidirectionalText),
            this.loadScriptResolve();
        }
        isParsed() {
          return (
            null != this.applyArabicShaping &&
            null != this.processBidirectionalText &&
            null != this.processStyledBidirectionalText
          );
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
        syncState(t, i) {
          return e(this, void 0, void 0, function* () {
            if (this.isParsed()) return this.getState();
            if ('loading' !== t.pluginStatus) return this.setState(t), t;
            const e = t.pluginURL,
              r = new Promise((t) => {
                this.loadScriptResolve = t;
              });
            i(e);
            const n = new Promise((t) => setTimeout(() => t(), this.TIMEOUT));
            if ((yield Promise.race([r, n]), this.isParsed())) {
              const t = { pluginStatus: 'loaded', pluginURL: e };
              return this.setState(t), t;
            }
            throw (
              (this.setState({ pluginStatus: 'error', pluginURL: '' }),
              new Error(`RTL Text Plugin failed to import scripts from ${e}`))
            );
          });
        }
      })();
      class zo {
        constructor(t, e) {
          (this.isSupportedScript = ko),
            (this.zoom = t),
            e
              ? ((this.now = e.now || 0),
                (this.fadeDuration = e.fadeDuration || 0),
                (this.zoomHistory = e.zoomHistory || new _o()),
                (this.transition = e.transition || {}))
              : ((this.now = 0),
                (this.fadeDuration = 0),
                (this.zoomHistory = new _o()),
                (this.transition = {}));
        }
        crossFadingFactor() {
          return 0 === this.fadeDuration
            ? 1
            : Math.min(
                (this.now - this.zoomHistory.lastIntegerZoomTime) /
                  this.fadeDuration,
                1
              );
        }
        getCrossfadeParameters() {
          const t = this.zoom,
            e = t - Math.floor(t),
            i = this.crossFadingFactor();
          return t > this.zoomHistory.lastIntegerZoom
            ? { fromScale: 2, toScale: 1, t: e + (1 - e) * i }
            : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * e };
        }
      }
      function ko(t) {
        return (function (t, e) {
          for (const i of t) if (!Co(i.charCodeAt(0), e)) return !1;
          return !0;
        })(t, 'loaded' === Eo.getRTLTextPluginStatus());
      }
      class Do {
        constructor(t, e, i) {
          (this.property = t),
            (this.value = e),
            (this.expression = (function (t, e, i) {
              if (qr(t)) return new sn(t, e);
              if (en(t)) {
                const r = an(t, e, i);
                if ('error' === r.result)
                  throw new Error(
                    r.value.map((t) => `${t.key}: ${t.message}`).join(', ')
                  );
                return r.value;
              }
              {
                let i = t;
                return (
                  'color' === e.type && 'string' == typeof t
                    ? (i = Ie.parse(t))
                    : 'padding' !== e.type ||
                      ('number' != typeof t && !Array.isArray(t))
                    ? 'numberArray' !== e.type ||
                      ('number' != typeof t && !Array.isArray(t))
                      ? 'colorArray' !== e.type ||
                        ('string' != typeof t && !Array.isArray(t))
                        ? 'variableAnchorOffsetCollection' === e.type &&
                          Array.isArray(t)
                          ? (i = Be.parse(t))
                          : 'projectionDefinition' === e.type &&
                            'string' == typeof t &&
                            (i = je.parse(t))
                        : (i = Re.parse(t))
                      : (i = De.parse(t))
                    : (i = ke.parse(t)),
                  {
                    globalStateRefs: new Set(),
                    _globalState: null,
                    kind: 'constant',
                    evaluate: () => i,
                  }
                );
              }
            })(void 0 === e ? t.specification.default : e, t.specification, i));
        }
        isDataDriven() {
          return (
            'source' === this.expression.kind ||
            'composite' === this.expression.kind
          );
        }
        getGlobalStateRefs() {
          return this.expression.globalStateRefs || new Set();
        }
        possiblyEvaluate(t, e, i) {
          return this.property.possiblyEvaluate(this, t, e, i);
        }
      }
      class Ro {
        constructor(t, e) {
          (this.property = t), (this.value = new Do(t, void 0, e));
        }
        transitioned(t, e) {
          return new Fo(
            this.property,
            this.value,
            e,
            O({}, t.transition, this.transition),
            t.now
          );
        }
        untransitioned() {
          return new Fo(this.property, this.value, null, {}, 0);
        }
      }
      class Lo {
        constructor(t, e) {
          (this._properties = t),
            (this._values = Object.create(
              t.defaultTransitionablePropertyValues
            )),
            (this._globalState = e);
        }
        getValue(t) {
          return U(this._values[t].value.value);
        }
        setValue(t, e) {
          Object.prototype.hasOwnProperty.call(this._values, t) ||
            (this._values[t] = new Ro(
              this._values[t].property,
              this._globalState
            )),
            (this._values[t].value = new Do(
              this._values[t].property,
              null === e ? void 0 : U(e),
              this._globalState
            ));
        }
        getTransition(t) {
          return U(this._values[t].transition);
        }
        setTransition(t, e) {
          Object.prototype.hasOwnProperty.call(this._values, t) ||
            (this._values[t] = new Ro(
              this._values[t].property,
              this._globalState
            )),
            (this._values[t].transition = U(e) || void 0);
        }
        serialize() {
          const t = {};
          for (const e of Object.keys(this._values)) {
            const i = this.getValue(e);
            void 0 !== i && (t[e] = i);
            const r = this.getTransition(e);
            void 0 !== r && (t[`${e}-transition`] = r);
          }
          return t;
        }
        transitioned(t, e) {
          const i = new Bo(this._properties);
          for (const r of Object.keys(this._values))
            i._values[r] = this._values[r].transitioned(t, e._values[r]);
          return i;
        }
        untransitioned() {
          const t = new Bo(this._properties);
          for (const e of Object.keys(this._values))
            t._values[e] = this._values[e].untransitioned();
          return t;
        }
      }
      class Fo {
        constructor(t, e, i, r, n) {
          (this.property = t),
            (this.value = e),
            (this.begin = n + r.delay || 0),
            (this.end = this.begin + r.duration || 0),
            t.specification.transition &&
              (r.delay || r.duration) &&
              (this.prior = i);
        }
        possiblyEvaluate(t, e, i) {
          const r = t.now || 0,
            n = this.value.possiblyEvaluate(t, e, i),
            o = this.prior;
          if (o) {
            if (r > this.end) return (this.prior = null), n;
            if (this.value.isDataDriven()) return (this.prior = null), n;
            if (r < this.begin) return o.possiblyEvaluate(t, e, i);
            {
              const a = (r - this.begin) / (this.end - this.begin);
              return this.property.interpolate(
                o.possiblyEvaluate(t, e, i),
                n,
                D(a)
              );
            }
          }
          return n;
        }
      }
      class Bo {
        constructor(t) {
          (this._properties = t),
            (this._values = Object.create(
              t.defaultTransitioningPropertyValues
            ));
        }
        possiblyEvaluate(t, e, i) {
          const r = new No(this._properties);
          for (const n of Object.keys(this._values))
            r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
          return r;
        }
        hasTransition() {
          for (const t of Object.keys(this._values))
            if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class Oo {
        constructor(t, e) {
          (this._properties = t),
            (this._values = Object.create(t.defaultPropertyValues)),
            (this._globalState = e);
        }
        hasValue(t) {
          return void 0 !== this._values[t].value;
        }
        getValue(t) {
          return U(this._values[t].value);
        }
        setValue(t, e) {
          this._values[t] = new Do(
            this._values[t].property,
            null === e ? void 0 : U(e),
            this._globalState
          );
        }
        serialize() {
          const t = {};
          for (const e of Object.keys(this._values)) {
            const i = this.getValue(e);
            void 0 !== i && (t[e] = i);
          }
          return t;
        }
        possiblyEvaluate(t, e, i) {
          const r = new No(this._properties);
          for (const n of Object.keys(this._values))
            r._values[n] = this._values[n].possiblyEvaluate(t, e, i);
          return r;
        }
      }
      class jo {
        constructor(t, e, i) {
          (this.property = t), (this.value = e), (this.parameters = i);
        }
        isConstant() {
          return 'constant' === this.value.kind;
        }
        constantOr(t) {
          return 'constant' === this.value.kind ? this.value.value : t;
        }
        evaluate(t, e, i, r) {
          return this.property.evaluate(
            this.value,
            this.parameters,
            t,
            e,
            i,
            r
          );
        }
      }
      class No {
        constructor(t) {
          (this._properties = t),
            (this._values = Object.create(t.defaultPossiblyEvaluatedValues));
        }
        get(t) {
          return this._values[t];
        }
      }
      class Vo {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, e) {
          if (t.isDataDriven())
            throw new Error('Value should not be data driven');
          return t.expression.evaluate(e);
        }
        interpolate(t, e, i) {
          const r = mi[this.specification.type];
          return r ? r(t, e, i) : t;
        }
      }
      class Uo {
        constructor(t, e) {
          (this.specification = t), (this.overrides = e);
        }
        possiblyEvaluate(t, e, i, r) {
          return new jo(
            this,
            'constant' === t.expression.kind || 'camera' === t.expression.kind
              ? {
                  kind: 'constant',
                  value: t.expression.evaluate(e, null, {}, i, r),
                }
              : t.expression,
            e
          );
        }
        interpolate(t, e, i) {
          if ('constant' !== t.value.kind || 'constant' !== e.value.kind)
            return t;
          if (void 0 === t.value.value || void 0 === e.value.value)
            return new jo(
              this,
              { kind: 'constant', value: void 0 },
              t.parameters
            );
          const r = mi[this.specification.type];
          if (r) {
            const n = r(t.value.value, e.value.value, i);
            return new jo(this, { kind: 'constant', value: n }, t.parameters);
          }
          return t;
        }
        evaluate(t, e, i, r, n, o) {
          return 'constant' === t.kind ? t.value : t.evaluate(e, i, r, n, o);
        }
      }
      class Go extends Uo {
        possiblyEvaluate(t, e, i, r) {
          if (void 0 === t.value)
            return new jo(this, { kind: 'constant', value: void 0 }, e);
          if ('constant' === t.expression.kind) {
            const n = t.expression.evaluate(e, null, {}, i, r),
              o =
                'resolvedImage' === t.property.specification.type &&
                'string' != typeof n
                  ? n.name
                  : n,
              a = this._calculate(o, o, o, e);
            return new jo(this, { kind: 'constant', value: a }, e);
          }
          if ('camera' === t.expression.kind) {
            const i = this._calculate(
              t.expression.evaluate({ zoom: e.zoom - 1 }),
              t.expression.evaluate({ zoom: e.zoom }),
              t.expression.evaluate({ zoom: e.zoom + 1 }),
              e
            );
            return new jo(this, { kind: 'constant', value: i }, e);
          }
          return new jo(this, t.expression, e);
        }
        evaluate(t, e, i, r, n, o) {
          if ('source' === t.kind) {
            const a = t.evaluate(e, i, r, n, o);
            return this._calculate(a, a, a, e);
          }
          return 'composite' === t.kind
            ? this._calculate(
                t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, i, r),
                t.evaluate({ zoom: Math.floor(e.zoom) }, i, r),
                t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, i, r),
                e
              )
            : t.value;
        }
        _calculate(t, e, i, r) {
          return r.zoom > r.zoomHistory.lastIntegerZoom
            ? { from: t, to: e }
            : { from: i, to: e };
        }
        interpolate(t) {
          return t;
        }
      }
      class Zo {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, e, i, r) {
          if (void 0 !== t.value) {
            if ('constant' === t.expression.kind) {
              const n = t.expression.evaluate(e, null, {}, i, r);
              return this._calculate(n, n, n, e);
            }
            return this._calculate(
              t.expression.evaluate(new zo(Math.floor(e.zoom - 1), e)),
              t.expression.evaluate(new zo(Math.floor(e.zoom), e)),
              t.expression.evaluate(new zo(Math.floor(e.zoom + 1), e)),
              e
            );
          }
        }
        _calculate(t, e, i, r) {
          return r.zoom > r.zoomHistory.lastIntegerZoom
            ? { from: t, to: e }
            : { from: i, to: e };
        }
        interpolate(t) {
          return t;
        }
      }
      class $o {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, e, i, r) {
          return !!t.expression.evaluate(e, null, {}, i, r);
        }
        interpolate() {
          return !1;
        }
      }
      class qo {
        constructor(t) {
          (this.properties = t),
            (this.defaultPropertyValues = {}),
            (this.defaultTransitionablePropertyValues = {}),
            (this.defaultTransitioningPropertyValues = {}),
            (this.defaultPossiblyEvaluatedValues = {}),
            (this.overridableProperties = []);
          for (const e in t) {
            const i = t[e];
            i.specification.overridable && this.overridableProperties.push(e);
            const r = (this.defaultPropertyValues[e] = new Do(
                i,
                void 0,
                void 0
              )),
              n = (this.defaultTransitionablePropertyValues[e] = new Ro(
                i,
                void 0
              ));
            (this.defaultTransitioningPropertyValues[e] = n.untransitioned()),
              (this.defaultPossiblyEvaluatedValues[e] = r.possiblyEvaluate({}));
          }
        }
      }
      co('DataDrivenProperty', Uo),
        co('DataConstantProperty', Vo),
        co('CrossFadedDataDrivenProperty', Go),
        co('CrossFadedProperty', Zo),
        co('ColorRampProperty', $o);
      const Wo = '-transition';
      class Yo extends yt {
        constructor(t, e, i) {
          if (
            (super(),
            (this.id = t.id),
            (this.type = t.type),
            (this._globalState = i),
            (this._featureFilter = {
              filter: () => !0,
              needGeometry: !1,
              getGlobalStateRefs: () => new Set(),
            }),
            'custom' !== t.type &&
              ((this.metadata = t.metadata),
              (this.minzoom = t.minzoom),
              (this.maxzoom = t.maxzoom),
              'background' !== t.type &&
                ((this.source = t.source),
                (this.sourceLayer = t['source-layer']),
                (this.filter = t.filter),
                (this._featureFilter = pn(t.filter, i))),
              e.layout && (this._unevaluatedLayout = new Oo(e.layout, i)),
              e.paint))
          ) {
            this._transitionablePaint = new Lo(e.paint, i);
            for (const e in t.paint)
              this.setPaintProperty(e, t.paint[e], { validate: !1 });
            for (const e in t.layout)
              this.setLayoutProperty(e, t.layout[e], { validate: !1 });
            (this._transitioningPaint =
              this._transitionablePaint.untransitioned()),
              (this.paint = new No(e.paint));
          }
        }
        setFilter(t) {
          (this.filter = t), (this._featureFilter = pn(t, this._globalState));
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t) {
          return 'visibility' === t
            ? this.visibility
            : this._unevaluatedLayout.getValue(t);
        }
        getLayoutAffectingGlobalStateRefs() {
          const t = new Set();
          if (this._unevaluatedLayout)
            for (const e in this._unevaluatedLayout._values) {
              const i = this._unevaluatedLayout._values[e];
              for (const e of i.getGlobalStateRefs()) t.add(e);
            }
          for (const e of this._featureFilter.getGlobalStateRefs()) t.add(e);
          return t;
        }
        getPaintAffectingGlobalStateRefs() {
          var t;
          const e = new globalThis.Map();
          if (this._transitionablePaint)
            for (const i in this._transitionablePaint._values) {
              const r = this._transitionablePaint._values[i].value;
              for (const n of r.getGlobalStateRefs()) {
                const o = null !== (t = e.get(n)) && void 0 !== t ? t : [];
                o.push({ name: i, value: r.value }), e.set(n, o);
              }
            }
          return e;
        }
        setLayoutProperty(t, e, i = {}) {
          (null != e &&
            this._validate(oo, `layers.${this.id}.layout.${t}`, t, e, i)) ||
            ('visibility' !== t
              ? this._unevaluatedLayout.setValue(t, e)
              : (this.visibility = e));
        }
        getPaintProperty(t) {
          return t.endsWith(Wo)
            ? this._transitionablePaint.getTransition(t.slice(0, -11))
            : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, e, i = {}) {
          if (
            null != e &&
            this._validate(no, `layers.${this.id}.paint.${t}`, t, e, i)
          )
            return !1;
          if (t.endsWith(Wo))
            return (
              this._transitionablePaint.setTransition(
                t.slice(0, -11),
                e || void 0
              ),
              !1
            );
          {
            const i = this._transitionablePaint._values[t],
              r =
                'cross-faded-data-driven' ===
                i.property.specification['property-type'],
              n = i.value.isDataDriven(),
              o = i.value;
            this._transitionablePaint.setValue(t, e),
              this._handleSpecialPaintPropertyUpdate(t);
            const a = this._transitionablePaint._values[t].value;
            return (
              a.isDataDriven() ||
              n ||
              r ||
              this._handleOverridablePaintPropertyUpdate(t, o, a)
            );
          }
        }
        _handleSpecialPaintPropertyUpdate(t) {}
        _handleOverridablePaintPropertyUpdate(t, e, i) {
          return !1;
        }
        isHidden(t, e = !1) {
          return (
            !!(
              this.minzoom && t < (e ? Math.floor(this.minzoom) : this.minzoom)
            ) ||
            !!(this.maxzoom && t >= this.maxzoom) ||
            'none' === this.visibility
          );
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(
            t,
            this._transitioningPaint
          );
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, e) {
          t.getCrossfadeParameters &&
            (this._crossfadeParameters = t.getCrossfadeParameters()),
            this._unevaluatedLayout &&
              (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                t,
                void 0,
                e
              )),
            (this.paint = this._transitioningPaint.possiblyEvaluate(
              t,
              void 0,
              e
            ));
        }
        serialize() {
          const t = {
            'id': this.id,
            'type': this.type,
            'source': this.source,
            'source-layer': this.sourceLayer,
            'metadata': this.metadata,
            'minzoom': this.minzoom,
            'maxzoom': this.maxzoom,
            'filter': this.filter,
            'layout':
              this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
            'paint':
              this._transitionablePaint &&
              this._transitionablePaint.serialize(),
          };
          return (
            this.visibility &&
              ((t.layout = t.layout || {}),
              (t.layout.visibility = this.visibility)),
            V(
              t,
              (t, e) =>
                !(
                  void 0 === t ||
                  ('layout' === e && !Object.keys(t).length) ||
                  ('paint' === e && !Object.keys(t).length)
                )
            )
          );
        }
        _validate(t, e, i, r, n = {}) {
          return (
            (!n || !1 !== n.validate) &&
            ao(
              this,
              t.call(eo, {
                key: e,
                layerType: this.type,
                objectKey: i,
                value: r,
                styleSpec: xt,
                style: { glyphs: !0, sprite: !0 },
              })
            )
          );
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {}
        isStateDependent() {
          for (const t in this.paint._values) {
            const e = this.paint.get(t);
            if (
              e instanceof jo &&
              Ur(e.property.specification) &&
              ('source' === e.value.kind || 'composite' === e.value.kind) &&
              e.value.isStateDependent
            )
              return !0;
          }
          return !1;
        }
      }
      let Ho;
      var Xo = {
        get paint() {
          return (Ho =
            Ho ||
            new qo({
              'raster-opacity': new Vo(xt.paint_raster['raster-opacity']),
              'raster-hue-rotate': new Vo(xt.paint_raster['raster-hue-rotate']),
              'raster-brightness-min': new Vo(
                xt.paint_raster['raster-brightness-min']
              ),
              'raster-brightness-max': new Vo(
                xt.paint_raster['raster-brightness-max']
              ),
              'raster-saturation': new Vo(xt.paint_raster['raster-saturation']),
              'raster-contrast': new Vo(xt.paint_raster['raster-contrast']),
              'raster-resampling': new Vo(xt.paint_raster['raster-resampling']),
              'raster-fade-duration': new Vo(
                xt.paint_raster['raster-fade-duration']
              ),
            }));
        },
      };
      class Ko extends Yo {
        constructor(t, e) {
          super(t, Xo, e);
        }
      }
      const Jo = {
        Int8: Int8Array,
        Uint8: Uint8Array,
        Int16: Int16Array,
        Uint16: Uint16Array,
        Int32: Int32Array,
        Uint32: Uint32Array,
        Float32: Float32Array,
      };
      class Qo {
        constructor(t, e) {
          (this._structArray = t),
            (this._pos1 = e * this.size),
            (this._pos2 = this._pos1 / 2),
            (this._pos4 = this._pos1 / 4),
            (this._pos8 = this._pos1 / 8);
        }
      }
      class ta {
        constructor() {
          (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
        }
        static serialize(t, e) {
          return (
            t._trim(),
            e && ((t.isTransferred = !0), e.push(t.arrayBuffer)),
            { length: t.length, arrayBuffer: t.arrayBuffer }
          );
        }
        static deserialize(t) {
          const e = Object.create(this.prototype);
          return (
            (e.arrayBuffer = t.arrayBuffer),
            (e.length = t.length),
            (e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement),
            e._refreshViews(),
            e
          );
        }
        _trim() {
          this.length !== this.capacity &&
            ((this.capacity = this.length),
            (this.arrayBuffer = this.arrayBuffer.slice(
              0,
              this.length * this.bytesPerElement
            )),
            this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          this.reserve(t), (this.length = t);
        }
        reserve(t) {
          if (t > this.capacity) {
            (this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128)),
              (this.arrayBuffer = new ArrayBuffer(
                this.capacity * this.bytesPerElement
              ));
            const e = this.uint8;
            this._refreshViews(), e && this.uint8.set(e);
          }
        }
        _refreshViews() {
          throw new Error(
            '_refreshViews() must be implemented by each concrete StructArray layout'
          );
        }
      }
      function ea(t, e = 1) {
        let i = 0,
          r = 0;
        return {
          members: t.map((t) => {
            const n = Jo[t.type].BYTES_PER_ELEMENT,
              o = (i = ia(i, Math.max(e, n))),
              a = t.components || 1;
            return (
              (r = Math.max(r, n)),
              (i += n * a),
              { name: t.name, type: t.type, components: a, offset: o }
            );
          }),
          size: ia(i, Math.max(r, e)),
          alignment: e,
        };
      }
      function ia(t, e) {
        return Math.ceil(t / e) * e;
      }
      class ra extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t, e);
        }
        emplace(t, e, i) {
          const r = 2 * t;
          return (this.int16[r + 0] = e), (this.int16[r + 1] = i), t;
        }
      }
      (ra.prototype.bytesPerElement = 4), co('StructArrayLayout2i4', ra);
      class na extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, e, i);
        }
        emplace(t, e, i, r) {
          const n = 3 * t;
          return (
            (this.int16[n + 0] = e),
            (this.int16[n + 1] = i),
            (this.int16[n + 2] = r),
            t
          );
        }
      }
      (na.prototype.bytesPerElement = 6), co('StructArrayLayout3i6', na);
      class oa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t, e, i, r);
        }
        emplace(t, e, i, r, n) {
          const o = 4 * t;
          return (
            (this.int16[o + 0] = e),
            (this.int16[o + 1] = i),
            (this.int16[o + 2] = r),
            (this.int16[o + 3] = n),
            t
          );
        }
      }
      (oa.prototype.bytesPerElement = 8), co('StructArrayLayout4i8', oa);
      class aa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, e, i, r, n, o);
        }
        emplace(t, e, i, r, n, o, a) {
          const s = 6 * t;
          return (
            (this.int16[s + 0] = e),
            (this.int16[s + 1] = i),
            (this.int16[s + 2] = r),
            (this.int16[s + 3] = n),
            (this.int16[s + 4] = o),
            (this.int16[s + 5] = a),
            t
          );
        }
      }
      (aa.prototype.bytesPerElement = 12), co('StructArrayLayout2i4i12', aa);
      class sa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, e, i, r, n, o);
        }
        emplace(t, e, i, r, n, o, a) {
          const s = 4 * t,
            l = 8 * t;
          return (
            (this.int16[s + 0] = e),
            (this.int16[s + 1] = i),
            (this.uint8[l + 4] = r),
            (this.uint8[l + 5] = n),
            (this.uint8[l + 6] = o),
            (this.uint8[l + 7] = a),
            t
          );
        }
      }
      (sa.prototype.bytesPerElement = 8), co('StructArrayLayout2i4ub8', sa);
      class la extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t, e);
        }
        emplace(t, e, i) {
          const r = 2 * t;
          return (this.float32[r + 0] = e), (this.float32[r + 1] = i), t;
        }
      }
      (la.prototype.bytesPerElement = 8), co('StructArrayLayout2f8', la);
      class ca extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o, a, s, l, c) {
          const h = this.length;
          return (
            this.resize(h + 1), this.emplace(h, t, e, i, r, n, o, a, s, l, c)
          );
        }
        emplace(t, e, i, r, n, o, a, s, l, c, h) {
          const u = 10 * t;
          return (
            (this.uint16[u + 0] = e),
            (this.uint16[u + 1] = i),
            (this.uint16[u + 2] = r),
            (this.uint16[u + 3] = n),
            (this.uint16[u + 4] = o),
            (this.uint16[u + 5] = a),
            (this.uint16[u + 6] = s),
            (this.uint16[u + 7] = l),
            (this.uint16[u + 8] = c),
            (this.uint16[u + 9] = h),
            t
          );
        }
      }
      (ca.prototype.bytesPerElement = 20), co('StructArrayLayout10ui20', ca);
      class ha extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o, a, s) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, t, e, i, r, n, o, a, s);
        }
        emplace(t, e, i, r, n, o, a, s, l) {
          const c = 8 * t;
          return (
            (this.uint16[c + 0] = e),
            (this.uint16[c + 1] = i),
            (this.uint16[c + 2] = r),
            (this.uint16[c + 3] = n),
            (this.uint16[c + 4] = o),
            (this.uint16[c + 5] = a),
            (this.uint16[c + 6] = s),
            (this.uint16[c + 7] = l),
            t
          );
        }
      }
      (ha.prototype.bytesPerElement = 16), co('StructArrayLayout8ui16', ha);
      class ua extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o, a, s, l, c, h, u) {
          const d = this.length;
          return (
            this.resize(d + 1),
            this.emplace(d, t, e, i, r, n, o, a, s, l, c, h, u)
          );
        }
        emplace(t, e, i, r, n, o, a, s, l, c, h, u, d) {
          const p = 12 * t;
          return (
            (this.int16[p + 0] = e),
            (this.int16[p + 1] = i),
            (this.int16[p + 2] = r),
            (this.int16[p + 3] = n),
            (this.uint16[p + 4] = o),
            (this.uint16[p + 5] = a),
            (this.uint16[p + 6] = s),
            (this.uint16[p + 7] = l),
            (this.int16[p + 8] = c),
            (this.int16[p + 9] = h),
            (this.int16[p + 10] = u),
            (this.int16[p + 11] = d),
            t
          );
        }
      }
      (ua.prototype.bytesPerElement = 24), co('StructArrayLayout4i4ui4i24', ua);
      class da extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, e, i);
        }
        emplace(t, e, i, r) {
          const n = 3 * t;
          return (
            (this.float32[n + 0] = e),
            (this.float32[n + 1] = i),
            (this.float32[n + 2] = r),
            t
          );
        }
      }
      (da.prototype.bytesPerElement = 12), co('StructArrayLayout3f12', da);
      class pa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const e = this.length;
          return this.resize(e + 1), this.emplace(e, t);
        }
        emplace(t, e) {
          return (this.uint32[1 * t + 0] = e), t;
        }
      }
      (pa.prototype.bytesPerElement = 4), co('StructArrayLayout1ul4', pa);
      class fa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o, a, s, l) {
          const c = this.length;
          return this.resize(c + 1), this.emplace(c, t, e, i, r, n, o, a, s, l);
        }
        emplace(t, e, i, r, n, o, a, s, l, c) {
          const h = 10 * t,
            u = 5 * t;
          return (
            (this.int16[h + 0] = e),
            (this.int16[h + 1] = i),
            (this.int16[h + 2] = r),
            (this.int16[h + 3] = n),
            (this.int16[h + 4] = o),
            (this.int16[h + 5] = a),
            (this.uint32[u + 3] = s),
            (this.uint16[h + 8] = l),
            (this.uint16[h + 9] = c),
            t
          );
        }
      }
      (fa.prototype.bytesPerElement = 20),
        co('StructArrayLayout6i1ul2ui20', fa);
      class ma extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, e, i, r, n, o);
        }
        emplace(t, e, i, r, n, o, a) {
          const s = 6 * t;
          return (
            (this.int16[s + 0] = e),
            (this.int16[s + 1] = i),
            (this.int16[s + 2] = r),
            (this.int16[s + 3] = n),
            (this.int16[s + 4] = o),
            (this.int16[s + 5] = a),
            t
          );
        }
      }
      (ma.prototype.bytesPerElement = 12), co('StructArrayLayout2i2i2i12', ma);
      class _a extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, e, i, r, n);
        }
        emplace(t, e, i, r, n, o) {
          const a = 4 * t,
            s = 8 * t;
          return (
            (this.float32[a + 0] = e),
            (this.float32[a + 1] = i),
            (this.float32[a + 2] = r),
            (this.int16[s + 6] = n),
            (this.int16[s + 7] = o),
            t
          );
        }
      }
      (_a.prototype.bytesPerElement = 16), co('StructArrayLayout2f1f2i16', _a);
      class ga extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, e, i, r, n, o);
        }
        emplace(t, e, i, r, n, o, a) {
          const s = 16 * t,
            l = 4 * t,
            c = 8 * t;
          return (
            (this.uint8[s + 0] = e),
            (this.uint8[s + 1] = i),
            (this.float32[l + 1] = r),
            (this.float32[l + 2] = n),
            (this.int16[c + 6] = o),
            (this.int16[c + 7] = a),
            t
          );
        }
      }
      (ga.prototype.bytesPerElement = 16), co('StructArrayLayout2ub2f2i16', ga);
      class ya extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, e, i);
        }
        emplace(t, e, i, r) {
          const n = 3 * t;
          return (
            (this.uint16[n + 0] = e),
            (this.uint16[n + 1] = i),
            (this.uint16[n + 2] = r),
            t
          );
        }
      }
      (ya.prototype.bytesPerElement = 6), co('StructArrayLayout3ui6', ya);
      class xa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r, n, o, a, s, l, c, h, u, d, p, f, m, _) {
          const g = this.length;
          return (
            this.resize(g + 1),
            this.emplace(g, t, e, i, r, n, o, a, s, l, c, h, u, d, p, f, m, _)
          );
        }
        emplace(t, e, i, r, n, o, a, s, l, c, h, u, d, p, f, m, _, g) {
          const y = 24 * t,
            x = 12 * t,
            v = 48 * t;
          return (
            (this.int16[y + 0] = e),
            (this.int16[y + 1] = i),
            (this.uint16[y + 2] = r),
            (this.uint16[y + 3] = n),
            (this.uint32[x + 2] = o),
            (this.uint32[x + 3] = a),
            (this.uint32[x + 4] = s),
            (this.uint16[y + 10] = l),
            (this.uint16[y + 11] = c),
            (this.uint16[y + 12] = h),
            (this.float32[x + 7] = u),
            (this.float32[x + 8] = d),
            (this.uint8[v + 36] = p),
            (this.uint8[v + 37] = f),
            (this.uint8[v + 38] = m),
            (this.uint32[x + 10] = _),
            (this.int16[y + 22] = g),
            t
          );
        }
      }
      (xa.prototype.bytesPerElement = 48),
        co('StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48', xa);
      class va extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.int16 = new Int16Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(
          t,
          e,
          i,
          r,
          n,
          o,
          a,
          s,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m,
          _,
          g,
          y,
          x,
          v,
          b,
          w,
          T,
          P,
          S,
          M,
          I
        ) {
          const C = this.length;
          return (
            this.resize(C + 1),
            this.emplace(
              C,
              t,
              e,
              i,
              r,
              n,
              o,
              a,
              s,
              l,
              c,
              h,
              u,
              d,
              p,
              f,
              m,
              _,
              g,
              y,
              x,
              v,
              b,
              w,
              T,
              P,
              S,
              M,
              I
            )
          );
        }
        emplace(
          t,
          e,
          i,
          r,
          n,
          o,
          a,
          s,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m,
          _,
          g,
          y,
          x,
          v,
          b,
          w,
          T,
          P,
          S,
          M,
          I,
          C
        ) {
          const A = 32 * t,
            E = 16 * t;
          return (
            (this.int16[A + 0] = e),
            (this.int16[A + 1] = i),
            (this.int16[A + 2] = r),
            (this.int16[A + 3] = n),
            (this.int16[A + 4] = o),
            (this.int16[A + 5] = a),
            (this.int16[A + 6] = s),
            (this.int16[A + 7] = l),
            (this.uint16[A + 8] = c),
            (this.uint16[A + 9] = h),
            (this.uint16[A + 10] = u),
            (this.uint16[A + 11] = d),
            (this.uint16[A + 12] = p),
            (this.uint16[A + 13] = f),
            (this.uint16[A + 14] = m),
            (this.uint16[A + 15] = _),
            (this.uint16[A + 16] = g),
            (this.uint16[A + 17] = y),
            (this.uint16[A + 18] = x),
            (this.uint16[A + 19] = v),
            (this.uint16[A + 20] = b),
            (this.uint16[A + 21] = w),
            (this.uint16[A + 22] = T),
            (this.uint32[E + 12] = P),
            (this.float32[E + 13] = S),
            (this.float32[E + 14] = M),
            (this.uint16[A + 30] = I),
            (this.uint16[A + 31] = C),
            t
          );
        }
      }
      (va.prototype.bytesPerElement = 64),
        co('StructArrayLayout8i15ui1ul2f2ui64', va);
      class ba extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const e = this.length;
          return this.resize(e + 1), this.emplace(e, t);
        }
        emplace(t, e) {
          return (this.float32[1 * t + 0] = e), t;
        }
      }
      (ba.prototype.bytesPerElement = 4), co('StructArrayLayout1f4', ba);
      class wa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, e, i);
        }
        emplace(t, e, i, r) {
          const n = 3 * t;
          return (
            (this.uint16[6 * t + 0] = e),
            (this.float32[n + 1] = i),
            (this.float32[n + 2] = r),
            t
          );
        }
      }
      (wa.prototype.bytesPerElement = 12), co('StructArrayLayout1ui2f12', wa);
      class Ta extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint32 = new Uint32Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, e, i);
        }
        emplace(t, e, i, r) {
          const n = 4 * t;
          return (
            (this.uint32[2 * t + 0] = e),
            (this.uint16[n + 2] = i),
            (this.uint16[n + 3] = r),
            t
          );
        }
      }
      (Ta.prototype.bytesPerElement = 8), co('StructArrayLayout1ul2ui8', Ta);
      class Pa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, e) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t, e);
        }
        emplace(t, e, i) {
          const r = 2 * t;
          return (this.uint16[r + 0] = e), (this.uint16[r + 1] = i), t;
        }
      }
      (Pa.prototype.bytesPerElement = 4), co('StructArrayLayout2ui4', Pa);
      class Sa extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const e = this.length;
          return this.resize(e + 1), this.emplace(e, t);
        }
        emplace(t, e) {
          return (this.uint16[1 * t + 0] = e), t;
        }
      }
      (Sa.prototype.bytesPerElement = 2), co('StructArrayLayout1ui2', Sa);
      class Ma extends ta {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)),
            (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, e, i, r) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t, e, i, r);
        }
        emplace(t, e, i, r, n) {
          const o = 4 * t;
          return (
            (this.float32[o + 0] = e),
            (this.float32[o + 1] = i),
            (this.float32[o + 2] = r),
            (this.float32[o + 3] = n),
            t
          );
        }
      }
      (Ma.prototype.bytesPerElement = 16), co('StructArrayLayout4f16', Ma);
      class Ia extends Qo {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new i(this.anchorPointX, this.anchorPointY);
        }
      }
      Ia.prototype.size = 20;
      class Ca extends fa {
        get(t) {
          return new Ia(this, t);
        }
      }
      co('CollisionBoxArray', Ca);
      class Aa extends Qo {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 37] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 38] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 10] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Aa.prototype.size = 48;
      class Ea extends xa {
        get(t) {
          return new Aa(this, t);
        }
      }
      co('PlacedSymbolArray', Ea);
      class za extends Qo {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 12] = t;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      za.prototype.size = 64;
      class ka extends va {
        get(t) {
          return new za(this, t);
        }
      }
      co('SymbolInstanceArray', ka);
      class Da extends ba {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      co('GlyphOffsetArray', Da);
      class Ra extends na {
        getx(t) {
          return this.int16[3 * t + 0];
        }
        gety(t) {
          return this.int16[3 * t + 1];
        }
        gettileUnitDistanceFromAnchor(t) {
          return this.int16[3 * t + 2];
        }
      }
      co('SymbolLineVertexArray', Ra);
      class La extends Qo {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      La.prototype.size = 12;
      class Fa extends wa {
        get(t) {
          return new La(this, t);
        }
      }
      co('TextAnchorOffsetArray', Fa);
      class Ba extends Qo {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Ba.prototype.size = 8;
      class Oa extends Ta {
        get(t) {
          return new Ba(this, t);
        }
      }
      co('FeatureIndexArray', Oa);
      class ja extends ra {}
      class Na extends ra {}
      class Va extends ra {}
      class Ua extends aa {}
      class Ga extends sa {}
      class Za extends la {}
      class $a extends ca {}
      class qa extends ha {}
      class Wa extends ua {}
      class Ya extends da {}
      class Ha extends pa {}
      class Xa extends ma {}
      class Ka extends ga {}
      class Ja extends ya {}
      class Qa extends Pa {}
      const ts = ea([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
        { members: es } = ts;
      class is {
        constructor(t = []) {
          (this._forceNewSegmentOnNextPrepare = !1), (this.segments = t);
        }
        prepareSegment(t, e, i, r) {
          const n = this.segments[this.segments.length - 1];
          return (
            t > is.MAX_VERTEX_ARRAY_LENGTH &&
              Z(
                `Max vertices per segment is ${is.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${is.MAX_VERTEX_ARRAY_LENGTH} vertices.`
              ),
            this._forceNewSegmentOnNextPrepare ||
            !n ||
            n.vertexLength + t > is.MAX_VERTEX_ARRAY_LENGTH ||
            n.sortKey !== r
              ? this.createNewSegment(e, i, r)
              : n
          );
        }
        createNewSegment(t, e, i) {
          const r = {
            vertexOffset: t.length,
            primitiveOffset: e.length,
            vertexLength: 0,
            primitiveLength: 0,
            vaos: {},
          };
          return (
            void 0 !== i && (r.sortKey = i),
            (this._forceNewSegmentOnNextPrepare = !1),
            this.segments.push(r),
            r
          );
        }
        getOrCreateLatestSegment(t, e, i) {
          return this.prepareSegment(0, t, e, i);
        }
        forceNewSegmentOnNextPrepare() {
          this._forceNewSegmentOnNextPrepare = !0;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments)
            for (const e in t.vaos) t.vaos[e].destroy();
        }
        static simpleSegment(t, e, i, r) {
          return new is([
            {
              vertexOffset: t,
              primitiveOffset: e,
              vertexLength: i,
              primitiveLength: r,
              vaos: {},
              sortKey: 0,
            },
          ]);
        }
      }
      function rs(t, e) {
        return 256 * (t = F(Math.floor(t), 0, 255)) + F(Math.floor(e), 0, 255);
      }
      (is.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
        co('SegmentVector', is);
      const ns = ea([
          { name: 'a_pattern_from', components: 4, type: 'Uint16' },
          { name: 'a_pattern_to', components: 4, type: 'Uint16' },
          { name: 'a_pixel_ratio_from', components: 1, type: 'Uint16' },
          { name: 'a_pixel_ratio_to', components: 1, type: 'Uint16' },
        ]),
        os = ea([
          { name: 'a_dasharray_from', components: 4, type: 'Uint16' },
          { name: 'a_dasharray_to', components: 4, type: 'Uint16' },
        ]);
      var as,
        ss,
        ls,
        cs = { exports: {} },
        hs = { exports: {} },
        us = { exports: {} },
        ds = (function () {
          if (ls) return cs.exports;
          ls = 1;
          var t =
              (as ||
                ((as = 1),
                (hs.exports = function (t, e) {
                  var i, r, n, o, a, s, l, c;
                  for (
                    r = t.length - (i = 3 & t.length),
                      n = e,
                      a = 3432918353,
                      s = 461845907,
                      c = 0;
                    c < r;

                  )
                    (l =
                      (255 & t.charCodeAt(c)) |
                      ((255 & t.charCodeAt(++c)) << 8) |
                      ((255 & t.charCodeAt(++c)) << 16) |
                      ((255 & t.charCodeAt(++c)) << 24)),
                      ++c,
                      (n =
                        27492 +
                        (65535 &
                          (o =
                            (5 *
                              (65535 &
                                (n =
                                  ((n ^= l =
                                    ((65535 &
                                      (l =
                                        ((l =
                                          ((65535 & l) * a +
                                            ((((l >>> 16) * a) & 65535) <<
                                              16)) &
                                          4294967295) <<
                                          15) |
                                        (l >>> 17))) *
                                      s +
                                      ((((l >>> 16) * s) & 65535) << 16)) &
                                    4294967295) <<
                                    13) |
                                  (n >>> 19))) +
                              (((5 * (n >>> 16)) & 65535) << 16)) &
                            4294967295)) +
                        (((58964 + (o >>> 16)) & 65535) << 16));
                  switch (((l = 0), i)) {
                    case 3:
                      l ^= (255 & t.charCodeAt(c + 2)) << 16;
                    case 2:
                      l ^= (255 & t.charCodeAt(c + 1)) << 8;
                    case 1:
                      n ^= l =
                        ((65535 &
                          (l =
                            ((l =
                              ((65535 & (l ^= 255 & t.charCodeAt(c))) * a +
                                ((((l >>> 16) * a) & 65535) << 16)) &
                              4294967295) <<
                              15) |
                            (l >>> 17))) *
                          s +
                          ((((l >>> 16) * s) & 65535) << 16)) &
                        4294967295;
                  }
                  return (
                    (n ^= t.length),
                    (n =
                      (2246822507 * (65535 & (n ^= n >>> 16)) +
                        (((2246822507 * (n >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (n =
                      (3266489909 * (65535 & (n ^= n >>> 13)) +
                        (((3266489909 * (n >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (n ^= n >>> 16) >>> 0
                  );
                })),
              hs.exports),
            e =
              (ss ||
                ((ss = 1),
                (us.exports = function (t, e) {
                  for (var i, r = t.length, n = e ^ r, o = 0; r >= 4; )
                    (i =
                      1540483477 *
                        (65535 &
                          (i =
                            (255 & t.charCodeAt(o)) |
                            ((255 & t.charCodeAt(++o)) << 8) |
                            ((255 & t.charCodeAt(++o)) << 16) |
                            ((255 & t.charCodeAt(++o)) << 24))) +
                      (((1540483477 * (i >>> 16)) & 65535) << 16)),
                      (n =
                        (1540483477 * (65535 & n) +
                          (((1540483477 * (n >>> 16)) & 65535) << 16)) ^
                        (i =
                          1540483477 * (65535 & (i ^= i >>> 24)) +
                          (((1540483477 * (i >>> 16)) & 65535) << 16))),
                      (r -= 4),
                      ++o;
                  switch (r) {
                    case 3:
                      n ^= (255 & t.charCodeAt(o + 2)) << 16;
                    case 2:
                      n ^= (255 & t.charCodeAt(o + 1)) << 8;
                    case 1:
                      n =
                        1540483477 * (65535 & (n ^= 255 & t.charCodeAt(o))) +
                        (((1540483477 * (n >>> 16)) & 65535) << 16);
                  }
                  return (
                    (n =
                      1540483477 * (65535 & (n ^= n >>> 13)) +
                      (((1540483477 * (n >>> 16)) & 65535) << 16)),
                    (n ^= n >>> 15) >>> 0
                  );
                })),
              us.exports);
          return (
            (cs.exports = t),
            (cs.exports.murmur3 = t),
            (cs.exports.murmur2 = e),
            cs.exports
          );
        })(),
        ps = r(ds);
      class fs {
        constructor() {
          (this.ids = []), (this.positions = []), (this.indexed = !1);
        }
        add(t, e, i, r) {
          this.ids.push(ms(t)), this.positions.push(e, i, r);
        }
        getPositions(t) {
          if (!this.indexed)
            throw new Error(
              'Trying to get index, but feature positions are not indexed'
            );
          const e = ms(t);
          let i = 0,
            r = this.ids.length - 1;
          for (; i < r; ) {
            const t = (i + r) >> 1;
            this.ids[t] >= e ? (r = t) : (i = t + 1);
          }
          const n = [];
          for (; this.ids[i] === e; )
            n.push({
              index: this.positions[3 * i],
              start: this.positions[3 * i + 1],
              end: this.positions[3 * i + 2],
            }),
              i++;
          return n;
        }
        static serialize(t, e) {
          const i = new Float64Array(t.ids),
            r = new Uint32Array(t.positions);
          return (
            _s(i, r, 0, i.length - 1),
            e && e.push(i.buffer, r.buffer),
            { ids: i, positions: r }
          );
        }
        static deserialize(t) {
          const e = new fs();
          return (
            (e.ids = t.ids), (e.positions = t.positions), (e.indexed = !0), e
          );
        }
      }
      function ms(t) {
        const e = +t;
        return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : ps(String(t));
      }
      function _s(t, e, i, r) {
        for (; i < r; ) {
          const n = t[(i + r) >> 1];
          let o = i - 1,
            a = r + 1;
          for (;;) {
            do {
              o++;
            } while (t[o] < n);
            do {
              a--;
            } while (t[a] > n);
            if (o >= a) break;
            gs(t, o, a),
              gs(e, 3 * o, 3 * a),
              gs(e, 3 * o + 1, 3 * a + 1),
              gs(e, 3 * o + 2, 3 * a + 2);
          }
          a - i < r - a
            ? (_s(t, e, i, a), (i = a + 1))
            : (_s(t, e, a + 1, r), (r = a));
        }
      }
      function gs(t, e, i) {
        const r = t[e];
        (t[e] = t[i]), (t[i] = r);
      }
      co('FeaturePositionMap', fs);
      class ys {
        constructor(t, e) {
          (this.gl = t.gl), (this.location = e);
        }
      }
      class xs extends ys {
        constructor(t, e) {
          super(t, e), (this.current = 0);
        }
        set(t) {
          this.current !== t &&
            ((this.current = t), this.gl.uniform1f(this.location, t));
        }
      }
      class vs extends ys {
        constructor(t, e) {
          super(t, e), (this.current = [0, 0, 0, 0]);
        }
        set(t) {
          (t[0] === this.current[0] &&
            t[1] === this.current[1] &&
            t[2] === this.current[2] &&
            t[3] === this.current[3]) ||
            ((this.current = t),
            this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
        }
      }
      class bs extends ys {
        constructor(t, e) {
          super(t, e), (this.current = Ie.transparent);
        }
        set(t) {
          (t.r === this.current.r &&
            t.g === this.current.g &&
            t.b === this.current.b &&
            t.a === this.current.a) ||
            ((this.current = t),
            this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
        }
      }
      const ws = new Float32Array(16);
      function Ts(t) {
        return [rs(255 * t.r, 255 * t.g), rs(255 * t.b, 255 * t.a)];
      }
      class Ps {
        constructor(t, e, i) {
          (this.value = t),
            (this.uniformNames = e.map((t) => `u_${t}`)),
            (this.type = i);
        }
        setUniform(t, e, i) {
          t.set(i.constantOr(this.value));
        }
        getBinding(t, e, i) {
          return 'color' === this.type ? new bs(t, e) : new xs(t, e);
        }
      }
      class Ss {
        constructor(t, e) {
          (this.uniformNames = e.map((t) => `u_${t}`)),
            (this.patternFrom = null),
            (this.patternTo = null),
            (this.pixelRatioFrom = 1),
            (this.pixelRatioTo = 1);
        }
        setConstantPatternPositions(t, e) {
          (this.pixelRatioFrom = e.pixelRatio),
            (this.pixelRatioTo = t.pixelRatio),
            (this.patternFrom = e.tlbr),
            (this.patternTo = t.tlbr);
        }
        setConstantDashPositions(t, e) {
          (this.dashTo = [0, t.y, t.height, t.width]),
            (this.dashFrom = [0, e.y, e.height, e.width]);
        }
        setUniform(t, e, i, r) {
          let n = null;
          'u_pattern_to' === r
            ? (n = this.patternTo)
            : 'u_pattern_from' === r
            ? (n = this.patternFrom)
            : 'u_dasharray_to' === r
            ? (n = this.dashTo)
            : 'u_dasharray_from' === r
            ? (n = this.dashFrom)
            : 'u_pixel_ratio_to' === r
            ? (n = this.pixelRatioTo)
            : 'u_pixel_ratio_from' === r && (n = this.pixelRatioFrom),
            null !== n && t.set(n);
        }
        getBinding(t, e, i) {
          return 'u_pattern' === i.substr(0, 9) ||
            'u_dasharray_' === i.substr(0, 12)
            ? new vs(t, e)
            : new xs(t, e);
        }
      }
      class Ms {
        constructor(t, e, i, r) {
          (this.expression = t),
            (this.type = i),
            (this.maxValue = 0),
            (this.paintVertexAttributes = e.map((t) => ({
              name: `a_${t}`,
              type: 'Float32',
              components: 'color' === i ? 2 : 1,
              offset: 0,
            }))),
            (this.paintVertexArray = new r());
        }
        populatePaintArray(t, e, i) {
          const r = this.paintVertexArray.length,
            n = this.expression.evaluate(
              new zo(0, i),
              e,
              {},
              i.canonical,
              [],
              i.formattedSection
            );
          this.paintVertexArray.resize(t), this._setPaintValue(r, t, n);
        }
        updatePaintArray(t, e, i, r, n) {
          const o = this.expression.evaluate(new zo(0, n), i, r);
          this._setPaintValue(t, e, o);
        }
        _setPaintValue(t, e, i) {
          if ('color' === this.type) {
            const r = Ts(i);
            for (let i = t; i < e; i++)
              this.paintVertexArray.emplace(i, r[0], r[1]);
          } else {
            for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i);
            this.maxValue = Math.max(this.maxValue, Math.abs(i));
          }
        }
        upload(t) {
          this.paintVertexArray &&
            this.paintVertexArray.arrayBuffer &&
            (this.paintVertexBuffer && this.paintVertexBuffer.buffer
              ? this.paintVertexBuffer.updateData(this.paintVertexArray)
              : (this.paintVertexBuffer = t.createVertexBuffer(
                  this.paintVertexArray,
                  this.paintVertexAttributes,
                  this.expression.isStateDependent
                )));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Is {
        constructor(t, e, i, r, n, o) {
          (this.expression = t),
            (this.uniformNames = e.map((t) => `u_${t}_t`)),
            (this.type = i),
            (this.useIntegerZoom = r),
            (this.zoom = n),
            (this.maxValue = 0),
            (this.paintVertexAttributes = e.map((t) => ({
              name: `a_${t}`,
              type: 'Float32',
              components: 'color' === i ? 4 : 2,
              offset: 0,
            }))),
            (this.paintVertexArray = new o());
        }
        populatePaintArray(t, e, i) {
          const r = this.expression.evaluate(
              new zo(this.zoom, i),
              e,
              {},
              i.canonical,
              [],
              i.formattedSection
            ),
            n = this.expression.evaluate(
              new zo(this.zoom + 1, i),
              e,
              {},
              i.canonical,
              [],
              i.formattedSection
            ),
            o = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValue(o, t, r, n);
        }
        updatePaintArray(t, e, i, r, n) {
          const o = this.expression.evaluate(new zo(this.zoom, n), i, r),
            a = this.expression.evaluate(new zo(this.zoom + 1, n), i, r);
          this._setPaintValue(t, e, o, a);
        }
        _setPaintValue(t, e, i, r) {
          if ('color' === this.type) {
            const n = Ts(i),
              o = Ts(r);
            for (let i = t; i < e; i++)
              this.paintVertexArray.emplace(i, n[0], n[1], o[0], o[1]);
          } else {
            for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, i, r);
            this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(r));
          }
        }
        upload(t) {
          this.paintVertexArray &&
            this.paintVertexArray.arrayBuffer &&
            (this.paintVertexBuffer && this.paintVertexBuffer.buffer
              ? this.paintVertexBuffer.updateData(this.paintVertexArray)
              : (this.paintVertexBuffer = t.createVertexBuffer(
                  this.paintVertexArray,
                  this.paintVertexAttributes,
                  this.expression.isStateDependent
                )));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, e) {
          const i = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,
            r = F(
              this.expression.interpolationFactor(i, this.zoom, this.zoom + 1),
              0,
              1
            );
          t.set(r);
        }
        getBinding(t, e, i) {
          return new xs(t, e);
        }
      }
      class Cs {
        constructor(t, e, i, r, n, o) {
          (this.expression = t),
            (this.type = e),
            (this.useIntegerZoom = i),
            (this.zoom = r),
            (this.layerId = o),
            (this.zoomInPaintVertexArray = new n()),
            (this.zoomOutPaintVertexArray = new n());
        }
        populatePaintArray(t, e, i) {
          const r = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t),
            this.zoomOutPaintVertexArray.resize(t),
            this._setPaintValues(r, t, this.getPositionIds(e), i);
        }
        updatePaintArray(t, e, i, r, n) {
          this._setPaintValues(t, e, this.getPositionIds(i), n);
        }
        _setPaintValues(t, e, i, r) {
          const n = this.getPositions(r);
          if (!n || !i) return;
          const o = n[i.min],
            a = n[i.mid],
            s = n[i.max];
          if (o && a && s)
            for (let l = t; l < e; l++)
              this.emplace(this.zoomInPaintVertexArray, l, a, o),
                this.emplace(this.zoomOutPaintVertexArray, l, a, s);
        }
        upload(t) {
          if (
            this.zoomInPaintVertexArray &&
            this.zoomInPaintVertexArray.arrayBuffer &&
            this.zoomOutPaintVertexArray &&
            this.zoomOutPaintVertexArray.arrayBuffer
          ) {
            const e = this.getVertexAttributes();
            (this.zoomInPaintVertexBuffer = t.createVertexBuffer(
              this.zoomInPaintVertexArray,
              e,
              this.expression.isStateDependent
            )),
              (this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
                this.zoomOutPaintVertexArray,
                e,
                this.expression.isStateDependent
              ));
          }
        }
        destroy() {
          this.zoomOutPaintVertexBuffer &&
            this.zoomOutPaintVertexBuffer.destroy(),
            this.zoomInPaintVertexBuffer &&
              this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class As extends Cs {
        getPositions(t) {
          return t.imagePositions;
        }
        getPositionIds(t) {
          return t.patterns && t.patterns[this.layerId];
        }
        getVertexAttributes() {
          return ns.members;
        }
        emplace(t, e, i, r) {
          t.emplace(
            e,
            i.tlbr[0],
            i.tlbr[1],
            i.tlbr[2],
            i.tlbr[3],
            r.tlbr[0],
            r.tlbr[1],
            r.tlbr[2],
            r.tlbr[3],
            i.pixelRatio,
            r.pixelRatio
          );
        }
      }
      class Es extends Cs {
        getPositions(t) {
          return t.dashPositions;
        }
        getPositionIds(t) {
          return t.dashes && t.dashes[this.layerId];
        }
        getVertexAttributes() {
          return os.members;
        }
        emplace(t, e, i, r) {
          t.emplace(e, 0, i.y, i.height, i.width, 0, r.y, r.height, r.width);
        }
      }
      class zs {
        constructor(t, e, i) {
          (this.binders = {}), (this._buffers = []);
          const r = [];
          for (const n in t.paint._values) {
            if (!i(n)) continue;
            const o = t.paint.get(n);
            if (!(o instanceof jo && Ur(o.property.specification))) continue;
            const a = Ds(n, t.type),
              s = o.value,
              l = o.property.specification.type,
              c = o.property.useIntegerZoom,
              h = o.property.specification['property-type'],
              u = 'cross-faded' === h || 'cross-faded-data-driven' === h;
            if ('constant' === s.kind)
              (this.binders[n] = u
                ? new Ss(s.value, a)
                : new Ps(s.value, a, l)),
                r.push(`/u_${n}`);
            else if ('source' === s.kind || u) {
              const i = Rs(n, l, 'source');
              (this.binders[n] = u
                ? 'line-dasharray' === n
                  ? new Es(s, l, c, e, i, t.id)
                  : new As(s, l, c, e, i, t.id)
                : new Ms(s, a, l, i)),
                r.push(`/a_${n}`);
            } else {
              const t = Rs(n, l, 'composite');
              (this.binders[n] = new Is(s, a, l, c, e, t)), r.push(`/z_${n}`);
            }
          }
          this.cacheKey = r.sort().join('');
        }
        getMaxValue(t) {
          const e = this.binders[t];
          return e instanceof Ms || e instanceof Is ? e.maxValue : 0;
        }
        populatePaintArrays(t, e, i) {
          for (const r in this.binders) {
            const n = this.binders[r];
            (n instanceof Ms || n instanceof Is || n instanceof Cs) &&
              n.populatePaintArray(t, e, i);
          }
        }
        setConstantPatternPositions(t, e) {
          for (const i in this.binders) {
            const r = this.binders[i];
            r instanceof Ss && r.setConstantPatternPositions(t, e);
          }
        }
        setConstantDashPositions(t, e) {
          for (const i in this.binders) {
            const r = this.binders[i];
            r instanceof Ss && r.setConstantDashPositions(t, e);
          }
        }
        updatePaintArrays(t, e, i, r, n) {
          let o = !1;
          for (const a in t) {
            const s = e.getPositions(a);
            for (const e of s) {
              const s = i.feature(e.index);
              for (const i in this.binders) {
                const l = this.binders[i];
                if (
                  (l instanceof Ms || l instanceof Is || l instanceof Cs) &&
                  !0 === l.expression.isStateDependent
                ) {
                  const c = r.paint.get(i);
                  (l.expression = c.value),
                    l.updatePaintArray(e.start, e.end, s, t[a], n),
                    (o = !0);
                }
              }
            }
          }
          return o;
        }
        defines() {
          const t = [];
          for (const e in this.binders) {
            const i = this.binders[e];
            (i instanceof Ps || i instanceof Ss) &&
              t.push(...i.uniformNames.map((t) => `#define HAS_UNIFORM_${t}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const e in this.binders) {
            const i = this.binders[e];
            if (i instanceof Ms || i instanceof Is)
              for (let e = 0; e < i.paintVertexAttributes.length; e++)
                t.push(i.paintVertexAttributes[e].name);
            else if (i instanceof Cs) {
              const e = i.getVertexAttributes();
              for (const i of e) t.push(i.name);
            }
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const e in this.binders) {
            const i = this.binders[e];
            if (i instanceof Ps || i instanceof Ss || i instanceof Is)
              for (const e of i.uniformNames) t.push(e);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t, e) {
          const i = [];
          for (const r in this.binders) {
            const n = this.binders[r];
            if (n instanceof Ps || n instanceof Ss || n instanceof Is)
              for (const o of n.uniformNames)
                if (e[o]) {
                  const a = n.getBinding(t, e[o], o);
                  i.push({ name: o, property: r, binding: a });
                }
          }
          return i;
        }
        setUniforms(t, e, i, r) {
          for (const { name: n, property: o, binding: a } of e)
            this.binders[o].setUniform(a, r, i.get(o), n);
        }
        updatePaintBuffers(t) {
          this._buffers = [];
          for (const e in this.binders) {
            const i = this.binders[e];
            if (t && i instanceof Cs) {
              const e =
                2 === t.fromScale
                  ? i.zoomInPaintVertexBuffer
                  : i.zoomOutPaintVertexBuffer;
              e && this._buffers.push(e);
            } else
              (i instanceof Ms || i instanceof Is) &&
                i.paintVertexBuffer &&
                this._buffers.push(i.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const e in this.binders) {
            const i = this.binders[e];
            (i instanceof Ms || i instanceof Is || i instanceof Cs) &&
              i.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const e = this.binders[t];
            (e instanceof Ms || e instanceof Is || e instanceof Cs) &&
              e.destroy();
          }
        }
      }
      class ks {
        constructor(t, e, i = () => !0) {
          this.programConfigurations = {};
          for (const r of t) this.programConfigurations[r.id] = new zs(r, e, i);
          (this.needsUpload = !1),
            (this._featureMap = new fs()),
            (this._bufferOffset = 0);
        }
        populatePaintArrays(t, e, i, r) {
          for (const n in this.programConfigurations)
            this.programConfigurations[n].populatePaintArrays(t, e, r);
          void 0 !== e.id &&
            this._featureMap.add(e.id, i, this._bufferOffset, t),
            (this._bufferOffset = t),
            (this.needsUpload = !0);
        }
        updatePaintArrays(t, e, i, r) {
          for (const n of i)
            this.needsUpload =
              this.programConfigurations[n.id].updatePaintArrays(
                t,
                this._featureMap,
                e,
                n,
                r
              ) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const e in this.programConfigurations)
              this.programConfigurations[e].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations)
            this.programConfigurations[t].destroy();
        }
      }
      function Ds(t, e) {
        return (
          {
            'text-opacity': ['opacity'],
            'icon-opacity': ['opacity'],
            'text-color': ['fill_color'],
            'icon-color': ['fill_color'],
            'text-halo-color': ['halo_color'],
            'icon-halo-color': ['halo_color'],
            'text-halo-blur': ['halo_blur'],
            'icon-halo-blur': ['halo_blur'],
            'text-halo-width': ['halo_width'],
            'icon-halo-width': ['halo_width'],
            'line-gap-width': ['gapwidth'],
            'line-dasharray': ['dasharray_to', 'dasharray_from'],
            'line-pattern': [
              'pattern_to',
              'pattern_from',
              'pixel_ratio_to',
              'pixel_ratio_from',
            ],
            'fill-pattern': [
              'pattern_to',
              'pattern_from',
              'pixel_ratio_to',
              'pixel_ratio_from',
            ],
            'fill-extrusion-pattern': [
              'pattern_to',
              'pattern_from',
              'pixel_ratio_to',
              'pixel_ratio_from',
            ],
          }[t] || [t.replace(`${e}-`, '').replace(/-/g, '_')]
        );
      }
      function Rs(t, e, i) {
        const r = {
            color: { source: la, composite: Ma },
            number: { source: ba, composite: la },
          },
          n = (function (t) {
            return {
              'line-pattern': { source: $a, composite: $a },
              'fill-pattern': { source: $a, composite: $a },
              'fill-extrusion-pattern': { source: $a, composite: $a },
              'line-dasharray': { source: qa, composite: qa },
            }[t];
          })(t);
        return (n && n[i]) || r[e][i];
      }
      co('ConstantBinder', Ps),
        co('CrossFadedConstantBinder', Ss),
        co('SourceExpressionBinder', Ms),
        co('CrossFadedPatternBinder', As),
        co('CrossFadedDasharrayBinder', Es),
        co('CompositeExpressionBinder', Is),
        co('ProgramConfiguration', zs, { omit: ['_buffers'] }),
        co('ProgramConfigurationSet', ks);
      const Ls = Math.pow(2, 14) - 1,
        Fs = -Ls - 1;
      function Bs(t) {
        const e = A / t.extent,
          i = t.loadGeometry();
        for (let r = 0; r < i.length; r++) {
          const t = i[r];
          for (let i = 0; i < t.length; i++) {
            const r = t[i],
              n = Math.round(r.x * e),
              o = Math.round(r.y * e);
            (r.x = F(n, Fs, Ls)),
              (r.y = F(o, Fs, Ls)),
              (n < r.x || n > r.x + 1 || o < r.y || o > r.y + 1) &&
                Z(
                  'Geometry exceeds allowed extent, reduce your vector tile buffer size'
                );
          }
        }
        return i;
      }
      function Os(t, e) {
        return {
          type: t.type,
          id: t.id,
          properties: t.properties,
          geometry: e ? Bs(t) : [],
        };
      }
      const js = -32768;
      function Ns(t, e, i, r, n) {
        t.emplaceBack(js + 8 * e + r, js + 8 * i + n);
      }
      class Vs {
        constructor(t) {
          (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((t) => t.id)),
            (this.index = t.index),
            (this.hasDependencies = !1),
            (this.layoutVertexArray = new Na()),
            (this.indexArray = new Ja()),
            (this.segments = new is()),
            (this.programConfigurations = new ks(t.layers, t.zoom)),
            (this.stateDependentLayerIds = this.layers
              .filter((t) => t.isStateDependent())
              .map((t) => t.id));
        }
        populate(t, e, i) {
          const r = this.layers[0],
            n = [];
          let o = null,
            a = !1,
            s = 'heatmap' === r.type;
          if ('circle' === r.type) {
            const t = r;
            (o = t.layout.get('circle-sort-key')),
              (a = !o.isConstant()),
              (s = s || 'map' === t.paint.get('circle-pitch-alignment'));
          }
          const l = s ? e.subdivisionGranularity.circle : 1;
          for (const {
            feature: c,
            id: h,
            index: u,
            sourceLayerIndex: d,
          } of t) {
            const t = this.layers[0]._featureFilter.needGeometry,
              e = Os(c, t);
            if (!this.layers[0]._featureFilter.filter(new zo(this.zoom), e, i))
              continue;
            const r = a ? o.evaluate(e, {}, i) : void 0,
              s = {
                id: h,
                properties: c.properties,
                type: c.type,
                sourceLayerIndex: d,
                index: u,
                geometry: t ? e.geometry : Bs(c),
                patterns: {},
                sortKey: r,
              };
            n.push(s);
          }
          a && n.sort((t, e) => t.sortKey - e.sortKey);
          for (const c of n) {
            const { geometry: r, index: n, sourceLayerIndex: o } = c,
              a = t[n].feature;
            this.addFeature(c, r, n, i, l),
              e.featureIndex.insert(a, r, n, o, this.index);
          }
        }
        update(t, e, i) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              e,
              this.stateDependentLayers,
              { imagePositions: i }
            );
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              es
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy());
        }
        addFeature(t, e, i, r, n = 1) {
          let o;
          switch (n) {
            case 1:
              o = [0, 7];
              break;
            case 3:
              o = [0, 2, 5, 7];
              break;
            case 5:
              o = [0, 1, 3, 4, 6, 7];
              break;
            case 7:
              o = [0, 1, 2, 3, 4, 5, 6, 7];
              break;
            default:
              throw new Error(
                `Invalid circle bucket granularity: ${n}; valid values are 1, 3, 5, 7.`
              );
          }
          const a = o.length;
          for (const s of e)
            for (const e of s) {
              const i = e.x,
                r = e.y;
              if (i < 0 || i >= A || r < 0 || r >= A) continue;
              const n = this.segments.prepareSegment(
                  a * a,
                  this.layoutVertexArray,
                  this.indexArray,
                  t.sortKey
                ),
                s = n.vertexLength;
              for (let t = 0; t < a; t++)
                for (let e = 0; e < a; e++)
                  Ns(this.layoutVertexArray, i, r, o[e], o[t]);
              for (let t = 0; t < a - 1; t++)
                for (let e = 0; e < a - 1; e++) {
                  const i = s + t * a + e,
                    r = s + (t + 1) * a + e;
                  this.indexArray.emplaceBack(i, r + 1, i + 1),
                    this.indexArray.emplaceBack(i, r, r + 1);
                }
              (n.vertexLength += a * a),
                (n.primitiveLength += (a - 1) * (a - 1) * 2);
            }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            i,
            { imagePositions: {}, canonical: r }
          );
        }
      }
      function Us(t, e) {
        for (let i = 0; i < t.length; i++) if (Ks(e, t[i])) return !0;
        for (let i = 0; i < e.length; i++) if (Ks(t, e[i])) return !0;
        return !!qs(t, e);
      }
      function Gs(t, e, i) {
        return !!Ks(t, e) || !!Ys(e, t, i);
      }
      function Zs(t, e) {
        if (1 === t.length) return Xs(e, t[0]);
        for (let i = 0; i < e.length; i++) {
          const r = e[i];
          for (let e = 0; e < r.length; e++) if (Ks(t, r[e])) return !0;
        }
        for (let i = 0; i < t.length; i++) if (Xs(e, t[i])) return !0;
        for (let i = 0; i < e.length; i++) if (qs(t, e[i])) return !0;
        return !1;
      }
      function $s(t, e, i) {
        if (t.length > 1) {
          if (qs(t, e)) return !0;
          for (let r = 0; r < e.length; r++) if (Ys(e[r], t, i)) return !0;
        }
        for (let r = 0; r < t.length; r++) if (Ys(t[r], e, i)) return !0;
        return !1;
      }
      function qs(t, e) {
        if (0 === t.length || 0 === e.length) return !1;
        for (let i = 0; i < t.length - 1; i++) {
          const r = t[i],
            n = t[i + 1];
          for (let t = 0; t < e.length - 1; t++)
            if (Ws(r, n, e[t], e[t + 1])) return !0;
        }
        return !1;
      }
      function Ws(t, e, i, r) {
        return $(t, i, r) !== $(e, i, r) && $(t, e, i) !== $(t, e, r);
      }
      function Ys(t, e, i) {
        const r = i * i;
        if (1 === e.length) return t.distSqr(e[0]) < r;
        for (let n = 1; n < e.length; n++)
          if (Hs(t, e[n - 1], e[n]) < r) return !0;
        return !1;
      }
      function Hs(t, e, i) {
        const r = e.distSqr(i);
        if (0 === r) return t.distSqr(e);
        const n = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / r;
        return t.distSqr(n < 0 ? e : n > 1 ? i : i.sub(e)._mult(n)._add(e));
      }
      function Xs(t, e) {
        let i,
          r,
          n,
          o = !1;
        for (let a = 0; a < t.length; a++) {
          i = t[a];
          for (let t = 0, a = i.length - 1; t < i.length; a = t++)
            (r = i[t]),
              (n = i[a]),
              r.y > e.y != n.y > e.y &&
                e.x < ((n.x - r.x) * (e.y - r.y)) / (n.y - r.y) + r.x &&
                (o = !o);
        }
        return o;
      }
      function Ks(t, e) {
        let i = !1;
        for (let r = 0, n = t.length - 1; r < t.length; n = r++) {
          const o = t[r],
            a = t[n];
          o.y > e.y != a.y > e.y &&
            e.x < ((a.x - o.x) * (e.y - o.y)) / (a.y - o.y) + o.x &&
            (i = !i);
        }
        return i;
      }
      function Js(t, e, i) {
        const r = i[0],
          n = i[2];
        if (
          (t.x < r.x && e.x < r.x) ||
          (t.x > n.x && e.x > n.x) ||
          (t.y < r.y && e.y < r.y) ||
          (t.y > n.y && e.y > n.y)
        )
          return !1;
        const o = $(t, e, i[0]);
        return (
          o !== $(t, e, i[1]) || o !== $(t, e, i[2]) || o !== $(t, e, i[3])
        );
      }
      function Qs(t, e, i) {
        const r = e.paint.get(t).value;
        return 'constant' === r.kind
          ? r.value
          : i.programConfigurations.get(e.id).getMaxValue(t);
      }
      function tl(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      }
      function el(t, e, r, n, o) {
        if (!e[0] && !e[1]) return t;
        const a = i.convert(e)._mult(o);
        'viewport' === r && a._rotate(-n);
        const s = [];
        for (let i = 0; i < t.length; i++) s.push(t[i].sub(a));
        return s;
      }
      function il({ queryGeometry: t, size: e }, i) {
        return Gs(t, i, e);
      }
      function rl(
        {
          queryGeometry: t,
          size: e,
          transform: i,
          unwrappedTileID: r,
          getElevation: n,
        },
        o
      ) {
        return Gs(
          t,
          o,
          e *
            (i.projectTileCoordinates(o.x, o.y, r, n).signedDistanceFromCamera /
              i.cameraToCenterDistance)
        );
      }
      function nl(
        {
          queryGeometry: t,
          size: e,
          transform: i,
          unwrappedTileID: r,
          getElevation: n,
        },
        o
      ) {
        const a = i.projectTileCoordinates(
            o.x,
            o.y,
            r,
            n
          ).signedDistanceFromCamera,
          s = e * (i.cameraToCenterDistance / a);
        return Gs(t, sl(o, i, r, n), s);
      }
      function ol(
        {
          queryGeometry: t,
          size: e,
          transform: i,
          unwrappedTileID: r,
          getElevation: n,
        },
        o
      ) {
        return Gs(t, sl(o, i, r, n), e);
      }
      function al(
        {
          queryGeometry: t,
          size: e,
          transform: i,
          unwrappedTileID: r,
          getElevation: n,
          pitchAlignment: o = 'map',
          pitchScale: a = 'map',
        },
        s
      ) {
        const l = 'map' === o ? ('map' === a ? il : rl) : 'map' === a ? nl : ol,
          c = {
            queryGeometry: t,
            size: e,
            transform: i,
            unwrappedTileID: r,
            getElevation: n,
          };
        for (const h of s) for (const t of h) if (l(c, t)) return !0;
        return !1;
      }
      function sl(t, e, r, n) {
        const o = e.projectTileCoordinates(t.x, t.y, r, n).point;
        return new i(
          (0.5 * o.x + 0.5) * e.width,
          (0.5 * -o.y + 0.5) * e.height
        );
      }
      let ll, cl;
      co('CircleBucket', Vs, { omit: ['layers'] });
      var hl = {
        get paint() {
          return (cl =
            cl ||
            new qo({
              'circle-radius': new Uo(xt.paint_circle['circle-radius']),
              'circle-color': new Uo(xt.paint_circle['circle-color']),
              'circle-blur': new Uo(xt.paint_circle['circle-blur']),
              'circle-opacity': new Uo(xt.paint_circle['circle-opacity']),
              'circle-translate': new Vo(xt.paint_circle['circle-translate']),
              'circle-translate-anchor': new Vo(
                xt.paint_circle['circle-translate-anchor']
              ),
              'circle-pitch-scale': new Vo(
                xt.paint_circle['circle-pitch-scale']
              ),
              'circle-pitch-alignment': new Vo(
                xt.paint_circle['circle-pitch-alignment']
              ),
              'circle-stroke-width': new Uo(
                xt.paint_circle['circle-stroke-width']
              ),
              'circle-stroke-color': new Uo(
                xt.paint_circle['circle-stroke-color']
              ),
              'circle-stroke-opacity': new Uo(
                xt.paint_circle['circle-stroke-opacity']
              ),
            }));
        },
        get layout() {
          return (ll =
            ll ||
            new qo({
              'circle-sort-key': new Uo(xt.layout_circle['circle-sort-key']),
            }));
        },
      };
      class ul extends Yo {
        constructor(t, e) {
          super(t, hl, e);
        }
        createBucket(t) {
          return new Vs(t);
        }
        queryRadius(t) {
          const e = t;
          return (
            Qs('circle-radius', this, e) +
            Qs('circle-stroke-width', this, e) +
            tl(this.paint.get('circle-translate'))
          );
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: e,
          featureState: i,
          geometry: r,
          transform: n,
          pixelsToTileUnits: o,
          unwrappedTileID: a,
          getElevation: s,
        }) {
          const l = el(
              t,
              this.paint.get('circle-translate'),
              this.paint.get('circle-translate-anchor'),
              -n.bearingInRadians,
              o
            ),
            c =
              this.paint.get('circle-radius').evaluate(e, i) +
              this.paint.get('circle-stroke-width').evaluate(e, i),
            h = this.paint.get('circle-pitch-scale'),
            u = this.paint.get('circle-pitch-alignment');
          let d, p;
          return (
            'map' === u
              ? ((d = l), (p = c * o))
              : ((d = (function (t, e, i, r) {
                  return t.map((t) => sl(t, e, i, r));
                })(l, n, a, s)),
                (p = c)),
            al(
              {
                queryGeometry: d,
                size: p,
                transform: n,
                unwrappedTileID: a,
                getElevation: s,
                pitchAlignment: u,
                pitchScale: h,
              },
              r
            )
          );
        }
      }
      class dl extends Vs {}
      let pl;
      co('HeatmapBucket', dl, { omit: ['layers'] });
      var fl = {
        get paint() {
          return (pl =
            pl ||
            new qo({
              'heatmap-radius': new Uo(xt.paint_heatmap['heatmap-radius']),
              'heatmap-weight': new Uo(xt.paint_heatmap['heatmap-weight']),
              'heatmap-intensity': new Vo(
                xt.paint_heatmap['heatmap-intensity']
              ),
              'heatmap-color': new $o(xt.paint_heatmap['heatmap-color']),
              'heatmap-opacity': new Vo(xt.paint_heatmap['heatmap-opacity']),
            }));
        },
      };
      function ml(t, { width: e, height: i }, r, n) {
        if (n) {
          if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);
          else if (n.length !== e * i * r)
            throw new RangeError(
              `mismatched image size. expected: ${n.length} but got: ${
                e * i * r
              }`
            );
        } else n = new Uint8Array(e * i * r);
        return (t.width = e), (t.height = i), (t.data = n), t;
      }
      function _l(t, { width: e, height: i }, r) {
        if (e === t.width && i === t.height) return;
        const n = ml({}, { width: e, height: i }, r);
        gl(
          t,
          n,
          { x: 0, y: 0 },
          { x: 0, y: 0 },
          { width: Math.min(t.width, e), height: Math.min(t.height, i) },
          r
        ),
          (t.width = e),
          (t.height = i),
          (t.data = n.data);
      }
      function gl(t, e, i, r, n, o) {
        if (0 === n.width || 0 === n.height) return e;
        if (
          n.width > t.width ||
          n.height > t.height ||
          i.x > t.width - n.width ||
          i.y > t.height - n.height
        )
          throw new RangeError(
            'out of range source coordinates for image copy'
          );
        if (
          n.width > e.width ||
          n.height > e.height ||
          r.x > e.width - n.width ||
          r.y > e.height - n.height
        )
          throw new RangeError(
            'out of range destination coordinates for image copy'
          );
        const a = t.data,
          s = e.data;
        if (a === s)
          throw new Error('srcData equals dstData, so image is already copied');
        for (let l = 0; l < n.height; l++) {
          const c = ((i.y + l) * t.width + i.x) * o,
            h = ((r.y + l) * e.width + r.x) * o;
          for (let t = 0; t < n.width * o; t++) s[h + t] = a[c + t];
        }
        return e;
      }
      class yl {
        constructor(t, e) {
          ml(this, t, 1, e);
        }
        resize(t) {
          _l(this, t, 1);
        }
        clone() {
          return new yl(
            { width: this.width, height: this.height },
            new Uint8Array(this.data)
          );
        }
        static copy(t, e, i, r, n) {
          gl(t, e, i, r, n, 1);
        }
      }
      class xl {
        constructor(t, e) {
          ml(this, t, 4, e);
        }
        resize(t) {
          _l(this, t, 4);
        }
        replace(t, e) {
          e
            ? this.data.set(t)
            : (this.data =
                t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t);
        }
        clone() {
          return new xl(
            { width: this.width, height: this.height },
            new Uint8Array(this.data)
          );
        }
        static copy(t, e, i, r, n) {
          gl(t, e, i, r, n, 4);
        }
        setPixel(t, e, i) {
          const r = 4 * (t * this.width + e);
          (this.data[r + 0] = Math.round((255 * i.r) / i.a)),
            (this.data[r + 1] = Math.round((255 * i.g) / i.a)),
            (this.data[r + 2] = Math.round((255 * i.b) / i.a)),
            (this.data[r + 3] = Math.round(255 * i.a));
        }
      }
      function vl(t) {
        const e = {},
          i = t.resolution || 256,
          r = t.clips ? t.clips.length : 1,
          n = t.image || new xl({ width: i, height: r });
        if ((Math.log(i) / Math.LN2) % 1 != 0)
          throw new Error(`width is not a power of 2 - ${i}`);
        const o = (r, o, a) => {
          e[t.evaluationKey] = a;
          const s = t.expression.evaluate(e);
          n.setPixel(r / 4 / i, o / 4, s);
        };
        if (t.clips)
          for (let a = 0, s = 0; a < r; ++a, s += 4 * i)
            for (let e = 0, r = 0; e < i; e++, r += 4) {
              const n = e / (i - 1),
                { start: l, end: c } = t.clips[a];
              o(s, r, l * (1 - n) + c * n);
            }
        else for (let a = 0, s = 0; a < i; a++, s += 4) o(0, s, a / (i - 1));
        return n;
      }
      co('AlphaImage', yl), co('RGBAImage', xl);
      const bl = 'big-fb';
      class wl extends Yo {
        createBucket(t) {
          return new dl(t);
        }
        constructor(t, e) {
          super(t, fl, e),
            (this.heatmapFbos = new Map()),
            this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          'heatmap-color' === t && this._updateColorRamp();
        }
        _updateColorRamp() {
          (this.colorRamp = vl({
            expression:
              this._transitionablePaint._values['heatmap-color'].value
                .expression,
            evaluationKey: 'heatmapDensity',
            image: this.colorRamp,
          })),
            (this.colorRampTexture = null);
        }
        resize() {
          this.heatmapFbos.has(bl) && this.heatmapFbos.delete(bl);
        }
        queryRadius(t) {
          return Qs('heatmap-radius', this, t);
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: e,
          featureState: i,
          geometry: r,
          transform: n,
          pixelsToTileUnits: o,
          unwrappedTileID: a,
          getElevation: s,
        }) {
          return al(
            {
              queryGeometry: t,
              size: this.paint.get('heatmap-radius').evaluate(e, i) * o,
              transform: n,
              unwrappedTileID: a,
              getElevation: s,
            },
            r
          );
        }
        hasOffscreenPass() {
          return (
            0 !== this.paint.get('heatmap-opacity') &&
            'none' !== this.visibility
          );
        }
      }
      let Tl;
      var Pl = {
        get paint() {
          return (Tl =
            Tl ||
            new qo({
              'hillshade-illumination-direction': new Vo(
                xt.paint_hillshade['hillshade-illumination-direction']
              ),
              'hillshade-illumination-altitude': new Vo(
                xt.paint_hillshade['hillshade-illumination-altitude']
              ),
              'hillshade-illumination-anchor': new Vo(
                xt.paint_hillshade['hillshade-illumination-anchor']
              ),
              'hillshade-exaggeration': new Vo(
                xt.paint_hillshade['hillshade-exaggeration']
              ),
              'hillshade-shadow-color': new Vo(
                xt.paint_hillshade['hillshade-shadow-color']
              ),
              'hillshade-highlight-color': new Vo(
                xt.paint_hillshade['hillshade-highlight-color']
              ),
              'hillshade-accent-color': new Vo(
                xt.paint_hillshade['hillshade-accent-color']
              ),
              'hillshade-method': new Vo(
                xt.paint_hillshade['hillshade-method']
              ),
            }));
        },
      };
      class Sl extends Yo {
        constructor(t, e) {
          super(t, Pl, e),
            this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
        }
        getIlluminationProperties() {
          let t = this.paint.get('hillshade-illumination-direction').values,
            e = this.paint.get('hillshade-illumination-altitude').values,
            i = this.paint.get('hillshade-highlight-color').values,
            r = this.paint.get('hillshade-shadow-color').values;
          const n = Math.max(t.length, e.length, i.length, r.length);
          (t = t.concat(Array(n - t.length).fill(t.at(-1)))),
            (e = e.concat(Array(n - e.length).fill(e.at(-1)))),
            (i = i.concat(Array(n - i.length).fill(i.at(-1)))),
            (r = r.concat(Array(n - r.length).fill(r.at(-1))));
          const o = e.map(et);
          return {
            directionRadians: t.map(et),
            altitudeRadians: o,
            shadowColor: r,
            highlightColor: i,
          };
        }
        hasOffscreenPass() {
          return (
            0 !== this.paint.get('hillshade-exaggeration') &&
            'none' !== this.visibility
          );
        }
      }
      let Ml;
      var Il = {
        get paint() {
          return (Ml =
            Ml ||
            new qo({
              'color-relief-opacity': new Vo(
                xt['paint_color-relief']['color-relief-opacity']
              ),
              'color-relief-color': new $o(
                xt['paint_color-relief']['color-relief-color']
              ),
            }));
        },
      };
      class Cl {
        constructor(t, e, i, r) {
          (this.context = t),
            (this.format = i),
            (this.texture = t.gl.createTexture()),
            this.update(e, r);
        }
        update(t, e, i) {
          const { width: r, height: n } = t,
            o = !((this.size && this.size[0] === r && this.size[1] === n) || i),
            { context: a } = this,
            { gl: s } = a;
          if (
            ((this.useMipmap = Boolean(e && e.useMipmap)),
            s.bindTexture(s.TEXTURE_2D, this.texture),
            a.pixelStoreUnpackFlipY.set(!1),
            a.pixelStoreUnpack.set(1),
            a.pixelStoreUnpackPremultiplyAlpha.set(
              this.format === s.RGBA && (!e || !1 !== e.premultiply)
            ),
            o)
          )
            (this.size = [r, n]),
              t instanceof HTMLImageElement ||
              t instanceof HTMLCanvasElement ||
              t instanceof HTMLVideoElement ||
              t instanceof ImageData ||
              H(t)
                ? s.texImage2D(
                    s.TEXTURE_2D,
                    0,
                    this.format,
                    this.format,
                    s.UNSIGNED_BYTE,
                    t
                  )
                : s.texImage2D(
                    s.TEXTURE_2D,
                    0,
                    this.format,
                    r,
                    n,
                    0,
                    this.format,
                    s.UNSIGNED_BYTE,
                    t.data
                  );
          else {
            const { x: e, y: o } = i || { x: 0, y: 0 };
            t instanceof HTMLImageElement ||
            t instanceof HTMLCanvasElement ||
            t instanceof HTMLVideoElement ||
            t instanceof ImageData ||
            H(t)
              ? s.texSubImage2D(
                  s.TEXTURE_2D,
                  0,
                  e,
                  o,
                  s.RGBA,
                  s.UNSIGNED_BYTE,
                  t
                )
              : s.texSubImage2D(
                  s.TEXTURE_2D,
                  0,
                  e,
                  o,
                  r,
                  n,
                  s.RGBA,
                  s.UNSIGNED_BYTE,
                  t.data
                );
          }
          this.useMipmap &&
            this.isSizePowerOfTwo() &&
            s.generateMipmap(s.TEXTURE_2D),
            a.pixelStoreUnpackFlipY.setDefault(),
            a.pixelStoreUnpack.setDefault(),
            a.pixelStoreUnpackPremultiplyAlpha.setDefault();
        }
        bind(t, e, i) {
          const { context: r } = this,
            { gl: n } = r;
          n.bindTexture(n.TEXTURE_2D, this.texture),
            i !== n.LINEAR_MIPMAP_NEAREST ||
              this.isSizePowerOfTwo() ||
              (i = n.LINEAR),
            t !== this.filter &&
              (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t),
              n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, i || t),
              (this.filter = t)),
            e !== this.wrap &&
              (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e),
              n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e),
              (this.wrap = e));
        }
        isSizePowerOfTwo() {
          return (
            this.size[0] === this.size[1] &&
            (Math.log(this.size[0]) / Math.LN2) % 1 == 0
          );
        }
        destroy() {
          const { gl: t } = this.context;
          t.deleteTexture(this.texture), (this.texture = null);
        }
      }
      class Al {
        constructor(t, e, i, r = 1, n = 1, o = 1, a = 0) {
          if (((this.uid = t), e.height !== e.width))
            throw new RangeError('DEM tiles must be square');
          if (i && !['mapbox', 'terrarium', 'custom'].includes(i))
            return void Z(
              `"${i}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`
            );
          this.stride = e.height;
          const s = (this.dim = e.height - 2);
          switch (((this.data = new Uint32Array(e.data.buffer)), i)) {
            case 'terrarium':
              (this.redFactor = 256),
                (this.greenFactor = 1),
                (this.blueFactor = 1 / 256),
                (this.baseShift = 32768);
              break;
            case 'custom':
              (this.redFactor = r),
                (this.greenFactor = n),
                (this.blueFactor = o),
                (this.baseShift = a);
              break;
            default:
              (this.redFactor = 6553.6),
                (this.greenFactor = 25.6),
                (this.blueFactor = 0.1),
                (this.baseShift = 1e4);
          }
          for (let l = 0; l < s; l++)
            (this.data[this._idx(-1, l)] = this.data[this._idx(0, l)]),
              (this.data[this._idx(s, l)] = this.data[this._idx(s - 1, l)]),
              (this.data[this._idx(l, -1)] = this.data[this._idx(l, 0)]),
              (this.data[this._idx(l, s)] = this.data[this._idx(l, s - 1)]);
          (this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
            (this.data[this._idx(s, -1)] = this.data[this._idx(s - 1, 0)]),
            (this.data[this._idx(-1, s)] = this.data[this._idx(0, s - 1)]),
            (this.data[this._idx(s, s)] = this.data[this._idx(s - 1, s - 1)]),
            (this.min = Number.MAX_SAFE_INTEGER),
            (this.max = Number.MIN_SAFE_INTEGER);
          for (let l = 0; l < s; l++)
            for (let t = 0; t < s; t++) {
              const e = this.get(l, t);
              e > this.max && (this.max = e), e < this.min && (this.min = e);
            }
        }
        get(t, e) {
          const i = new Uint8Array(this.data.buffer),
            r = 4 * this._idx(t, e);
          return this.unpack(i[r], i[r + 1], i[r + 2]);
        }
        getUnpackVector() {
          return [
            this.redFactor,
            this.greenFactor,
            this.blueFactor,
            this.baseShift,
          ];
        }
        _idx(t, e) {
          if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
            throw new RangeError(
              'out of range source coordinates for DEM data'
            );
          return (e + 1) * this.stride + (t + 1);
        }
        unpack(t, e, i) {
          return (
            t * this.redFactor +
            e * this.greenFactor +
            i * this.blueFactor -
            this.baseShift
          );
        }
        pack(t) {
          return El(t, this.getUnpackVector());
        }
        getPixels() {
          return new xl(
            { width: this.stride, height: this.stride },
            new Uint8Array(this.data.buffer)
          );
        }
        backfillBorder(t, e, i) {
          if (this.dim !== t.dim) throw new Error('dem dimension mismatch');
          let r = e * this.dim,
            n = e * this.dim + this.dim,
            o = i * this.dim,
            a = i * this.dim + this.dim;
          switch (e) {
            case -1:
              r = n - 1;
              break;
            case 1:
              n = r + 1;
          }
          switch (i) {
            case -1:
              o = a - 1;
              break;
            case 1:
              a = o + 1;
          }
          const s = -e * this.dim,
            l = -i * this.dim;
          for (let c = o; c < a; c++)
            for (let e = r; e < n; e++)
              this.data[this._idx(e, c)] = t.data[this._idx(e + s, c + l)];
        }
      }
      function El(t, e) {
        const i = e[0],
          r = e[1],
          n = e[2],
          o = e[3],
          a = Math.min(i, r, n),
          s = Math.round((t + o) / a);
        return {
          r: Math.floor((s * a) / i) % 256,
          g: Math.floor((s * a) / r) % 256,
          b: Math.floor((s * a) / n) % 256,
        };
      }
      co('DEMData', Al);
      class zl extends Yo {
        constructor(t, e) {
          super(t, Il, e);
        }
        _createColorRamp(t) {
          const e = { elevationStops: [], colorStops: [] },
            i =
              this._transitionablePaint._values['color-relief-color'].value
                .expression;
          if (i instanceof nn && i._styleExpression.expression instanceof pi) {
            this.colorRampExpression = i;
            const t = i._styleExpression.expression;
            (e.elevationStops = t.labels), (e.colorStops = []);
            for (const i of e.elevationStops)
              e.colorStops.push(t.evaluate({ globals: { elevation: i } }));
          }
          if (
            (e.elevationStops.length < 1 &&
              ((e.elevationStops = [0]), (e.colorStops = [Ie.transparent])),
            e.elevationStops.length < 2 &&
              (e.elevationStops.push(e.elevationStops[0] + 1),
              e.colorStops.push(e.colorStops[0])),
            e.elevationStops.length <= t)
          )
            return e;
          const r = { elevationStops: [], colorStops: [] },
            n = (e.elevationStops.length - 1) / (t - 1);
          for (let o = 0; o < e.elevationStops.length - 0.5; o += n)
            r.elevationStops.push(e.elevationStops[Math.round(o)]),
              r.colorStops.push(e.colorStops[Math.round(o)]);
          return (
            Z(
              `Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${e.elevationStops.length}`
            ),
            r
          );
        }
        _colorRampChanged() {
          return (
            this.colorRampExpression !=
            this._transitionablePaint._values['color-relief-color'].value
              .expression
          );
        }
        getColorRampTextures(t, e, i) {
          if (this.colorRampTextures && !this._colorRampChanged())
            return this.colorRampTextures;
          const r = this._createColorRamp(e),
            n = new xl({ width: r.colorStops.length, height: 1 }),
            o = new xl({ width: r.colorStops.length, height: 1 });
          for (let a = 0; a < r.elevationStops.length; a++) {
            const t = El(r.elevationStops[a], i);
            o.setPixel(0, a, new Ie(t.r / 255, t.g / 255, t.b / 255, 1)),
              n.setPixel(0, a, r.colorStops[a]);
          }
          return (
            (this.colorRampTextures = {
              elevationTexture: new Cl(t, o, t.gl.RGBA),
              colorTexture: new Cl(t, n, t.gl.RGBA),
            }),
            this.colorRampTextures
          );
        }
        hasOffscreenPass() {
          return 'none' !== this.visibility && !!this.colorRampTextures;
        }
      }
      const kl = ea([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
        { members: Dl } = kl;
      function Rl(t, e, i) {
        const r = i.patternDependencies;
        let n = !1;
        for (const o of e) {
          const e = o.paint.get(`${t}-pattern`);
          e.isConstant() || (n = !0);
          const i = e.constantOr(null);
          i && ((n = !0), (r[i.to] = !0), (r[i.from] = !0));
        }
        return n;
      }
      function Ll(t, e, i, r, n) {
        const { zoom: o } = r,
          a = n.patternDependencies;
        for (const s of e) {
          const e = s.paint.get(`${t}-pattern`).value;
          if ('constant' !== e.kind) {
            let t = e.evaluate({ zoom: o - 1 }, i, {}, n.availableImages),
              r = e.evaluate({ zoom: o }, i, {}, n.availableImages),
              l = e.evaluate({ zoom: o + 1 }, i, {}, n.availableImages);
            (t = t && t.name ? t.name : t),
              (r = r && r.name ? r.name : r),
              (l = l && l.name ? l.name : l),
              (a[t] = !0),
              (a[r] = !0),
              (a[l] = !0),
              (i.patterns[s.id] = { min: t, mid: r, max: l });
          }
        }
        return i;
      }
      function Fl(t, e, i, r, n) {
        let o;
        if (
          n ===
          (function (t, e, i, r) {
            let n = 0;
            for (let o = e, a = i - r; o < i; o += r)
              (n += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
            return n;
          })(t, e, i, r) >
            0
        )
          for (let a = e; a < i; a += r) o = nc((a / r) | 0, t[a], t[a + 1], o);
        else
          for (let a = i - r; a >= e; a -= r)
            o = nc((a / r) | 0, t[a], t[a + 1], o);
        return o && Jl(o, o.next) && (oc(o), (o = o.next)), o;
      }
      function Bl(t, e) {
        if (!t) return t;
        e || (e = t);
        let i,
          r = t;
        do {
          if (
            ((i = !1),
            r.steiner || (!Jl(r, r.next) && 0 !== Kl(r.prev, r, r.next)))
          )
            r = r.next;
          else {
            if ((oc(r), (r = e = r.prev), r === r.next)) break;
            i = !0;
          }
        } while (i || r !== e);
        return e;
      }
      function Ol(t, e, i, r, n, o, a) {
        if (!t) return;
        !a &&
          o &&
          (function (t, e, i, r) {
            let n = t;
            do {
              0 === n.z && (n.z = ql(n.x, n.y, e, i, r)),
                (n.prevZ = n.prev),
                (n.nextZ = n.next),
                (n = n.next);
            } while (n !== t);
            (n.prevZ.nextZ = null),
              (n.prevZ = null),
              (function (t) {
                let e,
                  i = 1;
                do {
                  let r,
                    n = t;
                  t = null;
                  let o = null;
                  for (e = 0; n; ) {
                    e++;
                    let a = n,
                      s = 0;
                    for (let t = 0; t < i && (s++, (a = a.nextZ), a); t++);
                    let l = i;
                    for (; s > 0 || (l > 0 && a); )
                      0 !== s && (0 === l || !a || n.z <= a.z)
                        ? ((r = n), (n = n.nextZ), s--)
                        : ((r = a), (a = a.nextZ), l--),
                        o ? (o.nextZ = r) : (t = r),
                        (r.prevZ = o),
                        (o = r);
                    n = a;
                  }
                  (o.nextZ = null), (i *= 2);
                } while (e > 1);
              })(n);
          })(t, r, n, o);
        let s = t;
        for (; t.prev !== t.next; ) {
          const l = t.prev,
            c = t.next;
          if (o ? Nl(t, r, n, o) : jl(t))
            e.push(l.i, t.i, c.i), oc(t), (t = c.next), (s = c.next);
          else if ((t = c) === s) {
            a
              ? 1 === a
                ? Ol((t = Vl(Bl(t), e)), e, i, r, n, o, 2)
                : 2 === a && Ul(t, e, i, r, n, o)
              : Ol(Bl(t), e, i, r, n, o, 1);
            break;
          }
        }
      }
      function jl(t) {
        const e = t.prev,
          i = t,
          r = t.next;
        if (Kl(e, i, r) >= 0) return !1;
        const n = e.x,
          o = i.x,
          a = r.x,
          s = e.y,
          l = i.y,
          c = r.y,
          h = Math.min(n, o, a),
          u = Math.min(s, l, c),
          d = Math.max(n, o, a),
          p = Math.max(s, l, c);
        let f = r.next;
        for (; f !== e; ) {
          if (
            f.x >= h &&
            f.x <= d &&
            f.y >= u &&
            f.y <= p &&
            Hl(n, s, o, l, a, c, f.x, f.y) &&
            Kl(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.next;
        }
        return !0;
      }
      function Nl(t, e, i, r) {
        const n = t.prev,
          o = t,
          a = t.next;
        if (Kl(n, o, a) >= 0) return !1;
        const s = n.x,
          l = o.x,
          c = a.x,
          h = n.y,
          u = o.y,
          d = a.y,
          p = Math.min(s, l, c),
          f = Math.min(h, u, d),
          m = Math.max(s, l, c),
          _ = Math.max(h, u, d),
          g = ql(p, f, e, i, r),
          y = ql(m, _, e, i, r);
        let x = t.prevZ,
          v = t.nextZ;
        for (; x && x.z >= g && v && v.z <= y; ) {
          if (
            x.x >= p &&
            x.x <= m &&
            x.y >= f &&
            x.y <= _ &&
            x !== n &&
            x !== a &&
            Hl(s, h, l, u, c, d, x.x, x.y) &&
            Kl(x.prev, x, x.next) >= 0
          )
            return !1;
          if (
            ((x = x.prevZ),
            v.x >= p &&
              v.x <= m &&
              v.y >= f &&
              v.y <= _ &&
              v !== n &&
              v !== a &&
              Hl(s, h, l, u, c, d, v.x, v.y) &&
              Kl(v.prev, v, v.next) >= 0)
          )
            return !1;
          v = v.nextZ;
        }
        for (; x && x.z >= g; ) {
          if (
            x.x >= p &&
            x.x <= m &&
            x.y >= f &&
            x.y <= _ &&
            x !== n &&
            x !== a &&
            Hl(s, h, l, u, c, d, x.x, x.y) &&
            Kl(x.prev, x, x.next) >= 0
          )
            return !1;
          x = x.prevZ;
        }
        for (; v && v.z <= y; ) {
          if (
            v.x >= p &&
            v.x <= m &&
            v.y >= f &&
            v.y <= _ &&
            v !== n &&
            v !== a &&
            Hl(s, h, l, u, c, d, v.x, v.y) &&
            Kl(v.prev, v, v.next) >= 0
          )
            return !1;
          v = v.nextZ;
        }
        return !0;
      }
      function Vl(t, e) {
        let i = t;
        do {
          const r = i.prev,
            n = i.next.next;
          !Jl(r, n) &&
            Ql(r, i, i.next, n) &&
            ic(r, n) &&
            ic(n, r) &&
            (e.push(r.i, i.i, n.i), oc(i), oc(i.next), (i = t = n)),
            (i = i.next);
        } while (i !== t);
        return Bl(i);
      }
      function Ul(t, e, i, r, n, o) {
        let a = t;
        do {
          let t = a.next.next;
          for (; t !== a.prev; ) {
            if (a.i !== t.i && Xl(a, t)) {
              let s = rc(a, t);
              return (
                (a = Bl(a, a.next)),
                (s = Bl(s, s.next)),
                Ol(a, e, i, r, n, o, 0),
                void Ol(s, e, i, r, n, o, 0)
              );
            }
            t = t.next;
          }
          a = a.next;
        } while (a !== t);
      }
      function Gl(t, e) {
        let i = t.x - e.x;
        return (
          0 === i &&
            ((i = t.y - e.y), 0 === i) &&
            (i =
              (t.next.y - t.y) / (t.next.x - t.x) -
              (e.next.y - e.y) / (e.next.x - e.x)),
          i
        );
      }
      function Zl(t, e) {
        const i = (function (t, e) {
          let i = e;
          const r = t.x,
            n = t.y;
          let o,
            a = -1 / 0;
          if (Jl(t, i)) return i;
          do {
            if (Jl(t, i.next)) return i.next;
            if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
              const t = i.x + ((n - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (
                t <= r &&
                t > a &&
                ((a = t), (o = i.x < i.next.x ? i : i.next), t === r)
              )
                return o;
            }
            i = i.next;
          } while (i !== e);
          if (!o) return null;
          const s = o,
            l = o.x,
            c = o.y;
          let h = 1 / 0;
          i = o;
          do {
            if (
              r >= i.x &&
              i.x >= l &&
              r !== i.x &&
              Yl(n < c ? r : a, n, l, c, n < c ? a : r, n, i.x, i.y)
            ) {
              const e = Math.abs(n - i.y) / (r - i.x);
              ic(i, t) &&
                (e < h ||
                  (e === h && (i.x > o.x || (i.x === o.x && $l(o, i))))) &&
                ((o = i), (h = e));
            }
            i = i.next;
          } while (i !== s);
          return o;
        })(t, e);
        if (!i) return e;
        const r = rc(i, t);
        return Bl(r, r.next), Bl(i, i.next);
      }
      function $l(t, e) {
        return Kl(t.prev, t, e.prev) < 0 && Kl(e.next, t, t.next) < 0;
      }
      function ql(t, e, i, r, n) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = ((t - i) * n) | 0) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = ((e - r) * n) | 0) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) <<
            1)
        );
      }
      function Wl(t) {
        let e = t,
          i = t;
        do {
          (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
        } while (e !== t);
        return i;
      }
      function Yl(t, e, i, r, n, o, a, s) {
        return (
          (n - a) * (e - s) >= (t - a) * (o - s) &&
          (t - a) * (r - s) >= (i - a) * (e - s) &&
          (i - a) * (o - s) >= (n - a) * (r - s)
        );
      }
      function Hl(t, e, i, r, n, o, a, s) {
        return !(t === a && e === s) && Yl(t, e, i, r, n, o, a, s);
      }
      function Xl(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let i = t;
            do {
              if (
                i.i !== t.i &&
                i.next.i !== t.i &&
                i.i !== e.i &&
                i.next.i !== e.i &&
                Ql(i, i.next, t, e)
              )
                return !0;
              i = i.next;
            } while (i !== t);
            return !1;
          })(t, e) &&
          ((ic(t, e) &&
            ic(e, t) &&
            (function (t, e) {
              let i = t,
                r = !1;
              const n = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
              do {
                i.y > o != i.next.y > o &&
                  i.next.y !== i.y &&
                  n < ((i.next.x - i.x) * (o - i.y)) / (i.next.y - i.y) + i.x &&
                  (r = !r),
                  (i = i.next);
              } while (i !== t);
              return r;
            })(t, e) &&
            (Kl(t.prev, t, e.prev) || Kl(t, e.prev, e))) ||
            (Jl(t, e) &&
              Kl(t.prev, t, t.next) > 0 &&
              Kl(e.prev, e, e.next) > 0))
        );
      }
      function Kl(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
      }
      function Jl(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function Ql(t, e, i, r) {
        const n = ec(Kl(t, e, i)),
          o = ec(Kl(t, e, r)),
          a = ec(Kl(i, r, t)),
          s = ec(Kl(i, r, e));
        return (
          (n !== o && a !== s) ||
          !(0 !== n || !tc(t, i, e)) ||
          !(0 !== o || !tc(t, r, e)) ||
          !(0 !== a || !tc(i, t, r)) ||
          !(0 !== s || !tc(i, e, r))
        );
      }
      function tc(t, e, i) {
        return (
          e.x <= Math.max(t.x, i.x) &&
          e.x >= Math.min(t.x, i.x) &&
          e.y <= Math.max(t.y, i.y) &&
          e.y >= Math.min(t.y, i.y)
        );
      }
      function ec(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
      function ic(t, e) {
        return Kl(t.prev, t, t.next) < 0
          ? Kl(t, e, t.next) >= 0 && Kl(t, t.prev, e) >= 0
          : Kl(t, e, t.prev) < 0 || Kl(t, t.next, e) < 0;
      }
      function rc(t, e) {
        const i = ac(t.i, t.x, t.y),
          r = ac(e.i, e.x, e.y),
          n = t.next,
          o = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (i.next = n),
          (n.prev = i),
          (r.next = i),
          (i.prev = r),
          (o.next = r),
          (r.prev = o),
          r
        );
      }
      function nc(t, e, i, r) {
        const n = ac(t, e, i);
        return (
          r
            ? ((n.next = r.next), (n.prev = r), (r.next.prev = n), (r.next = n))
            : ((n.prev = n), (n.next = n)),
          n
        );
      }
      function oc(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function ac(t, e, i) {
        return {
          i: t,
          x: e,
          y: i,
          prev: null,
          next: null,
          z: 0,
          prevZ: null,
          nextZ: null,
          steiner: !1,
        };
      }
      class sc {
        constructor(t, e) {
          if (e > t)
            throw new Error(
              'Min granularity must not be greater than base granularity.'
            );
          (this._baseZoomGranularity = t), (this._minGranularity = e);
        }
        getGranularityForZoomLevel(t) {
          return Math.max(
            Math.floor(this._baseZoomGranularity / (1 << t)),
            this._minGranularity,
            1
          );
        }
      }
      class lc {
        constructor(t) {
          (this.fill = t.fill),
            (this.line = t.line),
            (this.tile = t.tile),
            (this.stencil = t.stencil),
            (this.circle = t.circle);
        }
      }
      (lc.noSubdivision = new lc({
        fill: new sc(0, 0),
        line: new sc(0, 0),
        tile: new sc(0, 0),
        stencil: new sc(0, 0),
        circle: 1,
      })),
        co('SubdivisionGranularityExpression', sc),
        co('SubdivisionGranularitySetting', lc);
      const cc = -32768,
        hc = 32767;
      class uc {
        constructor(t, e) {
          (this._vertexBuffer = []),
            (this._vertexDictionary = new Map()),
            (this._used = !1),
            (this._granularity = t),
            (this._granularityCellSize = A / t),
            (this._canonical = e);
        }
        _getKey(t, e) {
          return ((t += 32768) << 16) | (e + 32768);
        }
        _vertexToIndex(t, e) {
          if (t < -32768 || e < -32768 || t > 32767 || e > 32767)
            throw new Error(
              'Vertex coordinates are out of signed 16 bit integer range.'
            );
          const i = 0 | Math.round(t),
            r = 0 | Math.round(e),
            n = this._getKey(i, r);
          if (this._vertexDictionary.has(n))
            return this._vertexDictionary.get(n);
          const o = this._vertexBuffer.length / 2;
          return (
            this._vertexDictionary.set(n, o), this._vertexBuffer.push(i, r), o
          );
        }
        _subdivideTrianglesScanline(t) {
          if (this._granularity < 2)
            return (function (t, e) {
              const i = [];
              for (let r = 0; r < e.length; r += 3) {
                const n = e[r],
                  o = e[r + 1],
                  a = e[r + 2],
                  s = t[2 * n],
                  l = t[2 * n + 1];
                (t[2 * o] - s) * (t[2 * a + 1] - l) -
                  (t[2 * o + 1] - l) * (t[2 * a] - s) >
                0
                  ? (i.push(n), i.push(a), i.push(o))
                  : (i.push(n), i.push(o), i.push(a));
              }
              return i;
            })(this._vertexBuffer, t);
          const e = [],
            i = t.length;
          for (let r = 0; r < i; r += 3) {
            const i = [t[r + 0], t[r + 1], t[r + 2]],
              n = [
                this._vertexBuffer[2 * t[r + 0] + 0],
                this._vertexBuffer[2 * t[r + 0] + 1],
                this._vertexBuffer[2 * t[r + 1] + 0],
                this._vertexBuffer[2 * t[r + 1] + 1],
                this._vertexBuffer[2 * t[r + 2] + 0],
                this._vertexBuffer[2 * t[r + 2] + 1],
              ];
            let o = 1 / 0,
              a = 1 / 0,
              s = -1 / 0,
              l = -1 / 0;
            for (let t = 0; t < 3; t++) {
              const e = n[2 * t],
                i = n[2 * t + 1];
              (o = Math.min(o, e)),
                (s = Math.max(s, e)),
                (a = Math.min(a, i)),
                (l = Math.max(l, i));
            }
            if (o === s || a === l) continue;
            const c = Math.floor(o / this._granularityCellSize),
              h = Math.ceil(s / this._granularityCellSize),
              u = Math.floor(a / this._granularityCellSize),
              d = Math.ceil(l / this._granularityCellSize);
            if (c !== h || u !== d)
              for (let t = u; t < d; t++) {
                const r = this._scanlineGenerateVertexRingForCellRow(t, n, i);
                fc(this._vertexBuffer, r, e);
              }
            else e.push(...i);
          }
          return e;
        }
        _scanlineGenerateVertexRingForCellRow(t, e, i) {
          const r = t * this._granularityCellSize,
            n = r + this._granularityCellSize,
            o = [];
          for (let a = 0; a < 3; a++) {
            const t = e[2 * a],
              s = e[2 * a + 1],
              l = e[(2 * (a + 1)) % 6],
              c = e[(2 * (a + 1) + 1) % 6],
              h = e[(2 * (a + 2)) % 6],
              u = e[(2 * (a + 2) + 1) % 6],
              d = l - t,
              p = c - s,
              f = 0 === d,
              m = 0 === p,
              _ = (r - s) / p,
              g = (n - s) / p,
              y = Math.min(_, g),
              x = Math.max(_, g);
            if ((!m && (y >= 1 || x <= 0)) || (m && (s < r || s > n))) {
              c >= r && c <= n && o.push(i[(a + 1) % 3]);
              continue;
            }
            !m && y > 0 && o.push(this._vertexToIndex(t + d * y, s + p * y));
            const v = t + d * Math.max(y, 0),
              b = t + d * Math.min(x, 1);
            f || this._generateIntraEdgeVertices(o, t, s, l, c, v, b),
              !m && x < 1 && o.push(this._vertexToIndex(t + d * x, s + p * x)),
              (m || (c >= r && c <= n)) && o.push(i[(a + 1) % 3]),
              !m &&
                (c <= r || c >= n) &&
                this._generateInterEdgeVertices(o, t, s, l, c, h, u, b, r, n);
          }
          return o;
        }
        _generateIntraEdgeVertices(t, e, i, r, n, o, a) {
          const s = r - e,
            l = n - i,
            c = 0 === l,
            h = c ? Math.min(e, r) : Math.min(o, a),
            u = c ? Math.max(e, r) : Math.max(o, a),
            d = Math.floor(h / this._granularityCellSize) + 1,
            p = Math.ceil(u / this._granularityCellSize) - 1;
          if (c ? e < r : o < a)
            for (let f = d; f <= p; f++) {
              const r = f * this._granularityCellSize;
              t.push(this._vertexToIndex(r, i + (l * (r - e)) / s));
            }
          else
            for (let f = p; f >= d; f--) {
              const r = f * this._granularityCellSize;
              t.push(this._vertexToIndex(r, i + (l * (r - e)) / s));
            }
        }
        _generateInterEdgeVertices(t, e, i, r, n, o, a, s, l, c) {
          const h = n - i,
            u = o - r,
            d = a - n,
            p = (l - n) / d,
            f = (c - n) / d,
            m = Math.min(p, f),
            _ = Math.max(p, f),
            g = r + u * m;
          let y = Math.floor(Math.min(g, s) / this._granularityCellSize) + 1,
            x = Math.ceil(Math.max(g, s) / this._granularityCellSize) - 1,
            v = s < g;
          const b = 0 === d;
          if (b && (a === l || a === c)) return;
          if (b || m >= 1 || _ <= 0) {
            const t = i - a,
              r = o + (e - o) * Math.min((l - a) / t, (c - a) / t);
            (y = Math.floor(Math.min(r, s) / this._granularityCellSize) + 1),
              (x = Math.ceil(Math.max(r, s) / this._granularityCellSize) - 1),
              (v = s < r);
          }
          const w = h > 0 ? c : l;
          if (v)
            for (let T = y; T <= x; T++)
              t.push(this._vertexToIndex(T * this._granularityCellSize, w));
          else
            for (let T = x; T >= y; T--)
              t.push(this._vertexToIndex(T * this._granularityCellSize, w));
        }
        _generateOutline(t) {
          const e = [];
          for (const i of t) {
            const t = pc(i, this._granularity, !0),
              r = this._pointArrayToIndices(t),
              n = [];
            for (let e = 1; e < r.length; e++) n.push(r[e - 1]), n.push(r[e]);
            e.push(n);
          }
          return e;
        }
        _handlePoles(t) {
          let e = !1,
            i = !1;
          this._canonical &&
            (0 === this._canonical.y && (e = !0),
            this._canonical.y === (1 << this._canonical.z) - 1 && (i = !0)),
            (e || i) && this._fillPoles(t, e, i);
        }
        _ensureNoPoleVertices() {
          const t = this._vertexBuffer;
          for (let e = 0; e < t.length; e += 2) {
            const i = t[e + 1];
            i === cc && (t[e + 1] = -32767), i === hc && (t[e + 1] = 32766);
          }
        }
        _generatePoleQuad(t, e, i, r, n, o) {
          r > n != (o === cc)
            ? (t.push(e),
              t.push(i),
              t.push(this._vertexToIndex(r, o)),
              t.push(i),
              t.push(this._vertexToIndex(n, o)),
              t.push(this._vertexToIndex(r, o)))
            : (t.push(i),
              t.push(e),
              t.push(this._vertexToIndex(r, o)),
              t.push(this._vertexToIndex(n, o)),
              t.push(i),
              t.push(this._vertexToIndex(r, o)));
        }
        _fillPoles(t, e, i) {
          const r = this._vertexBuffer,
            n = A,
            o = t.length;
          for (let a = 2; a < o; a += 3) {
            const o = t[a - 2],
              s = t[a - 1],
              l = t[a],
              c = r[2 * o],
              h = r[2 * o + 1],
              u = r[2 * s],
              d = r[2 * s + 1],
              p = r[2 * l],
              f = r[2 * l + 1];
            e &&
              (0 === h && 0 === d && this._generatePoleQuad(t, o, s, c, u, cc),
              0 === d && 0 === f && this._generatePoleQuad(t, s, l, u, p, cc),
              0 === f && 0 === h && this._generatePoleQuad(t, l, o, p, c, cc)),
              i &&
                (h === n &&
                  d === n &&
                  this._generatePoleQuad(t, o, s, c, u, hc),
                d === n && f === n && this._generatePoleQuad(t, s, l, u, p, hc),
                f === n &&
                  h === n &&
                  this._generatePoleQuad(t, l, o, p, c, hc));
          }
        }
        _initializeVertices(t) {
          for (let e = 0; e < t.length; e += 2)
            this._vertexToIndex(t[e], t[e + 1]);
        }
        subdividePolygonInternal(t, e) {
          if (this._used)
            throw new Error('Subdivision: multiple use not allowed.');
          this._used = !0;
          const { flattened: i, holeIndices: r } = (function (t) {
            const e = [],
              i = [];
            for (const r of t)
              if (0 !== r.length) {
                r !== t[0] && e.push(i.length / 2);
                for (let t = 0; t < r.length; t++)
                  i.push(r[t].x), i.push(r[t].y);
              }
            return { flattened: i, holeIndices: e };
          })(t);
          let n;
          this._initializeVertices(i);
          try {
            const t = (function (t, e, i = 2) {
                const r = e && e.length,
                  n = r ? e[0] * i : t.length;
                let o = Fl(t, 0, n, i, !0);
                const a = [];
                if (!o || o.next === o.prev) return a;
                let s, l, c;
                if (
                  (r &&
                    (o = (function (t, e, i, r) {
                      const n = [];
                      for (let o = 0, a = e.length; o < a; o++) {
                        const i = Fl(
                          t,
                          e[o] * r,
                          o < a - 1 ? e[o + 1] * r : t.length,
                          r,
                          !1
                        );
                        i === i.next && (i.steiner = !0), n.push(Wl(i));
                      }
                      n.sort(Gl);
                      for (let o = 0; o < n.length; o++) i = Zl(n[o], i);
                      return i;
                    })(t, e, o, i)),
                  t.length > 80 * i)
                ) {
                  (s = t[0]), (l = t[1]);
                  let e = s,
                    r = l;
                  for (let o = i; o < n; o += i) {
                    const i = t[o],
                      n = t[o + 1];
                    i < s && (s = i),
                      n < l && (l = n),
                      i > e && (e = i),
                      n > r && (r = n);
                  }
                  (c = Math.max(e - s, r - l)), (c = 0 !== c ? 32767 / c : 0);
                }
                return Ol(o, a, i, s, l, c, 0), a;
              })(i, r),
              e = this._convertIndices(i, t);
            n = this._subdivideTrianglesScanline(e);
          } catch (t) {
            console.error(t);
          }
          let o = [];
          return (
            e && (o = this._generateOutline(t)),
            this._ensureNoPoleVertices(),
            this._handlePoles(n),
            {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: n,
              indicesLineList: o,
            }
          );
        }
        _convertIndices(t, e) {
          const i = [];
          for (let r = 0; r < e.length; r++)
            i.push(this._vertexToIndex(t[2 * e[r]], t[2 * e[r] + 1]));
          return i;
        }
        _pointArrayToIndices(t) {
          const e = [];
          for (let i = 0; i < t.length; i++) {
            const r = t[i];
            e.push(this._vertexToIndex(r.x, r.y));
          }
          return e;
        }
      }
      function dc(t, e, i, r = !0) {
        return new uc(i, e).subdividePolygonInternal(t, r);
      }
      function pc(t, e, r = !1) {
        if (!t || t.length < 1) return [];
        if (t.length < 2) return [];
        const n = t[0],
          o = t[t.length - 1],
          a = r && (n.x !== o.x || n.y !== o.y);
        if (e < 2) return a ? [...t, t[0]] : [...t];
        const s = Math.floor(A / e),
          l = [];
        l.push(new i(t[0].x, t[0].y));
        const c = t.length,
          h = a ? c : c - 1;
        for (let u = 0; u < h; u++) {
          const e = t[u],
            r = u < c - 1 ? t[u + 1] : t[0],
            n = e.x,
            o = e.y,
            a = r.x,
            h = r.y,
            d = n !== a,
            p = o !== h;
          if (!d && !p) continue;
          const f = a - n,
            m = h - o,
            _ = Math.abs(f),
            g = Math.abs(m);
          let y = n,
            x = o;
          for (;;) {
            const t =
                f > 0
                  ? (Math.floor(y / s) + 1) * s
                  : (Math.ceil(y / s) - 1) * s,
              e =
                m > 0
                  ? (Math.floor(x / s) + 1) * s
                  : (Math.ceil(x / s) - 1) * s,
              r = Math.abs(y - t),
              n = Math.abs(x - e),
              o = Math.abs(y - a),
              c = Math.abs(x - h),
              u = d ? r / _ : Number.POSITIVE_INFINITY,
              v = p ? n / g : Number.POSITIVE_INFINITY;
            if ((o <= r || !d) && (c <= n || !p)) break;
            if ((u < v && d) || !p) {
              (y = t), (x += m * u);
              const e = new i(y, Math.round(x));
              (l[l.length - 1].x === e.x && l[l.length - 1].y === e.y) ||
                l.push(e);
            } else {
              (y += f * v), (x = e);
              const t = new i(Math.round(y), x);
              (l[l.length - 1].x === t.x && l[l.length - 1].y === t.y) ||
                l.push(t);
            }
          }
          const v = new i(a, h);
          (l[l.length - 1].x === v.x && l[l.length - 1].y === v.y) || l.push(v);
        }
        return l;
      }
      function fc(t, e, i) {
        if (0 === e.length)
          throw new Error('Subdivision vertex ring is empty.');
        let r = 0,
          n = t[2 * e[0]];
        for (let l = 1; l < e.length; l++) {
          const i = t[2 * e[l]];
          i < n && ((n = i), (r = l));
        }
        const o = e.length;
        let a = r,
          s = (a + 1) % o;
        for (;;) {
          const r = a - 1 >= 0 ? a - 1 : o - 1,
            n = (s + 1) % o,
            l = t[2 * e[r]],
            c = t[2 * e[n]],
            h = t[2 * e[a]],
            u = t[2 * e[a] + 1],
            d = t[2 * e[s] + 1];
          let p = !1;
          if (l < c) p = !0;
          else if (l > c) p = !1;
          else {
            const i = d - u,
              o = -(t[2 * e[s]] - h),
              a = u < d ? 1 : -1;
            ((l - h) * i + (t[2 * e[r] + 1] - u) * o) * a >
              ((c - h) * i + (t[2 * e[n] + 1] - u) * o) * a && (p = !0);
          }
          if (p) {
            const t = e[r],
              n = e[a],
              l = e[s];
            t !== n && t !== l && n !== l && i.push(l, n, t),
              a--,
              a < 0 && (a = o - 1);
          } else {
            const t = e[n],
              r = e[a],
              l = e[s];
            t !== r && t !== l && r !== l && i.push(l, r, t),
              s++,
              s >= o && (s = 0);
          }
          if (r === n) break;
        }
      }
      function mc(t, e, i, r, n, o, a, s, l) {
        const c = n.length / 2,
          h = a && s && l;
        if (c < is.MAX_VERTEX_ARRAY_LENGTH) {
          const u = e.prepareSegment(c, i, r),
            d = u.vertexLength;
          for (let t = 0; t < o.length; t += 3)
            r.emplaceBack(d + o[t], d + o[t + 1], d + o[t + 2]);
          let p, f;
          (u.vertexLength += c),
            (u.primitiveLength += o.length / 3),
            h &&
              ((f = a.prepareSegment(c, i, s)),
              (p = f.vertexLength),
              (f.vertexLength += c));
          for (let e = 0; e < n.length; e += 2) t(n[e], n[e + 1]);
          if (h)
            for (let t = 0; t < l.length; t++) {
              const e = l[t];
              for (let t = 1; t < e.length; t += 2)
                s.emplaceBack(p + e[t - 1], p + e[t]);
              f.primitiveLength += e.length / 2;
            }
        } else
          !(function (t, e, i, r, n, o) {
            const a = [];
            for (let u = 0; u < r.length / 2; u++) a.push(-1);
            const s = { count: 0 };
            let l = 0,
              c = t.getOrCreateLatestSegment(e, i),
              h = c.vertexLength;
            for (let u = 2; u < n.length; u += 3) {
              const d = n[u - 2],
                p = n[u - 1],
                f = n[u];
              let m = a[d] < l,
                _ = a[p] < l,
                g = a[f] < l;
              c.vertexLength + ((m ? 1 : 0) + (_ ? 1 : 0) + (g ? 1 : 0)) >
                is.MAX_VERTEX_ARRAY_LENGTH &&
                ((c = t.createNewSegment(e, i)),
                (l = s.count),
                (m = !0),
                (_ = !0),
                (g = !0),
                (h = 0));
              const y = _c(a, r, o, s, d, m, c),
                x = _c(a, r, o, s, p, _, c),
                v = _c(a, r, o, s, f, g, c);
              i.emplaceBack(h + y - l, h + x - l, h + v - l),
                c.primitiveLength++;
            }
          })(e, i, r, n, o, t),
            h &&
              (function (t, e, i, r, n, o) {
                const a = [];
                for (let u = 0; u < r.length / 2; u++) a.push(-1);
                const s = { count: 0 };
                let l = 0,
                  c = t.getOrCreateLatestSegment(e, i),
                  h = c.vertexLength;
                for (let u = 0; u < n.length; u++) {
                  const d = n[u];
                  for (let p = 1; p < n[u].length; p += 2) {
                    const n = d[p - 1],
                      u = d[p];
                    let f = a[n] < l,
                      m = a[u] < l;
                    c.vertexLength + ((f ? 1 : 0) + (m ? 1 : 0)) >
                      is.MAX_VERTEX_ARRAY_LENGTH &&
                      ((c = t.createNewSegment(e, i)),
                      (l = s.count),
                      (f = !0),
                      (m = !0),
                      (h = 0));
                    const _ = _c(a, r, o, s, n, f, c),
                      g = _c(a, r, o, s, u, m, c);
                    i.emplaceBack(h + _ - l, h + g - l), c.primitiveLength++;
                  }
                }
              })(a, i, s, n, l, t),
            e.forceNewSegmentOnNextPrepare(),
            null == a || a.forceNewSegmentOnNextPrepare();
      }
      function _c(t, e, i, r, n, o, a) {
        if (o) {
          const o = r.count;
          return (
            i(e[2 * n], e[2 * n + 1]),
            (t[n] = r.count),
            r.count++,
            a.vertexLength++,
            o
          );
        }
        return t[n];
      }
      class gc {
        constructor(t) {
          (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((t) => t.id)),
            (this.index = t.index),
            (this.hasDependencies = !1),
            (this.patternFeatures = []),
            (this.layoutVertexArray = new Va()),
            (this.indexArray = new Ja()),
            (this.indexArray2 = new Qa()),
            (this.programConfigurations = new ks(t.layers, t.zoom)),
            (this.segments = new is()),
            (this.segments2 = new is()),
            (this.stateDependentLayerIds = this.layers
              .filter((t) => t.isStateDependent())
              .map((t) => t.id));
        }
        populate(t, e, i) {
          this.hasDependencies = Rl('fill', this.layers, e);
          const r = this.layers[0].layout.get('fill-sort-key'),
            n = !r.isConstant(),
            o = [];
          for (const {
            feature: a,
            id: s,
            index: l,
            sourceLayerIndex: c,
          } of t) {
            const t = this.layers[0]._featureFilter.needGeometry,
              h = Os(a, t);
            if (!this.layers[0]._featureFilter.filter(new zo(this.zoom), h, i))
              continue;
            const u = n ? r.evaluate(h, {}, i, e.availableImages) : void 0,
              d = {
                id: s,
                properties: a.properties,
                type: a.type,
                sourceLayerIndex: c,
                index: l,
                geometry: t ? h.geometry : Bs(a),
                patterns: {},
                sortKey: u,
              };
            o.push(d);
          }
          n && o.sort((t, e) => t.sortKey - e.sortKey);
          for (const a of o) {
            const { geometry: r, index: n, sourceLayerIndex: o } = a;
            if (this.hasDependencies) {
              const t = Ll('fill', this.layers, a, { zoom: this.zoom }, e);
              this.patternFeatures.push(t);
            } else this.addFeature(a, r, n, i, {}, e.subdivisionGranularity);
            e.featureIndex.insert(t[n].feature, r, n, o, this.index);
          }
        }
        update(t, e, i) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              e,
              this.stateDependentLayers,
              { imagePositions: i }
            );
        }
        addFeatures(t, e, i) {
          for (const r of this.patternFeatures)
            this.addFeature(
              r,
              r.geometry,
              r.index,
              e,
              i,
              t.subdivisionGranularity
            );
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              Dl
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
            (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.indexBuffer2.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.segments2.destroy());
        }
        addFeature(t, e, i, r, n, o) {
          for (const a of tr(e, 500)) {
            const t = dc(a, r, o.fill.getGranularityForZoomLevel(r.z)),
              e = this.layoutVertexArray;
            mc(
              (t, i) => {
                e.emplaceBack(t, i);
              },
              this.segments,
              this.layoutVertexArray,
              this.indexArray,
              t.verticesFlattened,
              t.indicesTriangles,
              this.segments2,
              this.indexArray2,
              t.indicesLineList
            );
          }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            i,
            { imagePositions: n, canonical: r }
          );
        }
      }
      let yc, xc;
      co('FillBucket', gc, { omit: ['layers', 'patternFeatures'] });
      var vc = {
        get paint() {
          return (xc =
            xc ||
            new qo({
              'fill-antialias': new Vo(xt.paint_fill['fill-antialias']),
              'fill-opacity': new Uo(xt.paint_fill['fill-opacity']),
              'fill-color': new Uo(xt.paint_fill['fill-color']),
              'fill-outline-color': new Uo(xt.paint_fill['fill-outline-color']),
              'fill-translate': new Vo(xt.paint_fill['fill-translate']),
              'fill-translate-anchor': new Vo(
                xt.paint_fill['fill-translate-anchor']
              ),
              'fill-pattern': new Go(xt.paint_fill['fill-pattern']),
            }));
        },
        get layout() {
          return (yc =
            yc ||
            new qo({
              'fill-sort-key': new Uo(xt.layout_fill['fill-sort-key']),
            }));
        },
      };
      class bc extends Yo {
        constructor(t, e) {
          super(t, vc, e);
        }
        recalculate(t, e) {
          super.recalculate(t, e);
          const i = this.paint._values['fill-outline-color'];
          'constant' === i.value.kind &&
            void 0 === i.value.value &&
            (this.paint._values['fill-outline-color'] =
              this.paint._values['fill-color']);
        }
        createBucket(t) {
          return new gc(t);
        }
        queryRadius() {
          return tl(this.paint.get('fill-translate'));
        }
        queryIntersectsFeature({
          queryGeometry: t,
          geometry: e,
          transform: i,
          pixelsToTileUnits: r,
        }) {
          return Zs(
            el(
              t,
              this.paint.get('fill-translate'),
              this.paint.get('fill-translate-anchor'),
              -i.bearingInRadians,
              r
            ),
            e
          );
        }
        isTileClipped() {
          return !0;
        }
      }
      const wc = ea(
          [
            { name: 'a_pos', components: 2, type: 'Int16' },
            { name: 'a_normal_ed', components: 4, type: 'Int16' },
          ],
          4
        ),
        Tc = ea([{ name: 'a_centroid', components: 2, type: 'Int16' }], 4),
        { members: Pc } = wc;
      class Sc {
        constructor(t, e, i, r, n) {
          (this.properties = {}),
            (this.extent = i),
            (this.type = 0),
            (this.id = void 0),
            (this._pbf = t),
            (this._geometry = -1),
            (this._keys = r),
            (this._values = n),
            t.readFields(Mc, this, e);
        }
        loadGeometry() {
          const t = this._pbf;
          t.pos = this._geometry;
          const e = t.readVarint() + t.pos,
            r = [];
          let n,
            o = 1,
            a = 0,
            s = 0,
            l = 0;
          for (; t.pos < e; ) {
            if (a <= 0) {
              const e = t.readVarint();
              (o = 7 & e), (a = e >> 3);
            }
            if ((a--, 1 === o || 2 === o))
              (s += t.readSVarint()),
                (l += t.readSVarint()),
                1 === o && (n && r.push(n), (n = [])),
                n && n.push(new i(s, l));
            else {
              if (7 !== o) throw new Error(`unknown command ${o}`);
              n && n.push(n[0].clone());
            }
          }
          return n && r.push(n), r;
        }
        bbox() {
          const t = this._pbf;
          t.pos = this._geometry;
          const e = t.readVarint() + t.pos;
          let i = 1,
            r = 0,
            n = 0,
            o = 0,
            a = 1 / 0,
            s = -1 / 0,
            l = 1 / 0,
            c = -1 / 0;
          for (; t.pos < e; ) {
            if (r <= 0) {
              const e = t.readVarint();
              (i = 7 & e), (r = e >> 3);
            }
            if ((r--, 1 === i || 2 === i))
              (n += t.readSVarint()),
                (o += t.readSVarint()),
                n < a && (a = n),
                n > s && (s = n),
                o < l && (l = o),
                o > c && (c = o);
            else if (7 !== i) throw new Error(`unknown command ${i}`);
          }
          return [a, l, s, c];
        }
        toGeoJSON(t, e, i) {
          const r = this.extent * Math.pow(2, i),
            n = this.extent * t,
            o = this.extent * e,
            a = this.loadGeometry();
          function s(t) {
            return [
              (360 * (t.x + n)) / r - 180,
              (360 / Math.PI) *
                Math.atan(Math.exp((1 - (2 * (t.y + o)) / r) * Math.PI)) -
                90,
            ];
          }
          function l(t) {
            return t.map(s);
          }
          let c;
          if (1 === this.type) {
            const t = [];
            for (const i of a) t.push(i[0]);
            const e = l(t);
            c =
              1 === t.length
                ? { type: 'Point', coordinates: e[0] }
                : { type: 'MultiPoint', coordinates: e };
          } else if (2 === this.type) {
            const t = a.map(l);
            c =
              1 === t.length
                ? { type: 'LineString', coordinates: t[0] }
                : { type: 'MultiLineString', coordinates: t };
          } else {
            if (3 !== this.type) throw new Error('unknown feature type');
            {
              const t = (function (t) {
                  const e = t.length;
                  if (e <= 1) return [t];
                  const i = [];
                  let r, n;
                  for (let o = 0; o < e; o++) {
                    const e = Ic(t[o]);
                    0 !== e &&
                      (void 0 === n && (n = e < 0),
                      n === e < 0
                        ? (r && i.push(r), (r = [t[o]]))
                        : r && r.push(t[o]));
                  }
                  return r && i.push(r), i;
                })(a),
                e = [];
              for (const i of t) e.push(i.map(l));
              c =
                1 === e.length
                  ? { type: 'Polygon', coordinates: e[0] }
                  : { type: 'MultiPolygon', coordinates: e };
            }
          }
          const h = {
            type: 'Feature',
            geometry: c,
            properties: this.properties,
          };
          return null != this.id && (h.id = this.id), h;
        }
      }
      function Mc(t, e, i) {
        1 === t
          ? (e.id = i.readVarint())
          : 2 === t
          ? (function (t, e) {
              const i = t.readVarint() + t.pos;
              for (; t.pos < i; ) {
                const i = e._keys[t.readVarint()],
                  r = e._values[t.readVarint()];
                e.properties[i] = r;
              }
            })(i, e)
          : 3 === t
          ? (e.type = i.readVarint())
          : 4 === t && (e._geometry = i.pos);
      }
      function Ic(t) {
        let e = 0;
        for (let i, r, n = 0, o = t.length, a = o - 1; n < o; a = n++)
          (i = t[n]), (r = t[a]), (e += (r.x - i.x) * (i.y + r.y));
        return e;
      }
      Sc.types = ['Unknown', 'Point', 'LineString', 'Polygon'];
      class Cc {
        constructor(t, e) {
          (this.version = 1),
            (this.name = ''),
            (this.extent = 4096),
            (this.length = 0),
            (this._pbf = t),
            (this._keys = []),
            (this._values = []),
            (this._features = []),
            t.readFields(Ac, this, e),
            (this.length = this._features.length);
        }
        feature(t) {
          if (t < 0 || t >= this._features.length)
            throw new Error('feature index out of bounds');
          this._pbf.pos = this._features[t];
          const e = this._pbf.readVarint() + this._pbf.pos;
          return new Sc(this._pbf, e, this.extent, this._keys, this._values);
        }
      }
      function Ac(t, e, i) {
        15 === t
          ? (e.version = i.readVarint())
          : 1 === t
          ? (e.name = i.readString())
          : 5 === t
          ? (e.extent = i.readVarint())
          : 2 === t
          ? e._features.push(i.pos)
          : 3 === t
          ? e._keys.push(i.readString())
          : 4 === t &&
            e._values.push(
              (function (t) {
                let e = null;
                const i = t.readVarint() + t.pos;
                for (; t.pos < i; ) {
                  const i = t.readVarint() >> 3;
                  e =
                    1 === i
                      ? t.readString()
                      : 2 === i
                      ? t.readFloat()
                      : 3 === i
                      ? t.readDouble()
                      : 4 === i
                      ? t.readVarint64()
                      : 5 === i
                      ? t.readVarint()
                      : 6 === i
                      ? t.readSVarint()
                      : 7 === i
                      ? t.readBoolean()
                      : null;
                }
                if (null == e) throw new Error('unknown feature value');
                return e;
              })(i)
            );
      }
      class Ec {
        constructor(t, e) {
          this.layers = t.readFields(zc, {}, e);
        }
      }
      function zc(t, e, i) {
        if (3 === t) {
          const t = new Cc(i, i.readVarint() + i.pos);
          t.length && (e[t.name] = t);
        }
      }
      const kc = Math.pow(2, 13);
      function Dc(t, e, i, r, n, o, a, s) {
        t.emplaceBack(
          e,
          i,
          2 * Math.floor(r * kc) + a,
          n * kc * 2,
          o * kc * 2,
          Math.round(s)
        );
      }
      class Rc {
        constructor(t) {
          (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((t) => t.id)),
            (this.index = t.index),
            (this.hasDependencies = !1),
            (this.layoutVertexArray = new Ua()),
            (this.centroidVertexArray = new ja()),
            (this.indexArray = new Ja()),
            (this.programConfigurations = new ks(t.layers, t.zoom)),
            (this.segments = new is()),
            (this.stateDependentLayerIds = this.layers
              .filter((t) => t.isStateDependent())
              .map((t) => t.id));
        }
        populate(t, e, i) {
          (this.features = []),
            (this.hasDependencies = Rl('fill-extrusion', this.layers, e));
          for (const {
            feature: r,
            id: n,
            index: o,
            sourceLayerIndex: a,
          } of t) {
            const t = this.layers[0]._featureFilter.needGeometry,
              s = Os(r, t);
            if (!this.layers[0]._featureFilter.filter(new zo(this.zoom), s, i))
              continue;
            const l = {
              id: n,
              sourceLayerIndex: a,
              index: o,
              geometry: t ? s.geometry : Bs(r),
              properties: r.properties,
              type: r.type,
              patterns: {},
            };
            this.hasDependencies
              ? this.features.push(
                  Ll('fill-extrusion', this.layers, l, { zoom: this.zoom }, e)
                )
              : this.addFeature(
                  l,
                  l.geometry,
                  o,
                  i,
                  {},
                  e.subdivisionGranularity
                ),
              e.featureIndex.insert(r, l.geometry, o, a, this.index, !0);
          }
        }
        addFeatures(t, e, i) {
          for (const r of this.features) {
            const { geometry: n } = r;
            this.addFeature(r, n, r.index, e, i, t.subdivisionGranularity);
          }
        }
        update(t, e, i) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              e,
              this.stateDependentLayers,
              { imagePositions: i }
            );
        }
        isEmpty() {
          return (
            0 === this.layoutVertexArray.length &&
            0 === this.centroidVertexArray.length
          );
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded ||
            ((this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              Pc
            )),
            (this.centroidVertexBuffer = t.createVertexBuffer(
              this.centroidVertexArray,
              Tc.members,
              !0
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.centroidVertexBuffer.destroy());
        }
        addFeature(t, e, i, r, n, o) {
          for (const a of tr(e, 500)) {
            const e = { x: 0, y: 0, sampleCount: 0 },
              i = this.layoutVertexArray.length;
            this.processPolygon(e, r, t, a, o);
            const n = this.layoutVertexArray.length - i,
              s = Math.floor(e.x / e.sampleCount),
              l = Math.floor(e.y / e.sampleCount);
            for (let t = 0; t < n; t++)
              this.centroidVertexArray.emplaceBack(s, l);
          }
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            i,
            { imagePositions: n, canonical: r }
          );
        }
        processPolygon(t, e, i, r, n) {
          if (r.length < 1) return;
          if (Bc(r[0])) return;
          for (const h of r) 0 !== h.length && Lc(t, h);
          const o = {
              segment: this.segments.prepareSegment(
                4,
                this.layoutVertexArray,
                this.indexArray
              ),
            },
            a = n.fill.getGranularityForZoomLevel(e.z),
            s = 'Polygon' === Sc.types[i.type];
          for (const h of r) {
            if (0 === h.length) continue;
            if (Bc(h)) continue;
            const t = pc(h, a, s);
            this._generateSideFaces(t, o);
          }
          if (!s) return;
          const l = dc(r, e, a, !1),
            c = this.layoutVertexArray;
          mc(
            (t, e) => {
              Dc(c, t, e, 0, 0, 1, 1, 0);
            },
            this.segments,
            this.layoutVertexArray,
            this.indexArray,
            l.verticesFlattened,
            l.indicesTriangles
          );
        }
        _generateSideFaces(t, e) {
          let i = 0;
          for (let r = 1; r < t.length; r++) {
            const n = t[r],
              o = t[r - 1];
            if (Fc(n, o)) continue;
            e.segment.vertexLength + 4 > is.MAX_VERTEX_ARRAY_LENGTH &&
              (e.segment = this.segments.prepareSegment(
                4,
                this.layoutVertexArray,
                this.indexArray
              ));
            const a = n.sub(o)._perp()._unit(),
              s = o.dist(n);
            i + s > 32768 && (i = 0),
              Dc(this.layoutVertexArray, n.x, n.y, a.x, a.y, 0, 0, i),
              Dc(this.layoutVertexArray, n.x, n.y, a.x, a.y, 0, 1, i),
              (i += s),
              Dc(this.layoutVertexArray, o.x, o.y, a.x, a.y, 0, 0, i),
              Dc(this.layoutVertexArray, o.x, o.y, a.x, a.y, 0, 1, i);
            const l = e.segment.vertexLength;
            this.indexArray.emplaceBack(l, l + 2, l + 1),
              this.indexArray.emplaceBack(l + 1, l + 2, l + 3),
              (e.segment.vertexLength += 4),
              (e.segment.primitiveLength += 2);
          }
        }
      }
      function Lc(t, e) {
        for (let i = 0; i < e.length; i++) {
          const r = e[i];
          (i === e.length - 1 && e[0].x === r.x && e[0].y === r.y) ||
            ((t.x += r.x), (t.y += r.y), t.sampleCount++);
        }
      }
      function Fc(t, e) {
        return (
          (t.x === e.x && (t.x < 0 || t.x > A)) ||
          (t.y === e.y && (t.y < 0 || t.y > A))
        );
      }
      function Bc(t) {
        return (
          t.every((t) => t.x < 0) ||
          t.every((t) => t.x > A) ||
          t.every((t) => t.y < 0) ||
          t.every((t) => t.y > A)
        );
      }
      let Oc;
      co('FillExtrusionBucket', Rc, { omit: ['layers', 'features'] });
      var jc = {
        get paint() {
          return (Oc =
            Oc ||
            new qo({
              'fill-extrusion-opacity': new Vo(
                xt['paint_fill-extrusion']['fill-extrusion-opacity']
              ),
              'fill-extrusion-color': new Uo(
                xt['paint_fill-extrusion']['fill-extrusion-color']
              ),
              'fill-extrusion-translate': new Vo(
                xt['paint_fill-extrusion']['fill-extrusion-translate']
              ),
              'fill-extrusion-translate-anchor': new Vo(
                xt['paint_fill-extrusion']['fill-extrusion-translate-anchor']
              ),
              'fill-extrusion-pattern': new Go(
                xt['paint_fill-extrusion']['fill-extrusion-pattern']
              ),
              'fill-extrusion-height': new Uo(
                xt['paint_fill-extrusion']['fill-extrusion-height']
              ),
              'fill-extrusion-base': new Uo(
                xt['paint_fill-extrusion']['fill-extrusion-base']
              ),
              'fill-extrusion-vertical-gradient': new Vo(
                xt['paint_fill-extrusion']['fill-extrusion-vertical-gradient']
              ),
            }));
        },
      };
      class Nc extends Yo {
        constructor(t, e) {
          super(t, jc, e);
        }
        createBucket(t) {
          return new Rc(t);
        }
        queryRadius() {
          return tl(this.paint.get('fill-extrusion-translate'));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: e,
          featureState: r,
          geometry: n,
          transform: o,
          pixelsToTileUnits: a,
          pixelPosMatrix: s,
        }) {
          const l = el(
              t,
              this.paint.get('fill-extrusion-translate'),
              this.paint.get('fill-extrusion-translate-anchor'),
              -o.bearingInRadians,
              a
            ),
            c = this.paint.get('fill-extrusion-height').evaluate(e, r),
            h = this.paint.get('fill-extrusion-base').evaluate(e, r),
            u = (function (t, e) {
              const r = [];
              for (const n of t) {
                const t = [n.x, n.y, 0, 1];
                P(t, t, e), r.push(new i(t[0] / t[3], t[1] / t[3]));
              }
              return r;
            })(l, s),
            d = (function (t, e, r, n) {
              const o = [],
                a = [],
                s = n[8] * e,
                l = n[9] * e,
                c = n[10] * e,
                h = n[11] * e,
                u = n[8] * r,
                d = n[9] * r,
                p = n[10] * r,
                f = n[11] * r;
              for (const m of t) {
                const t = [],
                  e = [];
                for (const r of m) {
                  const o = r.x,
                    a = r.y,
                    m = n[0] * o + n[4] * a + n[12],
                    _ = n[1] * o + n[5] * a + n[13],
                    g = n[2] * o + n[6] * a + n[14],
                    y = n[3] * o + n[7] * a + n[15],
                    x = g + c,
                    v = y + h,
                    b = m + u,
                    w = _ + d,
                    T = g + p,
                    P = y + f,
                    S = new i((m + s) / v, (_ + l) / v);
                  (S.z = x / v), t.push(S);
                  const M = new i(b / P, w / P);
                  (M.z = T / P), e.push(M);
                }
                o.push(t), a.push(e);
              }
              return [o, a];
            })(n, h, c, s);
          return (function (t, e, i) {
            let r = 1 / 0;
            Zs(i, e) && (r = Uc(i, e[0]));
            for (let n = 0; n < e.length; n++) {
              const o = e[n],
                a = t[n];
              for (let t = 0; t < o.length - 1; t++) {
                const e = o[t],
                  n = [e, o[t + 1], a[t + 1], a[t], e];
                Us(i, n) && (r = Math.min(r, Uc(i, n)));
              }
            }
            return r !== 1 / 0 && r;
          })(d[0], d[1], u);
        }
      }
      function Vc(t, e) {
        return t.x * e.x + t.y * e.y;
      }
      function Uc(t, e) {
        if (1 === t.length) {
          let i = 0;
          const r = e[i++];
          let n;
          for (; !n || r.equals(n); ) if (((n = e[i++]), !n)) return 1 / 0;
          for (; i < e.length; i++) {
            const o = e[i],
              a = t[0],
              s = n.sub(r),
              l = o.sub(r),
              c = a.sub(r),
              h = Vc(s, s),
              u = Vc(s, l),
              d = Vc(l, l),
              p = Vc(c, s),
              f = Vc(c, l),
              m = h * d - u * u,
              _ = (d * p - u * f) / m,
              g = (h * f - u * p) / m,
              y = r.z * (1 - _ - g) + n.z * _ + o.z * g;
            if (isFinite(y)) return y;
          }
          return 1 / 0;
        }
        {
          let t = 1 / 0;
          for (const i of e) t = Math.min(t, i.z);
          return t;
        }
      }
      const Gc = ea(
          [
            { name: 'a_pos_normal', components: 2, type: 'Int16' },
            { name: 'a_data', components: 4, type: 'Uint8' },
          ],
          4
        ),
        { members: Zc } = Gc,
        $c = ea([
          { name: 'a_uv_x', components: 1, type: 'Float32' },
          { name: 'a_split_index', components: 1, type: 'Float32' },
        ]),
        { members: qc } = $c,
        Wc = Math.cos((Math.PI / 180) * 37.5),
        Yc = Math.pow(2, 14) / 0.5;
      class Hc {
        constructor(t) {
          (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((t) => t.id)),
            (this.index = t.index),
            (this.hasDependencies = !1),
            (this.patternFeatures = []),
            (this.lineClipsArray = []),
            (this.gradients = {}),
            this.layers.forEach((t) => {
              this.gradients[t.id] = {};
            }),
            (this.layoutVertexArray = new Ga()),
            (this.layoutVertexArray2 = new Za()),
            (this.indexArray = new Ja()),
            (this.programConfigurations = new ks(t.layers, t.zoom)),
            (this.segments = new is()),
            (this.maxLineLength = 0),
            (this.stateDependentLayerIds = this.layers
              .filter((t) => t.isStateDependent())
              .map((t) => t.id));
        }
        populate(t, e, i) {
          this.hasDependencies =
            Rl('line', this.layers, e) || this.hasLineDasharray(this.layers);
          const r = this.layers[0].layout.get('line-sort-key'),
            n = !r.isConstant(),
            o = [];
          for (const {
            feature: a,
            id: s,
            index: l,
            sourceLayerIndex: c,
          } of t) {
            const t = this.layers[0]._featureFilter.needGeometry,
              e = Os(a, t);
            if (!this.layers[0]._featureFilter.filter(new zo(this.zoom), e, i))
              continue;
            const h = n ? r.evaluate(e, {}, i) : void 0,
              u = {
                id: s,
                properties: a.properties,
                type: a.type,
                sourceLayerIndex: c,
                index: l,
                geometry: t ? e.geometry : Bs(a),
                patterns: {},
                dashes: {},
                sortKey: h,
              };
            o.push(u);
          }
          n && o.sort((t, e) => t.sortKey - e.sortKey);
          for (const a of o) {
            const { geometry: r, index: n, sourceLayerIndex: o } = a;
            this.hasDependencies
              ? (Rl('line', this.layers, e)
                  ? Ll('line', this.layers, a, { zoom: this.zoom }, e)
                  : this.hasLineDasharray(this.layers) &&
                    this.addLineDashDependencies(this.layers, a, this.zoom, e),
                this.patternFeatures.push(a))
              : this.addFeature(a, r, n, i, {}, {}, e.subdivisionGranularity),
              e.featureIndex.insert(t[n].feature, r, n, o, this.index);
          }
        }
        update(t, e, i, r) {
          this.stateDependentLayers.length &&
            this.programConfigurations.updatePaintArrays(
              t,
              e,
              this.stateDependentLayers,
              { imagePositions: i, dashPositions: r }
            );
        }
        addFeatures(t, e, i, r) {
          for (const n of this.patternFeatures)
            this.addFeature(
              n,
              n.geometry,
              n.index,
              e,
              i,
              r,
              t.subdivisionGranularity
            );
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded ||
            (0 !== this.layoutVertexArray2.length &&
              (this.layoutVertexBuffer2 = t.createVertexBuffer(
                this.layoutVertexArray2,
                qc
              )),
            (this.layoutVertexBuffer = t.createVertexBuffer(
              this.layoutVertexArray,
              Zc
            )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
            this.programConfigurations.upload(t),
            (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (
            t.properties &&
            Object.prototype.hasOwnProperty.call(
              t.properties,
              'mapbox_clip_start'
            ) &&
            Object.prototype.hasOwnProperty.call(
              t.properties,
              'mapbox_clip_end'
            )
          )
            return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end,
            };
        }
        addFeature(t, e, i, r, n, o, a) {
          const s = this.layers[0].layout,
            l = s.get('line-join').evaluate(t, {}),
            c = s.get('line-cap'),
            h = s.get('line-miter-limit'),
            u = s.get('line-round-limit');
          this.lineClips = this.lineFeatureClips(t);
          for (const d of e) this.addLine(d, t, l, c, h, u, r, a);
          this.programConfigurations.populatePaintArrays(
            this.layoutVertexArray.length,
            t,
            i,
            { imagePositions: n, dashPositions: o, canonical: r }
          );
        }
        addLine(t, e, i, r, n, o, a, s) {
          if (
            ((this.distance = 0),
            (this.scaledDistance = 0),
            (this.totalDistance = 0),
            (t = pc(t, a ? s.line.getGranularityForZoomLevel(a.z) : 1)),
            this.lineClips)
          ) {
            this.lineClipsArray.push(this.lineClips);
            for (let e = 0; e < t.length - 1; e++)
              this.totalDistance += t[e].dist(t[e + 1]);
            this.updateScaledDistance(),
              (this.maxLineLength = Math.max(
                this.maxLineLength,
                this.totalDistance
              ));
          }
          const l = 'Polygon' === Sc.types[e.type];
          let c = t.length;
          for (; c >= 2 && t[c - 1].equals(t[c - 2]); ) c--;
          let h = 0;
          for (; h < c - 1 && t[h].equals(t[h + 1]); ) h++;
          if (c < (l ? 3 : 2)) return;
          'bevel' === i && (n = 1.05);
          const u =
              this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
            d = this.segments.prepareSegment(
              10 * c,
              this.layoutVertexArray,
              this.indexArray
            );
          let p, f, m, _, g;
          (this.e1 = this.e2 = -1),
            l && ((p = t[c - 2]), (g = t[h].sub(p)._unit()._perp()));
          for (let y = h; y < c; y++) {
            if (
              ((m = y === c - 1 ? (l ? t[h + 1] : void 0) : t[y + 1]),
              m && t[y].equals(m))
            )
              continue;
            g && (_ = g),
              p && (f = p),
              (p = t[y]),
              (g = m ? m.sub(p)._unit()._perp() : _),
              (_ = _ || g);
            let e = _.add(g);
            (0 === e.x && 0 === e.y) || e._unit();
            const a = _.x * g.x + _.y * g.y,
              s = e.x * g.x + e.y * g.y,
              x = 0 !== s ? 1 / s : 1 / 0,
              v = 2 * Math.sqrt(2 - 2 * s),
              b = s < Wc && f && m,
              w = _.x * g.y - _.y * g.x > 0;
            if (b && y > h) {
              const t = p.dist(f);
              if (t > 2 * u) {
                const e = p.sub(
                  p
                    .sub(f)
                    ._mult(u / t)
                    ._round()
                );
                this.updateDistance(f, e),
                  this.addCurrentVertex(e, _, 0, 0, d),
                  (f = e);
              }
            }
            const T = f && m;
            let P = T ? i : l ? 'butt' : r;
            if (
              (T &&
                'round' === P &&
                (x < o ? (P = 'miter') : x <= 2 && (P = 'fakeround')),
              'miter' === P && x > n && (P = 'bevel'),
              'bevel' === P &&
                (x > 2 && (P = 'flipbevel'), x < n && (P = 'miter')),
              f && this.updateDistance(f, p),
              'miter' === P)
            )
              e._mult(x), this.addCurrentVertex(p, e, 0, 0, d);
            else if ('flipbevel' === P) {
              if (x > 100) e = g.mult(-1);
              else {
                const t = (x * _.add(g).mag()) / _.sub(g).mag();
                e._perp()._mult(t * (w ? -1 : 1));
              }
              this.addCurrentVertex(p, e, 0, 0, d),
                this.addCurrentVertex(p, e.mult(-1), 0, 0, d);
            } else if ('bevel' === P || 'fakeround' === P) {
              const t = -Math.sqrt(x * x - 1),
                e = w ? t : 0,
                i = w ? 0 : t;
              if (
                (f && this.addCurrentVertex(p, _, e, i, d), 'fakeround' === P)
              ) {
                const t = Math.round((180 * v) / Math.PI / 20);
                for (let e = 1; e < t; e++) {
                  let i = e / t;
                  if (0.5 !== i) {
                    const t = i - 0.5;
                    i +=
                      i *
                      t *
                      (i - 1) *
                      ((1.0904 + a * (a * (3.55645 - 1.43519 * a) - 3.2452)) *
                        t *
                        t +
                        (0.848013 + a * (0.215638 * a - 1.06021)));
                  }
                  const r = g
                    .sub(_)
                    ._mult(i)
                    ._add(_)
                    ._unit()
                    ._mult(w ? -1 : 1);
                  this.addHalfVertex(p, r.x, r.y, !1, w, 0, d);
                }
              }
              m && this.addCurrentVertex(p, g, -e, -i, d);
            } else if ('butt' === P) this.addCurrentVertex(p, e, 0, 0, d);
            else if ('square' === P) {
              const t = f ? 1 : -1;
              this.addCurrentVertex(p, e, t, t, d);
            } else
              'round' === P &&
                (f &&
                  (this.addCurrentVertex(p, _, 0, 0, d),
                  this.addCurrentVertex(p, _, 1, 1, d, !0)),
                m &&
                  (this.addCurrentVertex(p, g, -1, -1, d, !0),
                  this.addCurrentVertex(p, g, 0, 0, d)));
            if (b && y < c - 1) {
              const t = p.dist(m);
              if (t > 2 * u) {
                const e = p.add(
                  m
                    .sub(p)
                    ._mult(u / t)
                    ._round()
                );
                this.updateDistance(p, e),
                  this.addCurrentVertex(e, g, 0, 0, d),
                  (p = e);
              }
            }
          }
        }
        addCurrentVertex(t, e, i, r, n, o = !1) {
          const a = e.y * r - e.x,
            s = -e.y - e.x * r;
          this.addHalfVertex(t, e.x + e.y * i, e.y - e.x * i, o, !1, i, n),
            this.addHalfVertex(t, a, s, o, !0, -r, n),
            this.distance > Yc / 2 &&
              0 === this.totalDistance &&
              ((this.distance = 0),
              this.updateScaledDistance(),
              this.addCurrentVertex(t, e, i, r, n, o));
        }
        addHalfVertex({ x: t, y: e }, i, r, n, o, a, s) {
          const l =
            0.5 *
            (this.lineClips
              ? this.scaledDistance * (Yc - 1)
              : this.scaledDistance);
          this.layoutVertexArray.emplaceBack(
            (t << 1) + (n ? 1 : 0),
            (e << 1) + (o ? 1 : 0),
            Math.round(63 * i) + 128,
            Math.round(63 * r) + 128,
            (1 + (0 === a ? 0 : a < 0 ? -1 : 1)) | ((63 & l) << 2),
            l >> 6
          ),
            this.lineClips &&
              this.layoutVertexArray2.emplaceBack(
                (this.scaledDistance - this.lineClips.start) /
                  (this.lineClips.end - this.lineClips.start),
                this.lineClipsArray.length
              );
          const c = s.vertexLength++;
          this.e1 >= 0 &&
            this.e2 >= 0 &&
            (this.indexArray.emplaceBack(this.e1, c, this.e2),
            s.primitiveLength++),
            o ? (this.e2 = c) : (this.e1 = c);
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips
            ? this.lineClips.start +
              ((this.lineClips.end - this.lineClips.start) * this.distance) /
                this.totalDistance
            : this.distance;
        }
        updateDistance(t, e) {
          (this.distance += t.dist(e)), this.updateScaledDistance();
        }
        hasLineDasharray(t) {
          for (const e of t) {
            const t = e.paint.get('line-dasharray');
            if (t && !t.isConstant()) return !0;
          }
          return !1;
        }
        addLineDashDependencies(t, e, i, r) {
          for (const n of t) {
            const t = n.paint.get('line-dasharray');
            if (!t || 'constant' === t.value.kind) continue;
            const o = 'round' === n.layout.get('line-cap'),
              a = {
                dasharray: t.value.evaluate({ zoom: i - 1 }, e, {}),
                round: o,
              },
              s = { dasharray: t.value.evaluate({ zoom: i }, e, {}), round: o },
              l = {
                dasharray: t.value.evaluate({ zoom: i + 1 }, e, {}),
                round: o,
              },
              c = `${a.dasharray.join(',')},${a.round}`,
              h = `${s.dasharray.join(',')},${s.round}`,
              u = `${l.dasharray.join(',')},${l.round}`;
            (r.dashDependencies[c] = a),
              (r.dashDependencies[h] = s),
              (r.dashDependencies[u] = l),
              (e.dashes[n.id] = { min: c, mid: h, max: u });
          }
        }
      }
      let Xc, Kc;
      co('LineBucket', Hc, { omit: ['layers', 'patternFeatures'] });
      var Jc = {
        get paint() {
          return (Kc =
            Kc ||
            new qo({
              'line-opacity': new Uo(xt.paint_line['line-opacity']),
              'line-color': new Uo(xt.paint_line['line-color']),
              'line-translate': new Vo(xt.paint_line['line-translate']),
              'line-translate-anchor': new Vo(
                xt.paint_line['line-translate-anchor']
              ),
              'line-width': new Uo(xt.paint_line['line-width']),
              'line-gap-width': new Uo(xt.paint_line['line-gap-width']),
              'line-offset': new Uo(xt.paint_line['line-offset']),
              'line-blur': new Uo(xt.paint_line['line-blur']),
              'line-dasharray': new Go(xt.paint_line['line-dasharray']),
              'line-pattern': new Go(xt.paint_line['line-pattern']),
              'line-gradient': new $o(xt.paint_line['line-gradient']),
            }));
        },
        get layout() {
          return (Xc =
            Xc ||
            new qo({
              'line-cap': new Vo(xt.layout_line['line-cap']),
              'line-join': new Uo(xt.layout_line['line-join']),
              'line-miter-limit': new Vo(xt.layout_line['line-miter-limit']),
              'line-round-limit': new Vo(xt.layout_line['line-round-limit']),
              'line-sort-key': new Uo(xt.layout_line['line-sort-key']),
            }));
        },
      };
      class Qc extends Uo {
        possiblyEvaluate(t, e) {
          return (
            (e = new zo(Math.floor(e.zoom), {
              now: e.now,
              fadeDuration: e.fadeDuration,
              zoomHistory: e.zoomHistory,
              transition: e.transition,
            })),
            super.possiblyEvaluate(t, e)
          );
        }
        evaluate(t, e, i, r) {
          return (
            (e = O({}, e, { zoom: Math.floor(e.zoom) })),
            super.evaluate(t, e, i, r)
          );
        }
      }
      let th;
      class eh extends Yo {
        constructor(t, e) {
          super(t, Jc, e),
            (this.gradientVersion = 0),
            th ||
              ((th = new Qc(Jc.paint.properties['line-width'].specification)),
              (th.useIntegerZoom = !0));
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if ('line-gradient' === t) {
            const t = this.gradientExpression();
            (this.stepInterpolant =
              !!(function (t) {
                return void 0 !== t._styleExpression;
              })(t) && t._styleExpression.expression instanceof si),
              (this.gradientVersion =
                (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
          }
        }
        gradientExpression() {
          return this
            ._transitionablePaint._values['line-gradient'].value.expression;
        }
        recalculate(t, e) {
          super.recalculate(t, e),
            (this.paint._values['line-floorwidth'] = th.possiblyEvaluate(
              this._transitioningPaint._values['line-width'].value,
              t
            ));
        }
        createBucket(t) {
          return new Hc(t);
        }
        queryRadius(t) {
          const e = t,
            i = ih(Qs('line-width', this, e), Qs('line-gap-width', this, e)),
            r = Qs('line-offset', this, e);
          return i / 2 + Math.abs(r) + tl(this.paint.get('line-translate'));
        }
        queryIntersectsFeature({
          queryGeometry: t,
          feature: e,
          featureState: r,
          geometry: n,
          transform: o,
          pixelsToTileUnits: a,
        }) {
          const s = el(
              t,
              this.paint.get('line-translate'),
              this.paint.get('line-translate-anchor'),
              -o.bearingInRadians,
              a
            ),
            l =
              (a / 2) *
              ih(
                this.paint.get('line-width').evaluate(e, r),
                this.paint.get('line-gap-width').evaluate(e, r)
              ),
            c = this.paint.get('line-offset').evaluate(e, r);
          return (
            c &&
              (n = (function (t, e) {
                const r = [];
                for (let n = 0; n < t.length; n++) {
                  const o = t[n],
                    a = [];
                  for (let t = 0; t < o.length; t++) {
                    const r = o[t - 1],
                      n = o[t],
                      s = o[t + 1],
                      l = 0 === t ? new i(0, 0) : n.sub(r)._unit()._perp(),
                      c =
                        t === o.length - 1
                          ? new i(0, 0)
                          : s.sub(n)._unit()._perp(),
                      h = l._add(c)._unit(),
                      u = h.x * c.x + h.y * c.y;
                    0 !== u && h._mult(1 / u), a.push(h._mult(e)._add(n));
                  }
                  r.push(a);
                }
                return r;
              })(n, c * a)),
            (function (t, e, i) {
              for (let r = 0; r < e.length; r++) {
                const n = e[r];
                if (t.length >= 3)
                  for (let e = 0; e < n.length; e++) if (Ks(t, n[e])) return !0;
                if ($s(t, n, i)) return !0;
              }
              return !1;
            })(s, n, l)
          );
        }
        isTileClipped() {
          return !0;
        }
      }
      function ih(t, e) {
        return e > 0 ? e + 2 * t : t;
      }
      const rh = ea(
          [
            { name: 'a_pos_offset', components: 4, type: 'Int16' },
            { name: 'a_data', components: 4, type: 'Uint16' },
            { name: 'a_pixeloffset', components: 4, type: 'Int16' },
          ],
          4
        ),
        nh = ea(
          [{ name: 'a_projected_pos', components: 3, type: 'Float32' }],
          4
        );
      ea([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4);
      const oh = ea([
        { name: 'a_placed', components: 2, type: 'Uint8' },
        { name: 'a_shift', components: 2, type: 'Float32' },
        { name: 'a_box_real', components: 2, type: 'Int16' },
      ]);
      ea([
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },
        { type: 'Int16', name: 'x1' },
        { type: 'Int16', name: 'y1' },
        { type: 'Int16', name: 'x2' },
        { type: 'Int16', name: 'y2' },
        { type: 'Uint32', name: 'featureIndex' },
        { type: 'Uint16', name: 'sourceLayerIndex' },
        { type: 'Uint16', name: 'bucketIndex' },
      ]);
      const ah = ea(
          [
            { name: 'a_pos', components: 2, type: 'Int16' },
            { name: 'a_anchor_pos', components: 2, type: 'Int16' },
            { name: 'a_extrude', components: 2, type: 'Int16' },
          ],
          4
        ),
        sh = ea(
          [
            { name: 'a_pos', components: 2, type: 'Float32' },
            { name: 'a_radius', components: 1, type: 'Float32' },
            { name: 'a_flags', components: 2, type: 'Int16' },
          ],
          4
        );
      function lh(t, e, i) {
        return (
          t.sections.forEach((t) => {
            t.text = (function (t, e, i) {
              const r = e.layout.get('text-transform').evaluate(i, {});
              return (
                'uppercase' === r
                  ? (t = t.toLocaleUpperCase())
                  : 'lowercase' === r && (t = t.toLocaleLowerCase()),
                Eo.applyArabicShaping && (t = Eo.applyArabicShaping(t)),
                t
              );
            })(t.text, e, i);
          }),
          t
        );
      }
      ea([{ name: 'triangle', components: 3, type: 'Uint16' }]),
        ea([
          { type: 'Int16', name: 'anchorX' },
          { type: 'Int16', name: 'anchorY' },
          { type: 'Uint16', name: 'glyphStartIndex' },
          { type: 'Uint16', name: 'numGlyphs' },
          { type: 'Uint32', name: 'vertexStartIndex' },
          { type: 'Uint32', name: 'lineStartIndex' },
          { type: 'Uint32', name: 'lineLength' },
          { type: 'Uint16', name: 'segment' },
          { type: 'Uint16', name: 'lowerSize' },
          { type: 'Uint16', name: 'upperSize' },
          { type: 'Float32', name: 'lineOffsetX' },
          { type: 'Float32', name: 'lineOffsetY' },
          { type: 'Uint8', name: 'writingMode' },
          { type: 'Uint8', name: 'placedOrientation' },
          { type: 'Uint8', name: 'hidden' },
          { type: 'Uint32', name: 'crossTileID' },
          { type: 'Int16', name: 'associatedIconIndex' },
        ]),
        ea([
          { type: 'Int16', name: 'anchorX' },
          { type: 'Int16', name: 'anchorY' },
          { type: 'Int16', name: 'rightJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'centerJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'leftJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'verticalPlacedTextSymbolIndex' },
          { type: 'Int16', name: 'placedIconSymbolIndex' },
          { type: 'Int16', name: 'verticalPlacedIconSymbolIndex' },
          { type: 'Uint16', name: 'key' },
          { type: 'Uint16', name: 'textBoxStartIndex' },
          { type: 'Uint16', name: 'textBoxEndIndex' },
          { type: 'Uint16', name: 'verticalTextBoxStartIndex' },
          { type: 'Uint16', name: 'verticalTextBoxEndIndex' },
          { type: 'Uint16', name: 'iconBoxStartIndex' },
          { type: 'Uint16', name: 'iconBoxEndIndex' },
          { type: 'Uint16', name: 'verticalIconBoxStartIndex' },
          { type: 'Uint16', name: 'verticalIconBoxEndIndex' },
          { type: 'Uint16', name: 'featureIndex' },
          { type: 'Uint16', name: 'numHorizontalGlyphVertices' },
          { type: 'Uint16', name: 'numVerticalGlyphVertices' },
          { type: 'Uint16', name: 'numIconVertices' },
          { type: 'Uint16', name: 'numVerticalIconVertices' },
          { type: 'Uint16', name: 'useRuntimeCollisionCircles' },
          { type: 'Uint32', name: 'crossTileID' },
          { type: 'Float32', name: 'textBoxScale' },
          { type: 'Float32', name: 'collisionCircleDiameter' },
          { type: 'Uint16', name: 'textAnchorOffsetStartIndex' },
          { type: 'Uint16', name: 'textAnchorOffsetEndIndex' },
        ]),
        ea([{ type: 'Float32', name: 'offsetX' }]),
        ea([
          { type: 'Int16', name: 'x' },
          { type: 'Int16', name: 'y' },
          { type: 'Int16', name: 'tileUnitDistanceFromAnchor' },
        ]),
        ea([
          { type: 'Uint16', name: 'textAnchor' },
          { type: 'Float32', components: 2, name: 'textOffset' },
        ]);
      const ch = {
        '!': '',
        '#': '',
        '$': '',
        '%': '',
        '&': '',
        '(': '',
        ')': '',
        '*': '',
        '+': '',
        ',': '',
        '-': '',
        '.': '',
        '/': '',
        ':': '',
        ';': '',
        '<': '',
        '=': '',
        '>': '',
        '?': '',
        '@': '',
        '[': '',
        '\\': '',
        ']': '',
        '^': '',
        '_': '',
        '`': '',
        '{': '',
        '|': '',
        '}': '',
        '~': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
        '': '',
      };
      var hh = 24;
      const uh = 4294967296,
        dh = 1 / uh,
        ph =
          'undefined' == typeof TextDecoder ? null : new TextDecoder('utf-8');
      class fh {
        constructor(t = new Uint8Array(16)) {
          (this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t)),
            (this.dataView = new DataView(this.buf.buffer)),
            (this.pos = 0),
            (this.type = 0),
            (this.length = this.buf.length);
        }
        readFields(t, e, i = this.length) {
          for (; this.pos < i; ) {
            const i = this.readVarint(),
              r = i >> 3,
              n = this.pos;
            (this.type = 7 & i), t(r, e, this), this.pos === n && this.skip(i);
          }
          return e;
        }
        readMessage(t, e) {
          return this.readFields(t, e, this.readVarint() + this.pos);
        }
        readFixed32() {
          const t = this.dataView.getUint32(this.pos, !0);
          return (this.pos += 4), t;
        }
        readSFixed32() {
          const t = this.dataView.getInt32(this.pos, !0);
          return (this.pos += 4), t;
        }
        readFixed64() {
          const t =
            this.dataView.getUint32(this.pos, !0) +
            this.dataView.getUint32(this.pos + 4, !0) * uh;
          return (this.pos += 8), t;
        }
        readSFixed64() {
          const t =
            this.dataView.getUint32(this.pos, !0) +
            this.dataView.getInt32(this.pos + 4, !0) * uh;
          return (this.pos += 8), t;
        }
        readFloat() {
          const t = this.dataView.getFloat32(this.pos, !0);
          return (this.pos += 4), t;
        }
        readDouble() {
          const t = this.dataView.getFloat64(this.pos, !0);
          return (this.pos += 8), t;
        }
        readVarint(t) {
          const e = this.buf;
          let i, r;
          return (
            (r = e[this.pos++]),
            (i = 127 & r),
            r < 128
              ? i
              : ((r = e[this.pos++]),
                (i |= (127 & r) << 7),
                r < 128
                  ? i
                  : ((r = e[this.pos++]),
                    (i |= (127 & r) << 14),
                    r < 128
                      ? i
                      : ((r = e[this.pos++]),
                        (i |= (127 & r) << 21),
                        r < 128
                          ? i
                          : ((r = e[this.pos]),
                            (i |= (15 & r) << 28),
                            (function (t, e, i) {
                              const r = i.buf;
                              let n, o;
                              if (
                                ((o = r[i.pos++]),
                                (n = (112 & o) >> 4),
                                o < 128)
                              )
                                return mh(t, n, e);
                              if (
                                ((o = r[i.pos++]),
                                (n |= (127 & o) << 3),
                                o < 128)
                              )
                                return mh(t, n, e);
                              if (
                                ((o = r[i.pos++]),
                                (n |= (127 & o) << 10),
                                o < 128)
                              )
                                return mh(t, n, e);
                              if (
                                ((o = r[i.pos++]),
                                (n |= (127 & o) << 17),
                                o < 128)
                              )
                                return mh(t, n, e);
                              if (
                                ((o = r[i.pos++]),
                                (n |= (127 & o) << 24),
                                o < 128)
                              )
                                return mh(t, n, e);
                              if (
                                ((o = r[i.pos++]),
                                (n |= (1 & o) << 31),
                                o < 128)
                              )
                                return mh(t, n, e);
                              throw new Error(
                                'Expected varint not more than 10 bytes'
                              );
                            })(i, t, this)))))
          );
        }
        readVarint64() {
          return this.readVarint(!0);
        }
        readSVarint() {
          const t = this.readVarint();
          return t % 2 == 1 ? (t + 1) / -2 : t / 2;
        }
        readBoolean() {
          return Boolean(this.readVarint());
        }
        readString() {
          const t = this.readVarint() + this.pos,
            e = this.pos;
          return (
            (this.pos = t),
            t - e >= 12 && ph
              ? ph.decode(this.buf.subarray(e, t))
              : (function (t, e, i) {
                  let r = '',
                    n = e;
                  for (; n < i; ) {
                    const e = t[n];
                    let o,
                      a,
                      s,
                      l = null,
                      c = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                    if (n + c > i) break;
                    1 === c
                      ? e < 128 && (l = e)
                      : 2 === c
                      ? ((o = t[n + 1]),
                        128 == (192 & o) &&
                          ((l = ((31 & e) << 6) | (63 & o)),
                          l <= 127 && (l = null)))
                      : 3 === c
                      ? ((o = t[n + 1]),
                        (a = t[n + 2]),
                        128 == (192 & o) &&
                          128 == (192 & a) &&
                          ((l = ((15 & e) << 12) | ((63 & o) << 6) | (63 & a)),
                          (l <= 2047 || (l >= 55296 && l <= 57343)) &&
                            (l = null)))
                      : 4 === c &&
                        ((o = t[n + 1]),
                        (a = t[n + 2]),
                        (s = t[n + 3]),
                        128 == (192 & o) &&
                          128 == (192 & a) &&
                          128 == (192 & s) &&
                          ((l =
                            ((15 & e) << 18) |
                            ((63 & o) << 12) |
                            ((63 & a) << 6) |
                            (63 & s)),
                          (l <= 65535 || l >= 1114112) && (l = null))),
                      null === l
                        ? ((l = 65533), (c = 1))
                        : l > 65535 &&
                          ((l -= 65536),
                          (r += String.fromCharCode(
                            ((l >>> 10) & 1023) | 55296
                          )),
                          (l = 56320 | (1023 & l))),
                      (r += String.fromCharCode(l)),
                      (n += c);
                  }
                  return r;
                })(this.buf, e, t)
          );
        }
        readBytes() {
          const t = this.readVarint() + this.pos,
            e = this.buf.subarray(this.pos, t);
          return (this.pos = t), e;
        }
        readPackedVarint(t = [], e) {
          const i = this.readPackedEnd();
          for (; this.pos < i; ) t.push(this.readVarint(e));
          return t;
        }
        readPackedSVarint(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSVarint());
          return t;
        }
        readPackedBoolean(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readBoolean());
          return t;
        }
        readPackedFloat(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFloat());
          return t;
        }
        readPackedDouble(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readDouble());
          return t;
        }
        readPackedFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed32());
          return t;
        }
        readPackedSFixed32(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed32());
          return t;
        }
        readPackedFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readFixed64());
          return t;
        }
        readPackedSFixed64(t = []) {
          const e = this.readPackedEnd();
          for (; this.pos < e; ) t.push(this.readSFixed64());
          return t;
        }
        readPackedEnd() {
          return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
        }
        skip(t) {
          const e = 7 & t;
          if (0 === e) for (; this.buf[this.pos++] > 127; );
          else if (2 === e) this.pos = this.readVarint() + this.pos;
          else if (5 === e) this.pos += 4;
          else {
            if (1 !== e) throw new Error(`Unimplemented type: ${e}`);
            this.pos += 8;
          }
        }
        writeTag(t, e) {
          this.writeVarint((t << 3) | e);
        }
        realloc(t) {
          let e = this.length || 16;
          for (; e < this.pos + t; ) e *= 2;
          if (e !== this.length) {
            const t = new Uint8Array(e);
            t.set(this.buf),
              (this.buf = t),
              (this.dataView = new DataView(t.buffer)),
              (this.length = e);
          }
        }
        finish() {
          return (
            (this.length = this.pos),
            (this.pos = 0),
            this.buf.subarray(0, this.length)
          );
        }
        writeFixed32(t) {
          this.realloc(4),
            this.dataView.setInt32(this.pos, t, !0),
            (this.pos += 4);
        }
        writeSFixed32(t) {
          this.realloc(4),
            this.dataView.setInt32(this.pos, t, !0),
            (this.pos += 4);
        }
        writeFixed64(t) {
          this.realloc(8),
            this.dataView.setInt32(this.pos, -1 & t, !0),
            this.dataView.setInt32(this.pos + 4, Math.floor(t * dh), !0),
            (this.pos += 8);
        }
        writeSFixed64(t) {
          this.realloc(8),
            this.dataView.setInt32(this.pos, -1 & t, !0),
            this.dataView.setInt32(this.pos + 4, Math.floor(t * dh), !0),
            (this.pos += 8);
        }
        writeVarint(t) {
          (t = +t || 0) > 268435455 || t < 0
            ? (function (t, e) {
                let i, r;
                if (
                  (t >= 0
                    ? ((i = t % 4294967296 | 0), (r = (t / 4294967296) | 0))
                    : ((i = ~(-t % 4294967296)),
                      (r = ~(-t / 4294967296)),
                      4294967295 ^ i
                        ? (i = (i + 1) | 0)
                        : ((i = 0), (r = (r + 1) | 0))),
                  t >= 0x10000000000000000 || t < -0x10000000000000000)
                )
                  throw new Error("Given varint doesn't fit into 10 bytes");
                e.realloc(10),
                  (function (t, e, i) {
                    (i.buf[i.pos++] = (127 & t) | 128),
                      (t >>>= 7),
                      (i.buf[i.pos++] = (127 & t) | 128),
                      (t >>>= 7),
                      (i.buf[i.pos++] = (127 & t) | 128),
                      (t >>>= 7),
                      (i.buf[i.pos++] = (127 & t) | 128),
                      (i.buf[i.pos] = 127 & (t >>>= 7));
                  })(i, 0, e),
                  (function (t, e) {
                    const i = (7 & t) << 4;
                    (e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0)),
                      t &&
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        t &&
                          ((e.buf[e.pos++] =
                            (127 & t) | ((t >>>= 7) ? 128 : 0)),
                          t &&
                            ((e.buf[e.pos++] =
                              (127 & t) | ((t >>>= 7) ? 128 : 0)),
                            t &&
                              ((e.buf[e.pos++] =
                                (127 & t) | ((t >>>= 7) ? 128 : 0)),
                              t && (e.buf[e.pos++] = 127 & t)))));
                  })(r, e);
              })(t, this)
            : (this.realloc(4),
              (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
              t <= 127 ||
                ((this.buf[this.pos++] =
                  (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                t <= 127 ||
                  ((this.buf[this.pos++] =
                    (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                  t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
        }
        writeSVarint(t) {
          this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
        }
        writeBoolean(t) {
          this.writeVarint(+t);
        }
        writeString(t) {
          (t = String(t)), this.realloc(4 * t.length), this.pos++;
          const e = this.pos;
          this.pos = (function (t, e, i) {
            for (let r, n, o = 0; o < e.length; o++) {
              if (((r = e.charCodeAt(o)), r > 55295 && r < 57344)) {
                if (!n) {
                  r > 56319 || o + 1 === e.length
                    ? ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189))
                    : (n = r);
                  continue;
                }
                if (r < 56320) {
                  (t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (n = r);
                  continue;
                }
                (r = ((n - 55296) << 10) | (r - 56320) | 65536), (n = null);
              } else
                n &&
                  ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (n = null));
              r < 128
                ? (t[i++] = r)
                : (r < 2048
                    ? (t[i++] = (r >> 6) | 192)
                    : (r < 65536
                        ? (t[i++] = (r >> 12) | 224)
                        : ((t[i++] = (r >> 18) | 240),
                          (t[i++] = ((r >> 12) & 63) | 128)),
                      (t[i++] = ((r >> 6) & 63) | 128)),
                  (t[i++] = (63 & r) | 128));
            }
            return i;
          })(this.buf, t, this.pos);
          const i = this.pos - e;
          i >= 128 && _h(e, i, this),
            (this.pos = e - 1),
            this.writeVarint(i),
            (this.pos += i);
        }
        writeFloat(t) {
          this.realloc(4),
            this.dataView.setFloat32(this.pos, t, !0),
            (this.pos += 4);
        }
        writeDouble(t) {
          this.realloc(8),
            this.dataView.setFloat64(this.pos, t, !0),
            (this.pos += 8);
        }
        writeBytes(t) {
          const e = t.length;
          this.writeVarint(e), this.realloc(e);
          for (let i = 0; i < e; i++) this.buf[this.pos++] = t[i];
        }
        writeRawMessage(t, e) {
          this.pos++;
          const i = this.pos;
          t(e, this);
          const r = this.pos - i;
          r >= 128 && _h(i, r, this),
            (this.pos = i - 1),
            this.writeVarint(r),
            (this.pos += r);
        }
        writeMessage(t, e, i) {
          this.writeTag(t, 2), this.writeRawMessage(e, i);
        }
        writePackedVarint(t, e) {
          e.length && this.writeMessage(t, gh, e);
        }
        writePackedSVarint(t, e) {
          e.length && this.writeMessage(t, yh, e);
        }
        writePackedBoolean(t, e) {
          e.length && this.writeMessage(t, bh, e);
        }
        writePackedFloat(t, e) {
          e.length && this.writeMessage(t, xh, e);
        }
        writePackedDouble(t, e) {
          e.length && this.writeMessage(t, vh, e);
        }
        writePackedFixed32(t, e) {
          e.length && this.writeMessage(t, wh, e);
        }
        writePackedSFixed32(t, e) {
          e.length && this.writeMessage(t, Th, e);
        }
        writePackedFixed64(t, e) {
          e.length && this.writeMessage(t, Ph, e);
        }
        writePackedSFixed64(t, e) {
          e.length && this.writeMessage(t, Sh, e);
        }
        writeBytesField(t, e) {
          this.writeTag(t, 2), this.writeBytes(e);
        }
        writeFixed32Field(t, e) {
          this.writeTag(t, 5), this.writeFixed32(e);
        }
        writeSFixed32Field(t, e) {
          this.writeTag(t, 5), this.writeSFixed32(e);
        }
        writeFixed64Field(t, e) {
          this.writeTag(t, 1), this.writeFixed64(e);
        }
        writeSFixed64Field(t, e) {
          this.writeTag(t, 1), this.writeSFixed64(e);
        }
        writeVarintField(t, e) {
          this.writeTag(t, 0), this.writeVarint(e);
        }
        writeSVarintField(t, e) {
          this.writeTag(t, 0), this.writeSVarint(e);
        }
        writeStringField(t, e) {
          this.writeTag(t, 2), this.writeString(e);
        }
        writeFloatField(t, e) {
          this.writeTag(t, 5), this.writeFloat(e);
        }
        writeDoubleField(t, e) {
          this.writeTag(t, 1), this.writeDouble(e);
        }
        writeBooleanField(t, e) {
          this.writeVarintField(t, +e);
        }
      }
      function mh(t, e, i) {
        return i
          ? 4294967296 * e + (t >>> 0)
          : 4294967296 * (e >>> 0) + (t >>> 0);
      }
      function _h(t, e, i) {
        const r =
          e <= 16383
            ? 1
            : e <= 2097151
            ? 2
            : e <= 268435455
            ? 3
            : Math.floor(Math.log(e) / (7 * Math.LN2));
        i.realloc(r);
        for (let n = i.pos - 1; n >= t; n--) i.buf[n + r] = i.buf[n];
      }
      function gh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeVarint(t[i]);
      }
      function yh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeSVarint(t[i]);
      }
      function xh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeFloat(t[i]);
      }
      function vh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeDouble(t[i]);
      }
      function bh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeBoolean(t[i]);
      }
      function wh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeFixed32(t[i]);
      }
      function Th(t, e) {
        for (let i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
      }
      function Ph(t, e) {
        for (let i = 0; i < t.length; i++) e.writeFixed64(t[i]);
      }
      function Sh(t, e) {
        for (let i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
      }
      function Mh(t, e, i) {
        1 === t && i.readMessage(Ih, e);
      }
      function Ih(t, e, i) {
        if (3 === t) {
          const {
            id: t,
            bitmap: r,
            width: n,
            height: o,
            left: a,
            top: s,
            advance: l,
          } = i.readMessage(Ch, {});
          e.push({
            id: t,
            bitmap: new yl({ width: n + 6, height: o + 6 }, r),
            metrics: { width: n, height: o, left: a, top: s, advance: l },
          });
        }
      }
      function Ch(t, e, i) {
        1 === t
          ? (e.id = i.readVarint())
          : 2 === t
          ? (e.bitmap = i.readBytes())
          : 3 === t
          ? (e.width = i.readVarint())
          : 4 === t
          ? (e.height = i.readVarint())
          : 5 === t
          ? (e.left = i.readSVarint())
          : 6 === t
          ? (e.top = i.readSVarint())
          : 7 === t && (e.advance = i.readVarint());
      }
      function Ah(t) {
        let e = 0,
          i = 0;
        for (const a of t) (e += a.w * a.h), (i = Math.max(i, a.w));
        t.sort((t, e) => e.h - t.h);
        const r = [
          {
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i),
            h: 1 / 0,
          },
        ];
        let n = 0,
          o = 0;
        for (const a of t)
          for (let t = r.length - 1; t >= 0; t--) {
            const e = r[t];
            if (!(a.w > e.w || a.h > e.h)) {
              if (
                ((a.x = e.x),
                (a.y = e.y),
                (o = Math.max(o, a.y + a.h)),
                (n = Math.max(n, a.x + a.w)),
                a.w === e.w && a.h === e.h)
              ) {
                const e = r.pop();
                e && t < r.length && (r[t] = e);
              } else
                a.h === e.h
                  ? ((e.x += a.w), (e.w -= a.w))
                  : a.w === e.w
                  ? ((e.y += a.h), (e.h -= a.h))
                  : (r.push({ x: e.x + a.w, y: e.y, w: e.w - a.w, h: a.h }),
                    (e.y += a.h),
                    (e.h -= a.h));
              break;
            }
          }
        return { w: n, h: o, fill: e / (n * o) || 0 };
      }
      class Eh {
        constructor(
          t,
          {
            pixelRatio: e,
            version: i,
            stretchX: r,
            stretchY: n,
            content: o,
            textFitWidth: a,
            textFitHeight: s,
          }
        ) {
          (this.paddedRect = t),
            (this.pixelRatio = e),
            (this.stretchX = r),
            (this.stretchY = n),
            (this.content = o),
            (this.version = i),
            (this.textFitWidth = a),
            (this.textFitHeight = s);
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [
            this.paddedRect.x + this.paddedRect.w - 1,
            this.paddedRect.y + this.paddedRect.h - 1,
          ];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [
            (this.paddedRect.w - 2) / this.pixelRatio,
            (this.paddedRect.h - 2) / this.pixelRatio,
          ];
        }
      }
      class zh {
        constructor(t, e) {
          const i = {},
            r = {};
          this.haveRenderCallbacks = [];
          const n = [];
          this.addImages(t, i, n), this.addImages(e, r, n);
          const { w: o, h: a } = Ah(n),
            s = new xl({ width: o || 1, height: a || 1 });
          for (const l in t) {
            const e = t[l],
              r = i[l].paddedRect;
            xl.copy(
              e.data,
              s,
              { x: 0, y: 0 },
              { x: r.x + 1, y: r.y + 1 },
              e.data
            );
          }
          for (const l in e) {
            const t = e[l],
              i = r[l].paddedRect,
              n = i.x + 1,
              o = i.y + 1,
              a = t.data.width,
              c = t.data.height;
            xl.copy(t.data, s, { x: 0, y: 0 }, { x: n, y: o }, t.data),
              xl.copy(
                t.data,
                s,
                { x: 0, y: c - 1 },
                { x: n, y: o - 1 },
                { width: a, height: 1 }
              ),
              xl.copy(
                t.data,
                s,
                { x: 0, y: 0 },
                { x: n, y: o + c },
                { width: a, height: 1 }
              ),
              xl.copy(
                t.data,
                s,
                { x: a - 1, y: 0 },
                { x: n - 1, y: o },
                { width: 1, height: c }
              ),
              xl.copy(
                t.data,
                s,
                { x: 0, y: 0 },
                { x: n + a, y: o },
                { width: 1, height: c }
              );
          }
          (this.image = s),
            (this.iconPositions = i),
            (this.patternPositions = r);
        }
        addImages(t, e, i) {
          for (const r in t) {
            const n = t[r],
              o = { x: 0, y: 0, w: n.data.width + 2, h: n.data.height + 2 };
            i.push(o),
              (e[r] = new Eh(o, n)),
              n.hasRenderCallback && this.haveRenderCallbacks.push(r);
          }
        }
        patchUpdatedImages(t, e) {
          t.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const i in t.updatedImages)
            this.patchUpdatedImage(this.iconPositions[i], t.getImage(i), e),
              this.patchUpdatedImage(
                this.patternPositions[i],
                t.getImage(i),
                e
              );
        }
        patchUpdatedImage(t, e, i) {
          if (!t || !e) return;
          if (t.version === e.version) return;
          t.version = e.version;
          const [r, n] = t.tl;
          i.update(e.data, void 0, { x: r, y: n });
        }
      }
      var kh;
      co('ImagePosition', Eh),
        co('ImageAtlas', zh),
        (t.as = void 0),
        ((kh = t.as || (t.as = {}))[(kh.none = 0)] = 'none'),
        (kh[(kh.horizontal = 1)] = 'horizontal'),
        (kh[(kh.vertical = 2)] = 'vertical'),
        (kh[(kh.horizontalOnly = 3)] = 'horizontalOnly');
      class Dh {
        constructor() {
          (this.scale = 1),
            (this.fontStack = ''),
            (this.imageName = null),
            (this.verticalAlign = 'bottom');
        }
        static forText(t, e, i) {
          const r = new Dh();
          return (
            (r.scale = t || 1),
            (r.fontStack = e),
            (r.verticalAlign = i || 'bottom'),
            r
          );
        }
        static forImage(t, e) {
          const i = new Dh();
          return (i.imageName = t), (i.verticalAlign = e || 'bottom'), i;
        }
      }
      class Rh {
        constructor() {
          (this.text = ''),
            (this.sectionIndex = []),
            (this.sections = []),
            (this.imageSectionID = null);
        }
        static fromFeature(t, e) {
          const i = new Rh();
          for (let r = 0; r < t.sections.length; r++) {
            const n = t.sections[r];
            n.image ? i.addImageSection(n) : i.addTextSection(n, e);
          }
          return i;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCharCode(t) {
          return this.text.charCodeAt(t);
        }
        verticalizePunctuation() {
          this.text = (function (t) {
            let e = '';
            for (let i = 0; i < t.length; i++) {
              const r = t.charCodeAt(i + 1) || null,
                n = t.charCodeAt(i - 1) || null;
              e +=
                (r && So(r) && !ch[t[i + 1]]) ||
                (n && So(n) && !ch[t[i - 1]]) ||
                !ch[t[i]]
                  ? t[i]
                  : ch[t[i]];
            }
            return e;
          })(this.text);
        }
        trim() {
          let t = 0;
          for (
            let i = 0;
            i < this.text.length && Fh[this.text.charCodeAt(i)];
            i++
          )
            t++;
          let e = this.text.length;
          for (
            let i = this.text.length - 1;
            i >= 0 && i >= t && Fh[this.text.charCodeAt(i)];
            i--
          )
            e--;
          (this.text = this.text.substring(t, e)),
            (this.sectionIndex = this.sectionIndex.slice(t, e));
        }
        substring(t, e) {
          const i = new Rh();
          return (
            (i.text = this.text.substring(t, e)),
            (i.sectionIndex = this.sectionIndex.slice(t, e)),
            (i.sections = this.sections),
            i
          );
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce(
            (t, e) => Math.max(t, this.sections[e].scale),
            0
          );
        }
        getMaxImageSize(t) {
          let e = 0,
            i = 0;
          for (let r = 0; r < this.length(); r++) {
            const n = this.getSection(r);
            if (n.imageName) {
              const r = t[n.imageName];
              if (!r) continue;
              const o = r.displaySize;
              (e = Math.max(e, o[0])), (i = Math.max(i, o[1]));
            }
          }
          return { maxImageWidth: e, maxImageHeight: i };
        }
        addTextSection(t, e) {
          (this.text += t.text),
            this.sections.push(
              Dh.forText(t.scale, t.fontStack || e, t.verticalAlign)
            );
          const i = this.sections.length - 1;
          for (let r = 0; r < t.text.length; ++r) this.sectionIndex.push(i);
        }
        addImageSection(t) {
          const e = t.image ? t.image.name : '';
          if (0 === e.length)
            return void Z("Can't add FormattedSection with an empty image.");
          const i = this.getNextImageSectionCharCode();
          i
            ? ((this.text += String.fromCharCode(i)),
              this.sections.push(Dh.forImage(e, t.verticalAlign)),
              this.sectionIndex.push(this.sections.length - 1))
            : Z('Reached maximum number of images 6401');
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID
            ? this.imageSectionID >= 63743
              ? null
              : ++this.imageSectionID
            : ((this.imageSectionID = 57344), this.imageSectionID);
        }
      }
      function Lh(e, i, r, n, o, a, s, l, c, h, u, d, p, f, m) {
        const _ = Rh.fromFeature(e, o);
        let g;
        d === t.as.vertical && _.verticalizePunctuation();
        const {
          processBidirectionalText: y,
          processStyledBidirectionalText: x,
        } = Eo;
        if (y && 1 === _.sections.length) {
          g = [];
          const t = y(_.toString(), Zh(_, h, a, i, n, f));
          for (const e of t) {
            const t = new Rh();
            (t.text = e), (t.sections = _.sections);
            for (let i = 0; i < e.length; i++) t.sectionIndex.push(0);
            g.push(t);
          }
        } else if (x) {
          g = [];
          const t = x(_.text, _.sectionIndex, Zh(_, h, a, i, n, f));
          for (const e of t) {
            const t = new Rh();
            (t.text = e[0]),
              (t.sectionIndex = e[1]),
              (t.sections = _.sections),
              g.push(t);
          }
        } else
          g = (function (t, e) {
            const i = [],
              r = t.text;
            let n = 0;
            for (const o of e) i.push(t.substring(n, o)), (n = o);
            return n < r.length && i.push(t.substring(n, r.length)), i;
          })(_, Zh(_, h, a, i, n, f));
        const v = [],
          b = {
            positionedLines: v,
            text: _.toString(),
            top: u[1],
            bottom: u[1],
            left: u[0],
            right: u[0],
            writingMode: d,
            iconsInText: !1,
            verticalizable: !1,
          };
        return (
          (function (t, e, i, r, n, o, a, s, l, c, h, u) {
            let d = 0,
              p = 0,
              f = 0,
              m = 0;
            const _ = 'right' === s ? 1 : 'left' === s ? 0 : 0.5,
              g = hh / u;
            let y = 0;
            for (const b of n) {
              b.trim();
              const n = b.getMaxScale(),
                a = { positionedGlyphs: [], lineOffset: 0 };
              t.positionedLines[y] = a;
              const s = a.positionedGlyphs;
              let u = 0;
              if (!b.length()) {
                (p += o), ++y;
                continue;
              }
              const x = qh(r, b, g);
              for (let o = 0; o < b.length(); o++) {
                const a = b.getSection(o),
                  f = b.getSectionIndex(o),
                  m = b.getCharCode(o),
                  _ = Yh(l, h, m);
                let y;
                if (a.imageName) {
                  if (
                    ((t.iconsInText = !0),
                    (a.scale = a.scale * g),
                    (y = Xh(a, _, n, x, r)),
                    !y)
                  )
                    continue;
                  u = Math.max(u, y.imageOffset);
                } else if (((y = Hh(a, m, _, x, e, i)), !y)) continue;
                const { rect: v, metrics: w, baselineOffset: T } = y;
                s.push({
                  glyph: m,
                  imageName: a.imageName,
                  x: d,
                  y: p + T + -17,
                  vertical: _,
                  scale: a.scale,
                  fontStack: a.fontStack,
                  sectionIndex: f,
                  metrics: w,
                  rect: v,
                }),
                  _
                    ? ((t.verticalizable = !0),
                      (d += (a.imageName ? w.advance : hh) * a.scale + c))
                    : (d += w.advance * a.scale + c);
              }
              0 !== s.length &&
                ((f = Math.max(d - c, f)), Kh(s, 0, s.length - 1, _)),
                (d = 0),
                (a.lineOffset = Math.max(u, (n - 1) * hh));
              const v = o * n + u;
              (p += v), (m = Math.max(v, m)), ++y;
            }
            const { horizontalAlign: x, verticalAlign: v } = $h(a);
            (function (t, e, i, r, n, o, a, s, l) {
              const c = (e - i) * n;
              let h = 0;
              h = o !== a ? -s * r - -17 : -r * l * a + 0.5 * a;
              for (const u of t)
                for (const t of u.positionedGlyphs) (t.x += c), (t.y += h);
            })(t.positionedLines, _, x, v, f, m, o, p, n.length),
              (t.top += -v * p),
              (t.bottom = t.top + p),
              (t.left += -x * f),
              (t.right = t.left + f);
          })(b, i, r, n, g, s, l, c, d, h, p, m),
          !(function (t) {
            for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;
            return !0;
          })(v) && b
        );
      }
      const Fh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
        Bh = {
          10: !0,
          32: !0,
          38: !0,
          41: !0,
          43: !0,
          45: !0,
          47: !0,
          173: !0,
          183: !0,
          8203: !0,
          8208: !0,
          8211: !0,
          8231: !0,
        },
        Oh = { 40: !0 };
      function jh(t, e, i, r, n, o) {
        if (e.imageName) {
          const t = r[e.imageName];
          return t ? (t.displaySize[0] * e.scale * hh) / o + n : 0;
        }
        {
          const r = i[e.fontStack],
            o = r && r[t];
          return o ? o.metrics.advance * e.scale + n : 0;
        }
      }
      function Nh(t, e, i, r) {
        const n = Math.pow(t - e, 2);
        return r ? (t < e ? n / 2 : 2 * n) : n + Math.abs(i) * i;
      }
      function Vh(t, e, i) {
        let r = 0;
        return (
          10 === t && (r -= 1e4),
          i && (r += 150),
          (40 !== t && 65288 !== t) || (r += 50),
          (41 !== e && 65289 !== e) || (r += 50),
          r
        );
      }
      function Uh(t, e, i, r, n, o) {
        let a = null,
          s = Nh(e, i, n, o);
        for (const l of r) {
          const t = Nh(e - l.x, i, n, o) + l.badness;
          t <= s && ((a = l), (s = t));
        }
        return { index: t, x: e, priorBreak: a, badness: s };
      }
      function Gh(t) {
        return t ? Gh(t.priorBreak).concat(t.index) : [];
      }
      function Zh(t, e, i, r, n, o) {
        if (!t) return [];
        const a = [],
          s = (function (t, e, i, r, n, o) {
            let a = 0;
            for (let s = 0; s < t.length(); s++) {
              const i = t.getSection(s);
              a += jh(t.getCharCode(s), i, r, n, e, o);
            }
            return a / Math.max(1, Math.ceil(a / i));
          })(t, e, i, r, n, o),
          l = t.text.indexOf('') >= 0;
        let c = 0;
        for (let u = 0; u < t.length(); u++) {
          const i = t.getSection(u),
            d = t.getCharCode(u);
          if ((Fh[d] || (c += jh(d, i, r, n, e, o)), u < t.length() - 1)) {
            const e =
              !((h = d) < 11904) &&
              (!!go['CJK Compatibility Forms'](h) ||
                !!go['CJK Compatibility'](h) ||
                !!go['CJK Strokes'](h) ||
                !!go['CJK Symbols and Punctuation'](h) ||
                !!go['Enclosed CJK Letters and Months'](h) ||
                !!go['Halfwidth and Fullwidth Forms'](h) ||
                !!go['Ideographic Description Characters'](h) ||
                !!go['Vertical Forms'](h) ||
                To.test(String.fromCodePoint(h)));
            (Bh[d] ||
              e ||
              i.imageName ||
              (u !== t.length() - 2 && Oh[t.getCharCode(u + 1)])) &&
              a.push(
                Uh(u + 1, c, s, a, Vh(d, t.getCharCode(u + 1), e && l), !1)
              );
          }
        }
        var h;
        return Gh(Uh(t.length(), c, s, a, 0, !0));
      }
      function $h(t) {
        let e = 0.5,
          i = 0.5;
        switch (t) {
          case 'right':
          case 'top-right':
          case 'bottom-right':
            e = 1;
            break;
          case 'left':
          case 'top-left':
          case 'bottom-left':
            e = 0;
        }
        switch (t) {
          case 'bottom':
          case 'bottom-right':
          case 'bottom-left':
            i = 1;
            break;
          case 'top':
          case 'top-right':
          case 'top-left':
            i = 0;
        }
        return { horizontalAlign: e, verticalAlign: i };
      }
      function qh(t, e, i) {
        const r = e.getMaxScale() * hh,
          { maxImageWidth: n, maxImageHeight: o } = e.getMaxImageSize(t),
          a = Math.max(r, o * i);
        return {
          verticalLineContentWidth: Math.max(r, n * i),
          horizontalLineContentHeight: a,
        };
      }
      function Wh(t) {
        switch (t) {
          case 'top':
            return 0;
          case 'center':
            return 0.5;
          default:
            return 1;
        }
      }
      function Yh(e, i, r) {
        return !(
          e === t.as.horizontal ||
          (!i && !Po(r)) ||
          (i &&
            (Fh[r] || ((n = r), /\p{sc=Arab}/u.test(String.fromCodePoint(n)))))
        );
        var n;
      }
      function Hh(t, e, i, r, n, o) {
        const a = o[t.fontStack],
          s = (function (t, e, i, r) {
            if (t && t.rect) return t;
            const n = e[i.fontStack],
              o = n && n[r];
            return o ? { rect: null, metrics: o.metrics } : null;
          })(a && a[e], n, t, e);
        if (null === s) return null;
        let l;
        if (i) l = r.verticalLineContentWidth - t.scale * hh;
        else {
          const e = Wh(t.verticalAlign);
          l = (r.horizontalLineContentHeight - t.scale * hh) * e;
        }
        return { rect: s.rect, metrics: s.metrics, baselineOffset: l };
      }
      function Xh(t, e, i, r, n) {
        const o = n[t.imageName];
        if (!o) return null;
        const a = o.paddedRect,
          s = o.displaySize,
          l = {
            width: s[0],
            height: s[1],
            left: 1,
            top: -3,
            advance: e ? s[1] : s[0],
          };
        let c;
        if (e) c = r.verticalLineContentWidth - s[1] * t.scale;
        else {
          const e = Wh(t.verticalAlign);
          c = (r.horizontalLineContentHeight - s[1] * t.scale) * e;
        }
        return {
          rect: a,
          metrics: l,
          baselineOffset: c,
          imageOffset: (e ? s[0] : s[1]) * t.scale - hh * i,
        };
      }
      function Kh(t, e, i, r) {
        if (0 === r) return;
        const n = t[i],
          o = (t[i].x + n.metrics.advance * n.scale) * r;
        for (let a = e; a <= i; a++) t[a].x -= o;
      }
      function Jh(t, e, i) {
        const { horizontalAlign: r, verticalAlign: n } = $h(i),
          o = e[0] - t.displaySize[0] * r,
          a = e[1] - t.displaySize[1] * n;
        return {
          image: t,
          top: a,
          bottom: a + t.displaySize[1],
          left: o,
          right: o + t.displaySize[0],
        };
      }
      function Qh(t) {
        var e, i;
        let r = t.left,
          n = t.top,
          o = t.right - r,
          a = t.bottom - n;
        const s =
            null !== (e = t.image.textFitWidth) && void 0 !== e
              ? e
              : 'stretchOrShrink',
          l =
            null !== (i = t.image.textFitHeight) && void 0 !== i
              ? i
              : 'stretchOrShrink',
          c =
            (t.image.content[2] - t.image.content[0]) /
            (t.image.content[3] - t.image.content[1]);
        if ('proportional' === l) {
          if (('stretchOnly' === s && o / a < c) || 'proportional' === s) {
            const t = Math.ceil(a * c);
            (r *= t / o), (o = t);
          }
        } else if (
          'proportional' === s &&
          'stretchOnly' === l &&
          0 !== c &&
          o / a > c
        ) {
          const t = Math.ceil(o / c);
          (n *= t / a), (a = t);
        }
        return { x1: r, y1: n, x2: r + o, y2: n + a };
      }
      function tu(t, e, i, r, n, o) {
        const a = t.image;
        let s;
        if (a.content) {
          const t = a.content,
            e = a.pixelRatio || 1;
          s = [
            t[0] / e,
            t[1] / e,
            a.displaySize[0] - t[2] / e,
            a.displaySize[1] - t[3] / e,
          ];
        }
        const l = e.left * o,
          c = e.right * o;
        let h, u, d, p;
        'width' === i || 'both' === i
          ? ((p = n[0] + l - r[3]), (u = n[0] + c + r[1]))
          : ((p = n[0] + (l + c - a.displaySize[0]) / 2),
            (u = p + a.displaySize[0]));
        const f = e.top * o,
          m = e.bottom * o;
        return (
          'height' === i || 'both' === i
            ? ((h = n[1] + f - r[0]), (d = n[1] + m + r[2]))
            : ((h = n[1] + (f + m - a.displaySize[1]) / 2),
              (d = h + a.displaySize[1])),
          {
            image: a,
            top: h,
            right: u,
            bottom: d,
            left: p,
            collisionPadding: s,
          }
        );
      }
      const eu = 128,
        iu = 32640;
      function ru(t, e) {
        const { expression: i } = e;
        if ('constant' === i.kind)
          return { kind: 'constant', layoutSize: i.evaluate(new zo(t + 1)) };
        if ('source' === i.kind) return { kind: 'source' };
        {
          const { zoomStops: e, interpolationType: r } = i;
          let n = 0;
          for (; n < e.length && e[n] <= t; ) n++;
          n = Math.max(0, n - 1);
          let o = n;
          for (; o < e.length && e[o] < t + 1; ) o++;
          o = Math.min(e.length - 1, o);
          const a = e[n],
            s = e[o];
          return 'composite' === i.kind
            ? {
                kind: 'composite',
                minZoom: a,
                maxZoom: s,
                interpolationType: r,
              }
            : {
                kind: 'camera',
                minZoom: a,
                maxZoom: s,
                minSize: i.evaluate(new zo(a)),
                maxSize: i.evaluate(new zo(s)),
                interpolationType: r,
              };
        }
      }
      function nu(t, e, i) {
        let r = 'never';
        const n = t.get(e);
        return n ? (r = n) : t.get(i) && (r = 'always'), r;
      }
      const ou = [
        { name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0 },
      ];
      function au(t, e, i, r, n, o, a, s, l, c, h, u, d) {
        const p = s ? Math.min(iu, Math.round(s[0])) : 0,
          f = s ? Math.min(iu, Math.round(s[1])) : 0;
        t.emplaceBack(
          e,
          i,
          Math.round(32 * r),
          Math.round(32 * n),
          o,
          a,
          (p << 1) + (l ? 1 : 0),
          f,
          16 * c,
          16 * h,
          256 * u,
          256 * d
        );
      }
      function su(t, e, i) {
        t.emplaceBack(e.x, e.y, i),
          t.emplaceBack(e.x, e.y, i),
          t.emplaceBack(e.x, e.y, i),
          t.emplaceBack(e.x, e.y, i);
      }
      function lu(t) {
        for (const e of t.sections) if (Ao(e.text)) return !0;
        return !1;
      }
      class cu {
        constructor(t) {
          (this.layoutVertexArray = new Wa()),
            (this.indexArray = new Ja()),
            (this.programConfigurations = t),
            (this.segments = new is()),
            (this.dynamicLayoutVertexArray = new Ya()),
            (this.opacityVertexArray = new Ha()),
            (this.hasVisibleVertices = !1),
            (this.placedSymbolArray = new Ea());
        }
        isEmpty() {
          return (
            0 === this.layoutVertexArray.length &&
            0 === this.indexArray.length &&
            0 === this.dynamicLayoutVertexArray.length &&
            0 === this.opacityVertexArray.length
          );
        }
        upload(t, e, i, r) {
          this.isEmpty() ||
            (i &&
              ((this.layoutVertexBuffer = t.createVertexBuffer(
                this.layoutVertexArray,
                rh.members
              )),
              (this.indexBuffer = t.createIndexBuffer(this.indexArray, e)),
              (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
                this.dynamicLayoutVertexArray,
                nh.members,
                !0
              )),
              (this.opacityVertexBuffer = t.createVertexBuffer(
                this.opacityVertexArray,
                ou,
                !0
              )),
              (this.opacityVertexBuffer.itemSize = 1)),
            (i || r) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.programConfigurations.destroy(),
            this.segments.destroy(),
            this.dynamicLayoutVertexBuffer.destroy(),
            this.opacityVertexBuffer.destroy());
        }
      }
      co('SymbolBuffers', cu);
      class hu {
        constructor(t, e, i) {
          (this.layoutVertexArray = new t()),
            (this.layoutAttributes = e),
            (this.indexArray = new i()),
            (this.segments = new is()),
            (this.collisionVertexArray = new Ka());
        }
        upload(t) {
          (this.layoutVertexBuffer = t.createVertexBuffer(
            this.layoutVertexArray,
            this.layoutAttributes
          )),
            (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
            (this.collisionVertexBuffer = t.createVertexBuffer(
              this.collisionVertexArray,
              oh.members,
              !0
            ));
        }
        destroy() {
          this.layoutVertexBuffer &&
            (this.layoutVertexBuffer.destroy(),
            this.indexBuffer.destroy(),
            this.segments.destroy(),
            this.collisionVertexBuffer.destroy());
        }
      }
      co('CollisionBuffers', hu);
      class uu {
        constructor(e) {
          (this.collisionBoxArray = e.collisionBoxArray),
            (this.zoom = e.zoom),
            (this.overscaling = Y(globalThis)
              ? Math.min(e.overscaling, 128)
              : e.overscaling),
            (this.layers = e.layers),
            (this.layerIds = this.layers.map((t) => t.id)),
            (this.index = e.index),
            (this.pixelRatio = e.pixelRatio),
            (this.sourceLayerIndex = e.sourceLayerIndex),
            (this.hasDependencies = !1),
            (this.hasRTLText = !1),
            (this.sortKeyRanges = []),
            (this.collisionCircleArray = []);
          const i = this.layers[0]._unevaluatedLayout._values;
          (this.textSizeData = ru(this.zoom, i['text-size'])),
            (this.iconSizeData = ru(this.zoom, i['icon-size']));
          const r = this.layers[0].layout,
            n = r.get('symbol-sort-key'),
            o = r.get('symbol-z-order');
          (this.canOverlap =
            'never' !== nu(r, 'text-overlap', 'text-allow-overlap') ||
            'never' !== nu(r, 'icon-overlap', 'icon-allow-overlap') ||
            r.get('text-ignore-placement') ||
            r.get('icon-ignore-placement')),
            (this.sortFeaturesByKey = 'viewport-y' !== o && !n.isConstant()),
            (this.sortFeaturesByY =
              ('viewport-y' === o ||
                ('auto' === o && !this.sortFeaturesByKey)) &&
              this.canOverlap),
            'point' === r.get('symbol-placement') &&
              (this.writingModes = r
                .get('text-writing-mode')
                .map((e) => t.as[e])),
            (this.stateDependentLayerIds = this.layers
              .filter((t) => t.isStateDependent())
              .map((t) => t.id)),
            (this.sourceID = e.sourceID);
        }
        createArrays() {
          (this.text = new cu(
            new ks(this.layers, this.zoom, (t) => /^text/.test(t))
          )),
            (this.icon = new cu(
              new ks(this.layers, this.zoom, (t) => /^icon/.test(t))
            )),
            (this.glyphOffsetArray = new Da()),
            (this.lineVertexArray = new Ra()),
            (this.symbolInstances = new ka()),
            (this.textAnchorOffsets = new Fa());
        }
        calculateGlyphDependencies(t, e, i, r, n) {
          for (let o = 0; o < t.length; o++)
            if (((e[t.charCodeAt(o)] = !0), (i || r) && n)) {
              const i = ch[t.charAt(o)];
              i && (e[i.charCodeAt(0)] = !0);
            }
        }
        populate(e, i, r) {
          const n = this.layers[0],
            o = n.layout,
            a = o.get('text-font'),
            s = o.get('text-field'),
            l = o.get('icon-image'),
            c =
              ('constant' !== s.value.kind ||
                (s.value.value instanceof ze && !s.value.value.isEmpty()) ||
                s.value.value.toString().length > 0) &&
              ('constant' !== a.value.kind || a.value.value.length > 0),
            h =
              'constant' !== l.value.kind ||
              !!l.value.value ||
              Object.keys(l.parameters).length > 0,
            u = o.get('symbol-sort-key');
          if (((this.features = []), !c && !h)) return;
          const d = i.iconDependencies,
            p = i.glyphDependencies,
            f = i.availableImages,
            m = new zo(this.zoom);
          for (const {
            feature: _,
            id: g,
            index: y,
            sourceLayerIndex: x,
          } of e) {
            const e = n._featureFilter.needGeometry,
              i = Os(_, e);
            if (!n._featureFilter.filter(m, i, r)) continue;
            let s, l;
            if ((e || (i.geometry = Bs(_)), c)) {
              const t = n.getValueAndResolveTokens('text-field', i, r, f),
                e = ze.factory(t),
                o = (this.hasRTLText = this.hasRTLText || lu(e));
              (!o ||
                'unavailable' === Eo.getRTLTextPluginStatus() ||
                (o && Eo.isParsed())) &&
                (s = lh(e, n, i));
            }
            if (h) {
              const t = n.getValueAndResolveTokens('icon-image', i, r, f);
              l = t instanceof Oe ? t : Oe.fromString(t);
            }
            if (!s && !l) continue;
            const v = this.sortFeaturesByKey ? u.evaluate(i, {}, r) : void 0;
            if (
              (this.features.push({
                id: g,
                text: s,
                icon: l,
                index: y,
                sourceLayerIndex: x,
                geometry: i.geometry,
                properties: _.properties,
                type: Sc.types[_.type],
                sortKey: v,
              }),
              l && (d[l.name] = !0),
              s)
            ) {
              const e = a.evaluate(i, {}, r).join(','),
                n =
                  'viewport' !== o.get('text-rotation-alignment') &&
                  'point' !== o.get('symbol-placement');
              this.allowVerticalPlacement =
                this.writingModes &&
                this.writingModes.indexOf(t.as.vertical) >= 0;
              for (const t of s.sections)
                if (t.image) d[t.image.name] = !0;
                else {
                  const i = yo(s.toString()),
                    r = t.fontStack || e,
                    o = (p[r] = p[r] || {});
                  this.calculateGlyphDependencies(
                    t.text,
                    o,
                    n,
                    this.allowVerticalPlacement,
                    i
                  );
                }
            }
          }
          'line' === o.get('symbol-placement') &&
            (this.features = (function (t) {
              const e = {},
                i = {},
                r = [];
              let n = 0;
              function o(e) {
                r.push(t[e]), n++;
              }
              function a(t, e, n) {
                const o = i[t];
                return (
                  delete i[t],
                  (i[e] = o),
                  r[o].geometry[0].pop(),
                  (r[o].geometry[0] = r[o].geometry[0].concat(n[0])),
                  o
                );
              }
              function s(t, i, n) {
                const o = e[i];
                return (
                  delete e[i],
                  (e[t] = o),
                  r[o].geometry[0].shift(),
                  (r[o].geometry[0] = n[0].concat(r[o].geometry[0])),
                  o
                );
              }
              function l(t, e, i) {
                const r = i ? e[0][e[0].length - 1] : e[0][0];
                return `${t}:${r.x}:${r.y}`;
              }
              for (let c = 0; c < t.length; c++) {
                const h = t[c],
                  u = h.geometry,
                  d = h.text ? h.text.toString() : null;
                if (!d) {
                  o(c);
                  continue;
                }
                const p = l(d, u),
                  f = l(d, u, !0);
                if (p in i && f in e && i[p] !== e[f]) {
                  const t = s(p, f, u),
                    n = a(p, f, r[t].geometry);
                  delete e[p],
                    delete i[f],
                    (i[l(d, r[n].geometry, !0)] = n),
                    (r[t].geometry = null);
                } else
                  p in i
                    ? a(p, f, u)
                    : f in e
                    ? s(p, f, u)
                    : (o(c), (e[p] = n - 1), (i[f] = n - 1));
              }
              return r.filter((t) => t.geometry);
            })(this.features)),
            this.sortFeaturesByKey &&
              this.features.sort((t, e) => t.sortKey - e.sortKey);
        }
        update(t, e, i) {
          this.stateDependentLayers.length &&
            (this.text.programConfigurations.updatePaintArrays(
              t,
              e,
              this.layers,
              { imagePositions: i }
            ),
            this.icon.programConfigurations.updatePaintArrays(
              t,
              e,
              this.layers,
              { imagePositions: i }
            ));
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return (
            !this.uploaded ||
            this.text.programConfigurations.needsUpload ||
            this.icon.programConfigurations.needsUpload
          );
        }
        upload(t) {
          !this.uploaded &&
            this.hasDebugData() &&
            (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)),
            this.text.upload(
              t,
              this.sortFeaturesByY,
              !this.uploaded,
              this.text.programConfigurations.needsUpload
            ),
            this.icon.upload(
              t,
              this.sortFeaturesByY,
              !this.uploaded,
              this.icon.programConfigurations.needsUpload
            ),
            (this.uploaded = !0);
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(),
            this.icon.destroy(),
            this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t, e) {
          const i = this.lineVertexArray.length;
          if (void 0 !== t.segment) {
            let i = t.dist(e[t.segment + 1]),
              r = t.dist(e[t.segment]);
            const n = {};
            for (let o = t.segment + 1; o < e.length; o++)
              (n[o] = { x: e[o].x, y: e[o].y, tileUnitDistanceFromAnchor: i }),
                o < e.length - 1 && (i += e[o + 1].dist(e[o]));
            for (let o = t.segment || 0; o >= 0; o--)
              (n[o] = { x: e[o].x, y: e[o].y, tileUnitDistanceFromAnchor: r }),
                o > 0 && (r += e[o - 1].dist(e[o]));
            for (let t = 0; t < e.length; t++) {
              const e = n[t];
              this.lineVertexArray.emplaceBack(
                e.x,
                e.y,
                e.tileUnitDistanceFromAnchor
              );
            }
          }
          return {
            lineStartIndex: i,
            lineLength: this.lineVertexArray.length - i,
          };
        }
        addSymbols(e, i, r, n, o, a, s, l, c, h, u, d) {
          const p = e.indexArray,
            f = e.layoutVertexArray,
            m = e.segments.prepareSegment(
              4 * i.length,
              f,
              p,
              this.canOverlap ? a.sortKey : void 0
            ),
            _ = this.glyphOffsetArray.length,
            g = m.vertexLength,
            y =
              this.allowVerticalPlacement && s === t.as.vertical
                ? Math.PI / 2
                : 0,
            x = a.text && a.text.sections;
          for (let t = 0; t < i.length; t++) {
            const {
                tl: n,
                tr: o,
                bl: s,
                br: c,
                tex: h,
                pixelOffsetTL: u,
                pixelOffsetBR: _,
                minFontScaleX: g,
                minFontScaleY: v,
                glyphOffset: b,
                isSDF: w,
                sectionIndex: T,
              } = i[t],
              P = m.vertexLength,
              S = b[1];
            au(f, l.x, l.y, n.x, S + n.y, h.x, h.y, r, w, u.x, u.y, g, v),
              au(
                f,
                l.x,
                l.y,
                o.x,
                S + o.y,
                h.x + h.w,
                h.y,
                r,
                w,
                _.x,
                u.y,
                g,
                v
              ),
              au(
                f,
                l.x,
                l.y,
                s.x,
                S + s.y,
                h.x,
                h.y + h.h,
                r,
                w,
                u.x,
                _.y,
                g,
                v
              ),
              au(
                f,
                l.x,
                l.y,
                c.x,
                S + c.y,
                h.x + h.w,
                h.y + h.h,
                r,
                w,
                _.x,
                _.y,
                g,
                v
              ),
              su(e.dynamicLayoutVertexArray, l, y),
              p.emplaceBack(P, P + 2, P + 1),
              p.emplaceBack(P + 1, P + 2, P + 3),
              (m.vertexLength += 4),
              (m.primitiveLength += 2),
              this.glyphOffsetArray.emplaceBack(b[0]),
              (t !== i.length - 1 && T === i[t + 1].sectionIndex) ||
                e.programConfigurations.populatePaintArrays(
                  f.length,
                  a,
                  a.index,
                  {
                    imagePositions: {},
                    canonical: d,
                    formattedSection: x && x[T],
                  }
                );
          }
          e.placedSymbolArray.emplaceBack(
            l.x,
            l.y,
            _,
            this.glyphOffsetArray.length - _,
            g,
            c,
            h,
            l.segment,
            r ? r[0] : 0,
            r ? r[1] : 0,
            n[0],
            n[1],
            s,
            0,
            !1,
            0,
            u
          );
        }
        _addCollisionDebugVertex(t, e, i, r, n, o) {
          return (
            e.emplaceBack(0, 0),
            t.emplaceBack(i.x, i.y, r, n, Math.round(o.x), Math.round(o.y))
          );
        }
        addCollisionDebugVertices(t, e, r, n, o, a, s) {
          const l = o.segments.prepareSegment(
              4,
              o.layoutVertexArray,
              o.indexArray
            ),
            c = l.vertexLength,
            h = o.layoutVertexArray,
            u = o.collisionVertexArray,
            d = s.anchorX,
            p = s.anchorY;
          this._addCollisionDebugVertex(h, u, a, d, p, new i(t, e)),
            this._addCollisionDebugVertex(h, u, a, d, p, new i(r, e)),
            this._addCollisionDebugVertex(h, u, a, d, p, new i(r, n)),
            this._addCollisionDebugVertex(h, u, a, d, p, new i(t, n)),
            (l.vertexLength += 4);
          const f = o.indexArray;
          f.emplaceBack(c, c + 1),
            f.emplaceBack(c + 1, c + 2),
            f.emplaceBack(c + 2, c + 3),
            f.emplaceBack(c + 3, c),
            (l.primitiveLength += 4);
        }
        addDebugCollisionBoxes(t, e, i, r) {
          for (let n = t; n < e; n++) {
            const t = this.collisionBoxArray.get(n);
            this.addCollisionDebugVertices(
              t.x1,
              t.y1,
              t.x2,
              t.y2,
              r ? this.textCollisionBox : this.iconCollisionBox,
              t.anchorPoint,
              i
            );
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(),
            (this.textCollisionBox = new hu(Xa, ah.members, Qa)),
            (this.iconCollisionBox = new hu(Xa, ah.members, Qa));
          for (let t = 0; t < this.symbolInstances.length; t++) {
            const e = this.symbolInstances.get(t);
            this.addDebugCollisionBoxes(
              e.textBoxStartIndex,
              e.textBoxEndIndex,
              e,
              !0
            ),
              this.addDebugCollisionBoxes(
                e.verticalTextBoxStartIndex,
                e.verticalTextBoxEndIndex,
                e,
                !0
              ),
              this.addDebugCollisionBoxes(
                e.iconBoxStartIndex,
                e.iconBoxEndIndex,
                e,
                !1
              ),
              this.addDebugCollisionBoxes(
                e.verticalIconBoxStartIndex,
                e.verticalIconBoxEndIndex,
                e,
                !1
              );
          }
        }
        _deserializeCollisionBoxesForSymbol(t, e, i, r, n, o, a, s, l) {
          const c = {};
          for (let h = e; h < i; h++) {
            const e = t.get(h);
            (c.textBox = {
              x1: e.x1,
              y1: e.y1,
              x2: e.x2,
              y2: e.y2,
              anchorPointX: e.anchorPointX,
              anchorPointY: e.anchorPointY,
            }),
              (c.textFeatureIndex = e.featureIndex);
            break;
          }
          for (let h = r; h < n; h++) {
            const e = t.get(h);
            (c.verticalTextBox = {
              x1: e.x1,
              y1: e.y1,
              x2: e.x2,
              y2: e.y2,
              anchorPointX: e.anchorPointX,
              anchorPointY: e.anchorPointY,
            }),
              (c.verticalTextFeatureIndex = e.featureIndex);
            break;
          }
          for (let h = o; h < a; h++) {
            const e = t.get(h);
            (c.iconBox = {
              x1: e.x1,
              y1: e.y1,
              x2: e.x2,
              y2: e.y2,
              anchorPointX: e.anchorPointX,
              anchorPointY: e.anchorPointY,
            }),
              (c.iconFeatureIndex = e.featureIndex);
            break;
          }
          for (let h = s; h < l; h++) {
            const e = t.get(h);
            (c.verticalIconBox = {
              x1: e.x1,
              y1: e.y1,
              x2: e.x2,
              y2: e.y2,
              anchorPointX: e.anchorPointX,
              anchorPointY: e.anchorPointY,
            }),
              (c.verticalIconFeatureIndex = e.featureIndex);
            break;
          }
          return c;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let e = 0; e < this.symbolInstances.length; e++) {
            const i = this.symbolInstances.get(e);
            this.collisionArrays.push(
              this._deserializeCollisionBoxesForSymbol(
                t,
                i.textBoxStartIndex,
                i.textBoxEndIndex,
                i.verticalTextBoxStartIndex,
                i.verticalTextBoxEndIndex,
                i.iconBoxStartIndex,
                i.iconBoxEndIndex,
                i.verticalIconBoxStartIndex,
                i.verticalIconBoxEndIndex
              )
            );
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return (
            this.hasDebugData() &&
            this.textCollisionBox.segments.get().length > 0
          );
        }
        hasIconCollisionBoxData() {
          return (
            this.hasDebugData() &&
            this.iconCollisionBox.segments.get().length > 0
          );
        }
        addIndicesForPlacedSymbol(t, e) {
          const i = t.placedSymbolArray.get(e),
            r = i.vertexStartIndex + 4 * i.numGlyphs;
          for (let n = i.vertexStartIndex; n < r; n += 4)
            t.indexArray.emplaceBack(n, n + 2, n + 1),
              t.indexArray.emplaceBack(n + 1, n + 2, n + 3);
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const e = Math.sin(t),
            i = Math.cos(t),
            r = [],
            n = [],
            o = [];
          for (let a = 0; a < this.symbolInstances.length; ++a) {
            o.push(a);
            const t = this.symbolInstances.get(a);
            r.push(0 | Math.round(e * t.anchorX + i * t.anchorY)),
              n.push(t.featureIndex);
          }
          return o.sort((t, e) => r[t] - r[e] || n[e] - n[t]), o;
        }
        addToSortKeyRanges(t, e) {
          const i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          i && i.sortKey === e
            ? (i.symbolInstanceEnd = t + 1)
            : this.sortKeyRanges.push({
                sortKey: e,
                symbolInstanceStart: t,
                symbolInstanceEnd: t + 1,
              });
        }
        sortFeatures(t) {
          if (
            this.sortFeaturesByY &&
            this.sortedAngle !== t &&
            !(
              this.text.segments.get().length > 1 ||
              this.icon.segments.get().length > 1
            )
          ) {
            (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
              (this.sortedAngle = t),
              this.text.indexArray.clear(),
              this.icon.indexArray.clear(),
              (this.featureSortOrder = []);
            for (const t of this.symbolInstanceIndexes) {
              const e = this.symbolInstances.get(t);
              this.featureSortOrder.push(e.featureIndex),
                [
                  e.rightJustifiedTextSymbolIndex,
                  e.centerJustifiedTextSymbolIndex,
                  e.leftJustifiedTextSymbolIndex,
                ].forEach((t, e, i) => {
                  t >= 0 &&
                    i.indexOf(t) === e &&
                    this.addIndicesForPlacedSymbol(this.text, t);
                }),
                e.verticalPlacedTextSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.text,
                    e.verticalPlacedTextSymbolIndex
                  ),
                e.placedIconSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.icon,
                    e.placedIconSymbolIndex
                  ),
                e.verticalPlacedIconSymbolIndex >= 0 &&
                  this.addIndicesForPlacedSymbol(
                    this.icon,
                    e.verticalPlacedIconSymbolIndex
                  );
            }
            this.text.indexBuffer &&
              this.text.indexBuffer.updateData(this.text.indexArray),
              this.icon.indexBuffer &&
                this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let du, pu;
      co('SymbolBucket', uu, {
        omit: ['layers', 'collisionBoxArray', 'features', 'compareText'],
      }),
        (uu.MAX_GLYPHS = 65535),
        (uu.addDynamicAttributes = su);
      var fu = {
        get paint() {
          return (pu =
            pu ||
            new qo({
              'icon-opacity': new Uo(xt.paint_symbol['icon-opacity']),
              'icon-color': new Uo(xt.paint_symbol['icon-color']),
              'icon-halo-color': new Uo(xt.paint_symbol['icon-halo-color']),
              'icon-halo-width': new Uo(xt.paint_symbol['icon-halo-width']),
              'icon-halo-blur': new Uo(xt.paint_symbol['icon-halo-blur']),
              'icon-translate': new Vo(xt.paint_symbol['icon-translate']),
              'icon-translate-anchor': new Vo(
                xt.paint_symbol['icon-translate-anchor']
              ),
              'text-opacity': new Uo(xt.paint_symbol['text-opacity']),
              'text-color': new Uo(xt.paint_symbol['text-color'], {
                runtimeType: jt,
                getOverride: (t) => t.textColor,
                hasOverride: (t) => !!t.textColor,
              }),
              'text-halo-color': new Uo(xt.paint_symbol['text-halo-color']),
              'text-halo-width': new Uo(xt.paint_symbol['text-halo-width']),
              'text-halo-blur': new Uo(xt.paint_symbol['text-halo-blur']),
              'text-translate': new Vo(xt.paint_symbol['text-translate']),
              'text-translate-anchor': new Vo(
                xt.paint_symbol['text-translate-anchor']
              ),
            }));
        },
        get layout() {
          return (du =
            du ||
            new qo({
              'symbol-placement': new Vo(xt.layout_symbol['symbol-placement']),
              'symbol-spacing': new Vo(xt.layout_symbol['symbol-spacing']),
              'symbol-avoid-edges': new Vo(
                xt.layout_symbol['symbol-avoid-edges']
              ),
              'symbol-sort-key': new Uo(xt.layout_symbol['symbol-sort-key']),
              'symbol-z-order': new Vo(xt.layout_symbol['symbol-z-order']),
              'icon-allow-overlap': new Vo(
                xt.layout_symbol['icon-allow-overlap']
              ),
              'icon-overlap': new Vo(xt.layout_symbol['icon-overlap']),
              'icon-ignore-placement': new Vo(
                xt.layout_symbol['icon-ignore-placement']
              ),
              'icon-optional': new Vo(xt.layout_symbol['icon-optional']),
              'icon-rotation-alignment': new Vo(
                xt.layout_symbol['icon-rotation-alignment']
              ),
              'icon-size': new Uo(xt.layout_symbol['icon-size']),
              'icon-text-fit': new Vo(xt.layout_symbol['icon-text-fit']),
              'icon-text-fit-padding': new Vo(
                xt.layout_symbol['icon-text-fit-padding']
              ),
              'icon-image': new Uo(xt.layout_symbol['icon-image']),
              'icon-rotate': new Uo(xt.layout_symbol['icon-rotate']),
              'icon-padding': new Uo(xt.layout_symbol['icon-padding']),
              'icon-keep-upright': new Vo(
                xt.layout_symbol['icon-keep-upright']
              ),
              'icon-offset': new Uo(xt.layout_symbol['icon-offset']),
              'icon-anchor': new Uo(xt.layout_symbol['icon-anchor']),
              'icon-pitch-alignment': new Vo(
                xt.layout_symbol['icon-pitch-alignment']
              ),
              'text-pitch-alignment': new Vo(
                xt.layout_symbol['text-pitch-alignment']
              ),
              'text-rotation-alignment': new Vo(
                xt.layout_symbol['text-rotation-alignment']
              ),
              'text-field': new Uo(xt.layout_symbol['text-field']),
              'text-font': new Uo(xt.layout_symbol['text-font']),
              'text-size': new Uo(xt.layout_symbol['text-size']),
              'text-max-width': new Uo(xt.layout_symbol['text-max-width']),
              'text-line-height': new Vo(xt.layout_symbol['text-line-height']),
              'text-letter-spacing': new Uo(
                xt.layout_symbol['text-letter-spacing']
              ),
              'text-justify': new Uo(xt.layout_symbol['text-justify']),
              'text-radial-offset': new Uo(
                xt.layout_symbol['text-radial-offset']
              ),
              'text-variable-anchor': new Vo(
                xt.layout_symbol['text-variable-anchor']
              ),
              'text-variable-anchor-offset': new Uo(
                xt.layout_symbol['text-variable-anchor-offset']
              ),
              'text-anchor': new Uo(xt.layout_symbol['text-anchor']),
              'text-max-angle': new Vo(xt.layout_symbol['text-max-angle']),
              'text-writing-mode': new Vo(
                xt.layout_symbol['text-writing-mode']
              ),
              'text-rotate': new Uo(xt.layout_symbol['text-rotate']),
              'text-padding': new Vo(xt.layout_symbol['text-padding']),
              'text-keep-upright': new Vo(
                xt.layout_symbol['text-keep-upright']
              ),
              'text-transform': new Uo(xt.layout_symbol['text-transform']),
              'text-offset': new Uo(xt.layout_symbol['text-offset']),
              'text-allow-overlap': new Vo(
                xt.layout_symbol['text-allow-overlap']
              ),
              'text-overlap': new Vo(xt.layout_symbol['text-overlap']),
              'text-ignore-placement': new Vo(
                xt.layout_symbol['text-ignore-placement']
              ),
              'text-optional': new Vo(xt.layout_symbol['text-optional']),
            }));
        },
      };
      class mu {
        constructor(t) {
          if (void 0 === t.property.overrides)
            throw new Error(
              'overrides must be provided to instantiate FormatSectionOverride class'
            );
          (this.type = t.property.overrides
            ? t.property.overrides.runtimeType
            : Lt),
            (this.defaultValue = t);
        }
        evaluate(t) {
          if (t.formattedSection) {
            const e = this.defaultValue.property.overrides;
            if (e && e.hasOverride(t.formattedSection))
              return e.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState
            ? this.defaultValue.evaluate(t.feature, t.featureState)
            : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() ||
            t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      co('FormatSectionOverride', mu, { omit: ['defaultValue'] });
      class _u extends Yo {
        constructor(t, e) {
          super(t, fu, e);
        }
        recalculate(t, e) {
          if (
            (super.recalculate(t, e),
            'auto' === this.layout.get('icon-rotation-alignment') &&
              (this.layout._values['icon-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement')
                  ? 'map'
                  : 'viewport'),
            'auto' === this.layout.get('text-rotation-alignment') &&
              (this.layout._values['text-rotation-alignment'] =
                'point' !== this.layout.get('symbol-placement')
                  ? 'map'
                  : 'viewport'),
            'auto' === this.layout.get('text-pitch-alignment') &&
              (this.layout._values['text-pitch-alignment'] =
                'map' === this.layout.get('text-rotation-alignment')
                  ? 'map'
                  : 'viewport'),
            'auto' === this.layout.get('icon-pitch-alignment') &&
              (this.layout._values['icon-pitch-alignment'] = this.layout.get(
                'icon-rotation-alignment'
              )),
            'point' === this.layout.get('symbol-placement'))
          ) {
            const t = this.layout.get('text-writing-mode');
            if (t) {
              const e = [];
              for (const i of t) e.indexOf(i) < 0 && e.push(i);
              this.layout._values['text-writing-mode'] = e;
            } else this.layout._values['text-writing-mode'] = ['horizontal'];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, e, i, r) {
          const n = this.layout.get(t).evaluate(e, {}, i, r),
            o = this._unevaluatedLayout._values[t];
          return o.isDataDriven() || en(o.value) || !n
            ? n
            : (function (t, e) {
                return e.replace(/{([^{}]+)}/g, (e, i) =>
                  t && i in t ? String(t[i]) : ''
                );
              })(e.properties, n);
        }
        createBucket(t) {
          return new uu(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error('Should take a different path in FeatureIndex');
        }
        _setPaintOverrides() {
          for (const t of fu.paint.overridableProperties) {
            if (!_u.hasPaintOverride(this.layout, t)) continue;
            const e = this.paint.get(t),
              i = new mu(e),
              r = new tn(i, e.property.specification);
            let n = null;
            (n =
              'constant' === e.value.kind || 'source' === e.value.kind
                ? new nn('source', r)
                : new on('composite', r, e.value.zoomStops)),
              (this.paint._values[t] = new jo(e.property, n, e.parameters));
          }
        }
        _handleOverridablePaintPropertyUpdate(t, e, i) {
          return (
            !(!this.layout || e.isDataDriven() || i.isDataDriven()) &&
            _u.hasPaintOverride(this.layout, t)
          );
        }
        static hasPaintOverride(t, e) {
          const i = t.get('text-field'),
            r = fu.paint.properties[e];
          let n = !1;
          const o = (t) => {
            for (const e of t)
              if (r.overrides && r.overrides.hasOverride(e))
                return void (n = !0);
          };
          if ('constant' === i.value.kind && i.value.value instanceof ze)
            o(i.value.value.sections);
          else if ('source' === i.value.kind || 'composite' === i.value.kind) {
            const t = (e) => {
                n ||
                  (e instanceof Ze && Ue(e.value) === Zt
                    ? o(e.value.sections)
                    : e instanceof Ci
                    ? o(e.sections)
                    : e.eachChild(t));
              },
              e = i.value;
            e._styleExpression && t(e._styleExpression.expression);
          }
          return n;
        }
      }
      let gu;
      var yu = {
        get paint() {
          return (gu =
            gu ||
            new qo({
              'background-color': new Vo(
                xt.paint_background['background-color']
              ),
              'background-pattern': new Zo(
                xt.paint_background['background-pattern']
              ),
              'background-opacity': new Vo(
                xt.paint_background['background-opacity']
              ),
            }));
        },
      };
      class xu extends Yo {
        constructor(t, e) {
          super(t, yu, e);
        }
      }
      class vu extends Yo {
        constructor(t, e) {
          super(t, {}, e),
            (this.onAdd = (t) => {
              this.implementation.onAdd &&
                this.implementation.onAdd(t, t.painter.context.gl);
            }),
            (this.onRemove = (t) => {
              this.implementation.onRemove &&
                this.implementation.onRemove(t, t.painter.context.gl);
            }),
            (this.implementation = t);
        }
        is3D() {
          return '3d' === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        recalculate() {}
        updateTransitions() {}
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error('Custom layers cannot be serialized');
        }
      }
      class bu {
        constructor(t) {
          (this._methodToThrottle = t),
            (this._triggered = !1),
            'undefined' != typeof MessageChannel &&
              ((this._channel = new MessageChannel()),
              (this._channel.port2.onmessage = () => {
                (this._triggered = !1), this._methodToThrottle();
              }));
        }
        trigger() {
          this._triggered ||
            ((this._triggered = !0),
            this._channel
              ? this._channel.port1.postMessage(!0)
              : setTimeout(() => {
                  (this._triggered = !1), this._methodToThrottle();
                }, 0));
        }
        remove() {
          delete this._channel, (this._methodToThrottle = () => {});
        }
      }
      const wu = { once: !0 },
        Tu = 6371008.8;
      class Pu {
        constructor(t, e) {
          if (isNaN(t) || isNaN(e))
            throw new Error(`Invalid LngLat object: (${t}, ${e})`);
          if (
            ((this.lng = +t), (this.lat = +e), this.lat > 90 || this.lat < -90)
          )
            throw new Error(
              'Invalid LngLat latitude value: must be between -90 and 90'
            );
        }
        wrap() {
          return new Pu(B(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const e = Math.PI / 180,
            i = this.lat * e,
            r = t.lat * e,
            n =
              Math.sin(i) * Math.sin(r) +
              Math.cos(i) * Math.cos(r) * Math.cos((t.lng - this.lng) * e);
          return Tu * Math.acos(Math.min(n, 1));
        }
        static convert(t) {
          if (t instanceof Pu) return t;
          if (Array.isArray(t) && (2 === t.length || 3 === t.length))
            return new Pu(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && 'object' == typeof t && null !== t)
            return new Pu(Number('lng' in t ? t.lng : t.lon), Number(t.lat));
          throw new Error(
            '`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'
          );
        }
      }
      const Su = 2 * Math.PI * Tu;
      function Mu(t) {
        return Su * Math.cos((t * Math.PI) / 180);
      }
      function Iu(t) {
        return (180 + t) / 360;
      }
      function Cu(t) {
        return (
          (180 -
            (180 / Math.PI) *
              Math.log(Math.tan(Math.PI / 4 + (t * Math.PI) / 360))) /
          360
        );
      }
      function Au(t, e) {
        return t / Mu(e);
      }
      function Eu(t) {
        return 360 * t - 180;
      }
      function zu(t) {
        return (
          (360 / Math.PI) *
            Math.atan(Math.exp(((180 - 360 * t) * Math.PI) / 180)) -
          90
        );
      }
      function ku(t, e) {
        return t * Mu(zu(e));
      }
      class Du {
        constructor(t, e, i = 0) {
          (this.x = +t), (this.y = +e), (this.z = +i);
        }
        static fromLngLat(t, e = 0) {
          const i = Pu.convert(t);
          return new Du(Iu(i.lng), Cu(i.lat), Au(e, i.lat));
        }
        toLngLat() {
          return new Pu(Eu(this.x), zu(this.y));
        }
        toAltitude() {
          return ku(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return (
            (1 / Su) * ((t = zu(this.y)), 1 / Math.cos((t * Math.PI) / 180))
          );
          var t;
        }
      }
      function Ru(t, e, i) {
        var r = (2 * Math.PI * 6378137) / 256 / Math.pow(2, i);
        return [
          t * r - (2 * Math.PI * 6378137) / 2,
          e * r - (2 * Math.PI * 6378137) / 2,
        ];
      }
      class Lu {
        constructor(t, e, i) {
          if (
            !(function (t, e, i) {
              return !(
                t < 0 ||
                t > 25 ||
                i < 0 ||
                i >= Math.pow(2, t) ||
                e < 0 ||
                e >= Math.pow(2, t)
              );
            })(t, e, i)
          )
            throw new Error(
              `x=${e}, y=${i}, z=${t} outside of bounds. 0<=x<${Math.pow(
                2,
                t
              )}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `
            );
          (this.z = t),
            (this.x = e),
            (this.y = i),
            (this.key = Ou(0, t, t, e, i));
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, e, i) {
          const r =
            ((o = this.y),
            (a = this.z),
            (s = Ru(256 * (n = this.x), 256 * (o = Math.pow(2, a) - o - 1), a)),
            (l = Ru(256 * (n + 1), 256 * (o + 1), a)),
            s[0] + ',' + s[1] + ',' + l[0] + ',' + l[1]);
          var n, o, a, s, l;
          const c = (function (t, e, i) {
            let r,
              n = '';
            for (let o = t; o > 0; o--)
              (r = 1 << (o - 1)), (n += (e & r ? 1 : 0) + (i & r ? 2 : 0));
            return n;
          })(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length]
            .replace(
              /{prefix}/g,
              (this.x % 16).toString(16) + (this.y % 16).toString(16)
            )
            .replace(/{z}/g, String(this.z))
            .replace(/{x}/g, String(this.x))
            .replace(
              /{y}/g,
              String('tms' === i ? Math.pow(2, this.z) - this.y - 1 : this.y)
            )
            .replace(/{ratio}/g, e > 1 ? '@2x' : '')
            .replace(/{quadkey}/g, c)
            .replace(/{bbox-epsg-3857}/g, r);
        }
        isChildOf(t) {
          const e = this.z - t.z;
          return e > 0 && t.x === this.x >> e && t.y === this.y >> e;
        }
        getTilePoint(t) {
          const e = Math.pow(2, this.z);
          return new i((t.x * e - this.x) * A, (t.y * e - this.y) * A);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Fu {
        constructor(t, e) {
          (this.wrap = t),
            (this.canonical = e),
            (this.key = Ou(t, e.z, e.z, e.x, e.y));
        }
      }
      class Bu {
        constructor(t, e, i, r, n) {
          if (((this.terrainRttPosMatrix32f = null), t < i))
            throw new Error(
              `overscaledZ should be >= z; overscaledZ = ${t}; z = ${i}`
            );
          (this.overscaledZ = t),
            (this.wrap = e),
            (this.canonical = new Lu(i, +r, +n)),
            (this.key = Ou(e, t, i, r, n));
        }
        clone() {
          return new Bu(
            this.overscaledZ,
            this.wrap,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y
          );
        }
        equals(t) {
          return (
            this.overscaledZ === t.overscaledZ &&
            this.wrap === t.wrap &&
            this.canonical.equals(t.canonical)
          );
        }
        scaledTo(t) {
          if (t > this.overscaledZ)
            throw new Error(
              `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
            );
          const e = this.canonical.z - t;
          return t > this.canonical.z
            ? new Bu(
                t,
                this.wrap,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y
              )
            : new Bu(
                t,
                this.wrap,
                t,
                this.canonical.x >> e,
                this.canonical.y >> e
              );
        }
        isOverscaled() {
          return this.overscaledZ > this.canonical.z;
        }
        calculateScaledKey(t, e) {
          if (t > this.overscaledZ)
            throw new Error(
              `targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
            );
          const i = this.canonical.z - t;
          return t > this.canonical.z
            ? Ou(
                this.wrap * +e,
                t,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y
              )
            : Ou(
                this.wrap * +e,
                t,
                t,
                this.canonical.x >> i,
                this.canonical.y >> i
              );
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          if (this.overscaledZ - t.overscaledZ <= 0) return !1;
          if (0 === t.overscaledZ) return this.overscaledZ > 0;
          const e = this.canonical.z - t.canonical.z;
          return (
            !(e < 0) &&
            t.canonical.x === this.canonical.x >> e &&
            t.canonical.y === this.canonical.y >> e
          );
        }
        children(t) {
          if (this.overscaledZ >= t)
            return [
              new Bu(
                this.overscaledZ + 1,
                this.wrap,
                this.canonical.z,
                this.canonical.x,
                this.canonical.y
              ),
            ];
          const e = this.canonical.z + 1,
            i = 2 * this.canonical.x,
            r = 2 * this.canonical.y;
          return [
            new Bu(e, this.wrap, e, i, r),
            new Bu(e, this.wrap, e, i + 1, r),
            new Bu(e, this.wrap, e, i, r + 1),
            new Bu(e, this.wrap, e, i + 1, r + 1),
          ];
        }
        isLessThan(t) {
          return (
            this.wrap < t.wrap ||
            (!(this.wrap > t.wrap) &&
              (this.overscaledZ < t.overscaledZ ||
                (!(this.overscaledZ > t.overscaledZ) &&
                  (this.canonical.x < t.canonical.x ||
                    (!(this.canonical.x > t.canonical.x) &&
                      this.canonical.y < t.canonical.y)))))
          );
        }
        wrapped() {
          return new Bu(
            this.overscaledZ,
            0,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y
          );
        }
        unwrapTo(t) {
          return new Bu(
            this.overscaledZ,
            t,
            this.canonical.z,
            this.canonical.x,
            this.canonical.y
          );
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Fu(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t) {
          return this.canonical.getTilePoint(new Du(t.x - this.wrap, t.y));
        }
      }
      function Ou(t, e, i, r, n) {
        (t *= 2) < 0 && (t = -1 * t - 1);
        const o = 1 << i;
        return (
          (o * o * t + o * n + r).toString(36) + i.toString(36) + e.toString(36)
        );
      }
      function ju(t, e) {
        return e ? t.properties[e] : t.id;
      }
      co('CanonicalTileID', Lu),
        co('OverscaledTileID', Bu, { omit: ['terrainRttPosMatrix32f'] });
      class Nu {
        constructor() {
          (this.minX = 1 / 0),
            (this.maxX = -1 / 0),
            (this.minY = 1 / 0),
            (this.maxY = -1 / 0);
        }
        extend(t) {
          return (
            (this.minX = Math.min(this.minX, t.x)),
            (this.minY = Math.min(this.minY, t.y)),
            (this.maxX = Math.max(this.maxX, t.x)),
            (this.maxY = Math.max(this.maxY, t.y)),
            this
          );
        }
        expandBy(t) {
          return (
            (this.minX -= t),
            (this.minY -= t),
            (this.maxX += t),
            (this.maxY += t),
            (this.minX > this.maxX || this.minY > this.maxY) &&
              ((this.minX = 1 / 0),
              (this.maxX = -1 / 0),
              (this.minY = 1 / 0),
              (this.maxY = -1 / 0)),
            this
          );
        }
        shrinkBy(t) {
          return this.expandBy(-t);
        }
        map(t) {
          const e = new Nu();
          return (
            e.extend(t(new i(this.minX, this.minY))),
            e.extend(t(new i(this.maxX, this.minY))),
            e.extend(t(new i(this.minX, this.maxY))),
            e.extend(t(new i(this.maxX, this.maxY))),
            e
          );
        }
        static fromPoints(t) {
          const e = new Nu();
          for (const i of t) e.extend(i);
          return e;
        }
        contains(t) {
          return (
            t.x >= this.minX &&
            t.x <= this.maxX &&
            t.y >= this.minY &&
            t.y <= this.maxY
          );
        }
        empty() {
          return this.minX > this.maxX;
        }
        width() {
          return this.maxX - this.minX;
        }
        height() {
          return this.maxY - this.minY;
        }
        covers(t) {
          return (
            !this.empty() &&
            !t.empty() &&
            t.minX >= this.minX &&
            t.maxX <= this.maxX &&
            t.minY >= this.minY &&
            t.maxY <= this.maxY
          );
        }
        intersects(t) {
          return (
            !this.empty() &&
            !t.empty() &&
            t.minX <= this.maxX &&
            t.maxX >= this.minX &&
            t.minY <= this.maxY &&
            t.maxY >= this.minY
          );
        }
      }
      class Vu {
        constructor(t) {
          (this._stringToNumber = {}), (this._numberToString = []);
          for (let e = 0; e < t.length; e++) {
            const i = t[e];
            (this._stringToNumber[i] = e), (this._numberToString[e] = i);
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          if (t >= this._numberToString.length)
            throw new Error(
              `Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`
            );
          return this._numberToString[t];
        }
      }
      class Uu {
        constructor(t, e, i, r, n) {
          (this.type = 'Feature'),
            (this._vectorTileFeature = t),
            (t._z = e),
            (t._x = i),
            (t._y = r),
            (this.properties = t.properties),
            (this.id = n);
        }
        get geometry() {
          return (
            void 0 === this._geometry &&
              (this._geometry = this._vectorTileFeature.toGeoJSON(
                this._vectorTileFeature._x,
                this._vectorTileFeature._y,
                this._vectorTileFeature._z
              ).geometry),
            this._geometry
          );
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { geometry: this.geometry };
          for (const e in this)
            '_geometry' !== e && '_vectorTileFeature' !== e && (t[e] = this[e]);
          return t;
        }
      }
      class Gu {
        constructor(t, e) {
          (this.tileID = t),
            (this.x = t.canonical.x),
            (this.y = t.canonical.y),
            (this.z = t.canonical.z),
            (this.grid = new so(A, 16, 0)),
            (this.grid3D = new so(A, 16, 0)),
            (this.featureIndexArray = new Oa()),
            (this.promoteId = e);
        }
        insert(t, e, i, r, n, o) {
          const a = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(i, r, n);
          const s = o ? this.grid3D : this.grid;
          for (let l = 0; l < e.length; l++) {
            const t = e[l],
              i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e = 0; e < t.length; e++) {
              const r = t[e];
              (i[0] = Math.min(i[0], r.x)),
                (i[1] = Math.min(i[1], r.y)),
                (i[2] = Math.max(i[2], r.x)),
                (i[3] = Math.max(i[3], r.y));
            }
            i[0] < A &&
              i[1] < A &&
              i[2] >= 0 &&
              i[3] >= 0 &&
              s.insert(a, i[0], i[1], i[2], i[3]);
          }
        }
        loadVTLayers() {
          return (
            this.vtLayers ||
              ((this.vtLayers = new Ec(new fh(this.rawTileData)).layers),
              (this.sourceLayerCoder = new Vu(
                this.vtLayers
                  ? Object.keys(this.vtLayers).sort()
                  : ['_geojsonTileLayer']
              ))),
            this.vtLayers
          );
        }
        query(t, e, r, n) {
          this.loadVTLayers();
          const o = t.params,
            a = A / t.tileSize / t.scale,
            s = pn(o.filter, o.globalState),
            l = t.queryGeometry,
            c = t.queryPadding * a,
            h = Nu.fromPoints(l),
            u = this.grid.query(h.minX - c, h.minY - c, h.maxX + c, h.maxY + c),
            d = Nu.fromPoints(t.cameraQueryGeometry).expandBy(c),
            p = this.grid3D.query(
              d.minX,
              d.minY,
              d.maxX,
              d.maxY,
              (e, r, n, o) =>
                (function (t, e, r, n, o) {
                  for (const i of t)
                    if (e <= i.x && r <= i.y && n >= i.x && o >= i.y) return !0;
                  const a = [
                    new i(e, r),
                    new i(e, o),
                    new i(n, o),
                    new i(n, r),
                  ];
                  if (t.length > 2) for (const i of a) if (Ks(t, i)) return !0;
                  for (let i = 0; i < t.length - 1; i++)
                    if (Js(t[i], t[i + 1], a)) return !0;
                  return !1;
                })(t.cameraQueryGeometry, e - c, r - c, n + c, o + c)
            );
          for (const i of p) u.push(i);
          u.sort($u);
          const f = {};
          let m;
          for (let i = 0; i < u.length; i++) {
            const c = u[i];
            if (c === m) continue;
            m = c;
            const h = this.featureIndexArray.get(c);
            let d = null;
            this.loadMatchingFeature(
              f,
              h.bucketIndex,
              h.sourceLayerIndex,
              h.featureIndex,
              s,
              o.layers,
              o.availableImages,
              e,
              r,
              n,
              (e, i, r) => (
                d || (d = Bs(e)),
                i.queryIntersectsFeature({
                  queryGeometry: l,
                  feature: e,
                  featureState: r,
                  geometry: d,
                  zoom: this.z,
                  transform: t.transform,
                  pixelsToTileUnits: a,
                  pixelPosMatrix: t.pixelPosMatrix,
                  unwrappedTileID: this.tileID.toUnwrapped(),
                  getElevation: t.getElevation,
                })
              )
            );
          }
          return f;
        }
        loadMatchingFeature(t, e, i, r, n, o, a, s, l, c, h) {
          const u = this.bucketLayerIDs[e];
          if (o && !u.some((t) => o.has(t))) return;
          const d = this.sourceLayerCoder.decode(i),
            p = this.vtLayers[d].feature(r);
          if (n.needGeometry) {
            const t = Os(p, !0);
            if (
              !n.filter(
                new zo(this.tileID.overscaledZ),
                t,
                this.tileID.canonical
              )
            )
              return;
          } else if (!n.filter(new zo(this.tileID.overscaledZ), p)) return;
          const f = this.getId(p, d);
          for (let m = 0; m < u.length; m++) {
            const e = u[m];
            if (o && !o.has(e)) continue;
            const i = s[e];
            if (!i) continue;
            let n = {};
            f && c && (n = c.getState(i.sourceLayer || '_geojsonTileLayer', f));
            const d = O({}, l[e]);
            (d.paint = Zu(d.paint, i.paint, p, n, a)),
              (d.layout = Zu(d.layout, i.layout, p, n, a));
            const _ = !h || h(p, i, n);
            if (!_) continue;
            const g = new Uu(p, this.z, this.x, this.y, f);
            g.layer = d;
            let y = t[e];
            void 0 === y && (y = t[e] = []),
              y.push({ featureIndex: r, feature: g, intersectionZ: _ });
          }
        }
        lookupSymbolFeatures(t, e, i, r, n, o, a, s) {
          const l = {};
          this.loadVTLayers();
          const c = pn(n.filterSpec, n.globalState);
          for (const h of t)
            this.loadMatchingFeature(l, i, r, h, c, o, a, s, e);
          return l;
        }
        hasLayer(t) {
          for (const e of this.bucketLayerIDs)
            for (const i of e) if (t === i) return !0;
          return !1;
        }
        getId(t, e) {
          var i;
          let r = t.id;
          return (
            this.promoteId &&
              ((r =
                t.properties[
                  'string' == typeof this.promoteId
                    ? this.promoteId
                    : this.promoteId[e]
                ]),
              'boolean' == typeof r && (r = Number(r)),
              void 0 === r &&
                (null === (i = t.properties) || void 0 === i
                  ? void 0
                  : i.cluster) &&
                this.promoteId &&
                (r = Number(t.properties.cluster_id))),
            r
          );
        }
      }
      function Zu(t, e, i, r, n) {
        return N(t, (t, o) => {
          const a = e instanceof No ? e.get(o) : null;
          return a && a.evaluate ? a.evaluate(i, r, n) : a;
        });
      }
      function $u(t, e) {
        return e - t;
      }
      function qu(t, e, r, n, o) {
        const a = [];
        for (let s = 0; s < t.length; s++) {
          const l = t[s];
          let c;
          for (let t = 0; t < l.length - 1; t++) {
            let s = l[t],
              h = l[t + 1];
            (s.x < e && h.x < e) ||
              (s.x < e
                ? (s = new i(
                    e,
                    s.y + ((e - s.x) / (h.x - s.x)) * (h.y - s.y)
                  )._round())
                : h.x < e &&
                  (h = new i(
                    e,
                    s.y + ((e - s.x) / (h.x - s.x)) * (h.y - s.y)
                  )._round()),
              (s.y < r && h.y < r) ||
                (s.y < r
                  ? (s = new i(
                      s.x + ((r - s.y) / (h.y - s.y)) * (h.x - s.x),
                      r
                    )._round())
                  : h.y < r &&
                    (h = new i(
                      s.x + ((r - s.y) / (h.y - s.y)) * (h.x - s.x),
                      r
                    )._round()),
                (s.x >= n && h.x >= n) ||
                  (s.x >= n
                    ? (s = new i(
                        n,
                        s.y + ((n - s.x) / (h.x - s.x)) * (h.y - s.y)
                      )._round())
                    : h.x >= n &&
                      (h = new i(
                        n,
                        s.y + ((n - s.x) / (h.x - s.x)) * (h.y - s.y)
                      )._round()),
                  (s.y >= o && h.y >= o) ||
                    (s.y >= o
                      ? (s = new i(
                          s.x + ((o - s.y) / (h.y - s.y)) * (h.x - s.x),
                          o
                        )._round())
                      : h.y >= o &&
                        (h = new i(
                          s.x + ((o - s.y) / (h.y - s.y)) * (h.x - s.x),
                          o
                        )._round()),
                    (c && s.equals(c[c.length - 1])) || ((c = [s]), a.push(c)),
                    c.push(h)))));
          }
        }
        return a;
      }
      co('FeatureIndex', Gu, { omit: ['rawTileData', 'sourceLayerCoder'] });
      class Wu extends i {
        constructor(t, e, i, r) {
          super(t, e), (this.angle = i), void 0 !== r && (this.segment = r);
        }
        clone() {
          return new Wu(this.x, this.y, this.angle, this.segment);
        }
      }
      function Yu(t, e, i, r, n) {
        if (void 0 === e.segment || 0 === i) return !0;
        let o = e,
          a = e.segment + 1,
          s = 0;
        for (; s > -i / 2; ) {
          if ((a--, a < 0)) return !1;
          (s -= t[a].dist(o)), (o = t[a]);
        }
        (s += t[a].dist(t[a + 1])), a++;
        const l = [];
        let c = 0;
        for (; s < i / 2; ) {
          const e = t[a],
            i = t[a + 1];
          if (!i) return !1;
          let o = t[a - 1].angleTo(e) - e.angleTo(i);
          for (
            o = Math.abs(((o + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
              l.push({ distance: s, angleDelta: o }),
              c += o;
            s - l[0].distance > r;

          )
            c -= l.shift().angleDelta;
          if (c > n) return !1;
          a++, (s += e.dist(i));
        }
        return !0;
      }
      function Hu(t) {
        let e = 0;
        for (let i = 0; i < t.length - 1; i++) e += t[i].dist(t[i + 1]);
        return e;
      }
      function Xu(t, e, i) {
        return t ? 0.6 * e * i : 0;
      }
      function Ku(t, e) {
        return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
      }
      function Ju(t, e, i, r, n, o) {
        const a = Xu(i, n, o),
          s = Ku(i, r) * o;
        let l = 0;
        const c = Hu(t) / 2;
        for (let h = 0; h < t.length - 1; h++) {
          const i = t[h],
            r = t[h + 1],
            n = i.dist(r);
          if (l + n > c) {
            const o = (c - l) / n,
              u = mi.number(i.x, r.x, o),
              d = mi.number(i.y, r.y, o),
              p = new Wu(u, d, r.angleTo(i), h);
            return p._round(), !a || Yu(t, p, s, a, e) ? p : void 0;
          }
          l += n;
        }
      }
      function Qu(t, e, i, r, n, o, a, s, l) {
        const c = Xu(r, o, a),
          h = Ku(r, n),
          u = h * a,
          d = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
        return (
          e - u < e / 4 && (e = u + e / 4),
          td(
            t,
            d ? ((e / 2) * s) % e : ((h / 2 + 2 * o) * a * s) % e,
            e,
            c,
            i,
            u,
            d,
            !1,
            l
          )
        );
      }
      function td(t, e, i, r, n, o, a, s, l) {
        const c = o / 2,
          h = Hu(t);
        let u = 0,
          d = e - i,
          p = [];
        for (let f = 0; f < t.length - 1; f++) {
          const e = t[f],
            a = t[f + 1],
            s = e.dist(a),
            m = a.angleTo(e);
          for (; d + i < u + s; ) {
            d += i;
            const _ = (d - u) / s,
              g = mi.number(e.x, a.x, _),
              y = mi.number(e.y, a.y, _);
            if (
              g >= 0 &&
              g < l &&
              y >= 0 &&
              y < l &&
              d - c >= 0 &&
              d + c <= h
            ) {
              const e = new Wu(g, y, m, f);
              e._round(), (r && !Yu(t, e, o, r, n)) || p.push(e);
            }
          }
          u += s;
        }
        return (
          s || p.length || a || (p = td(t, u / 2, i, r, n, o, a, !0, l)), p
        );
      }
      function ed(t, e, r, n) {
        const o = [],
          a = t.image,
          s = a.pixelRatio,
          l = a.paddedRect.w - 2,
          c = a.paddedRect.h - 2;
        let h = { x1: t.left, y1: t.top, x2: t.right, y2: t.bottom };
        const u = a.stretchX || [[0, l]],
          d = a.stretchY || [[0, c]],
          p = (t, e) => t + e[1] - e[0],
          f = u.reduce(p, 0),
          m = d.reduce(p, 0),
          _ = l - f,
          g = c - m;
        let y = 0,
          x = f,
          v = 0,
          b = m,
          w = 0,
          T = _,
          P = 0,
          S = g;
        if (a.content && n) {
          const e = a.content,
            i = e[2] - e[0],
            r = e[3] - e[1];
          (a.textFitWidth || a.textFitHeight) && (h = Qh(t)),
            (y = id(u, 0, e[0])),
            (v = id(d, 0, e[1])),
            (x = id(u, e[0], e[2])),
            (b = id(d, e[1], e[3])),
            (w = e[0] - y),
            (P = e[1] - v),
            (T = i - x),
            (S = r - b);
        }
        const M = h.x1,
          I = h.y1,
          C = h.x2 - M,
          A = h.y2 - I,
          E = (t, n, o, l) => {
            const c = nd(t.stretch - y, x, C, M),
              h = od(t.fixed - w, T, t.stretch, f),
              u = nd(n.stretch - v, b, A, I),
              d = od(n.fixed - P, S, n.stretch, m),
              p = nd(o.stretch - y, x, C, M),
              _ = od(o.fixed - w, T, o.stretch, f),
              g = nd(l.stretch - v, b, A, I),
              E = od(l.fixed - P, S, l.stretch, m),
              z = new i(c, u),
              k = new i(p, u),
              D = new i(p, g),
              R = new i(c, g),
              L = new i(h / s, d / s),
              F = new i(_ / s, E / s),
              B = (e * Math.PI) / 180;
            if (B) {
              const t = Math.sin(B),
                e = Math.cos(B),
                i = [e, -t, t, e];
              z._matMult(i), k._matMult(i), R._matMult(i), D._matMult(i);
            }
            const O = t.stretch + t.fixed,
              j = n.stretch + n.fixed;
            return {
              tl: z,
              tr: k,
              bl: R,
              br: D,
              tex: {
                x: a.paddedRect.x + 1 + O,
                y: a.paddedRect.y + 1 + j,
                w: o.stretch + o.fixed - O,
                h: l.stretch + l.fixed - j,
              },
              writingMode: void 0,
              glyphOffset: [0, 0],
              sectionIndex: 0,
              pixelOffsetTL: L,
              pixelOffsetBR: F,
              minFontScaleX: T / s / C,
              minFontScaleY: S / s / A,
              isSDF: r,
            };
          };
        if (n && (a.stretchX || a.stretchY)) {
          const t = rd(u, _, f),
            e = rd(d, g, m);
          for (let i = 0; i < t.length - 1; i++) {
            const r = t[i],
              n = t[i + 1];
            for (let t = 0; t < e.length - 1; t++)
              o.push(E(r, e[t], n, e[t + 1]));
          }
        } else o.push(E({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l + 1 }, { fixed: 0, stretch: c + 1 }));
        return o;
      }
      function id(t, e, i) {
        let r = 0;
        for (const n of t)
          r += Math.max(e, Math.min(i, n[1])) - Math.max(e, Math.min(i, n[0]));
        return r;
      }
      function rd(t, e, i) {
        const r = [{ fixed: -1, stretch: 0 }];
        for (const [n, o] of t) {
          const t = r[r.length - 1];
          r.push({ fixed: n - t.stretch, stretch: t.stretch }),
            r.push({ fixed: n - t.stretch, stretch: t.stretch + (o - n) });
        }
        return r.push({ fixed: e + 1, stretch: i }), r;
      }
      function nd(t, e, i, r) {
        return (t / e) * i + r;
      }
      function od(t, e, i, r) {
        return t - (e * i) / r;
      }
      co('Anchor', Wu);
      class ad {
        constructor(t, e, r, n, o, a, s, l, c, h) {
          var u;
          if (((this.boxStartIndex = t.length), c)) {
            let t = a.top,
              e = a.bottom;
            const i = a.collisionPadding;
            i && ((t -= i[1]), (e += i[3]));
            let r = e - t;
            r > 0 && ((r = Math.max(10, r)), (this.circleDiameter = r));
          } else {
            const c =
              (null === (u = a.image) || void 0 === u ? void 0 : u.content) &&
              (a.image.textFitWidth || a.image.textFitHeight)
                ? Qh(a)
                : { x1: a.left, y1: a.top, x2: a.right, y2: a.bottom };
            (c.y1 = c.y1 * s - l[0]),
              (c.y2 = c.y2 * s + l[2]),
              (c.x1 = c.x1 * s - l[3]),
              (c.x2 = c.x2 * s + l[1]);
            const d = a.collisionPadding;
            if (
              (d &&
                ((c.x1 -= d[0] * s),
                (c.y1 -= d[1] * s),
                (c.x2 += d[2] * s),
                (c.y2 += d[3] * s)),
              h)
            ) {
              const t = new i(c.x1, c.y1),
                e = new i(c.x2, c.y1),
                r = new i(c.x1, c.y2),
                n = new i(c.x2, c.y2),
                o = (h * Math.PI) / 180;
              t._rotate(o),
                e._rotate(o),
                r._rotate(o),
                n._rotate(o),
                (c.x1 = Math.min(t.x, e.x, r.x, n.x)),
                (c.x2 = Math.max(t.x, e.x, r.x, n.x)),
                (c.y1 = Math.min(t.y, e.y, r.y, n.y)),
                (c.y2 = Math.max(t.y, e.y, r.y, n.y));
            }
            t.emplaceBack(e.x, e.y, c.x1, c.y1, c.x2, c.y2, r, n, o);
          }
          this.boxEndIndex = t.length;
        }
      }
      class sd {
        constructor(t = [], e = (t, e) => (t < e ? -1 : t > e ? 1 : 0)) {
          if (
            ((this.data = t),
            (this.length = this.data.length),
            (this.compare = e),
            this.length > 0)
          )
            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
        }
        push(t) {
          this.data.push(t), this._up(this.length++);
        }
        pop() {
          if (0 === this.length) return;
          const t = this.data[0],
            e = this.data.pop();
          return --this.length > 0 && ((this.data[0] = e), this._down(0)), t;
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: e, compare: i } = this,
            r = e[t];
          for (; t > 0; ) {
            const n = (t - 1) >> 1,
              o = e[n];
            if (i(r, o) >= 0) break;
            (e[t] = o), (t = n);
          }
          e[t] = r;
        }
        _down(t) {
          const { data: e, compare: i } = this,
            r = this.length >> 1,
            n = e[t];
          for (; t < r; ) {
            let r = 1 + (t << 1);
            const o = r + 1;
            if (
              (o < this.length && i(e[o], e[r]) < 0 && (r = o), i(e[r], n) >= 0)
            )
              break;
            (e[t] = e[r]), (t = r);
          }
          e[t] = n;
        }
      }
      function ld(t, e = 1, r = !1) {
        const n = Nu.fromPoints(t[0]),
          o = Math.min(n.width(), n.height());
        let a = o / 2;
        const s = new sd([], cd),
          { minX: l, minY: c, maxX: h, maxY: u } = n;
        if (0 === o) return new i(l, c);
        for (let i = l; i < h; i += o)
          for (let e = c; e < u; e += o) s.push(new hd(i + a, e + a, a, t));
        let d = (function (t) {
            let e = 0,
              i = 0,
              r = 0;
            const n = t[0];
            for (let o = 0, a = n.length, s = a - 1; o < a; s = o++) {
              const t = n[o],
                a = n[s],
                l = t.x * a.y - a.x * t.y;
              (i += (t.x + a.x) * l), (r += (t.y + a.y) * l), (e += 3 * l);
            }
            return new hd(i / e, r / e, 0, t);
          })(t),
          p = s.length;
        for (; s.length; ) {
          const i = s.pop();
          (i.d > d.d || !d.d) &&
            ((d = i),
            r &&
              console.log(
                'found best %d after %d probes',
                Math.round(1e4 * i.d) / 1e4,
                p
              )),
            i.max - d.d <= e ||
              ((a = i.h / 2),
              s.push(new hd(i.p.x - a, i.p.y - a, a, t)),
              s.push(new hd(i.p.x + a, i.p.y - a, a, t)),
              s.push(new hd(i.p.x - a, i.p.y + a, a, t)),
              s.push(new hd(i.p.x + a, i.p.y + a, a, t)),
              (p += 4));
        }
        return (
          r &&
            (console.log(`num probes: ${p}`),
            console.log(`best distance: ${d.d}`)),
          d.p
        );
      }
      function cd(t, e) {
        return e.max - t.max;
      }
      function hd(t, e, r, n) {
        (this.p = new i(t, e)),
          (this.h = r),
          (this.d = (function (t, e) {
            let i = !1,
              r = 1 / 0;
            for (let n = 0; n < e.length; n++) {
              const o = e[n];
              for (let e = 0, n = o.length, a = n - 1; e < n; a = e++) {
                const n = o[e],
                  s = o[a];
                n.y > t.y != s.y > t.y &&
                  t.x < ((s.x - n.x) * (t.y - n.y)) / (s.y - n.y) + n.x &&
                  (i = !i),
                  (r = Math.min(r, Hs(t, n, s)));
              }
            }
            return (i ? 1 : -1) * Math.sqrt(r);
          })(this.p, n)),
          (this.max = this.d + this.h * Math.SQRT2);
      }
      var ud;
      (t.aI = void 0),
        ((ud = t.aI || (t.aI = {}))[(ud.center = 1)] = 'center'),
        (ud[(ud.left = 2)] = 'left'),
        (ud[(ud.right = 3)] = 'right'),
        (ud[(ud.top = 4)] = 'top'),
        (ud[(ud.bottom = 5)] = 'bottom'),
        (ud[(ud['top-left'] = 6)] = 'top-left'),
        (ud[(ud['top-right'] = 7)] = 'top-right'),
        (ud[(ud['bottom-left'] = 8)] = 'bottom-left'),
        (ud[(ud['bottom-right'] = 9)] = 'bottom-right');
      const dd = Number.POSITIVE_INFINITY;
      function pd(t, e) {
        return e[1] !== dd
          ? (function (t, e, i) {
              let r = 0,
                n = 0;
              switch (((e = Math.abs(e)), (i = Math.abs(i)), t)) {
                case 'top-right':
                case 'top-left':
                case 'top':
                  n = i - 7;
                  break;
                case 'bottom-right':
                case 'bottom-left':
                case 'bottom':
                  n = 7 - i;
              }
              switch (t) {
                case 'top-right':
                case 'bottom-right':
                case 'right':
                  r = -e;
                  break;
                case 'top-left':
                case 'bottom-left':
                case 'left':
                  r = e;
              }
              return [r, n];
            })(t, e[0], e[1])
          : (function (t, e) {
              let i = 0,
                r = 0;
              e < 0 && (e = 0);
              const n = e / Math.SQRT2;
              switch (t) {
                case 'top-right':
                case 'top-left':
                  r = n - 7;
                  break;
                case 'bottom-right':
                case 'bottom-left':
                  r = 7 - n;
                  break;
                case 'bottom':
                  r = 7 - e;
                  break;
                case 'top':
                  r = e - 7;
              }
              switch (t) {
                case 'top-right':
                case 'bottom-right':
                  i = -n;
                  break;
                case 'top-left':
                case 'bottom-left':
                  i = n;
                  break;
                case 'left':
                  i = e;
                  break;
                case 'right':
                  i = -e;
              }
              return [i, r];
            })(t, e[0]);
      }
      function fd(t, e, i) {
        var r;
        const n = t.layout,
          o =
            null === (r = n.get('text-variable-anchor-offset')) || void 0 === r
              ? void 0
              : r.evaluate(e, {}, i);
        if (o) {
          const t = o.values,
            e = [];
          for (let i = 0; i < t.length; i += 2) {
            const r = (e[i] = t[i]),
              n = t[i + 1].map((t) => t * hh);
            r.startsWith('top')
              ? (n[1] -= 7)
              : r.startsWith('bottom') && (n[1] += 7),
              (e[i + 1] = n);
          }
          return new Be(e);
        }
        const a = n.get('text-variable-anchor');
        if (a) {
          let r;
          r =
            void 0 !== t._unevaluatedLayout.getValue('text-radial-offset')
              ? [n.get('text-radial-offset').evaluate(e, {}, i) * hh, dd]
              : n
                  .get('text-offset')
                  .evaluate(e, {}, i)
                  .map((t) => t * hh);
          const o = [];
          for (const t of a) o.push(t, pd(t, r));
          return new Be(o);
        }
        return null;
      }
      function md(t) {
        switch (t) {
          case 'right':
          case 'top-right':
          case 'bottom-right':
            return 'right';
          case 'left':
          case 'top-left':
          case 'bottom-left':
            return 'left';
        }
        return 'center';
      }
      function _d(e, i, r, n, o, a, s, l, c, h, u, d) {
        let p = a.textMaxSize.evaluate(i, {});
        void 0 === p && (p = s);
        const f = e.layers[0].layout,
          m = f.get('icon-offset').evaluate(i, {}, u),
          _ = yd(r.horizontal),
          g = s / 24,
          y = e.tilePixelRatio * g,
          x = (e.tilePixelRatio * p) / 24,
          v = e.tilePixelRatio * l,
          b = e.tilePixelRatio * f.get('symbol-spacing'),
          w = f.get('text-padding') * e.tilePixelRatio,
          T = (function (t, e, i, r = 1) {
            const n = t.get('icon-padding').evaluate(e, {}, i),
              o = n && n.values;
            return [o[0] * r, o[1] * r, o[2] * r, o[3] * r];
          })(f, i, u, e.tilePixelRatio),
          P = (f.get('text-max-angle') / 180) * Math.PI,
          S =
            'viewport' !== f.get('text-rotation-alignment') &&
            'point' !== f.get('symbol-placement'),
          M =
            'map' === f.get('icon-rotation-alignment') &&
            'point' !== f.get('symbol-placement'),
          I = f.get('symbol-placement'),
          C = b / 2,
          E = f.get('icon-text-fit');
        let z;
        n &&
          'none' !== E &&
          (e.allowVerticalPlacement &&
            r.vertical &&
            (z = tu(n, r.vertical, E, f.get('icon-text-fit-padding'), m, g)),
          _ && (n = tu(n, _, E, f.get('icon-text-fit-padding'), m, g)));
        const k = u ? d.line.getGranularityForZoomLevel(u.z) : 1,
          D = (l, d) => {
            d.x < 0 ||
              d.x >= A ||
              d.y < 0 ||
              d.y >= A ||
              (function (
                e,
                i,
                r,
                n,
                o,
                a,
                s,
                l,
                c,
                h,
                u,
                d,
                p,
                f,
                m,
                _,
                g,
                y,
                x,
                v,
                b,
                w,
                T,
                P,
                S
              ) {
                const M = e.addToLineVertexArray(i, r);
                let I,
                  C,
                  A,
                  E,
                  z = 0,
                  k = 0,
                  D = 0,
                  R = 0,
                  L = -1,
                  F = -1;
                const B = {};
                let O = ps('');
                if (e.allowVerticalPlacement && n.vertical) {
                  const t = l.layout.get('text-rotate').evaluate(b, {}, P) + 90;
                  (A = new ad(c, i, h, u, d, n.vertical, p, f, m, t)),
                    s && (E = new ad(c, i, h, u, d, s, g, y, m, t));
                }
                if (o) {
                  const r = l.layout.get('icon-rotate').evaluate(b, {}),
                    n = 'none' !== l.layout.get('icon-text-fit'),
                    a = ed(o, r, T, n),
                    p = s ? ed(s, r, T, n) : void 0;
                  (C = new ad(c, i, h, u, d, o, g, y, !1, r)),
                    (z = 4 * a.length);
                  const f = e.iconSizeData;
                  let m = null;
                  'source' === f.kind
                    ? ((m = [eu * l.layout.get('icon-size').evaluate(b, {})]),
                      m[0] > iu &&
                        Z(
                          `${e.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                        ))
                    : 'composite' === f.kind &&
                      ((m = [
                        eu * w.compositeIconSizes[0].evaluate(b, {}, P),
                        eu * w.compositeIconSizes[1].evaluate(b, {}, P),
                      ]),
                      (m[0] > iu || m[1] > iu) &&
                        Z(
                          `${e.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                        )),
                    e.addSymbols(
                      e.icon,
                      a,
                      m,
                      v,
                      x,
                      b,
                      t.as.none,
                      i,
                      M.lineStartIndex,
                      M.lineLength,
                      -1,
                      P
                    ),
                    (L = e.icon.placedSymbolArray.length - 1),
                    p &&
                      ((k = 4 * p.length),
                      e.addSymbols(
                        e.icon,
                        p,
                        m,
                        v,
                        x,
                        b,
                        t.as.vertical,
                        i,
                        M.lineStartIndex,
                        M.lineLength,
                        -1,
                        P
                      ),
                      (F = e.icon.placedSymbolArray.length - 1));
                }
                const j = Object.keys(n.horizontal);
                for (const Z of j) {
                  const r = n.horizontal[Z];
                  if (!I) {
                    O = ps(r.text);
                    const t = l.layout.get('text-rotate').evaluate(b, {}, P);
                    I = new ad(c, i, h, u, d, r, p, f, m, t);
                  }
                  const o = 1 === r.positionedLines.length;
                  if (
                    ((D += gd(
                      e,
                      i,
                      r,
                      a,
                      l,
                      m,
                      b,
                      _,
                      M,
                      n.vertical ? t.as.horizontal : t.as.horizontalOnly,
                      o ? j : [Z],
                      B,
                      L,
                      w,
                      P
                    )),
                    o)
                  )
                    break;
                }
                n.vertical &&
                  (R += gd(
                    e,
                    i,
                    n.vertical,
                    a,
                    l,
                    m,
                    b,
                    _,
                    M,
                    t.as.vertical,
                    ['vertical'],
                    B,
                    F,
                    w,
                    P
                  ));
                const N = I ? I.boxStartIndex : e.collisionBoxArray.length,
                  V = I ? I.boxEndIndex : e.collisionBoxArray.length,
                  U = A ? A.boxStartIndex : e.collisionBoxArray.length,
                  G = A ? A.boxEndIndex : e.collisionBoxArray.length,
                  $ = C ? C.boxStartIndex : e.collisionBoxArray.length,
                  q = C ? C.boxEndIndex : e.collisionBoxArray.length,
                  W = E ? E.boxStartIndex : e.collisionBoxArray.length,
                  Y = E ? E.boxEndIndex : e.collisionBoxArray.length;
                let H = -1;
                const X = (t, e) =>
                  t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;
                (H = X(I, H)), (H = X(A, H)), (H = X(C, H)), (H = X(E, H));
                const K = H > -1 ? 1 : 0;
                K && (H *= S / hh),
                  e.glyphOffsetArray.length >= uu.MAX_GLYPHS &&
                    Z(
                      'Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907'
                    ),
                  void 0 !== b.sortKey &&
                    e.addToSortKeyRanges(e.symbolInstances.length, b.sortKey);
                const J = fd(l, b, P),
                  [Q, tt] = (function (e, i) {
                    const r = e.length,
                      n = null == i ? void 0 : i.values;
                    if ((null == n ? void 0 : n.length) > 0)
                      for (let o = 0; o < n.length; o += 2) {
                        const i = n[o + 1];
                        e.emplaceBack(t.aI[n[o]], i[0], i[1]);
                      }
                    return [r, e.length];
                  })(e.textAnchorOffsets, J);
                e.symbolInstances.emplaceBack(
                  i.x,
                  i.y,
                  B.right >= 0 ? B.right : -1,
                  B.center >= 0 ? B.center : -1,
                  B.left >= 0 ? B.left : -1,
                  B.vertical || -1,
                  L,
                  F,
                  O,
                  N,
                  V,
                  U,
                  G,
                  $,
                  q,
                  W,
                  Y,
                  h,
                  D,
                  R,
                  z,
                  k,
                  K,
                  0,
                  p,
                  H,
                  Q,
                  tt
                );
              })(
                e,
                d,
                l,
                r,
                n,
                o,
                z,
                e.layers[0],
                e.collisionBoxArray,
                i.index,
                i.sourceLayerIndex,
                e.index,
                y,
                [w, w, w, w],
                S,
                c,
                v,
                T,
                M,
                m,
                i,
                a,
                h,
                u,
                s
              );
          };
        if ('line' === I)
          for (const t of qu(i.geometry, 0, 0, A, A)) {
            const i = pc(t, k),
              o = Qu(i, b, P, r.vertical || _, n, 24, x, e.overscaling, A);
            for (const t of o) (_ && xd(e, _.text, C, t)) || D(i, t);
          }
        else if ('line-center' === I) {
          for (const t of i.geometry)
            if (t.length > 1) {
              const e = pc(t, k),
                i = Ju(e, P, r.vertical || _, n, 24, x);
              i && D(e, i);
            }
        } else if ('Polygon' === i.type)
          for (const t of tr(i.geometry, 0)) {
            const e = ld(t, 16);
            D(pc(t[0], k, !0), new Wu(e.x, e.y, 0));
          }
        else if ('LineString' === i.type)
          for (const t of i.geometry) {
            const e = pc(t, k);
            D(e, new Wu(e[0].x, e[0].y, 0));
          }
        else if ('Point' === i.type)
          for (const t of i.geometry)
            for (const e of t) D([e], new Wu(e.x, e.y, 0));
      }
      function gd(t, e, r, n, o, a, s, l, c, h, u, d, p, f, m) {
        const _ = (function (t, e, r, n, o, a, s, l) {
            const c =
                (n.layout.get('text-rotate').evaluate(a, {}) * Math.PI) / 180,
              h = [];
            for (const u of e.positionedLines)
              for (const t of u.positionedGlyphs) {
                if (!t.rect) continue;
                const n = t.rect || {};
                let a = 4,
                  d = !0,
                  p = 1,
                  f = 0;
                const m = (o || l) && t.vertical,
                  _ = (t.metrics.advance * t.scale) / 2;
                if (
                  (l &&
                    e.verticalizable &&
                    (f =
                      u.lineOffset / 2 -
                      (t.imageName
                        ? -(hh - t.metrics.width * t.scale) / 2
                        : (t.scale - 1) * hh)),
                  t.imageName)
                ) {
                  const e = s[t.imageName];
                  (d = e.sdf), (p = e.pixelRatio), (a = 1 / p);
                }
                const g = o ? [t.x + _, t.y] : [0, 0];
                let y = o ? [0, 0] : [t.x + _ + r[0], t.y + r[1] - f],
                  x = [0, 0];
                m && ((x = y), (y = [0, 0]));
                const v = t.metrics.isDoubleResolution ? 2 : 1,
                  b = (t.metrics.left - a) * t.scale - _ + y[0],
                  w = (-t.metrics.top - a) * t.scale + y[1],
                  T = b + ((n.w / v) * t.scale) / p,
                  P = w + ((n.h / v) * t.scale) / p,
                  S = new i(b, w),
                  M = new i(T, w),
                  I = new i(b, P),
                  C = new i(T, P);
                if (m) {
                  const e = new i(-_, _ - -17),
                    r = -Math.PI / 2,
                    n = 12 - _,
                    o = new i(22 - n, -(t.imageName ? n : 0)),
                    a = new i(...x);
                  S._rotateAround(r, e)._add(o)._add(a),
                    M._rotateAround(r, e)._add(o)._add(a),
                    I._rotateAround(r, e)._add(o)._add(a),
                    C._rotateAround(r, e)._add(o)._add(a);
                }
                if (c) {
                  const t = Math.sin(c),
                    e = Math.cos(c),
                    i = [e, -t, t, e];
                  S._matMult(i), M._matMult(i), I._matMult(i), C._matMult(i);
                }
                const A = new i(0, 0),
                  E = new i(0, 0);
                h.push({
                  tl: S,
                  tr: M,
                  bl: I,
                  br: C,
                  tex: n,
                  writingMode: e.writingMode,
                  glyphOffset: g,
                  sectionIndex: t.sectionIndex,
                  isSDF: d,
                  pixelOffsetTL: A,
                  pixelOffsetBR: E,
                  minFontScaleX: 0,
                  minFontScaleY: 0,
                });
              }
            return h;
          })(0, r, l, o, a, s, n, t.allowVerticalPlacement),
          g = t.textSizeData;
        let y = null;
        'source' === g.kind
          ? ((y = [eu * o.layout.get('text-size').evaluate(s, {})]),
            y[0] > iu &&
              Z(
                `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
              ))
          : 'composite' === g.kind &&
            ((y = [
              eu * f.compositeTextSizes[0].evaluate(s, {}, m),
              eu * f.compositeTextSizes[1].evaluate(s, {}, m),
            ]),
            (y[0] > iu || y[1] > iu) &&
              Z(
                `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
              )),
          t.addSymbols(
            t.text,
            _,
            y,
            l,
            a,
            s,
            h,
            e,
            c.lineStartIndex,
            c.lineLength,
            p,
            m
          );
        for (const i of u) d[i] = t.text.placedSymbolArray.length - 1;
        return 4 * _.length;
      }
      function yd(t) {
        for (const e in t) return t[e];
        return null;
      }
      function xd(t, e, i, r) {
        const n = t.compareText;
        if (e in n) {
          const t = n[e];
          for (let e = t.length - 1; e >= 0; e--)
            if (r.dist(t[e]) < i) return !0;
        } else n[e] = [];
        return n[e].push(r), !1;
      }
      const vd = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
      class bd {
        static from(t) {
          if (!(t instanceof ArrayBuffer))
            throw new Error('Data must be an instance of ArrayBuffer.');
          const [e, i] = new Uint8Array(t, 0, 2);
          if (219 !== e)
            throw new Error('Data does not appear to be in a KDBush format.');
          const r = i >> 4;
          if (1 !== r) throw new Error(`Got v${r} data when expected v1.`);
          const n = vd[15 & i];
          if (!n) throw new Error('Unrecognized array type.');
          const [o] = new Uint16Array(t, 2, 1),
            [a] = new Uint32Array(t, 4, 1);
          return new bd(a, o, n, t);
        }
        constructor(t, e = 64, i = Float64Array, r) {
          if (isNaN(t) || t < 0)
            throw new Error(`Unpexpected numItems value: ${t}.`);
          (this.numItems = +t),
            (this.nodeSize = Math.min(Math.max(+e, 2), 65535)),
            (this.ArrayType = i),
            (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array);
          const n = vd.indexOf(this.ArrayType),
            o = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
            a = t * this.IndexArrayType.BYTES_PER_ELEMENT,
            s = (8 - (a % 8)) % 8;
          if (n < 0) throw new Error(`Unexpected typed array class: ${i}.`);
          r && r instanceof ArrayBuffer
            ? ((this.data = r),
              (this.ids = new this.IndexArrayType(this.data, 8, t)),
              (this.coords = new this.ArrayType(this.data, 8 + a + s, 2 * t)),
              (this._pos = 2 * t),
              (this._finished = !0))
            : ((this.data = new ArrayBuffer(8 + o + a + s)),
              (this.ids = new this.IndexArrayType(this.data, 8, t)),
              (this.coords = new this.ArrayType(this.data, 8 + a + s, 2 * t)),
              (this._pos = 0),
              (this._finished = !1),
              new Uint8Array(this.data, 0, 2).set([219, 16 + n]),
              (new Uint16Array(this.data, 2, 1)[0] = e),
              (new Uint32Array(this.data, 4, 1)[0] = t));
        }
        add(t, e) {
          const i = this._pos >> 1;
          return (
            (this.ids[i] = i),
            (this.coords[this._pos++] = t),
            (this.coords[this._pos++] = e),
            i
          );
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems)
            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return (
            wd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
            (this._finished = !0),
            this
          );
        }
        range(t, e, i, r) {
          if (!this._finished)
            throw new Error('Data not yet indexed - call index.finish().');
          const { ids: n, coords: o, nodeSize: a } = this,
            s = [0, n.length - 1, 0],
            l = [];
          for (; s.length; ) {
            const c = s.pop() || 0,
              h = s.pop() || 0,
              u = s.pop() || 0;
            if (h - u <= a) {
              for (let a = u; a <= h; a++) {
                const s = o[2 * a],
                  c = o[2 * a + 1];
                s >= t && s <= i && c >= e && c <= r && l.push(n[a]);
              }
              continue;
            }
            const d = (u + h) >> 1,
              p = o[2 * d],
              f = o[2 * d + 1];
            p >= t && p <= i && f >= e && f <= r && l.push(n[d]),
              (0 === c ? t <= p : e <= f) &&
                (s.push(u), s.push(d - 1), s.push(1 - c)),
              (0 === c ? i >= p : r >= f) &&
                (s.push(d + 1), s.push(h), s.push(1 - c));
          }
          return l;
        }
        within(t, e, i) {
          if (!this._finished)
            throw new Error('Data not yet indexed - call index.finish().');
          const { ids: r, coords: n, nodeSize: o } = this,
            a = [0, r.length - 1, 0],
            s = [],
            l = i * i;
          for (; a.length; ) {
            const c = a.pop() || 0,
              h = a.pop() || 0,
              u = a.pop() || 0;
            if (h - u <= o) {
              for (let i = u; i <= h; i++)
                Md(n[2 * i], n[2 * i + 1], t, e) <= l && s.push(r[i]);
              continue;
            }
            const d = (u + h) >> 1,
              p = n[2 * d],
              f = n[2 * d + 1];
            Md(p, f, t, e) <= l && s.push(r[d]),
              (0 === c ? t - i <= p : e - i <= f) &&
                (a.push(u), a.push(d - 1), a.push(1 - c)),
              (0 === c ? t + i >= p : e + i >= f) &&
                (a.push(d + 1), a.push(h), a.push(1 - c));
          }
          return s;
        }
      }
      function wd(t, e, i, r, n, o) {
        if (n - r <= i) return;
        const a = (r + n) >> 1;
        Td(t, e, a, r, n, o),
          wd(t, e, i, r, a - 1, 1 - o),
          wd(t, e, i, a + 1, n, 1 - o);
      }
      function Td(t, e, i, r, n, o) {
        for (; n > r; ) {
          if (n - r > 600) {
            const a = n - r + 1,
              s = i - r + 1,
              l = Math.log(a),
              c = 0.5 * Math.exp((2 * l) / 3),
              h =
                0.5 *
                Math.sqrt((l * c * (a - c)) / a) *
                (s - a / 2 < 0 ? -1 : 1);
            Td(
              t,
              e,
              i,
              Math.max(r, Math.floor(i - (s * c) / a + h)),
              Math.min(n, Math.floor(i + ((a - s) * c) / a + h)),
              o
            );
          }
          const a = e[2 * i + o];
          let s = r,
            l = n;
          for (Pd(t, e, r, i), e[2 * n + o] > a && Pd(t, e, r, n); s < l; ) {
            for (Pd(t, e, s, l), s++, l--; e[2 * s + o] < a; ) s++;
            for (; e[2 * l + o] > a; ) l--;
          }
          e[2 * r + o] === a ? Pd(t, e, r, l) : (l++, Pd(t, e, l, n)),
            l <= i && (r = l + 1),
            i <= l && (n = l - 1);
        }
      }
      function Pd(t, e, i, r) {
        Sd(t, i, r), Sd(e, 2 * i, 2 * r), Sd(e, 2 * i + 1, 2 * r + 1);
      }
      function Sd(t, e, i) {
        const r = t[e];
        (t[e] = t[i]), (t[i] = r);
      }
      function Md(t, e, i, r) {
        const n = t - i,
          o = e - r;
        return n * n + o * o;
      }
      var Id;
      (t.cA = void 0),
        ((Id = t.cA || (t.cA = {})).create = 'create'),
        (Id.load = 'load'),
        (Id.fullLoad = 'fullLoad');
      let Cd = null,
        Ad = [];
      const Ed = 1e3 / 60,
        zd = 'loadTime',
        kd = 'fullLoadTime',
        Dd = {
          mark(t) {
            performance.mark(t);
          },
          frame(t) {
            const e = t;
            null != Cd && Ad.push(e - Cd), (Cd = e);
          },
          clearMetrics() {
            (Cd = null),
              (Ad = []),
              performance.clearMeasures(zd),
              performance.clearMeasures(kd);
            for (const e in t.cA) performance.clearMarks(t.cA[e]);
          },
          getPerformanceMetrics() {
            performance.measure(zd, t.cA.create, t.cA.load),
              performance.measure(kd, t.cA.create, t.cA.fullLoad);
            const e = performance.getEntriesByName(zd)[0].duration,
              i = performance.getEntriesByName(kd)[0].duration,
              r = Ad.length,
              n = 1 / (Ad.reduce((t, e) => t + e, 0) / r / 1e3),
              o = Ad.filter((t) => t > Ed).reduce(
                (t, e) => t + (e - Ed) / Ed,
                0
              );
            return {
              loadTime: e,
              fullLoadTime: i,
              fps: n,
              percentDroppedFrames: (o / (r + o)) * 100,
              totalFrames: r,
            };
          },
        };
      (t.$ = K),
        (t.A = p),
        (t.B = eo),
        (t.C = function ([t, e, i]) {
          return (
            (e += 90),
            (e *= Math.PI / 180),
            (i *= Math.PI / 180),
            {
              x: t * Math.cos(e) * Math.sin(i),
              y: t * Math.sin(e) * Math.sin(i),
              z: t * Math.cos(i),
            }
          );
        }),
        (t.D = Vo),
        (t.E = yt),
        (t.F = mi),
        (t.G = zo),
        (t.H = ro),
        (t.I = Eh),
        (t.J = Y),
        (t.K = class {
          constructor(t, e) {
            (this.target = t),
              (this.mapId = e),
              (this.resolveRejects = {}),
              (this.tasks = {}),
              (this.taskQueue = []),
              (this.abortControllers = {}),
              (this.messageHandlers = {}),
              (this.invoker = new bu(() => this.process())),
              (this.subscription = tt(
                this.target,
                'message',
                (t) => this.receive(t),
                !1
              )),
              (this.globalScope = q(self) ? t : window);
          }
          registerMessageHandler(t, e) {
            this.messageHandlers[t] = e;
          }
          sendAsync(t, e) {
            return new Promise((i, r) => {
              const n = Math.round(1e18 * Math.random())
                  .toString(36)
                  .substring(0, 10),
                o = e
                  ? tt(
                      e.signal,
                      'abort',
                      () => {
                        null == o || o.unsubscribe(),
                          delete this.resolveRejects[n];
                        const e = {
                          id: n,
                          type: '<cancel>',
                          origin: location.origin,
                          targetMapId: t.targetMapId,
                          sourceMapId: this.mapId,
                        };
                        this.target.postMessage(e);
                      },
                      wu
                    )
                  : null;
              this.resolveRejects[n] = {
                resolve: (t) => {
                  null == o || o.unsubscribe(), i(t);
                },
                reject: (t) => {
                  null == o || o.unsubscribe(), r(t);
                },
              };
              const a = [],
                s = Object.assign(Object.assign({}, t), {
                  id: n,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: fo(t.data, a),
                });
              this.target.postMessage(s, { transfer: a });
            });
          }
          receive(t) {
            const e = t.data,
              i = e.id;
            if (
              !(
                ('file://' !== e.origin &&
                  'file://' !== location.origin &&
                  'resource://android' !== e.origin &&
                  'resource://android' !== location.origin &&
                  e.origin !== location.origin) ||
                (e.targetMapId && this.mapId !== e.targetMapId)
              )
            ) {
              if ('<cancel>' === e.type) {
                delete this.tasks[i];
                const t = this.abortControllers[i];
                return delete this.abortControllers[i], void (t && t.abort());
              }
              if (q(self) || e.mustQueue)
                return (
                  (this.tasks[i] = e),
                  this.taskQueue.push(i),
                  void this.invoker.trigger()
                );
              this.processTask(i, e);
            }
          }
          process() {
            if (0 === this.taskQueue.length) return;
            const t = this.taskQueue.shift(),
              e = this.tasks[t];
            delete this.tasks[t],
              this.taskQueue.length > 0 && this.invoker.trigger(),
              e && this.processTask(t, e);
          }
          processTask(t, i) {
            return e(this, void 0, void 0, function* () {
              if ('<response>' === i.type) {
                const e = this.resolveRejects[t];
                if ((delete this.resolveRejects[t], !e)) return;
                return void (i.error
                  ? e.reject(mo(i.error))
                  : e.resolve(mo(i.data)));
              }
              if (!this.messageHandlers[i.type])
                return void this.completeTask(
                  t,
                  new Error(
                    `Could not find a registered handler for ${
                      i.type
                    }, map ID: ${this.mapId}, available handlers: ${Object.keys(
                      this.messageHandlers
                    ).join(', ')}`
                  )
                );
              const e = mo(i.data),
                r = new AbortController();
              this.abortControllers[t] = r;
              try {
                const n = yield this.messageHandlers[i.type](
                  i.sourceMapId,
                  e,
                  r
                );
                this.completeTask(t, null, n);
              } catch (e) {
                this.completeTask(t, e);
              }
            });
          }
          completeTask(t, e, i) {
            const r = [];
            delete this.abortControllers[t];
            const n = {
              id: t,
              type: '<response>',
              sourceMapId: this.mapId,
              origin: location.origin,
              error: e ? fo(e) : null,
              data: fo(i, r),
            };
            this.target.postMessage(n, { transfer: r });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }),
        (t.L = ct),
        (t.M = function () {
          var t = new p(16);
          return (
            p != Float32Array &&
              ((t[1] = 0),
              (t[2] = 0),
              (t[3] = 0),
              (t[4] = 0),
              (t[6] = 0),
              (t[7] = 0),
              (t[8] = 0),
              (t[9] = 0),
              (t[11] = 0),
              (t[12] = 0),
              (t[13] = 0),
              (t[14] = 0)),
            (t[0] = 1),
            (t[5] = 1),
            (t[10] = 1),
            (t[15] = 1),
            t
          );
        }),
        (t.N = function (t, e, i) {
          var r,
            n,
            o,
            a,
            s,
            l,
            c,
            h,
            u,
            d,
            p,
            f,
            m = i[0],
            _ = i[1],
            g = i[2];
          return (
            e === t
              ? ((t[12] = e[0] * m + e[4] * _ + e[8] * g + e[12]),
                (t[13] = e[1] * m + e[5] * _ + e[9] * g + e[13]),
                (t[14] = e[2] * m + e[6] * _ + e[10] * g + e[14]),
                (t[15] = e[3] * m + e[7] * _ + e[11] * g + e[15]))
              : ((n = e[1]),
                (o = e[2]),
                (a = e[3]),
                (s = e[4]),
                (l = e[5]),
                (c = e[6]),
                (h = e[7]),
                (u = e[8]),
                (d = e[9]),
                (p = e[10]),
                (f = e[11]),
                (t[0] = r = e[0]),
                (t[1] = n),
                (t[2] = o),
                (t[3] = a),
                (t[4] = s),
                (t[5] = l),
                (t[6] = c),
                (t[7] = h),
                (t[8] = u),
                (t[9] = d),
                (t[10] = p),
                (t[11] = f),
                (t[12] = r * m + s * _ + u * g + e[12]),
                (t[13] = n * m + l * _ + d * g + e[13]),
                (t[14] = o * m + c * _ + p * g + e[14]),
                (t[15] = a * m + h * _ + f * g + e[15])),
            t
          );
        }),
        (t.O = function (t, e, i) {
          var r = i[0],
            n = i[1],
            o = i[2];
          return (
            (t[0] = e[0] * r),
            (t[1] = e[1] * r),
            (t[2] = e[2] * r),
            (t[3] = e[3] * r),
            (t[4] = e[4] * n),
            (t[5] = e[5] * n),
            (t[6] = e[6] * n),
            (t[7] = e[7] * n),
            (t[8] = e[8] * o),
            (t[9] = e[9] * o),
            (t[10] = e[10] * o),
            (t[11] = e[11] * o),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15]),
            t
          );
        }),
        (t.P = i),
        (t.Q = function (t, e, i) {
          var r = e[0],
            n = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            l = e[5],
            c = e[6],
            h = e[7],
            u = e[8],
            d = e[9],
            p = e[10],
            f = e[11],
            m = e[12],
            _ = e[13],
            g = e[14],
            y = e[15],
            x = i[0],
            v = i[1],
            b = i[2],
            w = i[3];
          return (
            (t[0] = x * r + v * s + b * u + w * m),
            (t[1] = x * n + v * l + b * d + w * _),
            (t[2] = x * o + v * c + b * p + w * g),
            (t[3] = x * a + v * h + b * f + w * y),
            (t[4] =
              (x = i[4]) * r +
              (v = i[5]) * s +
              (b = i[6]) * u +
              (w = i[7]) * m),
            (t[5] = x * n + v * l + b * d + w * _),
            (t[6] = x * o + v * c + b * p + w * g),
            (t[7] = x * a + v * h + b * f + w * y),
            (t[8] =
              (x = i[8]) * r +
              (v = i[9]) * s +
              (b = i[10]) * u +
              (w = i[11]) * m),
            (t[9] = x * n + v * l + b * d + w * _),
            (t[10] = x * o + v * c + b * p + w * g),
            (t[11] = x * a + v * h + b * f + w * y),
            (t[12] =
              (x = i[12]) * r +
              (v = i[13]) * s +
              (b = i[14]) * u +
              (w = i[15]) * m),
            (t[13] = x * n + v * l + b * d + w * _),
            (t[14] = x * o + v * c + b * p + w * g),
            (t[15] = x * a + v * h + b * f + w * y),
            t
          );
        }),
        (t.R = xl),
        (t.S = function (t, e) {
          const i = {};
          for (let r = 0; r < e.length; r++) {
            const n = e[r];
            n in t && (i[n] = t[n]);
          }
          return i;
        }),
        (t.T = Cl),
        (t.U = Pu),
        (t.V = B),
        (t.W = Cu),
        (t.X = Iu),
        (t.Y = h),
        (t.Z = u),
        (t._ = e),
        (t.a = st),
        (t.a$ = function (t, e, i) {
          return (
            (t[0] = e[0] * i[0]),
            (t[1] = e[1] * i[1]),
            (t[2] = e[2] * i[2]),
            (t[3] = e[3] * i[3]),
            t
          );
        }),
        (t.a0 = Bu),
        (t.a1 = Eu),
        (t.a2 = zu),
        (t.a3 = A),
        (t.a4 = function (t, e) {
          var i, r, n, o, a;
          if (!t) return null != e ? e : {};
          if (!e) return t;
          let s = Object.assign({}, t);
          if ((e.removeAll && (s = { removeAll: !0 }), e.remove)) {
            const r = new Set(e.remove);
            s.add && (s.add = s.add.filter((t) => !r.has(t.id))),
              s.update && (s.update = s.update.filter((t) => !r.has(t.id)));
            const n = new Set(
              (null !== (i = t.add) && void 0 !== i ? i : []).map((t) => t.id)
            );
            e.remove = e.remove.filter((t) => !n.has(t));
          }
          if (e.remove) {
            const t = new Set(s.remove ? s.remove.concat(e.remove) : e.remove);
            s.remove = Array.from(t.values());
          }
          if (e.add) {
            const t = s.add ? s.add.concat(e.add) : e.add,
              i = new Map(t.map((t) => [t.id, t]));
            s.add = Array.from(i.values());
          }
          if (e.update) {
            const t = new Map(
              null === (r = s.update) || void 0 === r
                ? void 0
                : r.map((t) => [t.id, t])
            );
            for (const i of e.update) {
              const e =
                null !== (n = t.get(i.id)) && void 0 !== n ? n : { id: i.id };
              i.newGeometry && (e.newGeometry = i.newGeometry),
                i.addOrUpdateProperties &&
                  (e.addOrUpdateProperties = (
                    null !== (o = e.addOrUpdateProperties) && void 0 !== o
                      ? o
                      : []
                  ).concat(i.addOrUpdateProperties)),
                i.removeProperties &&
                  (e.removeProperties = (
                    null !== (a = e.removeProperties) && void 0 !== a ? a : []
                  ).concat(i.removeProperties)),
                i.removeAllProperties && (e.removeAllProperties = !0),
                t.set(i.id, e);
            }
            s.update = Array.from(t.values());
          }
          return (
            s.remove &&
              s.add &&
              (s.remove = s.remove.filter(
                (t) => -1 === s.add.findIndex((e) => e.id === t)
              )),
            s
          );
        }),
        (t.a5 = Du),
        (t.a6 = Nu),
        (t.a7 = 25),
        (t.a8 = Lu),
        (t.a9 = (t) => {
          const e = window.document.createElement('video');
          return (
            (e.muted = !0),
            new Promise((i) => {
              e.onloadstart = () => {
                i(e);
              };
              for (const r of t) {
                const t = window.document.createElement('source');
                pt(r) || (e.crossOrigin = 'Anonymous'),
                  (t.src = r),
                  e.appendChild(t);
              }
            })
          );
        }),
        (t.aA = P),
        (t.aB = function (t, e, r, n) {
          const o = e.y - t.y,
            a = e.x - t.x,
            s = n.y - r.y,
            l = n.x - r.x,
            c = s * a - l * o;
          if (0 === c) return null;
          const h = (l * (t.y - r.y) - s * (t.x - r.x)) / c;
          return new i(t.x + h * a, t.y + h * o);
        }),
        (t.aC = qu),
        (t.aD = Us),
        (t.aE = function (t) {
          let e = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            n = -1 / 0;
          for (const o of t)
            (e = Math.min(e, o.x)),
              (i = Math.min(i, o.y)),
              (r = Math.max(r, o.x)),
              (n = Math.max(n, o.y));
          return [e, i, r, n];
        }),
        (t.aF = hh),
        (t.aG = E),
        (t.aH = function (t, e, i, r, n = !1) {
          if (!i[0] && !i[1]) return [0, 0];
          const o = n
            ? 'map' === r
              ? -t.bearingInRadians
              : 0
            : 'viewport' === r
            ? t.bearingInRadians
            : 0;
          if (o) {
            const t = Math.sin(o),
              e = Math.cos(o);
            i = [i[0] * e - i[1] * t, i[0] * t + i[1] * e];
          }
          return [n ? i[0] : E(e, i[0], t.zoom), n ? i[1] : E(e, i[1], t.zoom)];
        }),
        (t.aJ = nu),
        (t.aK = md),
        (t.aL = $h),
        (t.aM = bd),
        (t.aN = ea),
        (t.aO = lc),
        (t.aP = ja),
        (t.aQ = is),
        (t.aR = Ja),
        (t.aS = it),
        (t.aT = ku),
        (t.aU = v),
        (t.aV = x),
        (t.aW = function (t) {
          var e = new p(3);
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
        }),
        (t.aX = function (t, e, i) {
          return (
            (t[0] = e[0] - i[0]), (t[1] = e[1] - i[1]), (t[2] = e[2] - i[2]), t
          );
        }),
        (t.aY = function (t, e) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = i * i + r * r + n * n;
          return (
            o > 0 && (o = 1 / Math.sqrt(o)),
            (t[0] = e[0] * o),
            (t[1] = e[1] * o),
            (t[2] = e[2] * o),
            t
          );
        }),
        (t.aZ = b),
        (t.a_ = function (t, e) {
          return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
        }),
        (t.aa = zt),
        (t.ab = function () {
          return j++;
        }),
        (t.ac = Ca),
        (t.ad = uu),
        (t.ae = pn),
        (t.af = Os),
        (t.ag = Uu),
        (t.ah = function (t) {
          const e = {};
          if (
            (t.replace(
              /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
              (t, i, r, n) => {
                const o = r || n;
                return (e[i] = !o || o.toLowerCase()), '';
              }
            ),
            e['max-age'])
          ) {
            const t = parseInt(e['max-age'], 10);
            isNaN(t) ? delete e['max-age'] : (e['max-age'] = t);
          }
          return e;
        }),
        (t.ai = F),
        (t.aj = 85.051129),
        (t.ak = et),
        (t.al = function (t) {
          return Math.pow(2, t);
        }),
        (t.am = m),
        (t.an = Au),
        (t.ao = function (t) {
          return Math.log(t) / Math.LN2;
        }),
        (t.ap = function (t) {
          var e = t[0],
            i = t[1];
          return e * e + i * i;
        }),
        (t.aq = function (t) {
          if (!t.length) return new Set();
          const e = Math.max(...t.map((t) => t.canonical.z));
          let i = 1 / 0,
            r = -1 / 0,
            n = 1 / 0,
            o = -1 / 0;
          const a = [];
          for (const l of t) {
            const { x: t, y: s, z: c } = l.canonical,
              h = Math.pow(2, e - c),
              u = t * h,
              d = s * h;
            a.push({ id: l, x: u, y: d }),
              u < i && (i = u),
              u > r && (r = u),
              d < n && (n = d),
              d > o && (o = d);
          }
          const s = new Set();
          for (const l of a)
            (l.x !== i && l.x !== r && l.y !== n && l.y !== o) || s.add(l.id);
          return s;
        }),
        (t.ar = function (t, e) {
          let i = 0,
            r = 0;
          if ('constant' === t.kind) r = t.layoutSize;
          else if ('source' !== t.kind) {
            const { interpolationType: n, minZoom: o, maxZoom: a } = t,
              s = n ? F(pi.interpolationFactor(n, e, o, a), 0, 1) : 0;
            'camera' === t.kind
              ? (r = mi.number(t.minSize, t.maxSize, s))
              : (i = s);
          }
          return { uSizeT: i, uSize: r };
        }),
        (t.at = function (
          t,
          { uSize: e, uSizeT: i },
          { lowerSize: r, upperSize: n }
        ) {
          return 'source' === t.kind
            ? r / eu
            : 'composite' === t.kind
            ? mi.number(r / eu, n / eu, i)
            : e;
        }),
        (t.au = function (t, e) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = e[9],
            d = e[10],
            p = e[11],
            f = e[12],
            m = e[13],
            _ = e[14],
            g = e[15],
            y = i * s - r * a,
            x = i * l - n * a,
            v = i * c - o * a,
            b = r * l - n * s,
            w = r * c - o * s,
            T = n * c - o * l,
            P = h * m - u * f,
            S = h * _ - d * f,
            M = h * g - p * f,
            I = u * _ - d * m,
            C = u * g - p * m,
            A = d * g - p * _,
            E = y * A - x * C + v * I + b * M - w * S + T * P;
          return E
            ? ((t[0] = (s * A - l * C + c * I) * (E = 1 / E)),
              (t[1] = (n * C - r * A - o * I) * E),
              (t[2] = (m * T - _ * w + g * b) * E),
              (t[3] = (d * w - u * T - p * b) * E),
              (t[4] = (l * M - a * A - c * S) * E),
              (t[5] = (i * A - n * M + o * S) * E),
              (t[6] = (_ * v - f * T - g * x) * E),
              (t[7] = (h * T - d * v + p * x) * E),
              (t[8] = (a * C - s * M + c * P) * E),
              (t[9] = (r * M - i * C - o * P) * E),
              (t[10] = (f * w - m * v + g * y) * E),
              (t[11] = (u * v - h * w - p * y) * E),
              (t[12] = (s * S - a * I - l * P) * E),
              (t[13] = (i * I - r * S + n * P) * E),
              (t[14] = (m * x - f * b - _ * y) * E),
              (t[15] = (h * b - u * x + d * y) * E),
              t)
            : null;
        }),
        (t.av = I),
        (t.aw = function (t) {
          var e = t[0],
            i = t[1];
          return Math.sqrt(e * e + i * i);
        }),
        (t.ax = function (t) {
          return (t[0] = 0), (t[1] = 0), t;
        }),
        (t.ay = function (t, e, i) {
          return (t[0] = e[0] * i), (t[1] = e[1] * i), t;
        }),
        (t.az = su),
        (t.b = H),
        (t.b$ = function (t, e, i) {
          var r = e[0],
            n = e[1],
            o = e[2];
          return (
            (t[0] = r * i[0] + n * i[3] + o * i[6]),
            (t[1] = r * i[1] + n * i[4] + o * i[7]),
            (t[2] = r * i[2] + n * i[5] + o * i[8]),
            t
          );
        }),
        (t.b0 = g),
        (t.b1 = function (t, e, i) {
          const r = e[0] * i[0] + e[1] * i[1] + e[2] * i[2];
          return 0 === r
            ? null
            : (-(t[0] * i[0] + t[1] * i[1] + t[2] * i[2]) - i[3]) / r;
        }),
        (t.b2 = T),
        (t.b3 = function (t, e, i) {
          return (
            (t[0] = e[0] * i),
            (t[1] = e[1] * i),
            (t[2] = e[2] * i),
            (t[3] = e[3] * i),
            t
          );
        }),
        (t.b4 = function (t, e) {
          return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3];
        }),
        (t.b5 = Fu),
        (t.b6 = Ou),
        (t.b7 = function (t, e, i, r, n) {
          var o = 1 / Math.tan(e / 2);
          if (
            ((t[0] = o / i),
            (t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[4] = 0),
            (t[5] = o),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 0),
            (t[9] = 0),
            (t[11] = -1),
            (t[12] = 0),
            (t[13] = 0),
            (t[15] = 0),
            null != n && n !== 1 / 0)
          ) {
            var a = 1 / (r - n);
            (t[10] = (n + r) * a), (t[14] = 2 * n * r * a);
          } else (t[10] = -1), (t[14] = -2 * r);
          return t;
        }),
        (t.b8 = function (t) {
          var e = new p(16);
          return (
            (e[0] = t[0]),
            (e[1] = t[1]),
            (e[2] = t[2]),
            (e[3] = t[3]),
            (e[4] = t[4]),
            (e[5] = t[5]),
            (e[6] = t[6]),
            (e[7] = t[7]),
            (e[8] = t[8]),
            (e[9] = t[9]),
            (e[10] = t[10]),
            (e[11] = t[11]),
            (e[12] = t[12]),
            (e[13] = t[13]),
            (e[14] = t[14]),
            (e[15] = t[15]),
            e
          );
        }),
        (t.b9 = function (t, e, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = e[0],
            a = e[1],
            s = e[2],
            l = e[3],
            c = e[4],
            h = e[5],
            u = e[6],
            d = e[7];
          return (
            e !== t &&
              ((t[8] = e[8]),
              (t[9] = e[9]),
              (t[10] = e[10]),
              (t[11] = e[11]),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15])),
            (t[0] = o * n + c * r),
            (t[1] = a * n + h * r),
            (t[2] = s * n + u * r),
            (t[3] = l * n + d * r),
            (t[4] = c * n - o * r),
            (t[5] = h * n - a * r),
            (t[6] = u * n - s * r),
            (t[7] = d * n - l * r),
            t
          );
        }),
        (t.bA = function (t, e, i, r) {
          var n = [],
            o = [];
          return (
            (n[0] = e[0] - i[0]),
            (n[1] = e[1] - i[1]),
            (n[2] = e[2] - i[2]),
            (o[0] = n[0]),
            (o[1] = n[1] * Math.cos(r) - n[2] * Math.sin(r)),
            (o[2] = n[1] * Math.sin(r) + n[2] * Math.cos(r)),
            (t[0] = o[0] + i[0]),
            (t[1] = o[1] + i[1]),
            (t[2] = o[2] + i[2]),
            t
          );
        }),
        (t.bB = function (t, e, i, r) {
          var n = [],
            o = [];
          return (
            (n[0] = e[0] - i[0]),
            (n[1] = e[1] - i[1]),
            (n[2] = e[2] - i[2]),
            (o[0] = n[2] * Math.sin(r) + n[0] * Math.cos(r)),
            (o[1] = n[1]),
            (o[2] = n[2] * Math.cos(r) - n[0] * Math.sin(r)),
            (t[0] = o[0] + i[0]),
            (t[1] = o[1] + i[1]),
            (t[2] = o[2] + i[2]),
            t
          );
        }),
        (t.bC = function (t, e, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = e[0],
            a = e[1],
            s = e[2],
            l = e[3],
            c = e[8],
            h = e[9],
            u = e[10],
            d = e[11];
          return (
            e !== t &&
              ((t[4] = e[4]),
              (t[5] = e[5]),
              (t[6] = e[6]),
              (t[7] = e[7]),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15])),
            (t[0] = o * n - c * r),
            (t[1] = a * n - h * r),
            (t[2] = s * n - u * r),
            (t[3] = l * n - d * r),
            (t[8] = o * r + c * n),
            (t[9] = a * r + h * n),
            (t[10] = s * r + u * n),
            (t[11] = l * r + d * n),
            t
          );
        }),
        (t.bD = function (t, e) {
          const i = z(t, 360),
            r = z(e, 360),
            n = r - i,
            o = r > i ? n - 360 : n + 360;
          return Math.abs(n) < Math.abs(o) ? n : o;
        }),
        (t.bE = function (t) {
          return (t[0] = 0), (t[1] = 0), (t[2] = 0), t;
        }),
        (t.bF = function (t, e, i, r) {
          const n = Math.sqrt(t * t + e * e),
            o = Math.sqrt(i * i + r * r);
          (t /= n), (e /= n), (i /= o), (r /= o);
          const a = Math.acos(t * i + e * r);
          return -e * i + t * r > 0 ? a : -a;
        }),
        (t.bG = function (t, e) {
          const i = z(t, 2 * Math.PI),
            r = z(e, 2 * Math.PI);
          return Math.min(
            Math.abs(i - r),
            Math.abs(i - r + 2 * Math.PI),
            Math.abs(i - r - 2 * Math.PI)
          );
        }),
        (t.bH = function () {
          const t = {},
            e = xt.$version;
          for (const i in xt.$root) {
            const r = xt.$root[i];
            if (r.required) {
              let n = null;
              (n = 'version' === i ? e : 'array' === r.type ? [] : {}),
                null != n && (t[i] = n);
            }
          }
          return t;
        }),
        (t.bI = _o),
        (t.bJ = ut),
        (t.bK = function t(e, i) {
          if (Array.isArray(e)) {
            if (!Array.isArray(i) || e.length !== i.length) return !1;
            for (let r = 0; r < e.length; r++) if (!t(e[r], i[r])) return !1;
            return !0;
          }
          if ('object' == typeof e && null !== e && null !== i) {
            if ('object' != typeof i) return !1;
            if (Object.keys(e).length !== Object.keys(i).length) return !1;
            for (const r in e) if (!t(e[r], i[r])) return !1;
            return !0;
          }
          return e === i;
        }),
        (t.bL = function (t) {
          t = t.slice();
          const e = Object.create(null);
          for (let i = 0; i < t.length; i++) e[t[i].id] = t[i];
          for (let i = 0; i < t.length; i++)
            'ref' in t[i] && (t[i] = bt(t[i], e[t[i].ref]));
          return t;
        }),
        (t.bM = function (t, e) {
          if ('custom' === t.type) return new vu(t, e);
          switch (t.type) {
            case 'background':
              return new xu(t, e);
            case 'circle':
              return new ul(t, e);
            case 'color-relief':
              return new zl(t, e);
            case 'fill':
              return new bc(t, e);
            case 'fill-extrusion':
              return new Nc(t, e);
            case 'heatmap':
              return new wl(t, e);
            case 'hillshade':
              return new Sl(t, e);
            case 'line':
              return new eh(t, e);
            case 'raster':
              return new Ko(t, e);
            case 'symbol':
              return new _u(t, e);
          }
        }),
        (t.bN = (t) => 'raster' === t.type),
        (t.bO = U),
        (t.bP = function (t, e) {
          if (!t) return [{ command: 'setStyle', args: [e] }];
          let i = [];
          try {
            if (!wt(t.version, e.version))
              return [{ command: 'setStyle', args: [e] }];
            wt(t.center, e.center) ||
              i.push({ command: 'setCenter', args: [e.center] }),
              wt(t.state, e.state) ||
                i.push({ command: 'setGlobalState', args: [e.state] }),
              wt(t.centerAltitude, e.centerAltitude) ||
                i.push({
                  command: 'setCenterAltitude',
                  args: [e.centerAltitude],
                }),
              wt(t.zoom, e.zoom) ||
                i.push({ command: 'setZoom', args: [e.zoom] }),
              wt(t.bearing, e.bearing) ||
                i.push({ command: 'setBearing', args: [e.bearing] }),
              wt(t.pitch, e.pitch) ||
                i.push({ command: 'setPitch', args: [e.pitch] }),
              wt(t.roll, e.roll) ||
                i.push({ command: 'setRoll', args: [e.roll] }),
              wt(t.sprite, e.sprite) ||
                i.push({ command: 'setSprite', args: [e.sprite] }),
              wt(t.glyphs, e.glyphs) ||
                i.push({ command: 'setGlyphs', args: [e.glyphs] }),
              wt(t.transition, e.transition) ||
                i.push({ command: 'setTransition', args: [e.transition] }),
              wt(t.light, e.light) ||
                i.push({ command: 'setLight', args: [e.light] }),
              wt(t.terrain, e.terrain) ||
                i.push({ command: 'setTerrain', args: [e.terrain] }),
              wt(t.sky, e.sky) || i.push({ command: 'setSky', args: [e.sky] }),
              wt(t.projection, e.projection) ||
                i.push({ command: 'setProjection', args: [e.projection] });
            const r = {},
              n = [];
            !(function (t, e, i, r) {
              let n;
              for (n in ((e = e || {}), (t = t || {})))
                Object.prototype.hasOwnProperty.call(t, n) &&
                  (Object.prototype.hasOwnProperty.call(e, n) || St(n, i, r));
              for (n in e)
                Object.prototype.hasOwnProperty.call(e, n) &&
                  (Object.prototype.hasOwnProperty.call(t, n)
                    ? wt(t[n], e[n]) ||
                      ('geojson' === t[n].type &&
                      'geojson' === e[n].type &&
                      It(t, e, n)
                        ? Tt(i, {
                            command: 'setGeoJSONSourceData',
                            args: [n, e[n].data],
                          })
                        : Mt(n, e, i, r))
                    : Pt(n, e, i));
            })(t.sources, e.sources, n, r);
            const o = [];
            t.layers &&
              t.layers.forEach((t) => {
                'source' in t && r[t.source]
                  ? i.push({ command: 'removeLayer', args: [t.id] })
                  : o.push(t);
              }),
              (i = i.concat(n)),
              (function (t, e, i) {
                e = e || [];
                const r = (t = t || []).map(At),
                  n = e.map(At),
                  o = t.reduce(Et, {}),
                  a = e.reduce(Et, {}),
                  s = r.slice(),
                  l = Object.create(null);
                let c, h, u, d, p;
                for (let f = 0, m = 0; f < r.length; f++)
                  (c = r[f]),
                    Object.prototype.hasOwnProperty.call(a, c)
                      ? m++
                      : (Tt(i, { command: 'removeLayer', args: [c] }),
                        s.splice(s.indexOf(c, m), 1));
                for (let f = 0, m = 0; f < n.length; f++)
                  (c = n[n.length - 1 - f]),
                    s[s.length - 1 - f] !== c &&
                      (Object.prototype.hasOwnProperty.call(o, c)
                        ? (Tt(i, { command: 'removeLayer', args: [c] }),
                          s.splice(s.lastIndexOf(c, s.length - m), 1))
                        : m++,
                      (d = s[s.length - f]),
                      Tt(i, { command: 'addLayer', args: [a[c], d] }),
                      s.splice(s.length - f, 0, c),
                      (l[c] = !0));
                for (let f = 0; f < n.length; f++)
                  if (((c = n[f]), (h = o[c]), (u = a[c]), !l[c] && !wt(h, u)))
                    if (
                      wt(h.source, u.source) &&
                      wt(h['source-layer'], u['source-layer']) &&
                      wt(h.type, u.type)
                    ) {
                      for (p in (Ct(
                        h.layout,
                        u.layout,
                        i,
                        c,
                        null,
                        'setLayoutProperty'
                      ),
                      Ct(h.paint, u.paint, i, c, null, 'setPaintProperty'),
                      wt(h.filter, u.filter) ||
                        Tt(i, { command: 'setFilter', args: [c, u.filter] }),
                      (wt(h.minzoom, u.minzoom) && wt(h.maxzoom, u.maxzoom)) ||
                        Tt(i, {
                          command: 'setLayerZoomRange',
                          args: [c, u.minzoom, u.maxzoom],
                        }),
                      h))
                        Object.prototype.hasOwnProperty.call(h, p) &&
                          'layout' !== p &&
                          'paint' !== p &&
                          'filter' !== p &&
                          'metadata' !== p &&
                          'minzoom' !== p &&
                          'maxzoom' !== p &&
                          (0 === p.indexOf('paint.')
                            ? Ct(
                                h[p],
                                u[p],
                                i,
                                c,
                                p.slice(6),
                                'setPaintProperty'
                              )
                            : wt(h[p], u[p]) ||
                              Tt(i, {
                                command: 'setLayerProperty',
                                args: [c, p, u[p]],
                              }));
                      for (p in u)
                        Object.prototype.hasOwnProperty.call(u, p) &&
                          !Object.prototype.hasOwnProperty.call(h, p) &&
                          'layout' !== p &&
                          'paint' !== p &&
                          'filter' !== p &&
                          'metadata' !== p &&
                          'minzoom' !== p &&
                          'maxzoom' !== p &&
                          (0 === p.indexOf('paint.')
                            ? Ct(
                                h[p],
                                u[p],
                                i,
                                c,
                                p.slice(6),
                                'setPaintProperty'
                              )
                            : wt(h[p], u[p]) ||
                              Tt(i, {
                                command: 'setLayerProperty',
                                args: [c, p, u[p]],
                              }));
                    } else
                      Tt(i, { command: 'removeLayer', args: [c] }),
                        (d = s[s.lastIndexOf(c) + 1]),
                        Tt(i, { command: 'addLayer', args: [u, d] });
              })(o, e.layers, i);
          } catch (t) {
            console.warn('Unable to compute style diff:', t),
              (i = [{ command: 'setStyle', args: [e] }]);
          }
          return i;
        }),
        (t.bQ = function (t) {
          const e = [],
            i = t.id;
          return (
            void 0 === i &&
              e.push({
                message: `layers.${i}: missing required property "id"`,
              }),
            void 0 === t.render &&
              e.push({
                message: `layers.${i}: missing required method "render"`,
              }),
            t.renderingMode &&
              '2d' !== t.renderingMode &&
              '3d' !== t.renderingMode &&
              e.push({
                message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`,
              }),
            e
          );
        }),
        (t.bR = N),
        (t.bS = V),
        (t.bT = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = 0);
          }
          set(t) {
            this.current !== t &&
              ((this.current = t), this.gl.uniform1i(this.location, t));
          }
        }),
        (t.bU = bs),
        (t.bV = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = ws);
          }
          set(t) {
            if (t[12] !== this.current[12] || t[0] !== this.current[0])
              return (
                (this.current = t),
                void this.gl.uniformMatrix4fv(this.location, !1, t)
              );
            for (let e = 1; e < 16; e++)
              if (t[e] !== this.current[e]) {
                (this.current = t),
                  this.gl.uniformMatrix4fv(this.location, !1, t);
                break;
              }
          }
        }),
        (t.bW = vs),
        (t.bX = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = [0, 0, 0]);
          }
          set(t) {
            (t[0] === this.current[0] &&
              t[1] === this.current[1] &&
              t[2] === this.current[2]) ||
              ((this.current = t),
              this.gl.uniform3f(this.location, t[0], t[1], t[2]));
          }
        }),
        (t.bY = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = [0, 0]);
          }
          set(t) {
            (t[0] === this.current[0] && t[1] === this.current[1]) ||
              ((this.current = t),
              this.gl.uniform2f(this.location, t[0], t[1]));
          }
        }),
        (t.bZ = f),
        (t.b_ = function (t, e) {
          var i = Math.sin(e),
            r = Math.cos(e);
          return (
            (t[0] = r),
            (t[1] = i),
            (t[2] = 0),
            (t[3] = -i),
            (t[4] = r),
            (t[5] = 0),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 1),
            t
          );
        }),
        (t.ba = function (t, e, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = e[4],
            a = e[5],
            s = e[6],
            l = e[7],
            c = e[8],
            h = e[9],
            u = e[10],
            d = e[11];
          return (
            e !== t &&
              ((t[0] = e[0]),
              (t[1] = e[1]),
              (t[2] = e[2]),
              (t[3] = e[3]),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15])),
            (t[4] = o * n + c * r),
            (t[5] = a * n + h * r),
            (t[6] = s * n + u * r),
            (t[7] = l * n + d * r),
            (t[8] = c * n - o * r),
            (t[9] = h * n - a * r),
            (t[10] = u * n - s * r),
            (t[11] = d * n - l * r),
            t
          );
        }),
        (t.bb = function () {
          const t = new Float32Array(16);
          return m(t), t;
        }),
        (t.bc = function () {
          const t = new Float64Array(16);
          return m(t), t;
        }),
        (t.bd = function () {
          return new Float64Array(16);
        }),
        (t.be = function (t, e, i) {
          const r = new Float64Array(4);
          return M(r, t, e - 90, i), r;
        }),
        (t.bf = function (t, e, i, r) {
          var n,
            o,
            a,
            s,
            l,
            c = e[0],
            h = e[1],
            u = e[2],
            p = e[3],
            f = i[0],
            m = i[1],
            _ = i[2],
            g = i[3];
          return (
            (o = c * f + h * m + u * _ + p * g) < 0 &&
              ((o = -o), (f = -f), (m = -m), (_ = -_), (g = -g)),
            1 - o > d
              ? ((n = Math.acos(o)),
                (a = Math.sin(n)),
                (s = Math.sin((1 - r) * n) / a),
                (l = Math.sin(r * n) / a))
              : ((s = 1 - r), (l = r)),
            (t[0] = s * c + l * f),
            (t[1] = s * h + l * m),
            (t[2] = s * u + l * _),
            (t[3] = s * p + l * g),
            t
          );
        }),
        (t.bg = function (t) {
          const e = new Float64Array(9);
          var i, r, n, o, a, s, l, c, h, u, d, p, f, m, _, g, y, x;
          (u = (n = (r = t)[0]) * (l = n + n)),
            (d = (o = r[1]) * l),
            (f = (a = r[2]) * l),
            (m = a * (c = o + o)),
            (g = (s = r[3]) * l),
            (y = s * c),
            (x = s * (h = a + a)),
            ((i = e)[0] = 1 - (p = o * c) - (_ = a * h)),
            (i[3] = d - x),
            (i[6] = f + y),
            (i[1] = d + x),
            (i[4] = 1 - u - _),
            (i[7] = m - g),
            (i[2] = f - y),
            (i[5] = m + g),
            (i[8] = 1 - u - p);
          const v = it(-Math.asin(F(e[2], -1, 1)));
          let b, w;
          return (
            Math.hypot(e[5], e[8]) < 0.001
              ? ((b = 0), (w = -it(Math.atan2(e[3], e[4]))))
              : ((b = it(
                  0 === e[5] && 0 === e[8] ? 0 : Math.atan2(e[5], e[8])
                )),
                (w = it(
                  0 === e[1] && 0 === e[0] ? 0 : Math.atan2(e[1], e[0])
                ))),
            { roll: b, pitch: v + 90, bearing: w }
          );
        }),
        (t.bh = function (t, e) {
          return (
            t.roll == e.roll && t.pitch == e.pitch && t.bearing == e.bearing
          );
        }),
        (t.bi = Ie),
        (t.bj = xs),
        (t.bk = cc),
        (t.bl = hc),
        (t.bm = sc),
        (t.bn = k),
        (t.bo = D),
        (t.bp = je),
        (t.bq = function (t, e, i, r, n) {
          return k(r, n, F((t - e) / (i - e), 0, 1));
        }),
        (t.br = z),
        (t.bs = function () {
          return new Float64Array(3);
        }),
        (t.bt = function (t, e, i, r) {
          return (
            (t[0] = e[0] + i[0] * r),
            (t[1] = e[1] + i[1] * r),
            (t[2] = e[2] + i[2] * r),
            t
          );
        }),
        (t.bu = M),
        (t.bv = function (t, e, i) {
          var r = i[0],
            n = i[1],
            o = i[2],
            a = i[3],
            s = e[0],
            l = e[1],
            c = e[2],
            h = n * c - o * l,
            u = o * s - r * c,
            d = r * l - n * s;
          return (
            (t[0] = s + a * (h += h) + n * (d += d) - o * (u += u)),
            (t[1] = l + a * u + o * h - r * d),
            (t[2] = c + a * d + r * u - n * h),
            t
          );
        }),
        (t.bw = function (t, e, i) {
          const r =
            (n = [t[0], t[1], t[2], e[0], e[1], e[2], i[0], i[1], i[2]])[0] *
              ((h = n[8]) * (a = n[4]) - (s = n[5]) * (c = n[7])) +
            n[1] * (-h * (o = n[3]) + s * (l = n[6])) +
            n[2] * (c * o - a * l);
          var n, o, a, s, l, c, h;
          if (0 === r) return null;
          const u = b([], [e[0], e[1], e[2]], [i[0], i[1], i[2]]),
            d = b([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            p = b([], [t[0], t[1], t[2]], [e[0], e[1], e[2]]),
            f = v([], u, -t[3]);
          return (
            x(f, f, v([], d, -e[3])),
            x(f, f, v([], p, -i[3])),
            v(f, f, 1 / r),
            f
          );
        }),
        (t.bx = Tu),
        (t.by = function () {
          return new Float64Array(4);
        }),
        (t.bz = function (t, e, i, r) {
          var n = [],
            o = [];
          return (
            (n[0] = e[0] - i[0]),
            (n[1] = e[1] - i[1]),
            (n[2] = e[2] - i[2]),
            (o[0] = n[0] * Math.cos(r) - n[1] * Math.sin(r)),
            (o[1] = n[0] * Math.sin(r) + n[1] * Math.cos(r)),
            (o[2] = n[2]),
            (t[0] = o[0] + i[0]),
            (t[1] = o[1] + i[1]),
            (t[2] = o[2] + i[2]),
            t
          );
        }),
        (t.c = at),
        (t.c0 = function (t, e, i, r, n, o, a) {
          var s = 1 / (e - i),
            l = 1 / (r - n),
            c = 1 / (o - a);
          return (
            (t[0] = -2 * s),
            (t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[4] = 0),
            (t[5] = -2 * l),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 0),
            (t[9] = 0),
            (t[10] = 2 * c),
            (t[11] = 0),
            (t[12] = (e + i) * s),
            (t[13] = (n + r) * l),
            (t[14] = (a + o) * c),
            (t[15] = 1),
            t
          );
        }),
        (t.c1 = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = new Array());
          }
          set(t) {
            if (t != this.current) {
              this.current = t;
              const e = new Float32Array(4 * t.length);
              for (let i = 0; i < t.length; i++)
                (e[4 * i] = t[i].r),
                  (e[4 * i + 1] = t[i].g),
                  (e[4 * i + 2] = t[i].b),
                  (e[4 * i + 3] = t[i].a);
              this.gl.uniform4fv(this.location, e);
            }
          }
        }),
        (t.c2 = class extends ys {
          constructor(t, e) {
            super(t, e), (this.current = new Array());
          }
          set(t) {
            if (t != this.current) {
              this.current = t;
              const e = new Float32Array(t);
              this.gl.uniform1fv(this.location, e);
            }
          }
        }),
        (t.c3 = class extends _a {}),
        (t.c4 = sh),
        (t.c5 = class extends ya {}),
        (t.c6 = bl),
        (t.c7 = function (t) {
          return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }),
        (t.c8 = vl),
        (t.c9 = function (t, e, i) {
          var r = e[0],
            n = e[1],
            o = e[2],
            a = i[3] * r + i[7] * n + i[11] * o + i[15];
          return (
            (t[0] = (i[0] * r + i[4] * n + i[8] * o + i[12]) / (a = a || 1)),
            (t[1] = (i[1] * r + i[5] * n + i[9] * o + i[13]) / a),
            (t[2] = (i[2] * r + i[6] * n + i[10] * o + i[14]) / a),
            t
          );
        }),
        (t.cB = function (t) {
          return t.message === ot;
        }),
        (t.cC = ht),
        (t.cD = function (t, e) {
          st.REGISTERED_PROTOCOLS[t] = e;
        }),
        (t.cE = function (t) {
          delete st.REGISTERED_PROTOCOLS[t];
        }),
        (t.cF = function (t, e) {
          const i = {};
          for (let n = 0; n < t.length; n++) {
            const r = (e && e[t[n].id]) || wn(t[n]);
            e && (e[t[n].id] = r);
            let o = i[r];
            o || (o = i[r] = []), o.push(t[n]);
          }
          const r = [];
          for (const n in i) r.push(i[n]);
          return r;
        }),
        (t.cG = co),
        (t.cH = Vu),
        (t.cI = Gu),
        (t.cJ = zh),
        (t.cK = function (e) {
          e.bucket.createArrays(),
            (e.bucket.tilePixelRatio = A / (512 * e.bucket.overscaling)),
            (e.bucket.compareText = {}),
            (e.bucket.iconsNeedLinear = !1);
          const i = e.bucket.layers[0],
            r = i.layout,
            n = i._unevaluatedLayout._values,
            o = {
              layoutIconSize: n['icon-size'].possiblyEvaluate(
                new zo(e.bucket.zoom + 1),
                e.canonical
              ),
              layoutTextSize: n['text-size'].possiblyEvaluate(
                new zo(e.bucket.zoom + 1),
                e.canonical
              ),
              textMaxSize: n['text-size'].possiblyEvaluate(new zo(18)),
            };
          if ('composite' === e.bucket.textSizeData.kind) {
            const { minZoom: t, maxZoom: i } = e.bucket.textSizeData;
            o.compositeTextSizes = [
              n['text-size'].possiblyEvaluate(new zo(t), e.canonical),
              n['text-size'].possiblyEvaluate(new zo(i), e.canonical),
            ];
          }
          if ('composite' === e.bucket.iconSizeData.kind) {
            const { minZoom: t, maxZoom: i } = e.bucket.iconSizeData;
            o.compositeIconSizes = [
              n['icon-size'].possiblyEvaluate(new zo(t), e.canonical),
              n['icon-size'].possiblyEvaluate(new zo(i), e.canonical),
            ];
          }
          const a = r.get('text-line-height') * hh,
            s =
              'viewport' !== r.get('text-rotation-alignment') &&
              'point' !== r.get('symbol-placement'),
            l = r.get('text-keep-upright'),
            c = r.get('text-size');
          for (const h of e.bucket.features) {
            const n = r.get('text-font').evaluate(h, {}, e.canonical).join(','),
              u = c.evaluate(h, {}, e.canonical),
              d = o.layoutTextSize.evaluate(h, {}, e.canonical),
              p = o.layoutIconSize.evaluate(h, {}, e.canonical),
              f = { horizontal: {}, vertical: void 0 },
              m = h.text;
            let _,
              g = [0, 0];
            if (m) {
              const o = m.toString(),
                c =
                  r.get('text-letter-spacing').evaluate(h, {}, e.canonical) *
                  hh,
                p = xo(o) ? c : 0,
                _ = r.get('text-anchor').evaluate(h, {}, e.canonical),
                y = fd(i, h, e.canonical);
              if (!y) {
                const t = r
                  .get('text-radial-offset')
                  .evaluate(h, {}, e.canonical);
                g = t
                  ? pd(_, [t * hh, dd])
                  : r
                      .get('text-offset')
                      .evaluate(h, {}, e.canonical)
                      .map((t) => t * hh);
              }
              let x = s
                ? 'center'
                : r.get('text-justify').evaluate(h, {}, e.canonical);
              const v =
                  'point' === r.get('symbol-placement')
                    ? r.get('text-max-width').evaluate(h, {}, e.canonical) * hh
                    : 1 / 0,
                b = () => {
                  e.bucket.allowVerticalPlacement &&
                    yo(o) &&
                    (f.vertical = Lh(
                      m,
                      e.glyphMap,
                      e.glyphPositions,
                      e.imagePositions,
                      n,
                      v,
                      a,
                      _,
                      'left',
                      p,
                      g,
                      t.as.vertical,
                      !0,
                      d,
                      u
                    ));
                };
              if (!s && y) {
                const i = new Set();
                if ('auto' === x)
                  for (let t = 0; t < y.values.length; t += 2)
                    i.add(md(y.values[t]));
                else i.add(x);
                let r = !1;
                for (const o of i)
                  if (!f.horizontal[o])
                    if (r) f.horizontal[o] = f.horizontal[0];
                    else {
                      const i = Lh(
                        m,
                        e.glyphMap,
                        e.glyphPositions,
                        e.imagePositions,
                        n,
                        v,
                        a,
                        'center',
                        o,
                        p,
                        g,
                        t.as.horizontal,
                        !1,
                        d,
                        u
                      );
                      i &&
                        ((f.horizontal[o] = i),
                        (r = 1 === i.positionedLines.length));
                    }
                b();
              } else {
                'auto' === x && (x = md(_));
                const i = Lh(
                  m,
                  e.glyphMap,
                  e.glyphPositions,
                  e.imagePositions,
                  n,
                  v,
                  a,
                  _,
                  x,
                  p,
                  g,
                  t.as.horizontal,
                  !1,
                  d,
                  u
                );
                i && (f.horizontal[x] = i),
                  b(),
                  yo(o) &&
                    s &&
                    l &&
                    (f.vertical = Lh(
                      m,
                      e.glyphMap,
                      e.glyphPositions,
                      e.imagePositions,
                      n,
                      v,
                      a,
                      _,
                      x,
                      p,
                      g,
                      t.as.vertical,
                      !1,
                      d,
                      u
                    ));
              }
            }
            let y = !1;
            if (h.icon && h.icon.name) {
              const t = e.imageMap[h.icon.name];
              t &&
                ((_ = Jh(
                  e.imagePositions[h.icon.name],
                  r.get('icon-offset').evaluate(h, {}, e.canonical),
                  r.get('icon-anchor').evaluate(h, {}, e.canonical)
                )),
                (y = !!t.sdf),
                void 0 === e.bucket.sdfIcons
                  ? (e.bucket.sdfIcons = y)
                  : e.bucket.sdfIcons !== y &&
                    Z(
                      'Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer'
                    ),
                (t.pixelRatio !== e.bucket.pixelRatio ||
                  0 !== r.get('icon-rotate').constantOr(1)) &&
                  (e.bucket.iconsNeedLinear = !0));
            }
            const x = yd(f.horizontal) || f.vertical;
            (e.bucket.iconsInText = !!x && x.iconsInText),
              (x || _) &&
                _d(
                  e.bucket,
                  h,
                  f,
                  _,
                  e.imageMap,
                  o,
                  d,
                  p,
                  g,
                  y,
                  e.canonical,
                  e.subdivisionGranularity
                );
          }
          e.showCollisionBoxes && e.bucket.generateCollisionDebugBuffers();
        }),
        (t.cL = gc),
        (t.cM = Rc),
        (t.cN = Hc),
        (t.cO = Ec),
        (t.cP = fh),
        (t.cQ = class {
          constructor(t) {
            (this._marks = {
              start: [t.url, 'start'].join('#'),
              end: [t.url, 'end'].join('#'),
              measure: t.url.toString(),
            }),
              performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t = performance.getEntriesByName(this._marks.measure);
            return (
              0 === t.length &&
                (performance.measure(
                  this._marks.measure,
                  this._marks.start,
                  this._marks.end
                ),
                (t = performance.getEntriesByName(this._marks.measure)),
                performance.clearMarks(this._marks.start),
                performance.clearMarks(this._marks.end),
                performance.clearMeasures(this._marks.measure)),
              t
            );
          }
        }),
        (t.cR = function (t, i, r, n, o) {
          return e(this, void 0, void 0, function* () {
            if (u())
              try {
                return yield K(t, i, r, n, o);
              } catch (t) {}
            return (function (t, e, i, r, n) {
              const o = t.width,
                a = t.height;
              (J && Q) ||
                ((J = new OffscreenCanvas(o, a)),
                (Q = J.getContext('2d', { willReadFrequently: !0 }))),
                (J.width = o),
                (J.height = a),
                Q.drawImage(t, 0, 0, o, a);
              const s = Q.getImageData(e, i, r, n);
              return Q.clearRect(0, 0, o, a), s.data;
            })(t, i, r, n, o);
          });
        }),
        (t.cS = Al),
        (t.cT = r),
        (t.cU = Cc),
        (t.cV = Sc),
        (t.cW = rn),
        (t.cX = function (t, e) {
          const i = new Map();
          if (null == t);
          else if ('Feature' === t.type) i.set(ju(t, e), t);
          else for (const r of t.features) i.set(ju(r, e), r);
          return i;
        }),
        (t.cY = function (t, e) {
          if (null == t) return !0;
          if ('Feature' === t.type) return null != ju(t, e);
          if ('FeatureCollection' === t.type) {
            const i = new Set();
            for (const r of t.features) {
              const t = ju(r, e);
              if (null == t) return !1;
              if (i.has(t)) return !1;
              i.add(t);
            }
            return !0;
          }
          return !1;
        }),
        (t.cZ = function (t, e, i) {
          var r, n, o, a;
          if ((e.removeAll && t.clear(), e.remove))
            for (const s of e.remove) t.delete(s);
          if (e.add)
            for (const s of e.add) {
              const e = ju(s, i);
              null != e && t.set(e, s);
            }
          if (e.update)
            for (const s of e.update) {
              let e = t.get(s.id);
              if (null == e) continue;
              const i =
                !s.removeAllProperties &&
                ((null === (r = s.removeProperties) || void 0 === r
                  ? void 0
                  : r.length) > 0 ||
                  (null === (n = s.addOrUpdateProperties) || void 0 === n
                    ? void 0
                    : n.length) > 0);
              if (
                ((s.newGeometry || s.removeAllProperties || i) &&
                  ((e = Object.assign({}, e)),
                  t.set(s.id, e),
                  i && (e.properties = Object.assign({}, e.properties))),
                s.newGeometry && (e.geometry = s.newGeometry),
                s.removeAllProperties)
              )
                e.properties = {};
              else if (
                (null === (o = s.removeProperties) || void 0 === o
                  ? void 0
                  : o.length) > 0
              )
                for (const t of s.removeProperties)
                  Object.prototype.hasOwnProperty.call(e.properties, t) &&
                    delete e.properties[t];
              if (
                (null === (a = s.addOrUpdateProperties) || void 0 === a
                  ? void 0
                  : a.length) > 0
              )
                for (const { key: t, value: r } of s.addOrUpdateProperties)
                  e.properties[t] = r;
            }
        }),
        (t.c_ = Eo),
        (t.ca = class extends oa {}),
        (t.cb = class extends Sa {}),
        (t.cc = function (t, e) {
          return (
            t[0] === e[0] &&
            t[1] === e[1] &&
            t[2] === e[2] &&
            t[3] === e[3] &&
            t[4] === e[4] &&
            t[5] === e[5] &&
            t[6] === e[6] &&
            t[7] === e[7] &&
            t[8] === e[8] &&
            t[9] === e[9] &&
            t[10] === e[10] &&
            t[11] === e[11] &&
            t[12] === e[12] &&
            t[13] === e[13] &&
            t[14] === e[14] &&
            t[15] === e[15]
          );
        }),
        (t.cd = function (t, e) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            u = t[9],
            p = t[10],
            f = t[11],
            m = t[12],
            _ = t[13],
            g = t[14],
            y = t[15],
            x = e[0],
            v = e[1],
            b = e[2],
            w = e[3],
            T = e[4],
            P = e[5],
            S = e[6],
            M = e[7],
            I = e[8],
            C = e[9],
            A = e[10],
            E = e[11],
            z = e[12],
            k = e[13],
            D = e[14],
            R = e[15];
          return (
            Math.abs(i - x) <= d * Math.max(1, Math.abs(i), Math.abs(x)) &&
            Math.abs(r - v) <= d * Math.max(1, Math.abs(r), Math.abs(v)) &&
            Math.abs(n - b) <= d * Math.max(1, Math.abs(n), Math.abs(b)) &&
            Math.abs(o - w) <= d * Math.max(1, Math.abs(o), Math.abs(w)) &&
            Math.abs(a - T) <= d * Math.max(1, Math.abs(a), Math.abs(T)) &&
            Math.abs(s - P) <= d * Math.max(1, Math.abs(s), Math.abs(P)) &&
            Math.abs(l - S) <= d * Math.max(1, Math.abs(l), Math.abs(S)) &&
            Math.abs(c - M) <= d * Math.max(1, Math.abs(c), Math.abs(M)) &&
            Math.abs(h - I) <= d * Math.max(1, Math.abs(h), Math.abs(I)) &&
            Math.abs(u - C) <= d * Math.max(1, Math.abs(u), Math.abs(C)) &&
            Math.abs(p - A) <= d * Math.max(1, Math.abs(p), Math.abs(A)) &&
            Math.abs(f - E) <= d * Math.max(1, Math.abs(f), Math.abs(E)) &&
            Math.abs(m - z) <= d * Math.max(1, Math.abs(m), Math.abs(z)) &&
            Math.abs(_ - k) <= d * Math.max(1, Math.abs(_), Math.abs(k)) &&
            Math.abs(g - D) <= d * Math.max(1, Math.abs(g), Math.abs(D)) &&
            Math.abs(y - R) <= d * Math.max(1, Math.abs(y), Math.abs(R))
          );
        }),
        (t.ce = function (t, e) {
          return (
            (t[0] = e[0]),
            (t[1] = e[1]),
            (t[2] = e[2]),
            (t[3] = e[3]),
            (t[4] = e[4]),
            (t[5] = e[5]),
            (t[6] = e[6]),
            (t[7] = e[7]),
            (t[8] = e[8]),
            (t[9] = e[9]),
            (t[10] = e[10]),
            (t[11] = e[11]),
            (t[12] = e[12]),
            (t[13] = e[13]),
            (t[14] = e[14]),
            (t[15] = e[15]),
            t
          );
        }),
        (t.cf = (t) => 'symbol' === t.type),
        (t.cg = (t) => 'circle' === t.type),
        (t.ch = (t) => 'heatmap' === t.type),
        (t.ci = (t) => 'line' === t.type),
        (t.cj = (t) => 'fill' === t.type),
        (t.ck = (t) => 'fill-extrusion' === t.type),
        (t.cl = (t) => 'hillshade' === t.type),
        (t.cm = (t) => 'color-relief' === t.type),
        (t.cn = (t) => 'background' === t.type),
        (t.co = (t) => 'custom' === t.type),
        (t.cp = R),
        (t.cq = function (t, e, i) {
          const r = C(e.x - i.x, e.y - i.y),
            n = C(t.x - i.x, t.y - i.y);
          var o, a;
          return it(
            Math.atan2(
              r[0] * n[1] - r[1] * n[0],
              (o = r)[0] * (a = n)[0] + o[1] * a[1]
            )
          );
        }),
        (t.cr = L),
        (t.cs = function (t, e) {
          return nt[e] && (t instanceof MouseEvent || t instanceof WheelEvent);
        }),
        (t.ct = function (t, e) {
          return rt[e] && 'touches' in t;
        }),
        (t.cu = function (t) {
          return rt[t] || nt[t];
        }),
        (t.cv = function (t, e, i) {
          var r = e[0],
            n = e[1];
          return (
            (t[0] = i[0] * r + i[4] * n + i[12]),
            (t[1] = i[1] * r + i[5] * n + i[13]),
            t
          );
        }),
        (t.cw = function (t, e) {
          const { x: i, y: r } = Du.fromLngLat(e);
          return !(t < 0 || t > 25 || r < 0 || r >= 1 || i < 0 || i >= 1);
        }),
        (t.cx = function (t, e) {
          return (
            (t[0] = e[0]),
            (t[1] = 0),
            (t[2] = 0),
            (t[3] = 0),
            (t[4] = 0),
            (t[5] = e[1]),
            (t[6] = 0),
            (t[7] = 0),
            (t[8] = 0),
            (t[9] = 0),
            (t[10] = e[2]),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            t
          );
        }),
        (t.cy = class extends na {}),
        (t.cz = Dd),
        (t.d = pt),
        (t.e = O),
        (t.f = (t) =>
          e(void 0, void 0, void 0, function* () {
            if (0 === t.byteLength)
              return createImageBitmap(new ImageData(1, 1));
            const e = new Blob([new Uint8Array(t)], { type: 'image/png' });
            try {
              return createImageBitmap(e);
            } catch (t) {
              throw new Error(
                `Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
              );
            }
          })),
        (t.g = lt),
        (t.h = (t) =>
          new Promise((e, i) => {
            const r = new Image();
            (r.onload = () => {
              e(r),
                URL.revokeObjectURL(r.src),
                (r.onload = null),
                window.requestAnimationFrame(() => {
                  r.src = X;
                });
            }),
              (r.onerror = () =>
                i(
                  new Error(
                    'Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'
                  )
                ));
            const n = new Blob([new Uint8Array(t)], { type: 'image/png' });
            r.src = t.byteLength ? URL.createObjectURL(n) : X;
          })),
        (t.i = q),
        (t.j = (t, e) => dt(O(t, { type: 'json' }), e)),
        (t.k = gt),
        (t.l = _t),
        (t.m = dt),
        (t.n = (t, e) => dt(O(t, { type: 'arrayBuffer' }), e)),
        (t.o = function (t) {
          return new fh(t).readFields(Mh, []);
        }),
        (t.p = Ah),
        (t.q = yl),
        (t.r = qo),
        (t.s = tt),
        (t.t = xt),
        (t.u = go),
        (t.v = to),
        (t.w = Z),
        (t.x = Lo),
        (t.y = io),
        (t.z = ao);
    }),
      i('worker', ['./shared'], function (t) {
        class e {
          constructor(t, e) {
            (this.keyCache = {}), t && this.replace(t, e);
          }
          replace(t, e) {
            (this._layerConfigs = {}),
              (this._layers = {}),
              this.update(t, [], e);
          }
          update(e, i, r) {
            for (const o of e) {
              this._layerConfigs[o.id] = o;
              const e = (this._layers[o.id] = t.bM(o, r));
              (e._featureFilter = t.ae(e.filter, r)),
                this.keyCache[o.id] && delete this.keyCache[o.id];
            }
            for (const t of i)
              delete this.keyCache[t],
                delete this._layerConfigs[t],
                delete this._layers[t];
            this.familiesBySource = {};
            const n = t.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const t of n) {
              const e = t.map((t) => this._layers[t.id]),
                i = e[0];
              if ('none' === i.visibility) continue;
              const r = i.source || '';
              let n = this.familiesBySource[r];
              n || (n = this.familiesBySource[r] = {});
              const o = i.sourceLayer || '_geojsonTileLayer';
              let a = n[o];
              a || (a = n[o] = []), a.push(e);
            }
          }
        }
        class i {
          constructor(e) {
            const i = {},
              r = [];
            for (const t in e) {
              const n = e[t],
                o = (i[t] = {});
              for (const t in n) {
                const e = n[+t];
                if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height)
                  continue;
                const i = {
                  x: 0,
                  y: 0,
                  w: e.bitmap.width + 2,
                  h: e.bitmap.height + 2,
                };
                r.push(i), (o[t] = { rect: i, metrics: e.metrics });
              }
            }
            const { w: n, h: o } = t.p(r),
              a = new t.q({ width: n || 1, height: o || 1 });
            for (const s in e) {
              const r = e[s];
              for (const e in r) {
                const n = r[+e];
                if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height)
                  continue;
                const o = i[s][e].rect;
                t.q.copy(
                  n.bitmap,
                  a,
                  { x: 0, y: 0 },
                  { x: o.x + 1, y: o.y + 1 },
                  n.bitmap
                );
              }
            }
            (this.image = a), (this.positions = i);
          }
        }
        t.cG('GlyphAtlas', i);
        class r {
          constructor(e) {
            (this.tileID = new t.a0(
              e.tileID.overscaledZ,
              e.tileID.wrap,
              e.tileID.canonical.z,
              e.tileID.canonical.x,
              e.tileID.canonical.y
            )),
              (this.uid = e.uid),
              (this.zoom = e.zoom),
              (this.pixelRatio = e.pixelRatio),
              (this.tileSize = e.tileSize),
              (this.source = e.source),
              (this.overscaling = this.tileID.overscaleFactor()),
              (this.showCollisionBoxes = e.showCollisionBoxes),
              (this.collectResourceTiming = !!e.collectResourceTiming),
              (this.returnDependencies = !!e.returnDependencies),
              (this.promoteId = e.promoteId),
              (this.inFlightDependencies = []);
          }
          parse(e, r, o, a, s) {
            return t._(this, void 0, void 0, function* () {
              (this.status = 'parsing'),
                (this.data = e),
                (this.collisionBoxArray = new t.ac());
              const l = new t.cH(Object.keys(e.layers).sort()),
                c = new t.cI(this.tileID, this.promoteId);
              c.bucketLayerIDs = [];
              const h = {},
                u = {
                  featureIndex: c,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: o,
                  subdivisionGranularity: s,
                },
                d = r.familiesBySource[this.source];
              for (const i in d) {
                const r = e.layers[i];
                if (!r) continue;
                1 === r.version &&
                  t.w(
                    `Vector tile source "${this.source}" layer "${i}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                  );
                const a = l.encode(i),
                  s = [];
                for (let t = 0; t < r.length; t++) {
                  const e = r.feature(t),
                    n = c.getId(e, i);
                  s.push({ feature: e, id: n, index: t, sourceLayerIndex: a });
                }
                for (const e of d[i]) {
                  const i = e[0];
                  i.source !== this.source &&
                    t.w(
                      `layer.source = ${i.source} does not equal this.source = ${this.source}`
                    ),
                    i.isHidden(this.zoom, !0) ||
                      (n(e, this.zoom, o),
                      (h[i.id] = i.createBucket({
                        index: c.bucketLayerIDs.length,
                        layers: e,
                        zoom: this.zoom,
                        pixelRatio: this.pixelRatio,
                        overscaling: this.overscaling,
                        collisionBoxArray: this.collisionBoxArray,
                        sourceLayerIndex: a,
                        sourceID: this.source,
                      })).populate(s, u, this.tileID.canonical),
                      c.bucketLayerIDs.push(e.map((t) => t.id)));
                }
              }
              const p = t.bR(u.glyphDependencies, (t) =>
                Object.keys(t).map(Number)
              );
              this.inFlightDependencies.forEach((t) =>
                null == t ? void 0 : t.abort()
              ),
                (this.inFlightDependencies = []);
              let f = Promise.resolve({});
              if (Object.keys(p).length) {
                const t = new AbortController();
                this.inFlightDependencies.push(t),
                  (f = a.sendAsync(
                    {
                      type: 'GG',
                      data: {
                        stacks: p,
                        source: this.source,
                        tileID: this.tileID,
                        type: 'glyphs',
                      },
                    },
                    t
                  ));
              }
              const m = Object.keys(u.iconDependencies);
              let _ = Promise.resolve({});
              if (m.length) {
                const t = new AbortController();
                this.inFlightDependencies.push(t),
                  (_ = a.sendAsync(
                    {
                      type: 'GI',
                      data: {
                        icons: m,
                        source: this.source,
                        tileID: this.tileID,
                        type: 'icons',
                      },
                    },
                    t
                  ));
              }
              const g = Object.keys(u.patternDependencies);
              let y = Promise.resolve({});
              if (g.length) {
                const t = new AbortController();
                this.inFlightDependencies.push(t),
                  (y = a.sendAsync(
                    {
                      type: 'GI',
                      data: {
                        icons: g,
                        source: this.source,
                        tileID: this.tileID,
                        type: 'patterns',
                      },
                    },
                    t
                  ));
              }
              const x = u.dashDependencies;
              let v = Promise.resolve({});
              if (Object.keys(x).length) {
                const t = new AbortController();
                this.inFlightDependencies.push(t),
                  (v = a.sendAsync({ type: 'GDA', data: { dashes: x } }, t));
              }
              const [b, w, T, P] = yield Promise.all([f, _, y, v]),
                S = new i(b),
                M = new t.cJ(w, T);
              for (const e in h) {
                const i = h[e];
                i instanceof t.ad
                  ? (n(i.layers, this.zoom, o),
                    t.cK({
                      bucket: i,
                      glyphMap: b,
                      glyphPositions: S.positions,
                      imageMap: w,
                      imagePositions: M.iconPositions,
                      showCollisionBoxes: this.showCollisionBoxes,
                      canonical: this.tileID.canonical,
                      subdivisionGranularity: u.subdivisionGranularity,
                    }))
                  : i.hasDependencies &&
                    (i instanceof t.cL ||
                      i instanceof t.cM ||
                      i instanceof t.cN) &&
                    (n(i.layers, this.zoom, o),
                    i.addFeatures(
                      u,
                      this.tileID.canonical,
                      M.patternPositions,
                      P
                    ));
              }
              return (
                (this.status = 'done'),
                {
                  buckets: Object.values(h).filter((t) => !t.isEmpty()),
                  featureIndex: c,
                  collisionBoxArray: this.collisionBoxArray,
                  glyphAtlasImage: S.image,
                  imageAtlas: M,
                  dashPositions: P,
                  glyphMap: this.returnDependencies ? b : null,
                  iconMap: this.returnDependencies ? w : null,
                  glyphPositions: this.returnDependencies ? S.positions : null,
                }
              );
            });
          }
        }
        function n(e, i, r) {
          const n = new t.G(i);
          for (const t of e) t.recalculate(n, r);
        }
        class o {
          constructor(t, e, i) {
            (this.actor = t),
              (this.layerIndex = e),
              (this.availableImages = i),
              (this.fetching = {}),
              (this.loading = {}),
              (this.loaded = {});
          }
          loadVectorTile(e, i) {
            return t._(this, void 0, void 0, function* () {
              const r = yield t.n(e.request, i);
              try {
                return {
                  vectorTile: new t.cO(new t.cP(r.data)),
                  rawData: r.data,
                  cacheControl: r.cacheControl,
                  expires: r.expires,
                };
              } catch (t) {
                const n = new Uint8Array(r.data);
                let o = `Unable to parse the tile at ${e.request.url}, `;
                throw (
                  ((o +=
                    31 === n[0] && 139 === n[1]
                      ? 'please make sure the data is not gzipped and that you have configured the relevant header in the server'
                      : `got error: ${t.message}`),
                  new Error(o))
                );
              }
            });
          }
          loadTile(e) {
            return t._(this, void 0, void 0, function* () {
              const i = e.uid,
                n =
                  !!(e && e.request && e.request.collectResourceTiming) &&
                  new t.cQ(e.request),
                o = new r(e);
              this.loading[i] = o;
              const a = new AbortController();
              o.abort = a;
              try {
                const r = yield this.loadVectorTile(e, a);
                if ((delete this.loading[i], !r)) return null;
                const s = r.rawData,
                  l = {};
                r.expires && (l.expires = r.expires),
                  r.cacheControl && (l.cacheControl = r.cacheControl);
                const c = {};
                if (n) {
                  const t = n.finish();
                  t && (c.resourceTiming = JSON.parse(JSON.stringify(t)));
                }
                o.vectorTile = r.vectorTile;
                const h = o.parse(
                  r.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  e.subdivisionGranularity
                );
                (this.loaded[i] = o),
                  (this.fetching[i] = {
                    rawTileData: s,
                    cacheControl: l,
                    resourceTiming: c,
                  });
                try {
                  const e = yield h;
                  return t.e({ rawTileData: s.slice(0) }, e, l, c);
                } finally {
                  delete this.fetching[i];
                }
              } catch (t) {
                throw (
                  (delete this.loading[i],
                  (o.status = 'done'),
                  (this.loaded[i] = o),
                  t)
                );
              }
            });
          }
          reloadTile(e) {
            return t._(this, void 0, void 0, function* () {
              const i = e.uid;
              if (!this.loaded || !this.loaded[i])
                throw new Error(
                  'Should not be trying to reload a tile that was never loaded or has been removed'
                );
              const r = this.loaded[i];
              if (
                ((r.showCollisionBoxes = e.showCollisionBoxes),
                'parsing' === r.status)
              ) {
                const n = yield r.parse(
                  r.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  e.subdivisionGranularity
                );
                let o;
                if (this.fetching[i]) {
                  const {
                    rawTileData: e,
                    cacheControl: r,
                    resourceTiming: a,
                  } = this.fetching[i];
                  delete this.fetching[i],
                    (o = t.e({ rawTileData: e.slice(0) }, n, r, a));
                } else o = n;
                return o;
              }
              if ('done' === r.status && r.vectorTile)
                return r.parse(
                  r.vectorTile,
                  this.layerIndex,
                  this.availableImages,
                  this.actor,
                  e.subdivisionGranularity
                );
            });
          }
          abortTile(e) {
            return t._(this, void 0, void 0, function* () {
              const t = this.loading,
                i = e.uid;
              t && t[i] && t[i].abort && (t[i].abort.abort(), delete t[i]);
            });
          }
          removeTile(e) {
            return t._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[e.uid] && delete this.loaded[e.uid];
            });
          }
        }
        class a {
          constructor() {
            this.loaded = {};
          }
          loadTile(e) {
            return t._(this, void 0, void 0, function* () {
              const {
                  uid: i,
                  encoding: r,
                  rawImageData: n,
                  redFactor: o,
                  greenFactor: a,
                  blueFactor: s,
                  baseShift: l,
                } = e,
                c = n.width + 2,
                h = n.height + 2,
                u = t.b(n)
                  ? new t.R(
                      { width: c, height: h },
                      yield t.cR(n, -1, -1, c, h)
                    )
                  : n,
                d = new t.cS(i, u, r, o, a, s, l);
              return (this.loaded = this.loaded || {}), (this.loaded[i] = d), d;
            });
          }
          removeTile(t) {
            const e = this.loaded,
              i = t.uid;
            e && e[i] && delete e[i];
          }
        }
        var s,
          l,
          c = (function () {
            if (l) return s;
            function t(t, i) {
              if (0 !== t.length) {
                e(t[0], i);
                for (var r = 1; r < t.length; r++) e(t[r], !i);
              }
            }
            function e(t, e) {
              for (
                var i = 0, r = 0, n = 0, o = t.length, a = o - 1;
                n < o;
                a = n++
              ) {
                var s = (t[n][0] - t[a][0]) * (t[a][1] + t[n][1]),
                  l = i + s;
                (r += Math.abs(i) >= Math.abs(s) ? i - l + s : s - l + i),
                  (i = l);
              }
              i + r >= 0 != !!e && t.reverse();
            }
            return (
              (l = 1),
              (s = function e(i, r) {
                var n,
                  o = i && i.type;
                if ('FeatureCollection' === o)
                  for (n = 0; n < i.features.length; n++) e(i.features[n], r);
                else if ('GeometryCollection' === o)
                  for (n = 0; n < i.geometries.length; n++)
                    e(i.geometries[n], r);
                else if ('Feature' === o) e(i.geometry, r);
                else if ('Polygon' === o) t(i.coordinates, r);
                else if ('MultiPolygon' === o)
                  for (n = 0; n < i.coordinates.length; n++)
                    t(i.coordinates[n], r);
                return i;
              })
            );
          })(),
          h = t.cT(c);
        class u extends t.cV {
          constructor(e, i) {
            super(new t.cP(), 0, i, [], []),
              (this.feature = e),
              (this.type = e.type),
              (this.properties = e.tags ? e.tags : {}),
              'id' in e &&
                ('string' == typeof e.id
                  ? (this.id = parseInt(e.id, 10))
                  : 'number' != typeof e.id || isNaN(e.id) || (this.id = e.id));
          }
          loadGeometry() {
            const e = [],
              i =
                1 === this.feature.type
                  ? [this.feature.geometry]
                  : this.feature.geometry;
            for (const r of i) {
              const i = [];
              for (const e of r) i.push(new t.P(e[0], e[1]));
              e.push(i);
            }
            return e;
          }
        }
        class d extends t.cU {
          constructor(e, i) {
            super(new t.cP()),
              (this.layers = { _geojsonTileLayer: this }),
              (this.name = '_geojsonTileLayer'),
              (this.version = i ? i.version : 1),
              (this.extent = i ? i.extent : 4096),
              (this.length = e.length),
              (this.features = e);
          }
          feature(t) {
            return new u(this.features[t], this.extent);
          }
        }
        function p(t, e) {
          e.writeVarintField(15, t.version || 1),
            e.writeStringField(1, t.name || ''),
            e.writeVarintField(5, t.extent || 4096);
          const i = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let o = 0; o < t.length; o++)
            (i.feature = t.feature(o)), e.writeMessage(2, f, i);
          const r = i.keys;
          for (const o of r) e.writeStringField(3, o);
          const n = i.values;
          for (const o of n) e.writeMessage(4, x, o);
        }
        function f(t, e) {
          if (!t.feature) return;
          const i = t.feature;
          void 0 !== i.id && e.writeVarintField(1, i.id),
            e.writeMessage(2, m, t),
            e.writeVarintField(3, i.type),
            e.writeMessage(4, y, i);
        }
        function m(t, e) {
          for (const i in t.feature?.properties) {
            let r = t.feature.properties[i],
              n = t.keycache[i];
            if (null === r) continue;
            void 0 === n &&
              (t.keys.push(i), (n = t.keys.length - 1), (t.keycache[i] = n)),
              e.writeVarint(n),
              'string' != typeof r &&
                'boolean' != typeof r &&
                'number' != typeof r &&
                (r = JSON.stringify(r));
            const o = typeof r + ':' + r;
            let a = t.valuecache[o];
            void 0 === a &&
              (t.values.push(r),
              (a = t.values.length - 1),
              (t.valuecache[o] = a)),
              e.writeVarint(a);
          }
        }
        function _(t, e) {
          return (e << 3) + (7 & t);
        }
        function g(t) {
          return (t << 1) ^ (t >> 31);
        }
        function y(t, e) {
          const i = t.loadGeometry(),
            r = t.type;
          let n = 0,
            o = 0;
          for (const a of i) {
            let i = 1;
            1 === r && (i = a.length), e.writeVarint(_(1, i));
            const s = 3 === r ? a.length - 1 : a.length;
            for (let t = 0; t < s; t++) {
              1 === t && 1 !== r && e.writeVarint(_(2, s - 1));
              const i = a[t].x - n,
                l = a[t].y - o;
              e.writeVarint(g(i)), e.writeVarint(g(l)), (n += i), (o += l);
            }
            3 === t.type && e.writeVarint(_(7, 1));
          }
        }
        function x(t, e) {
          const i = typeof t;
          'string' === i
            ? e.writeStringField(1, t)
            : 'boolean' === i
            ? e.writeBooleanField(7, t)
            : 'number' === i &&
              (t % 1 != 0
                ? e.writeDoubleField(3, t)
                : t < 0
                ? e.writeSVarintField(6, t)
                : e.writeVarintField(5, t));
        }
        const v = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (t) => t,
          },
          b =
            Math.fround ||
            ((w = new Float32Array(1)), (t) => ((w[0] = +t), w[0]));
        var w;
        class T {
          constructor(t) {
            (this.options = Object.assign(Object.create(v), t)),
              (this.trees = new Array(this.options.maxZoom + 1)),
              (this.stride = this.options.reduce ? 7 : 6),
              (this.clusterProps = []);
          }
          load(t) {
            const { log: e, minZoom: i, maxZoom: r } = this.options;
            e && console.time('total time');
            const n = `prepare ${t.length} points`;
            e && console.time(n), (this.points = t);
            const o = [];
            for (let s = 0; s < t.length; s++) {
              const e = t[s];
              if (!e.geometry) continue;
              const [i, r] = e.geometry.coordinates,
                n = b(M(i)),
                a = b(I(r));
              o.push(n, a, 1 / 0, s, -1, 1), this.options.reduce && o.push(0);
            }
            let a = (this.trees[r + 1] = this._createTree(o));
            e && console.timeEnd(n);
            for (let s = r; s >= i; s--) {
              const t = +Date.now();
              (a = this.trees[s] = this._createTree(this._cluster(a, s))),
                e &&
                  console.log(
                    'z%d: %d clusters in %dms',
                    s,
                    a.numItems,
                    +Date.now() - t
                  );
            }
            return e && console.timeEnd('total time'), this;
          }
          getClusters(t, e) {
            let i = ((((t[0] + 180) % 360) + 360) % 360) - 180;
            const r = Math.max(-90, Math.min(90, t[1]));
            let n =
              180 === t[2] ? 180 : ((((t[2] + 180) % 360) + 360) % 360) - 180;
            const o = Math.max(-90, Math.min(90, t[3]));
            if (t[2] - t[0] >= 360) (i = -180), (n = 180);
            else if (i > n) {
              const t = this.getClusters([i, r, 180, o], e),
                a = this.getClusters([-180, r, n, o], e);
              return t.concat(a);
            }
            const a = this.trees[this._limitZoom(e)],
              s = a.range(M(i), I(o), M(n), I(r)),
              l = a.data,
              c = [];
            for (const h of s) {
              const t = this.stride * h;
              c.push(
                l[t + 5] > 1
                  ? P(l, t, this.clusterProps)
                  : this.points[l[t + 3]]
              );
            }
            return c;
          }
          getChildren(t) {
            const e = this._getOriginId(t),
              i = this._getOriginZoom(t),
              r = 'No cluster with the specified id.',
              n = this.trees[i];
            if (!n) throw new Error(r);
            const o = n.data;
            if (e * this.stride >= o.length) throw new Error(r);
            const a =
                this.options.radius /
                (this.options.extent * Math.pow(2, i - 1)),
              s = n.within(o[e * this.stride], o[e * this.stride + 1], a),
              l = [];
            for (const c of s) {
              const e = c * this.stride;
              o[e + 4] === t &&
                l.push(
                  o[e + 5] > 1
                    ? P(o, e, this.clusterProps)
                    : this.points[o[e + 3]]
                );
            }
            if (0 === l.length) throw new Error(r);
            return l;
          }
          getLeaves(t, e, i) {
            const r = [];
            return this._appendLeaves(r, t, (e = e || 10), (i = i || 0), 0), r;
          }
          getTile(t, e, i) {
            const r = this.trees[this._limitZoom(t)],
              n = Math.pow(2, t),
              { extent: o, radius: a } = this.options,
              s = a / o,
              l = (i - s) / n,
              c = (i + 1 + s) / n,
              h = { features: [] };
            return (
              this._addTileFeatures(
                r.range((e - s) / n, l, (e + 1 + s) / n, c),
                r.data,
                e,
                i,
                n,
                h
              ),
              0 === e &&
                this._addTileFeatures(
                  r.range(1 - s / n, l, 1, c),
                  r.data,
                  n,
                  i,
                  n,
                  h
                ),
              e === n - 1 &&
                this._addTileFeatures(
                  r.range(0, l, s / n, c),
                  r.data,
                  -1,
                  i,
                  n,
                  h
                ),
              h.features.length ? h : null
            );
          }
          getClusterExpansionZoom(t) {
            let e = this._getOriginZoom(t) - 1;
            for (; e <= this.options.maxZoom; ) {
              const i = this.getChildren(t);
              if ((e++, 1 !== i.length)) break;
              t = i[0].properties.cluster_id;
            }
            return e;
          }
          _appendLeaves(t, e, i, r, n) {
            const o = this.getChildren(e);
            for (const a of o) {
              const e = a.properties;
              if (
                (e && e.cluster
                  ? n + e.point_count <= r
                    ? (n += e.point_count)
                    : (n = this._appendLeaves(t, e.cluster_id, i, r, n))
                  : n < r
                  ? n++
                  : t.push(a),
                t.length === i)
              )
                break;
            }
            return n;
          }
          _createTree(e) {
            const i = new t.aM(
              (e.length / this.stride) | 0,
              this.options.nodeSize,
              Float32Array
            );
            for (let t = 0; t < e.length; t += this.stride)
              i.add(e[t], e[t + 1]);
            return i.finish(), (i.data = e), i;
          }
          _addTileFeatures(t, e, i, r, n, o) {
            for (const a of t) {
              const t = a * this.stride,
                s = e[t + 5] > 1;
              let l, c, h;
              if (s)
                (l = S(e, t, this.clusterProps)), (c = e[t]), (h = e[t + 1]);
              else {
                const i = this.points[e[t + 3]];
                l = i.properties;
                const [r, n] = i.geometry.coordinates;
                (c = M(r)), (h = I(n));
              }
              const u = {
                type: 1,
                geometry: [
                  [
                    Math.round(this.options.extent * (c * n - i)),
                    Math.round(this.options.extent * (h * n - r)),
                  ],
                ],
                tags: l,
              };
              let d;
              (d =
                s || this.options.generateId
                  ? e[t + 3]
                  : this.points[e[t + 3]].id),
                void 0 !== d && (u.id = d),
                o.features.push(u);
            }
          }
          _limitZoom(t) {
            return Math.max(
              this.options.minZoom,
              Math.min(Math.floor(+t), this.options.maxZoom + 1)
            );
          }
          _cluster(t, e) {
            const {
                radius: i,
                extent: r,
                reduce: n,
                minPoints: o,
              } = this.options,
              a = i / (r * Math.pow(2, e)),
              s = t.data,
              l = [],
              c = this.stride;
            for (let h = 0; h < s.length; h += c) {
              if (s[h + 2] <= e) continue;
              s[h + 2] = e;
              const i = s[h],
                r = s[h + 1],
                u = t.within(s[h], s[h + 1], a),
                d = s[h + 5];
              let p = d;
              for (const t of u) {
                const i = t * c;
                s[i + 2] > e && (p += s[i + 5]);
              }
              if (p > d && p >= o) {
                let t,
                  o = i * d,
                  a = r * d,
                  f = -1;
                const m = ((h / c) << 5) + (e + 1) + this.points.length;
                for (const i of u) {
                  const r = i * c;
                  if (s[r + 2] <= e) continue;
                  s[r + 2] = e;
                  const l = s[r + 5];
                  (o += s[r] * l),
                    (a += s[r + 1] * l),
                    (s[r + 4] = m),
                    n &&
                      (t ||
                        ((t = this._map(s, h, !0)),
                        (f = this.clusterProps.length),
                        this.clusterProps.push(t)),
                      n(t, this._map(s, r)));
                }
                (s[h + 4] = m),
                  l.push(o / p, a / p, 1 / 0, m, -1, p),
                  n && l.push(f);
              } else {
                for (let t = 0; t < c; t++) l.push(s[h + t]);
                if (p > 1)
                  for (const t of u) {
                    const i = t * c;
                    if (!(s[i + 2] <= e)) {
                      s[i + 2] = e;
                      for (let t = 0; t < c; t++) l.push(s[i + t]);
                    }
                  }
              }
            }
            return l;
          }
          _getOriginId(t) {
            return (t - this.points.length) >> 5;
          }
          _getOriginZoom(t) {
            return (t - this.points.length) % 32;
          }
          _map(t, e, i) {
            if (t[e + 5] > 1) {
              const r = this.clusterProps[t[e + 6]];
              return i ? Object.assign({}, r) : r;
            }
            const r = this.points[t[e + 3]].properties,
              n = this.options.map(r);
            return i && n === r ? Object.assign({}, n) : n;
          }
        }
        function P(t, e, i) {
          return {
            type: 'Feature',
            id: t[e + 3],
            properties: S(t, e, i),
            geometry: {
              type: 'Point',
              coordinates: [((r = t[e]), 360 * (r - 0.5)), C(t[e + 1])],
            },
          };
          var r;
        }
        function S(t, e, i) {
          const r = t[e + 5],
            n =
              r >= 1e4
                ? `${Math.round(r / 1e3)}k`
                : r >= 1e3
                ? Math.round(r / 100) / 10 + 'k'
                : r,
            o = t[e + 6],
            a = -1 === o ? {} : Object.assign({}, i[o]);
          return Object.assign(a, {
            cluster: !0,
            cluster_id: t[e + 3],
            point_count: r,
            point_count_abbreviated: n,
          });
        }
        function M(t) {
          return t / 360 + 0.5;
        }
        function I(t) {
          const e = Math.sin((t * Math.PI) / 180),
            i = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
          return i < 0 ? 0 : i > 1 ? 1 : i;
        }
        function C(t) {
          const e = ((180 - 360 * t) * Math.PI) / 180;
          return (360 * Math.atan(Math.exp(e))) / Math.PI - 90;
        }
        function A(t, e, i, r) {
          let n = r;
          const o = e + ((i - e) >> 1);
          let a,
            s = i - e;
          const l = t[e],
            c = t[e + 1],
            h = t[i],
            u = t[i + 1];
          for (let d = e + 3; d < i; d += 3) {
            const e = E(t[d], t[d + 1], l, c, h, u);
            if (e > n) (a = d), (n = e);
            else if (e === n) {
              const t = Math.abs(d - o);
              t < s && ((a = d), (s = t));
            }
          }
          n > r &&
            (a - e > 3 && A(t, e, a, r),
            (t[a + 2] = n),
            i - a > 3 && A(t, a, i, r));
        }
        function E(t, e, i, r, n, o) {
          let a = n - i,
            s = o - r;
          if (0 !== a || 0 !== s) {
            const l = ((t - i) * a + (e - r) * s) / (a * a + s * s);
            l > 1 ? ((i = n), (r = o)) : l > 0 && ((i += a * l), (r += s * l));
          }
          return (a = t - i), (s = e - r), a * a + s * s;
        }
        function z(t, e, i, r) {
          const n = {
            id: null == t ? null : t,
            type: e,
            geometry: i,
            tags: r,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0,
          };
          if ('Point' === e || 'MultiPoint' === e || 'LineString' === e)
            k(n, i);
          else if ('Polygon' === e) k(n, i[0]);
          else if ('MultiLineString' === e) for (const o of i) k(n, o);
          else if ('MultiPolygon' === e) for (const o of i) k(n, o[0]);
          return n;
        }
        function k(t, e) {
          for (let i = 0; i < e.length; i += 3)
            (t.minX = Math.min(t.minX, e[i])),
              (t.minY = Math.min(t.minY, e[i + 1])),
              (t.maxX = Math.max(t.maxX, e[i])),
              (t.maxY = Math.max(t.maxY, e[i + 1]));
        }
        function D(t, e, i, r) {
          if (!e.geometry) return;
          const n = e.geometry.coordinates;
          if (n && 0 === n.length) return;
          const o = e.geometry.type,
            a = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2);
          let s = [],
            l = e.id;
          if (
            (i.promoteId
              ? (l = e.properties[i.promoteId])
              : i.generateId && (l = r || 0),
            'Point' === o)
          )
            R(n, s);
          else if ('MultiPoint' === o) for (const c of n) R(c, s);
          else if ('LineString' === o) L(n, s, a, !1);
          else if ('MultiLineString' === o) {
            if (i.lineMetrics) {
              for (const i of n)
                (s = []),
                  L(i, s, a, !1),
                  t.push(z(l, 'LineString', s, e.properties));
              return;
            }
            F(n, s, a, !1);
          } else if ('Polygon' === o) F(n, s, a, !0);
          else {
            if ('MultiPolygon' !== o) {
              if ('GeometryCollection' === o) {
                for (const n of e.geometry.geometries)
                  D(t, { id: l, geometry: n, properties: e.properties }, i, r);
                return;
              }
              throw new Error('Input data is not a valid GeoJSON object.');
            }
            for (const t of n) {
              const e = [];
              F(t, e, a, !0), s.push(e);
            }
          }
          t.push(z(l, o, s, e.properties));
        }
        function R(t, e) {
          e.push(B(t[0]), O(t[1]), 0);
        }
        function L(t, e, i, r) {
          let n,
            o,
            a = 0;
          for (let l = 0; l < t.length; l++) {
            const i = B(t[l][0]),
              s = O(t[l][1]);
            e.push(i, s, 0),
              l > 0 &&
                (a += r
                  ? (n * s - i * o) / 2
                  : Math.sqrt(Math.pow(i - n, 2) + Math.pow(s - o, 2))),
              (n = i),
              (o = s);
          }
          const s = e.length - 3;
          (e[2] = 1),
            A(e, 0, s, i),
            (e[s + 2] = 1),
            (e.size = Math.abs(a)),
            (e.start = 0),
            (e.end = e.size);
        }
        function F(t, e, i, r) {
          for (let n = 0; n < t.length; n++) {
            const o = [];
            L(t[n], o, i, r), e.push(o);
          }
        }
        function B(t) {
          return t / 360 + 0.5;
        }
        function O(t) {
          const e = Math.sin((t * Math.PI) / 180),
            i = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
          return i < 0 ? 0 : i > 1 ? 1 : i;
        }
        function j(t, e, i, r, n, o, a, s) {
          if (((r /= e), o >= (i /= e) && a < r)) return t;
          if (a < i || o >= r) return null;
          const l = [];
          for (const c of t) {
            const t = c.geometry;
            let e = c.type;
            const o = 0 === n ? c.minX : c.minY,
              a = 0 === n ? c.maxX : c.maxY;
            if (o >= i && a < r) {
              l.push(c);
              continue;
            }
            if (a < i || o >= r) continue;
            let h = [];
            if ('Point' === e || 'MultiPoint' === e) N(t, h, i, r, n);
            else if ('LineString' === e) V(t, h, i, r, n, !1, s.lineMetrics);
            else if ('MultiLineString' === e) G(t, h, i, r, n, !1);
            else if ('Polygon' === e) G(t, h, i, r, n, !0);
            else if ('MultiPolygon' === e)
              for (const s of t) {
                const t = [];
                G(s, t, i, r, n, !0), t.length && h.push(t);
              }
            if (h.length) {
              if (s.lineMetrics && 'LineString' === e) {
                for (const t of h) l.push(z(c.id, e, t, c.tags));
                continue;
              }
              ('LineString' !== e && 'MultiLineString' !== e) ||
                (1 === h.length
                  ? ((e = 'LineString'), (h = h[0]))
                  : (e = 'MultiLineString')),
                ('Point' !== e && 'MultiPoint' !== e) ||
                  (e = 3 === h.length ? 'Point' : 'MultiPoint'),
                l.push(z(c.id, e, h, c.tags));
            }
          }
          return l.length ? l : null;
        }
        function N(t, e, i, r, n) {
          for (let o = 0; o < t.length; o += 3) {
            const a = t[o + n];
            a >= i && a <= r && Z(e, t[o], t[o + 1], t[o + 2]);
          }
        }
        function V(t, e, i, r, n, o, a) {
          let s = U(t);
          const l = 0 === n ? $ : q;
          let c,
            h,
            u = t.start;
          for (let _ = 0; _ < t.length - 3; _ += 3) {
            const d = t[_],
              p = t[_ + 1],
              f = t[_ + 2],
              m = t[_ + 3],
              g = t[_ + 4],
              y = 0 === n ? d : p,
              x = 0 === n ? m : g;
            let v = !1;
            a && (c = Math.sqrt(Math.pow(d - m, 2) + Math.pow(p - g, 2))),
              y < i
                ? x > i &&
                  ((h = l(s, d, p, m, g, i)), a && (s.start = u + c * h))
                : y > r
                ? x < r &&
                  ((h = l(s, d, p, m, g, r)), a && (s.start = u + c * h))
                : Z(s, d, p, f),
              x < i && y >= i && ((h = l(s, d, p, m, g, i)), (v = !0)),
              x > r && y <= r && ((h = l(s, d, p, m, g, r)), (v = !0)),
              !o && v && (a && (s.end = u + c * h), e.push(s), (s = U(t))),
              a && (u += c);
          }
          let d = t.length - 3;
          const p = t[d],
            f = t[d + 1],
            m = 0 === n ? p : f;
          m >= i && m <= r && Z(s, p, f, t[d + 2]),
            (d = s.length - 3),
            o &&
              d >= 3 &&
              (s[d] !== s[0] || s[d + 1] !== s[1]) &&
              Z(s, s[0], s[1], s[2]),
            s.length && e.push(s);
        }
        function U(t) {
          const e = [];
          return (e.size = t.size), (e.start = t.start), (e.end = t.end), e;
        }
        function G(t, e, i, r, n, o) {
          for (const a of t) V(a, e, i, r, n, o, !1);
        }
        function Z(t, e, i, r) {
          t.push(e, i, r);
        }
        function $(t, e, i, r, n, o) {
          const a = (o - e) / (r - e);
          return Z(t, o, i + (n - i) * a, 1), a;
        }
        function q(t, e, i, r, n, o) {
          const a = (o - i) / (n - i);
          return Z(t, e + (r - e) * a, o, 1), a;
        }
        function W(t, e) {
          const i = [];
          for (let r = 0; r < t.length; r++) {
            const n = t[r],
              o = n.type;
            let a;
            if ('Point' === o || 'MultiPoint' === o || 'LineString' === o)
              a = Y(n.geometry, e);
            else if ('MultiLineString' === o || 'Polygon' === o) {
              a = [];
              for (const t of n.geometry) a.push(Y(t, e));
            } else if ('MultiPolygon' === o) {
              a = [];
              for (const t of n.geometry) {
                const i = [];
                for (const r of t) i.push(Y(r, e));
                a.push(i);
              }
            }
            i.push(z(n.id, o, a, n.tags));
          }
          return i;
        }
        function Y(t, e) {
          const i = [];
          (i.size = t.size),
            void 0 !== t.start && ((i.start = t.start), (i.end = t.end));
          for (let r = 0; r < t.length; r += 3)
            i.push(t[r] + e, t[r + 1], t[r + 2]);
          return i;
        }
        function H(t, e) {
          if (t.transformed) return t;
          const i = 1 << t.z,
            r = t.x,
            n = t.y;
          for (const o of t.features) {
            const t = o.geometry,
              a = o.type;
            if (((o.geometry = []), 1 === a))
              for (let s = 0; s < t.length; s += 2)
                o.geometry.push(X(t[s], t[s + 1], e, i, r, n));
            else
              for (let s = 0; s < t.length; s++) {
                const a = [];
                for (let o = 0; o < t[s].length; o += 2)
                  a.push(X(t[s][o], t[s][o + 1], e, i, r, n));
                o.geometry.push(a);
              }
          }
          return (t.transformed = !0), t;
        }
        function X(t, e, i, r, n, o) {
          return [Math.round(i * (t * r - n)), Math.round(i * (e * r - o))];
        }
        function K(t, e, i, r, n) {
          const o = e === n.maxZoom ? 0 : n.tolerance / ((1 << e) * n.extent),
            a = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: t.length,
              source: null,
              x: i,
              y: r,
              z: e,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0,
            };
          for (const s of t) J(a, s, o, n);
          return a;
        }
        function J(t, e, i, r) {
          const n = e.geometry,
            o = e.type,
            a = [];
          if (
            ((t.minX = Math.min(t.minX, e.minX)),
            (t.minY = Math.min(t.minY, e.minY)),
            (t.maxX = Math.max(t.maxX, e.maxX)),
            (t.maxY = Math.max(t.maxY, e.maxY)),
            'Point' === o || 'MultiPoint' === o)
          )
            for (let s = 0; s < n.length; s += 3)
              a.push(n[s], n[s + 1]), t.numPoints++, t.numSimplified++;
          else if ('LineString' === o) Q(a, n, t, i, !1, !1);
          else if ('MultiLineString' === o || 'Polygon' === o)
            for (let s = 0; s < n.length; s++)
              Q(a, n[s], t, i, 'Polygon' === o, 0 === s);
          else if ('MultiPolygon' === o)
            for (let s = 0; s < n.length; s++) {
              const e = n[s];
              for (let r = 0; r < e.length; r++) Q(a, e[r], t, i, !0, 0 === r);
            }
          if (a.length) {
            let i = e.tags || null;
            if ('LineString' === o && r.lineMetrics) {
              i = {};
              for (const t in e.tags) i[t] = e.tags[t];
              (i.mapbox_clip_start = n.start / n.size),
                (i.mapbox_clip_end = n.end / n.size);
            }
            const s = {
              geometry: a,
              type:
                'Polygon' === o || 'MultiPolygon' === o
                  ? 3
                  : 'LineString' === o || 'MultiLineString' === o
                  ? 2
                  : 1,
              tags: i,
            };
            null !== e.id && (s.id = e.id), t.features.push(s);
          }
        }
        function Q(t, e, i, r, n, o) {
          const a = r * r;
          if (r > 0 && e.size < (n ? a : r))
            return void (i.numPoints += e.length / 3);
          const s = [];
          for (let l = 0; l < e.length; l += 3)
            (0 === r || e[l + 2] > a) &&
              (i.numSimplified++, s.push(e[l], e[l + 1])),
              i.numPoints++;
          n &&
            (function (t, e) {
              let i = 0;
              for (let r = 0, n = t.length, o = n - 2; r < n; o = r, r += 2)
                i += (t[r] - t[o]) * (t[r + 1] + t[o + 1]);
              if (i > 0 === e)
                for (let r = 0, n = t.length; r < n / 2; r += 2) {
                  const e = t[r],
                    i = t[r + 1];
                  (t[r] = t[n - 2 - r]),
                    (t[r + 1] = t[n - 1 - r]),
                    (t[n - 2 - r] = e),
                    (t[n - 1 - r] = i);
                }
            })(s, o),
            t.push(s);
        }
        const tt = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0,
        };
        class et {
          constructor(t, e) {
            const i = (e = this.options =
              (function (t, e) {
                for (const i in e) t[i] = e[i];
                return t;
              })(Object.create(tt), e)).debug;
            if (
              (i && console.time('preprocess data'),
              e.maxZoom < 0 || e.maxZoom > 24)
            )
              throw new Error('maxZoom should be in the 0-24 range');
            if (e.promoteId && e.generateId)
              throw new Error(
                'promoteId and generateId cannot be used together.'
              );
            let r = (function (t, e) {
              const i = [];
              if ('FeatureCollection' === t.type)
                for (let r = 0; r < t.features.length; r++)
                  D(i, t.features[r], e, r);
              else D(i, 'Feature' === t.type ? t : { geometry: t }, e);
              return i;
            })(t, e);
            (this.tiles = {}),
              (this.tileCoords = []),
              i &&
                (console.timeEnd('preprocess data'),
                console.log(
                  'index: maxZoom: %d, maxPoints: %d',
                  e.indexMaxZoom,
                  e.indexMaxPoints
                ),
                console.time('generate tiles'),
                (this.stats = {}),
                (this.total = 0)),
              (r = (function (t, e) {
                const i = e.buffer / e.extent;
                let r = t;
                const n = j(t, 1, -1 - i, i, 0, -1, 2, e),
                  o = j(t, 1, 1 - i, 2 + i, 0, -1, 2, e);
                return (
                  (n || o) &&
                    ((r = j(t, 1, -i, 1 + i, 0, -1, 2, e) || []),
                    n && (r = W(n, 1).concat(r)),
                    o && (r = r.concat(W(o, -1)))),
                  r
                );
              })(r, e)),
              r.length && this.splitTile(r, 0, 0, 0),
              i &&
                (r.length &&
                  console.log(
                    'features: %d, points: %d',
                    this.tiles[0].numFeatures,
                    this.tiles[0].numPoints
                  ),
                console.timeEnd('generate tiles'),
                console.log(
                  'tiles generated:',
                  this.total,
                  JSON.stringify(this.stats)
                ));
          }
          splitTile(t, e, i, r, n, o, a) {
            const s = [t, e, i, r],
              l = this.options,
              c = l.debug;
            for (; s.length; ) {
              (r = s.pop()), (i = s.pop()), (e = s.pop()), (t = s.pop());
              const h = 1 << e,
                u = it(e, i, r);
              let d = this.tiles[u];
              if (
                !d &&
                (c > 1 && console.time('creation'),
                (d = this.tiles[u] = K(t, e, i, r, l)),
                this.tileCoords.push({ z: e, x: i, y: r }),
                c)
              ) {
                c > 1 &&
                  (console.log(
                    'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                    e,
                    i,
                    r,
                    d.numFeatures,
                    d.numPoints,
                    d.numSimplified
                  ),
                  console.timeEnd('creation'));
                const t = `z${e}`;
                (this.stats[t] = (this.stats[t] || 0) + 1), this.total++;
              }
              if (((d.source = t), null == n)) {
                if (e === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints)
                  continue;
              } else {
                if (e === l.maxZoom || e === n) continue;
                if (null != n) {
                  const t = n - e;
                  if (i !== o >> t || r !== a >> t) continue;
                }
              }
              if (((d.source = null), 0 === t.length)) continue;
              c > 1 && console.time('clipping');
              const p = (0.5 * l.buffer) / l.extent,
                f = 0.5 - p,
                m = 0.5 + p,
                _ = 1 + p;
              let g = null,
                y = null,
                x = null,
                v = null,
                b = j(t, h, i - p, i + m, 0, d.minX, d.maxX, l),
                w = j(t, h, i + f, i + _, 0, d.minX, d.maxX, l);
              (t = null),
                b &&
                  ((g = j(b, h, r - p, r + m, 1, d.minY, d.maxY, l)),
                  (y = j(b, h, r + f, r + _, 1, d.minY, d.maxY, l)),
                  (b = null)),
                w &&
                  ((x = j(w, h, r - p, r + m, 1, d.minY, d.maxY, l)),
                  (v = j(w, h, r + f, r + _, 1, d.minY, d.maxY, l)),
                  (w = null)),
                c > 1 && console.timeEnd('clipping'),
                s.push(g || [], e + 1, 2 * i, 2 * r),
                s.push(y || [], e + 1, 2 * i, 2 * r + 1),
                s.push(x || [], e + 1, 2 * i + 1, 2 * r),
                s.push(v || [], e + 1, 2 * i + 1, 2 * r + 1);
            }
          }
          getTile(t, e, i) {
            (t = +t), (e = +e), (i = +i);
            const r = this.options,
              { extent: n, debug: o } = r;
            if (t < 0 || t > 24) return null;
            const a = 1 << t,
              s = it(t, (e = (e + a) & (a - 1)), i);
            if (this.tiles[s]) return H(this.tiles[s], n);
            o > 1 && console.log('drilling down to z%d-%d-%d', t, e, i);
            let l,
              c = t,
              h = e,
              u = i;
            for (; !l && c > 0; )
              c--, (h >>= 1), (u >>= 1), (l = this.tiles[it(c, h, u)]);
            return l && l.source
              ? (o > 1 &&
                  (console.log('found parent tile z%d-%d-%d', c, h, u),
                  console.time('drilling down')),
                this.splitTile(l.source, c, h, u, t, e, i),
                o > 1 && console.timeEnd('drilling down'),
                this.tiles[s] ? H(this.tiles[s], n) : null)
              : null;
          }
        }
        function it(t, e, i) {
          return 32 * ((1 << t) * i + e) + t;
        }
        class rt extends o {
          constructor(t, e, i, r = nt) {
            super(t, e, i),
              (this._dataUpdateable = new Map()),
              (this._createGeoJSONIndex = r);
          }
          loadVectorTile(e, i) {
            return t._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical;
              if (!this._geoJSONIndex)
                throw new Error(
                  'Unable to parse the data into a cluster or geojson'
                );
              const r = this._geoJSONIndex.getTile(i.z, i.x, i.y);
              if (!r) return null;
              const n = new d(r.features, { version: 2, extent: t.a3 });
              let o = (function (e) {
                const i = new t.cP();
                return (
                  (function (t, e) {
                    for (const i in t.layers) e.writeMessage(3, p, t.layers[i]);
                  })(e, i),
                  i.finish()
                );
              })(n);
              return (
                (0 === o.byteOffset && o.byteLength === o.buffer.byteLength) ||
                  (o = new Uint8Array(o)),
                { vectorTile: n, rawData: o.buffer }
              );
            });
          }
          loadData(e) {
            return t._(this, void 0, void 0, function* () {
              var i;
              null === (i = this._pendingRequest) || void 0 === i || i.abort();
              const r =
                !!(e && e.request && e.request.collectResourceTiming) &&
                new t.cQ(e.request);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || e.request || e.data || e.dataDiff) &&
                  (this._pendingData = this.loadAndProcessGeoJSON(
                    e,
                    this._pendingRequest
                  ));
                const t = yield this._pendingData;
                (this._geoJSONIndex = this._createGeoJSONIndex(t, e)),
                  (this.loaded = {});
                const i = { data: t };
                if (r) {
                  const t = r.finish();
                  t &&
                    ((i.resourceTiming = {}),
                    (i.resourceTiming[e.source] = JSON.parse(
                      JSON.stringify(t)
                    )));
                }
                return i;
              } catch (e) {
                if ((delete this._pendingRequest, t.cB(e)))
                  return { abandoned: !0 };
                throw e;
              }
            });
          }
          getData() {
            return t._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(t) {
            const e = this.loaded;
            return e && e[t.uid] ? super.reloadTile(t) : this.loadTile(t);
          }
          loadAndProcessGeoJSON(e, i) {
            return t._(this, void 0, void 0, function* () {
              let r = yield this.loadGeoJSON(e, i);
              if ((delete this._pendingRequest, 'object' != typeof r))
                throw new Error(
                  `Input data given to '${e.source}' is not a valid GeoJSON object.`
                );
              if ((h(r, !0), e.filter)) {
                const i = t.cW(e.filter, {
                  'type': 'boolean',
                  'property-type': 'data-driven',
                  'overridable': !1,
                  'transition': !1,
                });
                if ('error' === i.result)
                  throw new Error(
                    i.value.map((t) => `${t.key}: ${t.message}`).join(', ')
                  );
                const n = r.features.filter((t) =>
                  i.value.evaluate({ zoom: 0 }, t)
                );
                r = { type: 'FeatureCollection', features: n };
              }
              return r;
            });
          }
          loadGeoJSON(e, i) {
            return t._(this, void 0, void 0, function* () {
              const { promoteId: r } = e;
              if (e.request) {
                const n = yield t.j(e.request, i);
                return (
                  (this._dataUpdateable = t.cY(n.data, r)
                    ? t.cX(n.data, r)
                    : void 0),
                  n.data
                );
              }
              if ('string' == typeof e.data)
                try {
                  const i = JSON.parse(e.data);
                  return (
                    (this._dataUpdateable = t.cY(i, r) ? t.cX(i, r) : void 0), i
                  );
                } catch (t) {
                  throw new Error(
                    `Input data given to '${e.source}' is not a valid GeoJSON object.`
                  );
                }
              if (!e.dataDiff)
                throw new Error(
                  `Input data given to '${e.source}' is not a valid GeoJSON object.`
                );
              if (!this._dataUpdateable)
                throw new Error(
                  `Cannot update existing geojson data in ${e.source}`
                );
              return (
                t.cZ(this._dataUpdateable, e.dataDiff, r),
                {
                  type: 'FeatureCollection',
                  features: Array.from(this._dataUpdateable.values()),
                }
              );
            });
          }
          removeSource(e) {
            return t._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(t) {
            return this._geoJSONIndex.getClusterExpansionZoom(t.clusterId);
          }
          getClusterChildren(t) {
            return this._geoJSONIndex.getChildren(t.clusterId);
          }
          getClusterLeaves(t) {
            return this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset);
          }
        }
        function nt(e, i) {
          return i.cluster
            ? new T(
                (function ({ superclusterOptions: e, clusterProperties: i }) {
                  if (!i || !e) return e;
                  const r = {},
                    n = {},
                    o = { accumulated: null, zoom: 0 },
                    a = { properties: null },
                    s = Object.keys(i);
                  for (const l of s) {
                    const [e, o] = i[l],
                      a = t.cW(o),
                      s = t.cW(
                        'string' == typeof e
                          ? [e, ['accumulated'], ['get', l]]
                          : e
                      );
                    (r[l] = a.value), (n[l] = s.value);
                  }
                  return (
                    (e.map = (t) => {
                      a.properties = t;
                      const e = {};
                      for (const i of s) e[i] = r[i].evaluate(o, a);
                      return e;
                    }),
                    (e.reduce = (t, e) => {
                      a.properties = e;
                      for (const i of s)
                        (o.accumulated = t[i]), (t[i] = n[i].evaluate(o, a));
                    }),
                    e
                  );
                })(i)
              ).load(e.features)
            : (function (t, e) {
                return new et(t, e);
              })(e, i.geojsonVtOptions);
        }
        class ot {
          constructor(e) {
            (this.self = e),
              (this.actor = new t.K(e)),
              (this.layerIndexes = {}),
              (this.availableImages = {}),
              (this.workerSources = {}),
              (this.demWorkerSources = {}),
              (this.externalWorkerSourceTypes = {}),
              (this.globalStates = new Map()),
              (this.self.registerWorkerSource = (t, e) => {
                if (this.externalWorkerSourceTypes[t])
                  throw new Error(
                    `Worker source with name "${t}" already registered.`
                  );
                this.externalWorkerSourceTypes[t] = e;
              }),
              (this.self.addProtocol = t.cD),
              (this.self.removeProtocol = t.cE),
              (this.self.registerRTLTextPlugin = (e) => {
                t.c_.setMethods(e);
              }),
              this.actor.registerMessageHandler('LDT', (t, e) =>
                this._getDEMWorkerSource(t, e.source).loadTile(e)
              ),
              this.actor.registerMessageHandler('RDT', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  this._getDEMWorkerSource(e, i.source).removeTile(i);
                })
              ),
              this.actor.registerMessageHandler('GCEZ', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    e,
                    i.type,
                    i.source
                  ).getClusterExpansionZoom(i);
                })
              ),
              this.actor.registerMessageHandler('GCC', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    e,
                    i.type,
                    i.source
                  ).getClusterChildren(i);
                })
              ),
              this.actor.registerMessageHandler('GCL', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  return this._getWorkerSource(
                    e,
                    i.type,
                    i.source
                  ).getClusterLeaves(i);
                })
              ),
              this.actor.registerMessageHandler('LD', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).loadData(e)
              ),
              this.actor.registerMessageHandler('GD', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).getData()
              ),
              this.actor.registerMessageHandler('LT', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).loadTile(e)
              ),
              this.actor.registerMessageHandler('RT', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).reloadTile(e)
              ),
              this.actor.registerMessageHandler('AT', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).abortTile(e)
              ),
              this.actor.registerMessageHandler('RMT', (t, e) =>
                this._getWorkerSource(t, e.type, e.source).removeTile(e)
              ),
              this.actor.registerMessageHandler('RS', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  if (
                    !this.workerSources[e] ||
                    !this.workerSources[e][i.type] ||
                    !this.workerSources[e][i.type][i.source]
                  )
                    return;
                  const t = this.workerSources[e][i.type][i.source];
                  delete this.workerSources[e][i.type][i.source],
                    void 0 !== t.removeSource && t.removeSource(i);
                })
              ),
              this.actor.registerMessageHandler('RM', (e) =>
                t._(this, void 0, void 0, function* () {
                  delete this.layerIndexes[e],
                    delete this.availableImages[e],
                    delete this.workerSources[e],
                    delete this.demWorkerSources[e],
                    this.globalStates.delete(e);
                })
              ),
              this.actor.registerMessageHandler('SR', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  this.referrer = i;
                })
              ),
              this.actor.registerMessageHandler('SRPS', (t, e) =>
                this._syncRTLPluginState(t, e)
              ),
              this.actor.registerMessageHandler('IS', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  this.self.importScripts(i);
                })
              ),
              this.actor.registerMessageHandler('SI', (t, e) =>
                this._setImages(t, e)
              ),
              this.actor.registerMessageHandler('UL', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  this._getLayerIndex(e).update(
                    i.layers,
                    i.removedIds,
                    this._getGlobalState(e)
                  );
                })
              ),
              this.actor.registerMessageHandler('UGS', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  const t = this._getGlobalState(e);
                  for (const e in i) t[e] = i[e];
                })
              ),
              this.actor.registerMessageHandler('SL', (e, i) =>
                t._(this, void 0, void 0, function* () {
                  this._getLayerIndex(e).replace(i, this._getGlobalState(e));
                })
              );
          }
          _getGlobalState(t) {
            let e = this.globalStates.get(t);
            return e || ((e = {}), this.globalStates.set(t, e)), e;
          }
          _setImages(e, i) {
            return t._(this, void 0, void 0, function* () {
              this.availableImages[e] = i;
              for (const t in this.workerSources[e]) {
                const r = this.workerSources[e][t];
                for (const t in r) r[t].availableImages = i;
              }
            });
          }
          _syncRTLPluginState(e, i) {
            return t._(this, void 0, void 0, function* () {
              return yield t.c_.syncState(i, this.self.importScripts);
            });
          }
          _getAvailableImages(t) {
            let e = this.availableImages[t];
            return e || (e = []), e;
          }
          _getLayerIndex(t) {
            let i = this.layerIndexes[t];
            return i || (i = this.layerIndexes[t] = new e()), i;
          }
          _getWorkerSource(t, e, i) {
            if (
              (this.workerSources[t] || (this.workerSources[t] = {}),
              this.workerSources[t][e] || (this.workerSources[t][e] = {}),
              !this.workerSources[t][e][i])
            ) {
              const r = {
                sendAsync: (e, i) => (
                  (e.targetMapId = t), this.actor.sendAsync(e, i)
                ),
              };
              switch (e) {
                case 'vector':
                  this.workerSources[t][e][i] = new o(
                    r,
                    this._getLayerIndex(t),
                    this._getAvailableImages(t)
                  );
                  break;
                case 'geojson':
                  this.workerSources[t][e][i] = new rt(
                    r,
                    this._getLayerIndex(t),
                    this._getAvailableImages(t)
                  );
                  break;
                default:
                  this.workerSources[t][e][i] =
                    new this.externalWorkerSourceTypes[e](
                      r,
                      this._getLayerIndex(t),
                      this._getAvailableImages(t)
                    );
              }
            }
            return this.workerSources[t][e][i];
          }
          _getDEMWorkerSource(t, e) {
            return (
              this.demWorkerSources[t] || (this.demWorkerSources[t] = {}),
              this.demWorkerSources[t][e] ||
                (this.demWorkerSources[t][e] = new a()),
              this.demWorkerSources[t][e]
            );
          }
        }
        return t.i(self) && (self.worker = new ot(self)), ot;
      }),
      i('index', ['exports', './shared'], function (t, e) {
        var i = '5.11.0';
        function r() {
          var t = new e.A(4);
          return (
            e.A != Float32Array && ((t[1] = 0), (t[2] = 0)),
            (t[0] = 1),
            (t[3] = 1),
            t
          );
        }
        let n, o;
        const a = {
            frame(t, i, r) {
              const n = requestAnimationFrame((t) => {
                  o(), i(t);
                }),
                { unsubscribe: o } = e.s(
                  t.signal,
                  'abort',
                  () => {
                    o(), cancelAnimationFrame(n), r(e.c());
                  },
                  !1
                );
            },
            frameAsync(t) {
              return new Promise((e, i) => {
                this.frame(t, e, i);
              });
            },
            getImageData(t, e = 0) {
              return this.getImageCanvasContext(t).getImageData(
                -e,
                -e,
                t.width + 2 * e,
                t.height + 2 * e
              );
            },
            getImageCanvasContext(t) {
              const e = window.document.createElement('canvas'),
                i = e.getContext('2d', { willReadFrequently: !0 });
              if (!i) throw new Error('failed to create canvas 2d context');
              return (
                (e.width = t.width),
                (e.height = t.height),
                i.drawImage(t, 0, 0, t.width, t.height),
                i
              );
            },
            resolveURL: (t) => (
              n || (n = document.createElement('a')), (n.href = t), n.href
            ),
            hardwareConcurrency:
              ('undefined' != typeof navigator &&
                navigator.hardwareConcurrency) ||
              4,
            get prefersReducedMotion() {
              return (
                !!matchMedia &&
                (null == o &&
                  (o = matchMedia('(prefers-reduced-motion: reduce)')),
                o.matches)
              );
            },
          },
          s = new (class {
            constructor() {
              (this._realTime =
                'undefined' != typeof performance &&
                performance &&
                performance.now
                  ? performance.now.bind(performance)
                  : Date.now.bind(Date)),
                (this._frozenAt = null);
            }
            getCurrentTime() {
              return null !== this._frozenAt
                ? this._frozenAt
                : this._realTime();
            }
            setNow(t) {
              this._frozenAt = t;
            }
            restoreNow() {
              this._frozenAt = null;
            }
            isFrozen() {
              return null !== this._frozenAt;
            }
          })();
        function l() {
          return s.getCurrentTime();
        }
        class c {
          static testProp(t) {
            if (!c.docStyle) return t[0];
            for (let e = 0; e < t.length; e++)
              if (t[e] in c.docStyle) return t[e];
            return t[0];
          }
          static create(t, e, i) {
            const r = window.document.createElement(t);
            return void 0 !== e && (r.className = e), i && i.appendChild(r), r;
          }
          static createNS(t, e) {
            return window.document.createElementNS(t, e);
          }
          static disableDrag() {
            c.docStyle &&
              c.selectProp &&
              ((c.userSelect = c.docStyle[c.selectProp]),
              (c.docStyle[c.selectProp] = 'none'));
          }
          static enableDrag() {
            c.docStyle &&
              c.selectProp &&
              (c.docStyle[c.selectProp] = c.userSelect);
          }
          static setTransform(t, e) {
            t.style[c.transformProp] = e;
          }
          static addEventListener(t, e, i, r = {}) {
            t.addEventListener(e, i, 'passive' in r ? r : r.capture);
          }
          static removeEventListener(t, e, i, r = {}) {
            t.removeEventListener(e, i, 'passive' in r ? r : r.capture);
          }
          static suppressClickInternal(t) {
            t.preventDefault(),
              t.stopPropagation(),
              window.removeEventListener('click', c.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener('click', c.suppressClickInternal, !0),
              window.setTimeout(() => {
                window.removeEventListener(
                  'click',
                  c.suppressClickInternal,
                  !0
                );
              }, 0);
          }
          static getScale(t) {
            const e = t.getBoundingClientRect();
            return {
              x: e.width / t.offsetWidth || 1,
              y: e.height / t.offsetHeight || 1,
              boundingClientRect: e,
            };
          }
          static getPoint(t, i, r) {
            const n = i.boundingClientRect;
            return new e.P(
              (r.clientX - n.left) / i.x - t.clientLeft,
              (r.clientY - n.top) / i.y - t.clientTop
            );
          }
          static mousePos(t, e) {
            const i = c.getScale(t);
            return c.getPoint(t, i, e);
          }
          static touchPos(t, e) {
            const i = [],
              r = c.getScale(t);
            for (let n = 0; n < e.length; n++) i.push(c.getPoint(t, r, e[n]));
            return i;
          }
          static mouseButton(t) {
            return t.button;
          }
          static remove(t) {
            t.parentNode && t.parentNode.removeChild(t);
          }
          static sanitize(t) {
            const e =
                new DOMParser().parseFromString(t, 'text/html').body ||
                document.createElement('body'),
              i = e.querySelectorAll('script');
            for (const r of i) r.remove();
            return c.clean(e), e.innerHTML;
          }
          static isPossiblyDangerous(t, e) {
            const i = e.replace(/\s+/g, '').toLowerCase();
            return (
              !(
                !['src', 'href', 'xlink:href'].includes(t) ||
                (!i.includes('javascript:') && !i.includes('data:'))
              ) ||
              !!t.startsWith('on') ||
              void 0
            );
          }
          static clean(t) {
            const e = t.children;
            for (const i of e) c.removeAttributes(i), c.clean(i);
          }
          static removeAttributes(t) {
            for (const { name: e, value: i } of t.attributes)
              c.isPossiblyDangerous(e, i) && t.removeAttribute(e);
          }
        }
        (c.docStyle =
          'undefined' != typeof window &&
          window.document &&
          window.document.documentElement.style),
          (c.selectProp = c.testProp([
            'userSelect',
            'MozUserSelect',
            'WebkitUserSelect',
            'msUserSelect',
          ])),
          (c.transformProp = c.testProp(['transform', 'WebkitTransform']));
        const h = {
          supported: !1,
          testSupport: function (t) {
            !p && d && (f ? m(t) : (u = t));
          },
        };
        let u,
          d,
          p = !1,
          f = !1;
        function m(t) {
          const e = t.createTexture();
          t.bindTexture(t.TEXTURE_2D, e);
          try {
            if (
              (t.texImage2D(
                t.TEXTURE_2D,
                0,
                t.RGBA,
                t.RGBA,
                t.UNSIGNED_BYTE,
                d
              ),
              t.isContextLost())
            )
              return;
            h.supported = !0;
          } catch (t) {}
          t.deleteTexture(e), (p = !0);
        }
        var _;
        'undefined' != typeof document &&
          ((d = document.createElement('img')),
          (d.onload = () => {
            u && m(u), (u = null), (f = !0);
          }),
          (d.onerror = () => {
            (p = !0), (u = null);
          }),
          (d.src =
            'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=')),
          (function (t) {
            let i, r, n, o;
            (t.resetRequestQueue = () => {
              (i = []), (r = 0), (n = 0), (o = {});
            }),
              (t.addThrottleControl = (t) => {
                const e = n++;
                return (o[e] = t), e;
              }),
              (t.removeThrottleControl = (t) => {
                delete o[t], s();
              }),
              (t.getImage = (t, r, n = !0) =>
                new Promise((o, a) => {
                  h.supported &&
                    (t.headers || (t.headers = {}),
                    (t.headers.accept = 'image/webp,*/*')),
                    e.e(t, { type: 'image' }),
                    i.push({
                      abortController: r,
                      requestParameters: t,
                      supportImageRefresh: n,
                      state: 'queued',
                      onError: (t) => {
                        a(t);
                      },
                      onSuccess: (t) => {
                        o(t);
                      },
                    }),
                    s();
                }));
            const a = (t) =>
                e._(this, void 0, void 0, function* () {
                  t.state = 'running';
                  const {
                      requestParameters: i,
                      supportImageRefresh: n,
                      onError: o,
                      onSuccess: a,
                      abortController: c,
                    } = t,
                    h =
                      !1 === n &&
                      !e.i(self) &&
                      !e.g(i.url) &&
                      (!i.headers ||
                        Object.keys(i.headers).reduce(
                          (t, e) => t && 'accept' === e,
                          !0
                        ));
                  r++;
                  const u = h ? l(i, c) : e.m(i, c);
                  try {
                    const i = yield u;
                    delete t.abortController,
                      (t.state = 'completed'),
                      i.data instanceof HTMLImageElement || e.b(i.data)
                        ? a(i)
                        : i.data &&
                          a({
                            data: yield ((d = i.data),
                            'function' == typeof createImageBitmap
                              ? e.f(d)
                              : e.h(d)),
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                          });
                  } catch (e) {
                    delete t.abortController, o(e);
                  } finally {
                    r--, s();
                  }
                  var d;
                }),
              s = () => {
                const t = (() => {
                  for (const t of Object.keys(o)) if (o[t]()) return !0;
                  return !1;
                })()
                  ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME
                  : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
                for (let e = r; e < t && i.length > 0; e++) {
                  const t = i.shift();
                  t.abortController.signal.aborted ? e-- : a(t);
                }
              },
              l = (t, i) =>
                new Promise((r, n) => {
                  const o = new Image(),
                    a = t.url,
                    s = t.credentials;
                  s && 'include' === s
                    ? (o.crossOrigin = 'use-credentials')
                    : ((s && 'same-origin' === s) || !e.d(a)) &&
                      (o.crossOrigin = 'anonymous'),
                    i.signal.addEventListener('abort', () => {
                      (o.src = ''), n(e.c());
                    }),
                    (o.fetchPriority = 'high'),
                    (o.onload = () => {
                      (o.onerror = o.onload = null), r({ data: o });
                    }),
                    (o.onerror = () => {
                      (o.onerror = o.onload = null),
                        i.signal.aborted ||
                          n(
                            new Error(
                              'Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'
                            )
                          );
                    }),
                    (o.src = a);
                });
          })(_ || (_ = {})),
          _.resetRequestQueue();
        class g {
          constructor(t) {
            this._transformRequestFn = null != t ? t : null;
          }
          transformRequest(t, e) {
            return (
              (this._transformRequestFn && this._transformRequestFn(t, e)) || {
                url: t,
              }
            );
          }
          setTransformRequest(t) {
            this._transformRequestFn = t;
          }
        }
        function y(t) {
          const e = [];
          if ('string' == typeof t) e.push({ id: 'default', url: t });
          else if (t && t.length > 0) {
            const i = [];
            for (const { id: r, url: n } of t) {
              const t = `${r}${n}`;
              -1 === i.indexOf(t) && (i.push(t), e.push({ id: r, url: n }));
            }
          }
          return e;
        }
        function x(t, e, i) {
          try {
            const r = new URL(t);
            return (r.pathname += `${e}${i}`), r.toString();
          } catch (e) {
            throw new Error(
              `Invalid sprite URL "${t}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`
            );
          }
        }
        function v(t) {
          const { userImage: e } = t;
          return (
            !!(e && e.render && e.render()) &&
            (t.data.replace(new Uint8Array(e.data.buffer)), !0)
          );
        }
        class b extends e.E {
          constructor() {
            super(),
              (this.images = {}),
              (this.updatedImages = {}),
              (this.callbackDispatchedThisFrame = {}),
              (this.loaded = !1),
              (this.requestors = []),
              (this.patterns = {}),
              (this.atlasImage = new e.R({ width: 1, height: 1 })),
              (this.dirty = !0);
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t) {
            if (this.loaded !== t && ((this.loaded = t), t)) {
              for (const { ids: t, promiseResolve: e } of this.requestors)
                e(this._getImagesForIds(t));
              this.requestors = [];
            }
          }
          getImage(t) {
            const i = this.images[t];
            if (i && !i.data && i.spriteData) {
              const t = i.spriteData;
              (i.data = new e.R(
                { width: t.width, height: t.height },
                t.context.getImageData(t.x, t.y, t.width, t.height).data
              )),
                (i.spriteData = null);
            }
            return i;
          }
          addImage(t, e) {
            if (this.images[t])
              throw new Error(
                `Image id ${t} already exist, use updateImage instead`
              );
            this._validate(t, e) && (this.images[t] = e);
          }
          _validate(t, i) {
            let r = !0;
            const n = i.data || i.spriteData;
            return (
              this._validateStretch(i.stretchX, n && n.width) ||
                (this.fire(
                  new e.k(
                    new Error(`Image "${t}" has invalid "stretchX" value`)
                  )
                ),
                (r = !1)),
              this._validateStretch(i.stretchY, n && n.height) ||
                (this.fire(
                  new e.k(
                    new Error(`Image "${t}" has invalid "stretchY" value`)
                  )
                ),
                (r = !1)),
              this._validateContent(i.content, i) ||
                (this.fire(
                  new e.k(new Error(`Image "${t}" has invalid "content" value`))
                ),
                (r = !1)),
              r
            );
          }
          _validateStretch(t, e) {
            if (!t) return !0;
            let i = 0;
            for (const r of t) {
              if (r[0] < i || r[1] < r[0] || e < r[1]) return !1;
              i = r[1];
            }
            return !0;
          }
          _validateContent(t, e) {
            if (!t) return !0;
            if (4 !== t.length) return !1;
            const i = e.spriteData,
              r = (i && i.width) || e.data.width,
              n = (i && i.height) || e.data.height;
            return !(
              t[0] < 0 ||
              r < t[0] ||
              t[1] < 0 ||
              n < t[1] ||
              t[2] < 0 ||
              r < t[2] ||
              t[3] < 0 ||
              n < t[3] ||
              t[2] < t[0] ||
              t[3] < t[1]
            );
          }
          updateImage(t, e, i = !0) {
            const r = this.getImage(t);
            if (
              i &&
              (r.data.width !== e.data.width || r.data.height !== e.data.height)
            )
              throw new Error(
                `size mismatch between old image (${r.data.width}x${r.data.height}) and new image (${e.data.width}x${e.data.height}).`
              );
            (e.version = r.version + 1),
              (this.images[t] = e),
              (this.updatedImages[t] = !0);
          }
          removeImage(t) {
            const e = this.images[t];
            delete this.images[t],
              delete this.patterns[t],
              e.userImage && e.userImage.onRemove && e.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t) {
            return new Promise((e, i) => {
              let r = !0;
              if (!this.isLoaded())
                for (const n of t) this.images[n] || (r = !1);
              this.isLoaded() || r
                ? e(this._getImagesForIds(t))
                : this.requestors.push({ ids: t, promiseResolve: e });
            });
          }
          _getImagesForIds(t) {
            const i = {};
            for (const r of t) {
              let t = this.getImage(r);
              t ||
                (this.fire(new e.l('styleimagemissing', { id: r })),
                (t = this.getImage(r))),
                t
                  ? (i[r] = {
                      data: t.data.clone(),
                      pixelRatio: t.pixelRatio,
                      sdf: t.sdf,
                      version: t.version,
                      stretchX: t.stretchX,
                      stretchY: t.stretchY,
                      content: t.content,
                      textFitWidth: t.textFitWidth,
                      textFitHeight: t.textFitHeight,
                      hasRenderCallback: Boolean(
                        t.userImage && t.userImage.render
                      ),
                    })
                  : e.w(
                      `Image "${r}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                    );
            }
            return i;
          }
          getPixelSize() {
            const { width: t, height: e } = this.atlasImage;
            return { width: t, height: e };
          }
          getPattern(t) {
            const i = this.patterns[t],
              r = this.getImage(t);
            if (!r) return null;
            if (i && i.position.version === r.version) return i.position;
            if (i) i.position.version = r.version;
            else {
              const i = {
                  w: r.data.width + 2,
                  h: r.data.height + 2,
                  x: 0,
                  y: 0,
                },
                n = new e.I(i, r);
              this.patterns[t] = { bin: i, position: n };
            }
            return this._updatePatternAtlas(), this.patterns[t].position;
          }
          bind(t) {
            const i = t.gl;
            this.atlasTexture
              ? this.dirty &&
                (this.atlasTexture.update(this.atlasImage), (this.dirty = !1))
              : (this.atlasTexture = new e.T(t, this.atlasImage, i.RGBA)),
              this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t = [];
            for (const e in this.patterns) t.push(this.patterns[e].bin);
            const { w: i, h: r } = e.p(t),
              n = this.atlasImage;
            n.resize({ width: i || 1, height: r || 1 });
            for (const o in this.patterns) {
              const { bin: t } = this.patterns[o],
                i = t.x + 1,
                r = t.y + 1,
                a = this.getImage(o).data,
                s = a.width,
                l = a.height;
              e.R.copy(
                a,
                n,
                { x: 0, y: 0 },
                { x: i, y: r },
                { width: s, height: l }
              ),
                e.R.copy(
                  a,
                  n,
                  { x: 0, y: l - 1 },
                  { x: i, y: r - 1 },
                  { width: s, height: 1 }
                ),
                e.R.copy(
                  a,
                  n,
                  { x: 0, y: 0 },
                  { x: i, y: r + l },
                  { width: s, height: 1 }
                ),
                e.R.copy(
                  a,
                  n,
                  { x: s - 1, y: 0 },
                  { x: i - 1, y: r },
                  { width: 1, height: l }
                ),
                e.R.copy(
                  a,
                  n,
                  { x: 0, y: 0 },
                  { x: i + s, y: r },
                  { width: 1, height: l }
                );
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t) {
            for (const i of t) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const t = this.getImage(i);
              t || e.w(`Image with ID: "${i}" was not found`),
                v(t) && this.updateImage(i, t);
            }
          }
        }
        const w = 1e20;
        function T(t, e, i, r, n, o, a, s, l) {
          for (let c = e; c < e + r; c++) P(t, i * o + c, o, n, a, s, l);
          for (let c = i; c < i + n; c++) P(t, c * o + e, 1, r, a, s, l);
        }
        function P(t, e, i, r, n, o, a) {
          (o[0] = 0), (a[0] = -w), (a[1] = w), (n[0] = t[e]);
          for (let s = 1, l = 0, c = 0; s < r; s++) {
            n[s] = t[e + s * i];
            const r = s * s;
            do {
              const t = o[l];
              c = (n[s] - n[t] + r - t * t) / (s - t) / 2;
            } while (c <= a[l] && --l > -1);
            l++, (o[l] = s), (a[l] = c), (a[l + 1] = w);
          }
          for (let s = 0, l = 0; s < r; s++) {
            for (; a[l + 1] < s; ) l++;
            const r = o[l],
              c = s - r;
            t[e + s * i] = n[r] + c * c;
          }
        }
        const S = e.v.layout_symbol['text-font'].default.join(',');
        class M {
          constructor(t, e, i) {
            (this.requestManager = t),
              (this.localIdeographFontFamily = e),
              (this.entries = {}),
              (this.lang = i);
          }
          setURL(t) {
            this.url = t;
          }
          getGlyphs(t) {
            return e._(this, void 0, void 0, function* () {
              const e = [];
              for (const n in t)
                for (const i of t[n])
                  e.push(this._getAndCacheGlyphsPromise(n, i));
              const i = yield Promise.all(e),
                r = {};
              for (const { stack: t, id: n, glyph: o } of i)
                r[t] || (r[t] = {}),
                  (r[t][n] = o && {
                    id: o.id,
                    bitmap: o.bitmap.clone(),
                    metrics: o.metrics,
                  });
              return r;
            });
          }
          _getAndCacheGlyphsPromise(t, i) {
            return e._(this, void 0, void 0, function* () {
              let e = this.entries[t];
              e ||
                (e = this.entries[t] =
                  { glyphs: {}, requests: {}, ranges: {} });
              let r = e.glyphs[i];
              return void 0 !== r
                ? { stack: t, id: i, glyph: r }
                : !this.url || this._charUsesLocalIdeographFontFamily(i)
                ? ((r = e.glyphs[i] = this._drawGlyph(e, t, i)),
                  { stack: t, id: i, glyph: r })
                : yield this._downloadAndCacheRangePromise(t, i);
            });
          }
          _downloadAndCacheRangePromise(t, i) {
            return e._(this, void 0, void 0, function* () {
              const e = Math.floor(i / 256);
              if (256 * e > 65535)
                throw new Error('glyphs > 65535 not supported');
              const r = this.entries[t];
              if (r.ranges[e]) return { stack: t, id: i, glyph: null };
              if (!r.requests[e]) {
                const i = M.loadGlyphRange(t, e, this.url, this.requestManager);
                r.requests[e] = i;
              }
              try {
                const n = yield r.requests[e];
                for (const t in n) r.glyphs[+t] = n[+t];
                return (
                  (r.ranges[e] = !0), { stack: t, id: i, glyph: n[i] || null }
                );
              } catch (n) {
                const a = (r.glyphs[i] = this._drawGlyph(r, t, i));
                return (
                  this._warnOnMissingGlyphRange(a, e, i, n),
                  { stack: t, id: i, glyph: a }
                );
              }
            });
          }
          _warnOnMissingGlyphRange(t, i, r, n) {
            const o = 256 * i,
              a = o + 255,
              s = r.toString(16).padStart(4, '0').toUpperCase();
            e.w(
              `Unable to load glyph range ${i}, ${o}-${a}. Rendering codepoint U+${s} locally instead. ${n}`
            );
          }
          _charUsesLocalIdeographFontFamily(t) {
            return (
              !!this.localIdeographFontFamily &&
              (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(
                String.fromCodePoint(t)
              ) ||
                e.u['CJK Unified Ideographs'](t) ||
                e.u['Hangul Syllables'](t) ||
                e.u.Hiragana(t) ||
                e.u.Katakana(t) ||
                e.u['CJK Symbols and Punctuation'](t) ||
                e.u['Halfwidth and Fullwidth Forms'](t))
            );
          }
          _drawGlyph(t, i, r) {
            const n =
                i === S &&
                '' !== this.localIdeographFontFamily &&
                this._charUsesLocalIdeographFontFamily(r),
              o = n ? 'ideographTinySDF' : 'tinySDF';
            t[o] ||
              (t[o] = this._createTinySDF(
                n ? this.localIdeographFontFamily : i
              ));
            const a = t[o].draw(String.fromCharCode(r));
            return {
              id: r,
              bitmap: new e.q(
                { width: a.width || 60, height: a.height || 60 },
                a.data
              ),
              metrics: {
                width: a.glyphWidth / 2 || 24,
                height: a.glyphHeight / 2 || 24,
                left: a.glyphLeft / 2 + 0.5 || 0,
                top: a.glyphTop / 2 - 27.5 || -8,
                advance: a.glyphAdvance / 2 || 24,
                isDoubleResolution: !0,
              },
            };
          }
          _createTinySDF(t) {
            const e = t ? t.split(',') : [];
            e.push('sans-serif');
            const i = e
              .map((t) => (/[-\w]+/.test(t) ? t : `'${CSS.escape(t)}'`))
              .join(',');
            return new M.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: 0.25,
              fontFamily: i,
              fontWeight: this._fontWeight(e[0]),
              fontStyle: this._fontStyle(e[0]),
              lang: this.lang,
            });
          }
          _fontStyle(t) {
            return /italic/i.test(t)
              ? 'italic'
              : /oblique/i.test(t)
              ? 'oblique'
              : 'normal';
          }
          _fontWeight(t) {
            const e = {
              'thin': 100,
              'hairline': 100,
              'extra light': 200,
              'ultra light': 200,
              'light': 300,
              'normal': 400,
              'regular': 400,
              'medium': 500,
              'semibold': 600,
              'demibold': 600,
              'bold': 700,
              'extra bold': 800,
              'ultra bold': 800,
              'black': 900,
              'heavy': 900,
              'extra black': 950,
              'ultra black': 950,
            };
            let i;
            for (const [r, n] of Object.entries(e))
              new RegExp(`\\b${r}\\b`, 'i').test(t) && (i = `${n}`);
            return i;
          }
        }
        (M.loadGlyphRange = function (t, i, r, n) {
          return e._(this, void 0, void 0, function* () {
            const o = 256 * i,
              a = o + 255,
              s = n.transformRequest(
                r.replace('{fontstack}', t).replace('{range}', `${o}-${a}`),
                'Glyphs'
              ),
              l = yield e.n(s, new AbortController());
            if (!l || !l.data)
              throw new Error(
                `Could not load glyph range. range: ${i}, ${o}-${a}`
              );
            const c = {};
            for (const t of e.o(l.data)) c[t.id] = t;
            return c;
          });
        }),
          (M.TinySDF = class {
            constructor({
              fontSize: t = 24,
              buffer: e = 3,
              radius: i = 8,
              cutoff: r = 0.25,
              fontFamily: n = 'sans-serif',
              fontWeight: o = 'normal',
              fontStyle: a = 'normal',
              lang: s = null,
            } = {}) {
              (this.buffer = e),
                (this.cutoff = r),
                (this.radius = i),
                (this.lang = s);
              const l = (this.size = t + 4 * e),
                c = this._createCanvas(l),
                h = (this.ctx = c.getContext('2d', { willReadFrequently: !0 }));
              (h.font = `${a} ${o} ${t}px ${n}`),
                (h.textBaseline = 'alphabetic'),
                (h.textAlign = 'left'),
                (h.fillStyle = 'black'),
                (this.gridOuter = new Float64Array(l * l)),
                (this.gridInner = new Float64Array(l * l)),
                (this.f = new Float64Array(l)),
                (this.z = new Float64Array(l + 1)),
                (this.v = new Uint16Array(l));
            }
            _createCanvas(t) {
              const e = document.createElement('canvas');
              return (e.width = e.height = t), e;
            }
            draw(t) {
              const {
                  width: e,
                  actualBoundingBoxAscent: i,
                  actualBoundingBoxDescent: r,
                  actualBoundingBoxLeft: n,
                  actualBoundingBoxRight: o,
                } = this.ctx.measureText(t),
                a = Math.ceil(i),
                s = Math.max(
                  0,
                  Math.min(this.size - this.buffer, Math.ceil(o - n))
                ),
                l = Math.min(this.size - this.buffer, a + Math.ceil(r)),
                c = s + 2 * this.buffer,
                h = l + 2 * this.buffer,
                u = Math.max(c * h, 0),
                d = new Uint8ClampedArray(u),
                p = {
                  data: d,
                  width: c,
                  height: h,
                  glyphWidth: s,
                  glyphHeight: l,
                  glyphTop: a,
                  glyphLeft: 0,
                  glyphAdvance: e,
                };
              if (0 === s || 0 === l) return p;
              const { ctx: f, buffer: m, gridInner: _, gridOuter: g } = this;
              this.lang && (f.lang = this.lang),
                f.clearRect(m, m, s, l),
                f.fillText(t, m, m + a);
              const y = f.getImageData(m, m, s, l);
              g.fill(w, 0, u), _.fill(0, 0, u);
              for (let x = 0; x < l; x++)
                for (let t = 0; t < s; t++) {
                  const e = y.data[4 * (x * s + t) + 3] / 255;
                  if (0 === e) continue;
                  const i = (x + m) * c + t + m;
                  if (1 === e) (g[i] = 0), (_[i] = w);
                  else {
                    const t = 0.5 - e;
                    (g[i] = t > 0 ? t * t : 0), (_[i] = t < 0 ? t * t : 0);
                  }
                }
              T(g, 0, 0, c, h, c, this.f, this.v, this.z),
                T(_, m, m, s, l, c, this.f, this.v, this.z);
              for (let x = 0; x < u; x++) {
                const t = Math.sqrt(g[x]) - Math.sqrt(_[x]);
                d[x] = Math.round(255 - 255 * (t / this.radius + this.cutoff));
              }
              return p;
            }
          });
        class I {
          constructor() {
            this.specification = e.t.light.position;
          }
          possiblyEvaluate(t, i) {
            return e.C(t.expression.evaluate(i));
          }
          interpolate(t, i, r) {
            return {
              x: e.F.number(t.x, i.x, r),
              y: e.F.number(t.y, i.y, r),
              z: e.F.number(t.z, i.z, r),
            };
          }
        }
        let C;
        class A extends e.E {
          constructor(t) {
            super(),
              (C =
                C ||
                new e.r({
                  anchor: new e.D(e.t.light.anchor),
                  position: new I(),
                  color: new e.D(e.t.light.color),
                  intensity: new e.D(e.t.light.intensity),
                })),
              (this._transitionable = new e.x(C, void 0)),
              this.setLight(t),
              (this._transitioning = this._transitionable.untransitioned());
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, i = {}) {
            if (!this._validate(e.y, t, i))
              for (const e in t) {
                const i = t[e];
                e.endsWith('-transition')
                  ? this._transitionable.setTransition(e.slice(0, -11), i)
                  : this._transitionable.setValue(e, i);
              }
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(
              t,
              this._transitioning
            );
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, i, r) {
            return (
              (!r || !1 !== r.validate) &&
              e.z(
                this,
                t.call(e.B, {
                  value: i,
                  style: { glyphs: !0, sprite: !0 },
                  styleSpec: e.t,
                })
              )
            );
          }
        }
        const E = new e.r({
          'sky-color': new e.D(e.t.sky['sky-color']),
          'horizon-color': new e.D(e.t.sky['horizon-color']),
          'fog-color': new e.D(e.t.sky['fog-color']),
          'fog-ground-blend': new e.D(e.t.sky['fog-ground-blend']),
          'horizon-fog-blend': new e.D(e.t.sky['horizon-fog-blend']),
          'sky-horizon-blend': new e.D(e.t.sky['sky-horizon-blend']),
          'atmosphere-blend': new e.D(e.t.sky['atmosphere-blend']),
        });
        class z extends e.E {
          constructor(t) {
            super(),
              (this._transitionable = new e.x(E, void 0)),
              this.setSky(t),
              (this._transitioning = this._transitionable.untransitioned()),
              this.recalculate(new e.G(0));
          }
          setSky(t, i = {}) {
            if (!this._validate(e.H, t, i)) {
              t ||
                (t = {
                  'sky-color': 'transparent',
                  'horizon-color': 'transparent',
                  'fog-color': 'transparent',
                  'fog-ground-blend': 1,
                  'atmosphere-blend': 0,
                });
              for (const e in t) {
                const i = t[e];
                e.endsWith('-transition')
                  ? this._transitionable.setTransition(e.slice(0, -11), i)
                  : this._transitionable.setValue(e, i);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(
              t,
              this._transitioning
            );
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, i, r = {}) {
            return (
              !1 !== (null == r ? void 0 : r.validate) &&
              e.z(
                this,
                t.call(
                  e.B,
                  e.e({
                    value: i,
                    style: { glyphs: !0, sprite: !0 },
                    styleSpec: e.t,
                  })
                )
              )
            );
          }
          calculateFogBlendOpacity(t) {
            return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
          }
        }
        class k {
          constructor(t, e) {
            (this.width = t),
              (this.height = e),
              (this.nextRow = 0),
              (this.data = new Uint8Array(this.width * this.height)),
              (this.dashEntry = {});
          }
          getDash(t, e) {
            const i = t.join(',') + String(e);
            return (
              this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)),
              this.dashEntry[i]
            );
          }
          getDashRanges(t, e, i) {
            const r = [];
            let n = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,
              o = t[0] * i,
              a = !0;
            r.push({ left: n, right: o, isDash: a, zeroLength: 0 === t[0] });
            let s = t[0];
            for (let l = 1; l < t.length; l++) {
              a = !a;
              const e = t[l];
              (n = s * i),
                (s += e),
                (o = s * i),
                r.push({ left: n, right: o, isDash: a, zeroLength: 0 === e });
            }
            return r;
          }
          addRoundDash(t, e, i) {
            const r = e / 2;
            for (let n = -i; n <= i; n++) {
              const e = this.width * (this.nextRow + i + n);
              let o = 0,
                a = t[o];
              for (let s = 0; s < this.width; s++) {
                s / a.right > 1 && (a = t[++o]);
                const l = Math.abs(s - a.left),
                  c = Math.abs(s - a.right),
                  h = Math.min(l, c);
                let u;
                const d = (n / i) * (r + 1);
                if (a.isDash) {
                  const t = r - Math.abs(d);
                  u = Math.sqrt(h * h + t * t);
                } else u = r - Math.sqrt(h * h + d * d);
                this.data[e + s] = Math.max(0, Math.min(255, u + 128));
              }
            }
          }
          addRegularDash(t) {
            for (let a = t.length - 1; a >= 0; --a) {
              const e = t[a],
                i = t[a + 1];
              e.zeroLength
                ? t.splice(a, 1)
                : i &&
                  i.isDash === e.isDash &&
                  ((i.left = e.left), t.splice(a, 1));
            }
            const e = t[0],
              i = t[t.length - 1];
            e.isDash === i.isDash &&
              ((e.left = i.left - this.width),
              (i.right = e.right + this.width));
            const r = this.width * this.nextRow;
            let n = 0,
              o = t[n];
            for (let a = 0; a < this.width; a++) {
              a / o.right > 1 && (o = t[++n]);
              const e = Math.abs(a - o.left),
                i = Math.abs(a - o.right),
                s = Math.min(e, i);
              this.data[r + a] = Math.max(
                0,
                Math.min(255, (o.isDash ? s : -s) + 128)
              );
            }
          }
          addDash(t, i) {
            const r = i ? 7 : 0,
              n = 2 * r + 1;
            if (this.nextRow + n > this.height)
              return e.w('LineAtlas out of space'), null;
            let o = 0;
            for (let e = 0; e < t.length; e++) o += t[e];
            if (0 !== o) {
              const e = this.width / o,
                n = this.getDashRanges(t, this.width, e);
              i ? this.addRoundDash(n, e, r) : this.addRegularDash(n);
            }
            const a = { y: this.nextRow + r, height: 2 * r, width: o };
            return (this.nextRow += n), (this.dirty = !0), a;
          }
          bind(t) {
            const e = t.gl;
            this.texture
              ? (e.bindTexture(e.TEXTURE_2D, this.texture),
                this.dirty &&
                  ((this.dirty = !1),
                  e.texSubImage2D(
                    e.TEXTURE_2D,
                    0,
                    0,
                    0,
                    this.width,
                    this.height,
                    e.ALPHA,
                    e.UNSIGNED_BYTE,
                    this.data
                  )))
              : ((this.texture = e.createTexture()),
                e.bindTexture(e.TEXTURE_2D, this.texture),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
                e.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  e.ALPHA,
                  this.width,
                  this.height,
                  0,
                  e.ALPHA,
                  e.UNSIGNED_BYTE,
                  this.data
                ));
          }
        }
        const D = 'maplibre_preloaded_worker_pool';
        class R {
          constructor() {
            this.active = {};
          }
          acquire(t) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < R.workerCount; )
                this.workers.push(new Worker(e.a.WORKER_URL));
            return (this.active[t] = !0), this.workers.slice();
          }
          release(t) {
            delete this.active[t],
              0 === this.numActive() &&
                (this.workers.forEach((t) => {
                  t.terminate();
                }),
                (this.workers = null));
          }
          isPreloaded() {
            return !!this.active[D];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const L = Math.floor(a.hardwareConcurrency / 2);
        let F, B;
        function O() {
          return F || (F = new R()), F;
        }
        R.workerCount = e.J(globalThis) ? Math.max(Math.min(L, 3), 1) : 1;
        class j {
          constructor(t, i) {
            (this.workerPool = t),
              (this.actors = []),
              (this.currentActor = 0),
              (this.id = i);
            const r = this.workerPool.acquire(i);
            for (let n = 0; n < r.length; n++) {
              const t = new e.K(r[n], i);
              (t.name = `Worker ${n}`), this.actors.push(t);
            }
            if (!this.actors.length) throw new Error('No actors found');
          }
          broadcast(t, e) {
            const i = [];
            for (const r of this.actors)
              i.push(r.sendAsync({ type: t, data: e }));
            return Promise.all(i);
          }
          getActor() {
            return (
              (this.currentActor =
                (this.currentActor + 1) % this.actors.length),
              this.actors[this.currentActor]
            );
          }
          remove(t = !0) {
            this.actors.forEach((t) => {
              t.remove();
            }),
              (this.actors = []),
              t && this.workerPool.release(this.id);
          }
          registerMessageHandler(t, e) {
            for (const i of this.actors) i.registerMessageHandler(t, e);
          }
        }
        function N() {
          return (
            B ||
              ((B = new j(O(), e.L)),
              B.registerMessageHandler('GR', (t, i, r) => e.m(i, r))),
            B
          );
        }
        function V(t, i) {
          const r = e.M();
          return (
            e.N(r, r, [1, 1, 0]),
            e.O(r, r, [0.5 * t.width, 0.5 * t.height, 1]),
            t.calculatePosMatrix
              ? e.Q(r, r, t.calculatePosMatrix(i.toUnwrapped()))
              : r
          );
        }
        function U(t, e, i, r, n, o, a) {
          var s;
          const l = (function (t, e, i) {
              if (t)
                for (const r of t) {
                  const t = e[r];
                  if (t && t.source === i && 'fill-extrusion' === t.type)
                    return !0;
                }
              else
                for (const r in e) {
                  const t = e[r];
                  if (t.source === i && 'fill-extrusion' === t.type) return !0;
                }
              return !1;
            })(
              null !== (s = null == n ? void 0 : n.layers) && void 0 !== s
                ? s
                : null,
              e,
              t.id
            ),
            c = o.maxPitchScaleFactor(),
            h = t.tilesIn(r, c, l);
          h.sort(G);
          const u = [];
          for (const d of h)
            u.push({
              wrappedTileID: d.tileID.wrapped().key,
              queryResults: d.tile.queryRenderedFeatures(
                e,
                i,
                t.getState(),
                d.queryGeometry,
                d.cameraQueryGeometry,
                d.scale,
                n,
                o,
                c,
                V(o, d.tileID),
                a ? (t, e) => a(d.tileID, t, e) : void 0
              ),
            });
          return (function (t, e) {
            for (const i in t) for (const r of t[i]) Z(r, e);
            return t;
          })(
            (function (t) {
              const e = {},
                i = {};
              for (const r of t) {
                const t = r.queryResults,
                  n = r.wrappedTileID,
                  o = (i[n] = i[n] || {});
                for (const i in t) {
                  const r = t[i],
                    n = (o[i] = o[i] || {}),
                    a = (e[i] = e[i] || []);
                  for (const t of r)
                    n[t.featureIndex] || ((n[t.featureIndex] = !0), a.push(t));
                }
              }
              return e;
            })(u),
            t
          );
        }
        function G(t, e) {
          const i = t.tileID,
            r = e.tileID;
          return (
            i.overscaledZ - r.overscaledZ ||
            i.canonical.y - r.canonical.y ||
            i.wrap - r.wrap ||
            i.canonical.x - r.canonical.x
          );
        }
        function Z(t, e) {
          const i = t.feature,
            r = e.getFeatureState(i.layer['source-layer'], i.id);
          (i.source = i.layer.source),
            i.layer['source-layer'] &&
              (i.sourceLayer = i.layer['source-layer']),
            (i.state = r);
        }
        function $(t, i, r) {
          return e._(this, void 0, void 0, function* () {
            let n = t;
            if (
              (t.url
                ? (n = (yield e.j(i.transformRequest(t.url, 'Source'), r)).data)
                : yield a.frameAsync(r),
              !n)
            )
              return null;
            const o = e.S(e.e(n, t), [
              'tiles',
              'minzoom',
              'maxzoom',
              'attribution',
              'bounds',
              'scheme',
              'tileSize',
              'encoding',
            ]);
            return (
              'vector_layers' in n &&
                n.vector_layers &&
                (o.vectorLayerIds = n.vector_layers.map((t) => t.id)),
              o
            );
          });
        }
        class q {
          constructor(t, e) {
            t &&
              (e
                ? this.setSouthWest(t).setNorthEast(e)
                : Array.isArray(t) &&
                  (4 === t.length
                    ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]])
                    : this.setSouthWest(t[0]).setNorthEast(t[1])));
          }
          setNorthEast(t) {
            return (
              (this._ne =
                t instanceof e.U ? new e.U(t.lng, t.lat) : e.U.convert(t)),
              this
            );
          }
          setSouthWest(t) {
            return (
              (this._sw =
                t instanceof e.U ? new e.U(t.lng, t.lat) : e.U.convert(t)),
              this
            );
          }
          extend(t) {
            const i = this._sw,
              r = this._ne;
            let n, o;
            if (t instanceof e.U) (n = t), (o = t);
            else {
              if (!(t instanceof q))
                return Array.isArray(t)
                  ? 4 === t.length || t.every(Array.isArray)
                    ? this.extend(q.convert(t))
                    : this.extend(e.U.convert(t))
                  : t && ('lng' in t || 'lon' in t) && 'lat' in t
                  ? this.extend(e.U.convert(t))
                  : this;
              if (((n = t._sw), (o = t._ne), !n || !o)) return this;
            }
            return (
              i || r
                ? ((i.lng = Math.min(n.lng, i.lng)),
                  (i.lat = Math.min(n.lat, i.lat)),
                  (r.lng = Math.max(o.lng, r.lng)),
                  (r.lat = Math.max(o.lat, r.lat)))
                : ((this._sw = new e.U(n.lng, n.lat)),
                  (this._ne = new e.U(o.lng, o.lat))),
              this
            );
          }
          getCenter() {
            return new e.U(
              (this._sw.lng + this._ne.lng) / 2,
              (this._sw.lat + this._ne.lat) / 2
            );
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new e.U(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new e.U(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t) {
            const { lng: i, lat: r } = e.U.convert(t);
            let n = this._sw.lng <= i && i <= this._ne.lng;
            return (
              this._sw.lng > this._ne.lng &&
                (n = this._sw.lng >= i && i >= this._ne.lng),
              this._sw.lat <= r && r <= this._ne.lat && n
            );
          }
          intersects(t) {
            if (
              (t = q.convert(t)).getNorth() < this.getSouth() ||
              t.getSouth() > this.getNorth()
            )
              return !1;
            const i = e.V(this.getWest(), -180, 180),
              r = e.V(this.getEast(), -180, 180),
              n = e.V(t.getWest(), -180, 180),
              o = e.V(t.getEast(), -180, 180),
              a = i > r,
              s = n > o;
            return (
              !(!a || !s) ||
              (a ? o >= i || n <= r : s ? r >= n || i <= o : !(n > r || o < i))
            );
          }
          static convert(t) {
            return t instanceof q ? t : t ? new q(t) : t;
          }
          static fromLngLat(t, i = 0) {
            const r = (360 * i) / 40075017,
              n = r / Math.cos((Math.PI / 180) * t.lat);
            return new q(
              new e.U(t.lng - n, t.lat - r),
              new e.U(t.lng + n, t.lat + r)
            );
          }
          adjustAntiMeridian() {
            const t = new e.U(this._sw.lng, this._sw.lat),
              i = new e.U(this._ne.lng, this._ne.lat);
            return new q(t, t.lng > i.lng ? new e.U(i.lng + 360, i.lat) : i);
          }
        }
        class W {
          constructor(t, e, i) {
            (this.bounds = q.convert(this.validateBounds(t))),
              (this.minzoom = e || 0),
              (this.maxzoom = i || 24);
          }
          validateBounds(t) {
            return Array.isArray(t) && 4 === t.length
              ? [
                  Math.max(-180, t[0]),
                  Math.max(-90, t[1]),
                  Math.min(180, t[2]),
                  Math.min(90, t[3]),
                ]
              : [-180, -90, 180, 90];
          }
          contains(t) {
            const i = Math.pow(2, t.z),
              r = Math.floor(e.X(this.bounds.getWest()) * i),
              n = Math.floor(e.W(this.bounds.getNorth()) * i),
              o = Math.ceil(e.X(this.bounds.getEast()) * i),
              a = Math.ceil(e.W(this.bounds.getSouth()) * i);
            return t.x >= r && t.x < o && t.y >= n && t.y < a;
          }
        }
        class Y extends e.E {
          constructor(t, i, r, n) {
            if (
              (super(),
              (this.id = t),
              (this.dispatcher = r),
              (this.type = 'vector'),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.scheme = 'xyz'),
              (this.tileSize = 512),
              (this.reparseOverscaled = !0),
              (this.isTileClipped = !0),
              (this._loaded = !1),
              e.e(this, e.S(i, ['url', 'scheme', 'tileSize', 'promoteId'])),
              (this._options = e.e({ type: 'vector' }, i)),
              (this._collectResourceTiming = i.collectResourceTiming),
              512 !== this.tileSize)
            )
              throw new Error(
                'vector tile sources must have a tileSize of 512'
              );
            this.setEventedParent(n);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              (this._loaded = !1),
                this.fire(new e.l('dataloading', { dataType: 'source' })),
                (this._tileJSONRequest = new AbortController());
              try {
                const t = yield $(
                  this._options,
                  this.map._requestManager,
                  this._tileJSONRequest
                );
                (this._tileJSONRequest = null),
                  (this._loaded = !0),
                  this.map.style.tileManagers[this.id].clearTiles(),
                  t &&
                    (e.e(this, t),
                    t.bounds &&
                      (this.tileBounds = new W(
                        t.bounds,
                        this.minzoom,
                        this.maxzoom
                      )),
                    this.fire(
                      new e.l('data', {
                        dataType: 'source',
                        sourceDataType: 'metadata',
                      })
                    ),
                    this.fire(
                      new e.l('data', {
                        dataType: 'source',
                        sourceDataType: 'content',
                      })
                    ));
              } catch (t) {
                (this._tileJSONRequest = null),
                  (this._loaded = !0),
                  this.fire(new e.k(t));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            (this.map = t), this.load();
          }
          setSourceProperty(t) {
            this._tileJSONRequest && this._tileJSONRequest.abort(),
              t(),
              this.load();
          }
          setTiles(t) {
            return (
              this.setSourceProperty(() => {
                this._options.tiles = t;
              }),
              this
            );
          }
          setUrl(t) {
            return (
              this.setSourceProperty(() => {
                (this.url = t), (this._options.url = t);
              }),
              this
            );
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
          }
          serialize() {
            return e.e({}, this._options);
          }
          loadTile(t) {
            return e._(this, void 0, void 0, function* () {
              const e = t.tileID.canonical.url(
                  this.tiles,
                  this.map.getPixelRatio(),
                  this.scheme
                ),
                i = {
                  request: this.map._requestManager.transformRequest(e, 'Tile'),
                  uid: t.uid,
                  tileID: t.tileID,
                  zoom: t.tileID.overscaledZ,
                  tileSize: this.tileSize * t.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity:
                    this.map.style.projection.subdivisionGranularity,
                };
              i.request.collectResourceTiming = this._collectResourceTiming;
              let r = 'RT';
              if (t.actor && 'expired' !== t.state) {
                if ('loading' === t.state)
                  return new Promise((e, i) => {
                    t.reloadPromise = { resolve: e, reject: i };
                  });
              } else (t.actor = this.dispatcher.getActor()), (r = 'LT');
              t.abortController = new AbortController();
              try {
                const e = yield t.actor.sendAsync(
                  { type: r, data: i },
                  t.abortController
                );
                if ((delete t.abortController, t.aborted)) return;
                this._afterTileLoadWorkerResponse(t, e);
              } catch (e) {
                if ((delete t.abortController, t.aborted)) return;
                if (e && 404 !== e.status) throw e;
                this._afterTileLoadWorkerResponse(t, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(t, e) {
            if (
              (e && e.resourceTiming && (t.resourceTiming = e.resourceTiming),
              e && this.map._refreshExpiredTiles && t.setExpiryData(e),
              t.loadVectorData(e, this.map.painter),
              t.reloadPromise)
            ) {
              const e = t.reloadPromise;
              (t.reloadPromise = null),
                this.loadTile(t).then(e.resolve).catch(e.reject);
            }
          }
          abortTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.abortController &&
                (t.abortController.abort(), delete t.abortController),
                t.actor &&
                  (yield t.actor.sendAsync({
                    type: 'AT',
                    data: { uid: t.uid, type: this.type, source: this.id },
                  }));
            });
          }
          unloadTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.unloadVectorData(),
                t.actor &&
                  (yield t.actor.sendAsync({
                    type: 'RMT',
                    data: { uid: t.uid, type: this.type, source: this.id },
                  }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class H extends e.E {
          constructor(t, i, r, n) {
            super(),
              (this.id = t),
              (this.dispatcher = r),
              this.setEventedParent(n),
              (this.type = 'raster'),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.roundZoom = !0),
              (this.scheme = 'xyz'),
              (this.tileSize = 512),
              (this._loaded = !1),
              (this._options = e.e({ type: 'raster' }, i)),
              e.e(this, e.S(i, ['url', 'scheme', 'tileSize']));
          }
          load() {
            return e._(this, arguments, void 0, function* (t = !1) {
              (this._loaded = !1),
                this.fire(new e.l('dataloading', { dataType: 'source' })),
                (this._tileJSONRequest = new AbortController());
              try {
                const i = yield $(
                  this._options,
                  this.map._requestManager,
                  this._tileJSONRequest
                );
                (this._tileJSONRequest = null),
                  (this._loaded = !0),
                  i &&
                    (e.e(this, i),
                    i.bounds &&
                      (this.tileBounds = new W(
                        i.bounds,
                        this.minzoom,
                        this.maxzoom
                      )),
                    this.fire(
                      new e.l('data', {
                        dataType: 'source',
                        sourceDataType: 'metadata',
                      })
                    ),
                    this.fire(
                      new e.l('data', {
                        dataType: 'source',
                        sourceDataType: 'content',
                        sourceDataChanged: t,
                      })
                    ));
              } catch (t) {
                (this._tileJSONRequest = null),
                  (this._loaded = !0),
                  this.fire(new e.k(t));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            (this.map = t), this.load();
          }
          onRemove() {
            this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null));
          }
          setSourceProperty(t) {
            this._tileJSONRequest &&
              (this._tileJSONRequest.abort(), (this._tileJSONRequest = null)),
              t(),
              this.load(!0);
          }
          setTiles(t) {
            return (
              this.setSourceProperty(() => {
                this._options.tiles = t;
              }),
              this
            );
          }
          setUrl(t) {
            return (
              this.setSourceProperty(() => {
                (this.url = t), (this._options.url = t);
              }),
              this
            );
          }
          serialize() {
            return e.e({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t) {
            return e._(this, void 0, void 0, function* () {
              const i = t.tileID.canonical.url(
                this.tiles,
                this.map.getPixelRatio(),
                this.scheme
              );
              t.abortController = new AbortController();
              try {
                const r = yield _.getImage(
                  this.map._requestManager.transformRequest(i, 'Tile'),
                  t.abortController,
                  this.map._refreshExpiredTiles
                );
                if ((delete t.abortController, t.aborted))
                  return void (t.state = 'unloaded');
                if (r && r.data) {
                  this.map._refreshExpiredTiles &&
                    (r.cacheControl || r.expires) &&
                    t.setExpiryData({
                      cacheControl: r.cacheControl,
                      expires: r.expires,
                    });
                  const i = this.map.painter.context,
                    n = i.gl,
                    o = r.data;
                  (t.texture = this.map.painter.getTileTexture(o.width)),
                    t.texture
                      ? t.texture.update(o, { useMipmap: !0 })
                      : ((t.texture = new e.T(i, o, n.RGBA, { useMipmap: !0 })),
                        t.texture.bind(
                          n.LINEAR,
                          n.CLAMP_TO_EDGE,
                          n.LINEAR_MIPMAP_NEAREST
                        )),
                    (t.state = 'loaded');
                }
              } catch (e) {
                if ((delete t.abortController, t.aborted)) t.state = 'unloaded';
                else if (e) throw ((t.state = 'errored'), e);
              }
            });
          }
          abortTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.abortController &&
                (t.abortController.abort(), delete t.abortController);
            });
          }
          unloadTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.texture && this.map.painter.saveTileTexture(t.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class X extends H {
          constructor(t, i, r, n) {
            super(t, i, r, n),
              (this.type = 'raster-dem'),
              (this.maxzoom = 22),
              (this._options = e.e({ type: 'raster-dem' }, i)),
              (this.encoding = i.encoding || 'mapbox'),
              (this.redFactor = i.redFactor),
              (this.greenFactor = i.greenFactor),
              (this.blueFactor = i.blueFactor),
              (this.baseShift = i.baseShift);
          }
          loadTile(t) {
            return e._(this, void 0, void 0, function* () {
              const i = t.tileID.canonical.url(
                  this.tiles,
                  this.map.getPixelRatio(),
                  this.scheme
                ),
                r = this.map._requestManager.transformRequest(i, 'Tile');
              (t.neighboringTiles = this._getNeighboringTiles(t.tileID)),
                (t.abortController = new AbortController());
              try {
                const i = yield _.getImage(
                  r,
                  t.abortController,
                  this.map._refreshExpiredTiles
                );
                if ((delete t.abortController, t.aborted))
                  return void (t.state = 'unloaded');
                if (i && i.data) {
                  const r = i.data;
                  this.map._refreshExpiredTiles &&
                    (i.cacheControl || i.expires) &&
                    t.setExpiryData({
                      cacheControl: i.cacheControl,
                      expires: i.expires,
                    });
                  const n = e.b(r) && e.Y() ? r : yield this.readImageNow(r),
                    o = {
                      type: this.type,
                      uid: t.uid,
                      source: this.id,
                      rawImageData: n,
                      encoding: this.encoding,
                      redFactor: this.redFactor,
                      greenFactor: this.greenFactor,
                      blueFactor: this.blueFactor,
                      baseShift: this.baseShift,
                    };
                  if (!t.actor || 'expired' === t.state) {
                    t.actor = this.dispatcher.getActor();
                    const e = yield t.actor.sendAsync({ type: 'LDT', data: o });
                    (t.dem = e),
                      (t.needsHillshadePrepare = !0),
                      (t.needsTerrainPrepare = !0),
                      (t.state = 'loaded');
                  }
                }
              } catch (e) {
                if ((delete t.abortController, t.aborted)) t.state = 'unloaded';
                else if (e) throw ((t.state = 'errored'), e);
              }
            });
          }
          readImageNow(t) {
            return e._(this, void 0, void 0, function* () {
              if ('undefined' != typeof VideoFrame && e.Z()) {
                const i = t.width + 2,
                  r = t.height + 2;
                try {
                  return new e.R(
                    { width: i, height: r },
                    yield e.$(t, -1, -1, i, r)
                  );
                } catch (t) {}
              }
              return a.getImageData(t, 1);
            });
          }
          _getNeighboringTiles(t) {
            const i = t.canonical,
              r = Math.pow(2, i.z),
              n = (i.x - 1 + r) % r,
              o = 0 === i.x ? t.wrap - 1 : t.wrap,
              a = (i.x + 1 + r) % r,
              s = i.x + 1 === r ? t.wrap + 1 : t.wrap,
              l = {};
            return (
              (l[new e.a0(t.overscaledZ, o, i.z, n, i.y).key] = {
                backfilled: !1,
              }),
              (l[new e.a0(t.overscaledZ, s, i.z, a, i.y).key] = {
                backfilled: !1,
              }),
              i.y > 0 &&
                ((l[new e.a0(t.overscaledZ, o, i.z, n, i.y - 1).key] = {
                  backfilled: !1,
                }),
                (l[new e.a0(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {
                  backfilled: !1,
                }),
                (l[new e.a0(t.overscaledZ, s, i.z, a, i.y - 1).key] = {
                  backfilled: !1,
                })),
              i.y + 1 < r &&
                ((l[new e.a0(t.overscaledZ, o, i.z, n, i.y + 1).key] = {
                  backfilled: !1,
                }),
                (l[new e.a0(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {
                  backfilled: !1,
                }),
                (l[new e.a0(t.overscaledZ, s, i.z, a, i.y + 1).key] = {
                  backfilled: !1,
                })),
              l
            );
          }
          unloadTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.demTexture && this.map.painter.saveTileTexture(t.demTexture),
                t.fbo && (t.fbo.destroy(), delete t.fbo),
                t.dem && delete t.dem,
                delete t.neighboringTiles,
                (t.state = 'unloaded'),
                t.actor &&
                  (yield t.actor.sendAsync({
                    type: 'RDT',
                    data: { type: this.type, uid: t.uid, source: this.id },
                  }));
            });
          }
        }
        function K(t) {
          return 'GeometryCollection' === t.type
            ? t.geometries.map((t) => t.coordinates).flat(1 / 0)
            : t.coordinates.flat(1 / 0);
        }
        function J(t) {
          const e = new q();
          let i;
          switch (t.type) {
            case 'FeatureCollection':
              i = t.features.map((t) => K(t.geometry)).flat(1 / 0);
              break;
            case 'Feature':
              i = K(t.geometry);
              break;
            default:
              i = K(t);
          }
          if (0 == i.length) return e;
          for (let r = 0; r < i.length - 1; r += 2) e.extend([i[r], i[r + 1]]);
          return e;
        }
        class Q extends e.E {
          constructor(t, i, r, n) {
            super(),
              (this.id = t),
              (this.type = 'geojson'),
              (this.minzoom = 0),
              (this.maxzoom = 18),
              (this.tileSize = 512),
              (this.isTileClipped = !0),
              (this.reparseOverscaled = !0),
              (this._removed = !1),
              (this._isUpdatingWorker = !1),
              (this._pendingWorkerUpdate = { data: i.data }),
              (this.actor = r.getActor()),
              this.setEventedParent(n),
              (this._data = i.data),
              (this._options = e.e({}, i)),
              (this._collectResourceTiming = i.collectResourceTiming),
              void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
              i.type && (this.type = i.type),
              i.attribution && (this.attribution = i.attribution),
              (this.promoteId = i.promoteId),
              void 0 !== i.clusterMaxZoom &&
                this.maxzoom <= i.clusterMaxZoom &&
                e.w(
                  `The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`
                ),
              (this.workerOptions = e.e(
                {
                  source: this.id,
                  cluster: i.cluster || !1,
                  geojsonVtOptions: {
                    buffer: this._pixelsToTileUnits(
                      void 0 !== i.buffer ? i.buffer : 128
                    ),
                    tolerance: this._pixelsToTileUnits(
                      void 0 !== i.tolerance ? i.tolerance : 0.375
                    ),
                    extent: e.a3,
                    maxZoom: this.maxzoom,
                    lineMetrics: i.lineMetrics || !1,
                    generateId: i.generateId || !1,
                  },
                  superclusterOptions: {
                    maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
                    minPoints: Math.max(2, i.clusterMinPoints || 2),
                    extent: e.a3,
                    radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                    log: !1,
                    generateId: i.generateId || !1,
                  },
                  clusterProperties: i.clusterProperties,
                  filter: i.filter,
                },
                i.workerOptions
              )),
              'string' == typeof this.promoteId &&
                (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return (
              void 0 !== this._pendingWorkerUpdate.data ||
              void 0 !== this._pendingWorkerUpdate.diff ||
              this._pendingWorkerUpdate.optionsChanged
            );
          }
          _pixelsToTileUnits(t) {
            return t * (e.a3 / this.tileSize);
          }
          _getClusterMaxZoom(t) {
            const i = t ? Math.round(t) : this.maxzoom - 1;
            return (
              Number.isInteger(t) ||
                void 0 === t ||
                e.w(
                  `Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${i}"`
                ),
              i
            );
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(t) {
            (this.map = t), this.load();
          }
          setData(t) {
            return (
              (this._data = t),
              (this._pendingWorkerUpdate = { data: t }),
              this._updateWorkerData(),
              this
            );
          }
          updateData(t) {
            return (
              (this._pendingWorkerUpdate.diff = e.a4(
                this._pendingWorkerUpdate.diff,
                t
              )),
              this._updateWorkerData(),
              this
            );
          }
          getData() {
            return e._(this, void 0, void 0, function* () {
              const t = e.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: 'GD', data: t });
            });
          }
          getBounds() {
            return e._(this, void 0, void 0, function* () {
              return J(yield this.getData());
            });
          }
          setClusterOptions(t) {
            return (
              (this.workerOptions.cluster = t.cluster),
              void 0 !== t.clusterRadius &&
                (this.workerOptions.superclusterOptions.radius =
                  this._pixelsToTileUnits(t.clusterRadius)),
              void 0 !== t.clusterMaxZoom &&
                (this.workerOptions.superclusterOptions.maxZoom =
                  this._getClusterMaxZoom(t.clusterMaxZoom)),
              (this._pendingWorkerUpdate.optionsChanged = !0),
              this._updateWorkerData(),
              this
            );
          }
          getClusterExpansionZoom(t) {
            return this.actor.sendAsync({
              type: 'GCEZ',
              data: { type: this.type, clusterId: t, source: this.id },
            });
          }
          getClusterChildren(t) {
            return this.actor.sendAsync({
              type: 'GCC',
              data: { type: this.type, clusterId: t, source: this.id },
            });
          }
          getClusterLeaves(t, e, i) {
            return this.actor.sendAsync({
              type: 'GCL',
              data: {
                type: this.type,
                source: this.id,
                clusterId: t,
                limit: e,
                offset: i,
              },
            });
          }
          _updateWorkerData() {
            return e._(this, void 0, void 0, function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate())
                return void e.w(
                  `No pending worker updates for GeoJSONSource ${this.id}.`
                );
              const { data: t, diff: i } = this._pendingWorkerUpdate,
                r = e.e({ type: this.type }, this.workerOptions);
              t
                ? ('string' == typeof t
                    ? ((r.request = this.map._requestManager.transformRequest(
                        a.resolveURL(t),
                        'Source'
                      )),
                      (r.request.collectResourceTiming =
                        this._collectResourceTiming))
                    : (r.data = JSON.stringify(t)),
                  (this._pendingWorkerUpdate.data = void 0))
                : i &&
                  ((r.dataDiff = i), (this._pendingWorkerUpdate.diff = void 0)),
                (this._pendingWorkerUpdate.optionsChanged = void 0),
                (this._isUpdatingWorker = !0),
                this.fire(new e.l('dataloading', { dataType: 'source' }));
              try {
                const t = yield this.actor.sendAsync({ type: 'LD', data: r });
                if (
                  ((this._isUpdatingWorker = !1), this._removed || t.abandoned)
                )
                  return void this.fire(
                    new e.l('dataabort', { dataType: 'source' })
                  );
                this._data = t.data;
                let n = null;
                t.resourceTiming &&
                  t.resourceTiming[this.id] &&
                  (n = t.resourceTiming[this.id].slice(0));
                const o = { dataType: 'source' };
                this._collectResourceTiming &&
                  n &&
                  n.length > 0 &&
                  e.e(o, { resourceTiming: n }),
                  this.fire(
                    new e.l(
                      'data',
                      Object.assign(Object.assign({}, o), {
                        sourceDataType: 'metadata',
                      })
                    )
                  ),
                  this.fire(
                    new e.l(
                      'data',
                      Object.assign(Object.assign({}, o), {
                        sourceDataType: 'content',
                        shouldReloadTileOptions:
                          this._getShouldReloadTileOptions(i),
                      })
                    )
                  );
              } catch (t) {
                if (((this._isUpdatingWorker = !1), this._removed))
                  return void this.fire(
                    new e.l('dataabort', { dataType: 'source' })
                  );
                this.fire(new e.k(t));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            });
          }
          _getShouldReloadTileOptions(t) {
            if (!t || t.removeAll) return;
            const { add: e = [], update: i = [], remove: r = [] } = t || {},
              n = new Set([...i.map((t) => t.id), ...r]);
            return {
              nextBounds: [
                ...i.map((t) => t.newGeometry),
                ...e.map((t) => t.geometry),
              ].map((t) => J(t)),
              prevIds: n,
            };
          }
          shouldReloadTile(t, { nextBounds: i, prevIds: r }) {
            const n = t.latestFeatureIndex.loadVTLayers();
            for (
              let e = 0;
              e < t.latestFeatureIndex.featureIndexArray.length;
              e++
            ) {
              const i = t.latestFeatureIndex.featureIndexArray.get(e),
                o = n._geojsonTileLayer.feature(i.featureIndex);
              if (r.has(o.id)) return !0;
            }
            const { buffer: o, extent: a } =
                this.workerOptions.geojsonVtOptions,
              s = (function ({ x: t, y: i, z: r }, n = 0) {
                const o = e.a1((t - n) / Math.pow(2, r)),
                  a = e.a2((i + 1 + n) / Math.pow(2, r)),
                  s = e.a1((t + 1 + n) / Math.pow(2, r)),
                  l = e.a2((i - n) / Math.pow(2, r));
                return new q([o, a], [s, l]);
              })(t.tileID.canonical, o / a);
            for (const e of i) if (s.intersects(e)) return !0;
            return !1;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(t) {
            return e._(this, void 0, void 0, function* () {
              const e = t.actor ? 'RT' : 'LT';
              t.actor = this.actor;
              const i = {
                type: this.type,
                uid: t.uid,
                tileID: t.tileID,
                zoom: t.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity:
                  this.map.style.projection.subdivisionGranularity,
              };
              t.abortController = new AbortController();
              const r = yield this.actor.sendAsync(
                { type: e, data: i },
                t.abortController
              );
              delete t.abortController,
                t.unloadVectorData(),
                t.aborted || t.loadVectorData(r, this.map.painter, 'RT' === e);
            });
          }
          abortTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.abortController &&
                (t.abortController.abort(), delete t.abortController),
                (t.aborted = !0);
            });
          }
          unloadTile(t) {
            return e._(this, void 0, void 0, function* () {
              t.unloadVectorData(),
                yield this.actor.sendAsync({
                  type: 'RMT',
                  data: { uid: t.uid, type: this.type, source: this.id },
                });
            });
          }
          onRemove() {
            (this._removed = !0),
              this.actor.sendAsync({
                type: 'RS',
                data: { type: this.type, source: this.id },
              });
          }
          serialize() {
            return e.e({}, this._options, {
              type: this.type,
              data: this._data,
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class tt extends e.E {
          constructor(t, e, i, r) {
            super(),
              (this.flippedWindingOrder = !1),
              (this.id = t),
              (this.dispatcher = i),
              (this.coordinates = e.coordinates),
              (this.type = 'image'),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.tileSize = 512),
              (this.tiles = {}),
              (this._loaded = !1),
              this.setEventedParent(r),
              (this.options = e);
          }
          load(t) {
            return e._(this, void 0, void 0, function* () {
              (this._loaded = !1),
                this.fire(new e.l('dataloading', { dataType: 'source' })),
                (this.url = this.options.url),
                (this._request = new AbortController());
              try {
                const e = yield _.getImage(
                  this.map._requestManager.transformRequest(this.url, 'Image'),
                  this._request
                );
                (this._request = null),
                  (this._loaded = !0),
                  e &&
                    e.data &&
                    ((this.image = e.data),
                    t && (this.coordinates = t),
                    this._finishLoading());
              } catch (t) {
                (this._request = null),
                  (this._loaded = !0),
                  this.fire(new e.k(t));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t) {
            return t.url
              ? (this._request &&
                  (this._request.abort(), (this._request = null)),
                (this.options.url = t.url),
                this.load(t.coordinates).finally(() => {
                  this.texture = null;
                }),
                this)
              : this;
          }
          _finishLoading() {
            this.map &&
              (this.setCoordinates(this.coordinates),
              this.fire(
                new e.l('data', {
                  dataType: 'source',
                  sourceDataType: 'metadata',
                })
              ));
          }
          onAdd(t) {
            (this.map = t), this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), (this._request = null));
          }
          setCoordinates(t) {
            this.coordinates = t;
            const i = t.map(e.a5.fromLngLat);
            var r;
            return (
              (this.tileID = (function (t) {
                const i = e.a6.fromPoints(t),
                  r = i.width(),
                  n = i.height(),
                  o = Math.max(r, n),
                  a = Math.max(0, Math.floor(-Math.log(o) / Math.LN2)),
                  s = Math.pow(2, a);
                return new e.a8(
                  a,
                  Math.floor(((i.minX + i.maxX) / 2) * s),
                  Math.floor(((i.minY + i.maxY) / 2) * s)
                );
              })(i)),
              (this.terrainTileRanges = this._getOverlappingTileRanges(i)),
              (this.minzoom = this.maxzoom = this.tileID.z),
              (this.tileCoords = i.map((t) =>
                this.tileID.getTilePoint(t)._round()
              )),
              (this.flippedWindingOrder =
                ((r = this.tileCoords)[1].x - r[0].x) * (r[2].y - r[0].y) -
                  (r[1].y - r[0].y) * (r[2].x - r[0].x) <
                0),
              this.fire(
                new e.l('data', {
                  dataType: 'source',
                  sourceDataType: 'content',
                })
              ),
              this
            );
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const t = this.map.painter.context,
              i = t.gl;
            this.texture ||
              ((this.texture = new e.T(t, this.image, i.RGBA)),
              this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let r = !1;
            for (const e in this.tiles) {
              const t = this.tiles[e];
              'loaded' !== t.state &&
                ((t.state = 'loaded'), (t.texture = this.texture), (r = !0));
            }
            r &&
              this.fire(
                new e.l('data', {
                  dataType: 'source',
                  sourceDataType: 'idle',
                  sourceId: this.id,
                })
              );
          }
          loadTile(t) {
            return e._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(t.tileID.canonical)
                ? ((this.tiles[String(t.tileID.wrap)] = t), (t.buckets = {}))
                : (t.state = 'errored');
            });
          }
          serialize() {
            return {
              type: 'image',
              url: this.options.url,
              coordinates: this.coordinates,
            };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(t) {
            const { minX: i, minY: r, maxX: n, maxY: o } = e.a6.fromPoints(t),
              a = {};
            for (let s = 0; s <= e.a7; s++) {
              const t = Math.pow(2, s),
                e = Math.floor(i * t),
                l = Math.floor(r * t),
                c = Math.floor(n * t),
                h = Math.floor(o * t);
              a[s] = { minTileX: e, minTileY: l, maxTileX: c, maxTileY: h };
            }
            return a;
          }
        }
        class et extends tt {
          constructor(t, e, i, r) {
            super(t, e, i, r),
              (this.roundZoom = !0),
              (this.type = 'video'),
              (this.options = e);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const t = this.options;
              this.urls = [];
              for (const e of t.urls)
                this.urls.push(
                  this.map._requestManager.transformRequest(e, 'Source').url
                );
              try {
                const t = yield e.a9(this.urls);
                if (((this._loaded = !0), !t)) return;
                (this.video = t),
                  (this.video.loop = !0),
                  this.video.addEventListener('playing', () => {
                    this.map.triggerRepaint();
                  }),
                  this.map && this.video.play(),
                  this._finishLoading();
              } catch (t) {
                this.fire(new e.k(t));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t) {
            if (this.video) {
              const i = this.video.seekable;
              t < i.start(0) || t > i.end(0)
                ? this.fire(
                    new e.k(
                      new e.aa(
                        `sources.${this.id}`,
                        null,
                        `Playback for this video can be set only between the ${i.start(
                          0
                        )} and ${i.end(0)}-second mark.`
                      )
                    )
                  )
                : (this.video.currentTime = t);
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t) {
            this.map ||
              ((this.map = t),
              this.load(),
              this.video &&
                (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (
              0 === Object.keys(this.tiles).length ||
              this.video.readyState < 2
            )
              return;
            const t = this.map.painter.context,
              i = t.gl;
            this.texture
              ? this.video.paused ||
                (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                i.texSubImage2D(
                  i.TEXTURE_2D,
                  0,
                  0,
                  0,
                  i.RGBA,
                  i.UNSIGNED_BYTE,
                  this.video
                ))
              : ((this.texture = new e.T(t, this.video, i.RGBA)),
                this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let r = !1;
            for (const e in this.tiles) {
              const t = this.tiles[e];
              'loaded' !== t.state &&
                ((t.state = 'loaded'), (t.texture = this.texture), (r = !0));
            }
            r &&
              this.fire(
                new e.l('data', {
                  dataType: 'source',
                  sourceDataType: 'idle',
                  sourceId: this.id,
                })
              );
          }
          serialize() {
            return {
              type: 'video',
              urls: this.urls,
              coordinates: this.coordinates,
            };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class it extends tt {
          constructor(t, i, r, n) {
            super(t, i, r, n),
              i.coordinates
                ? (Array.isArray(i.coordinates) &&
                    4 === i.coordinates.length &&
                    !i.coordinates.some(
                      (t) =>
                        !Array.isArray(t) ||
                        2 !== t.length ||
                        t.some((t) => 'number' != typeof t)
                    )) ||
                  this.fire(
                    new e.k(
                      new e.aa(
                        `sources.${t}`,
                        null,
                        '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                      )
                    )
                  )
                : this.fire(
                    new e.k(
                      new e.aa(
                        `sources.${t}`,
                        null,
                        'missing required property "coordinates"'
                      )
                    )
                  ),
              i.animate &&
                'boolean' != typeof i.animate &&
                this.fire(
                  new e.k(
                    new e.aa(
                      `sources.${t}`,
                      null,
                      'optional "animate" property must be a boolean value'
                    )
                  )
                ),
              i.canvas
                ? 'string' == typeof i.canvas ||
                  i.canvas instanceof HTMLCanvasElement ||
                  this.fire(
                    new e.k(
                      new e.aa(
                        `sources.${t}`,
                        null,
                        '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                      )
                    )
                  )
                : this.fire(
                    new e.k(
                      new e.aa(
                        `sources.${t}`,
                        null,
                        'missing required property "canvas"'
                      )
                    )
                  ),
              (this.options = i),
              (this.animate = void 0 === i.animate || i.animate);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              (this._loaded = !0),
                this.canvas ||
                  (this.canvas =
                    this.options.canvas instanceof HTMLCanvasElement
                      ? this.options.canvas
                      : document.getElementById(this.options.canvas)),
                (this.width = this.canvas.width),
                (this.height = this.canvas.height),
                this._hasInvalidDimensions()
                  ? this.fire(
                      new e.k(
                        new Error(
                          'Canvas dimensions cannot be less than or equal to zero.'
                        )
                      )
                    )
                  : ((this.play = function () {
                      (this._playing = !0), this.map.triggerRepaint();
                    }),
                    (this.pause = function () {
                      this._playing && (this.prepare(), (this._playing = !1));
                    }),
                    this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t) {
            (this.map = t),
              this.load(),
              this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = !1;
            if (
              (this.canvas.width !== this.width &&
                ((this.width = this.canvas.width), (t = !0)),
              this.canvas.height !== this.height &&
                ((this.height = this.canvas.height), (t = !0)),
              this._hasInvalidDimensions())
            )
              return;
            if (0 === Object.keys(this.tiles).length) return;
            const i = this.map.painter.context,
              r = i.gl;
            this.texture
              ? (t || this._playing) &&
                this.texture.update(this.canvas, { premultiply: !0 })
              : (this.texture = new e.T(i, this.canvas, r.RGBA, {
                  premultiply: !0,
                }));
            let n = !1;
            for (const e in this.tiles) {
              const t = this.tiles[e];
              'loaded' !== t.state &&
                ((t.state = 'loaded'), (t.texture = this.texture), (n = !0));
            }
            n &&
              this.fire(
                new e.l('data', {
                  dataType: 'source',
                  sourceDataType: 'idle',
                  sourceId: this.id,
                })
              );
          }
          serialize() {
            return { type: 'canvas', coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t of [this.canvas.width, this.canvas.height])
              if (isNaN(t) || t <= 0) return !0;
            return !1;
          }
        }
        const rt = {},
          nt = (t) => {
            switch (t) {
              case 'geojson':
                return Q;
              case 'image':
                return tt;
              case 'raster':
                return H;
              case 'raster-dem':
                return X;
              case 'vector':
                return Y;
              case 'video':
                return et;
              case 'canvas':
                return it;
            }
            return rt[t];
          },
          ot = 'RTLPluginLoaded';
        class at extends e.E {
          constructor() {
            super(...arguments),
              (this.status = 'unavailable'),
              (this.url = null),
              (this.dispatcher = N());
          }
          _syncState(t) {
            return (
              (this.status = t),
              this.dispatcher
                .broadcast('SRPS', { pluginStatus: t, pluginURL: this.url })
                .catch((t) => {
                  throw ((this.status = 'error'), t);
                })
            );
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            (this.status = 'unavailable'), (this.url = null);
          }
          setRTLTextPlugin(t) {
            return e._(this, arguments, void 0, function* (t, e = !1) {
              if (this.url)
                throw new Error(
                  'setRTLTextPlugin cannot be called multiple times.'
                );
              if (((this.url = a.resolveURL(t)), !this.url))
                throw new Error(`requested url ${t} is invalid`);
              if ('unavailable' === this.status) {
                if (!e) return this._requestImport();
                (this.status = 'deferred'), this._syncState(this.status);
              } else if ('requested' === this.status) return this._requestImport();
            });
          }
          _requestImport() {
            return e._(this, void 0, void 0, function* () {
              yield this._syncState('loading'),
                (this.status = 'loaded'),
                this.fire(new e.l(ot));
            });
          }
          lazyLoad() {
            'unavailable' === this.status
              ? (this.status = 'requested')
              : 'deferred' === this.status && this._requestImport();
          }
        }
        let st = null;
        function lt() {
          return st || (st = new at()), st;
        }
        var ct, ht;
        !(function (t) {
          (t[(t.Base = 0)] = 'Base'), (t[(t.Parent = 1)] = 'Parent');
        })(ct || (ct = {})),
          (function (t) {
            (t[(t.Departing = 0)] = 'Departing'),
              (t[(t.Incoming = 1)] = 'Incoming');
          })(ht || (ht = {}));
        class ut {
          constructor(t, i) {
            (this.timeAdded = 0),
              (this.fadeEndTime = 0),
              (this.fadeOpacity = 1),
              (this.tileID = t),
              (this.uid = e.ab()),
              (this.uses = 0),
              (this.tileSize = i),
              (this.buckets = {}),
              (this.expirationTime = null),
              (this.queryPadding = 0),
              (this.hasSymbolBuckets = !1),
              (this.hasRTLText = !1),
              (this.dependencies = {}),
              (this.rtt = []),
              (this.rttCoords = {}),
              (this.expiredRequestCount = 0),
              (this.state = 'loading');
          }
          isRenderable(t) {
            return (
              this.hasData() &&
              (!this.fadeEndTime || this.fadeOpacity > 0) &&
              (t || !this.holdingForSymbolFade())
            );
          }
          setCrossFadeLogic({
            fadingRole: t,
            fadingDirection: e,
            fadingParentID: i,
            fadeEndTime: r,
          }) {
            this.resetFadeLogic(),
              (this.fadingRole = t),
              (this.fadingDirection = e),
              (this.fadingParentID = i),
              (this.fadeEndTime = r);
          }
          setSelfFadeLogic(t) {
            this.resetFadeLogic(),
              (this.selfFading = !0),
              (this.fadeEndTime = t);
          }
          resetFadeLogic() {
            (this.fadingRole = null),
              (this.fadingDirection = null),
              (this.fadingParentID = null),
              (this.selfFading = !1),
              (this.timeAdded = l()),
              (this.fadeEndTime = 0),
              (this.fadeOpacity = 1);
          }
          wasRequested() {
            return (
              'errored' === this.state ||
              'loaded' === this.state ||
              'reloading' === this.state
            );
          }
          clearTextures(t) {
            this.demTexture && t.saveTileTexture(this.demTexture),
              (this.demTexture = null);
          }
          loadVectorData(t, i, r) {
            if (
              (this.hasData() && this.unloadVectorData(),
              (this.state = 'loaded'),
              t)
            ) {
              t.featureIndex &&
                ((this.latestFeatureIndex = t.featureIndex),
                t.rawTileData
                  ? ((this.latestRawTileData = t.rawTileData),
                    (this.latestFeatureIndex.rawTileData = t.rawTileData))
                  : this.latestRawTileData &&
                    (this.latestFeatureIndex.rawTileData =
                      this.latestRawTileData)),
                (this.collisionBoxArray = t.collisionBoxArray),
                (this.buckets = (function (t, e) {
                  const i = {};
                  if (!e) return i;
                  for (const r of t) {
                    const t = r.layerIds
                      .map((t) => e.getLayer(t))
                      .filter(Boolean);
                    if (0 !== t.length) {
                      (r.layers = t),
                        r.stateDependentLayerIds &&
                          (r.stateDependentLayers =
                            r.stateDependentLayerIds.map(
                              (e) => t.filter((t) => t.id === e)[0]
                            ));
                      for (const e of t) i[e.id] = r;
                    }
                  }
                  return i;
                })(t.buckets, null == i ? void 0 : i.style)),
                (this.hasSymbolBuckets = !1);
              for (const t in this.buckets) {
                const i = this.buckets[t];
                if (i instanceof e.ad) {
                  if (((this.hasSymbolBuckets = !0), !r)) break;
                  i.justReloaded = !0;
                }
              }
              if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                for (const t in this.buckets) {
                  const i = this.buckets[t];
                  if (i instanceof e.ad && i.hasRTLText) {
                    (this.hasRTLText = !0), lt().lazyLoad();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t in this.buckets) {
                const e = this.buckets[t];
                this.queryPadding = Math.max(
                  this.queryPadding,
                  i.style.getLayer(t).queryRadius(e)
                );
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
                (this.dashPositions = t.dashPositions);
            } else this.collisionBoxArray = new e.ac();
          }
          unloadVectorData() {
            for (const t in this.buckets) this.buckets[t].destroy();
            (this.buckets = {}),
              this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
              this.imageAtlas && (this.imageAtlas = null),
              this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
              this.dashPositions && (this.dashPositions = null),
              (this.latestFeatureIndex = null),
              (this.state = 'unloaded');
          }
          getBucket(t) {
            return this.buckets[t.id];
          }
          upload(t) {
            for (const e in this.buckets) {
              const i = this.buckets[e];
              i.uploadPending() && i.upload(t);
            }
            const i = t.gl;
            this.imageAtlas &&
              !this.imageAtlas.uploaded &&
              ((this.imageAtlasTexture = new e.T(
                t,
                this.imageAtlas.image,
                i.RGBA
              )),
              (this.imageAtlas.uploaded = !0)),
              this.glyphAtlasImage &&
                ((this.glyphAtlasTexture = new e.T(
                  t,
                  this.glyphAtlasImage,
                  i.ALPHA
                )),
                (this.glyphAtlasImage = null));
          }
          prepare(t) {
            this.imageAtlas &&
              this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t, e, i, r, n, o, a, s, l, c, h) {
            return this.latestFeatureIndex &&
              this.latestFeatureIndex.rawTileData
              ? this.latestFeatureIndex.query(
                  {
                    queryGeometry: r,
                    cameraQueryGeometry: n,
                    scale: o,
                    tileSize: this.tileSize,
                    pixelPosMatrix: c,
                    transform: s,
                    params: a,
                    queryPadding: this.queryPadding * l,
                    getElevation: h,
                  },
                  t,
                  e,
                  i
                )
              : {};
          }
          querySourceFeatures(t, i) {
            const r = this.latestFeatureIndex;
            if (!r || !r.rawTileData) return;
            const n = r.loadVTLayers(),
              o = i && i.sourceLayer ? i.sourceLayer : '',
              a = n._geojsonTileLayer || n[o];
            if (!a) return;
            const s = e.ae(
                null == i ? void 0 : i.filter,
                null == i ? void 0 : i.globalState
              ),
              { z: l, x: c, y: h } = this.tileID.canonical,
              u = { z: l, x: c, y: h };
            for (let d = 0; d < a.length; d++) {
              const i = a.feature(d);
              if (s.needGeometry) {
                const t = e.af(i, !0);
                if (
                  !s.filter(
                    new e.G(this.tileID.overscaledZ),
                    t,
                    this.tileID.canonical
                  )
                )
                  continue;
              } else if (!s.filter(new e.G(this.tileID.overscaledZ), i))
                continue;
              const n = r.getId(i, o),
                p = new e.ag(i, l, c, h, n);
              (p.tile = u), t.push(p);
            }
          }
          hasData() {
            return (
              'loaded' === this.state ||
              'reloading' === this.state ||
              'expired' === this.state
            );
          }
          patternsLoaded() {
            return (
              this.imageAtlas &&
              !!Object.keys(this.imageAtlas.patternPositions).length
            );
          }
          setExpiryData(t) {
            const i = this.expirationTime;
            if (t.cacheControl) {
              const i = e.ah(t.cacheControl);
              i['max-age'] &&
                (this.expirationTime = Date.now() + 1e3 * i['max-age']);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const t = Date.now();
              let e = !1;
              if (this.expirationTime > t) e = !1;
              else if (i)
                if (this.expirationTime < i) e = !0;
                else {
                  const r = this.expirationTime - i;
                  r ? (this.expirationTime = t + Math.max(r, 3e4)) : (e = !0);
                }
              else e = !0;
              e
                ? (this.expiredRequestCount++, (this.state = 'expired'))
                : (this.expiredRequestCount = 0);
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount
                ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                : Math.min(
                    this.expirationTime - new Date().getTime(),
                    Math.pow(2, 31) - 1
                  );
          }
          setFeatureState(t, e) {
            if (
              !this.latestFeatureIndex ||
              !this.latestFeatureIndex.rawTileData ||
              0 === Object.keys(t).length
            )
              return;
            const i = this.latestFeatureIndex.loadVTLayers();
            for (const r in this.buckets) {
              if (!e.style.hasLayer(r)) continue;
              const n = this.buckets[r],
                o = n.layers[0].sourceLayer || '_geojsonTileLayer',
                a = i[o],
                s = t[o];
              if (!a || !s || 0 === Object.keys(s).length) continue;
              n.update(
                s,
                a,
                (this.imageAtlas && this.imageAtlas.patternPositions) || {},
                this.dashPositions || {}
              );
              const l = e && e.style && e.style.getLayer(r);
              l &&
                (this.queryPadding = Math.max(
                  this.queryPadding,
                  l.queryRadius(n)
                ));
            }
          }
          holdingForSymbolFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < l();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(t) {
            this.symbolFadeHoldUntil = l() + t;
          }
          setDependencies(t, e) {
            const i = {};
            for (const r of e) i[r] = !0;
            this.dependencies[t] = i;
          }
          hasDependency(t, e) {
            for (const i of t) {
              const t = this.dependencies[i];
              if (t) for (const i of e) if (t[i]) return !0;
            }
            return !1;
          }
        }
        class dt {
          constructor(t, e) {
            (this.max = t), (this.onRemove = e), this.reset();
          }
          reset() {
            for (const t in this.data)
              for (const e of this.data[t])
                e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
            return (this.data = {}), (this.order = []), this;
          }
          add(t, e, i) {
            const r = t.wrapped().key;
            void 0 === this.data[r] && (this.data[r] = []);
            const n = { value: e, timeout: void 0 };
            if (
              (void 0 !== i &&
                (n.timeout = setTimeout(() => {
                  this.remove(t, n);
                }, i)),
              this.data[r].push(n),
              this.order.push(r),
              this.order.length > this.max)
            ) {
              const t = this._getAndRemoveByKey(this.order[0]);
              t && this.onRemove(t);
            }
            return this;
          }
          has(t) {
            return t.wrapped().key in this.data;
          }
          getAndRemove(t) {
            return this.has(t)
              ? this._getAndRemoveByKey(t.wrapped().key)
              : null;
          }
          _getAndRemoveByKey(t) {
            const e = this.data[t].shift();
            return (
              e.timeout && clearTimeout(e.timeout),
              0 === this.data[t].length && delete this.data[t],
              this.order.splice(this.order.indexOf(t), 1),
              e.value
            );
          }
          getByKey(t) {
            const e = this.data[t];
            return e ? e[0].value : null;
          }
          get(t) {
            return this.has(t) ? this.data[t.wrapped().key][0].value : null;
          }
          remove(t, e) {
            if (!this.has(t)) return this;
            const i = t.wrapped().key,
              r = void 0 === e ? 0 : this.data[i].indexOf(e),
              n = this.data[i][r];
            return (
              this.data[i].splice(r, 1),
              n.timeout && clearTimeout(n.timeout),
              0 === this.data[i].length && delete this.data[i],
              this.onRemove(n.value),
              this.order.splice(this.order.indexOf(i), 1),
              this
            );
          }
          setMaxSize(t) {
            for (this.max = t; this.order.length > this.max; ) {
              const t = this._getAndRemoveByKey(this.order[0]);
              t && this.onRemove(t);
            }
            return this;
          }
          filter(t) {
            const e = [];
            for (const i in this.data)
              for (const r of this.data[i]) t(r.value) || e.push(r);
            for (const i of e) this.remove(i.value.tileID, i);
          }
        }
        class pt {
          constructor() {
            (this.state = {}),
              (this.stateChanges = {}),
              (this.deletedStates = {});
          }
          updateState(t, i, r) {
            const n = String(i);
            if (
              ((this.stateChanges[t] = this.stateChanges[t] || {}),
              (this.stateChanges[t][n] = this.stateChanges[t][n] || {}),
              e.e(this.stateChanges[t][n], r),
              null === this.deletedStates[t])
            ) {
              this.deletedStates[t] = {};
              for (const e in this.state[t])
                e !== n && (this.deletedStates[t][e] = null);
            } else if (
              this.deletedStates[t] &&
              null === this.deletedStates[t][n]
            ) {
              this.deletedStates[t][n] = {};
              for (const e in this.state[t][n])
                r[e] || (this.deletedStates[t][n][e] = null);
            } else
              for (const e in r)
                this.deletedStates[t] &&
                  this.deletedStates[t][n] &&
                  null === this.deletedStates[t][n][e] &&
                  delete this.deletedStates[t][n][e];
          }
          removeFeatureState(t, e, i) {
            if (null === this.deletedStates[t]) return;
            const r = String(e);
            if (
              ((this.deletedStates[t] = this.deletedStates[t] || {}),
              i && void 0 !== e)
            )
              null !== this.deletedStates[t][r] &&
                ((this.deletedStates[t][r] = this.deletedStates[t][r] || {}),
                (this.deletedStates[t][r][i] = null));
            else if (void 0 !== e)
              if (this.stateChanges[t] && this.stateChanges[t][r])
                for (i in ((this.deletedStates[t][r] = {}),
                this.stateChanges[t][r]))
                  this.deletedStates[t][r][i] = null;
              else this.deletedStates[t][r] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, i) {
            const r = String(i),
              n = e.e(
                {},
                (this.state[t] || {})[r],
                (this.stateChanges[t] || {})[r]
              );
            if (null === this.deletedStates[t]) return {};
            if (this.deletedStates[t]) {
              const e = this.deletedStates[t][i];
              if (null === e) return {};
              for (const t in e) delete n[t];
            }
            return n;
          }
          initializeTileState(t, e) {
            t.setFeatureState(this.state, e);
          }
          coalesceChanges(t, i) {
            const r = {};
            for (const n in this.stateChanges) {
              this.state[n] = this.state[n] || {};
              const t = {};
              for (const i in this.stateChanges[n])
                this.state[n][i] || (this.state[n][i] = {}),
                  e.e(this.state[n][i], this.stateChanges[n][i]),
                  (t[i] = this.state[n][i]);
              r[n] = t;
            }
            for (const n in this.deletedStates) {
              this.state[n] = this.state[n] || {};
              const t = {};
              if (null === this.deletedStates[n])
                for (const e in this.state[n])
                  (t[e] = {}), (this.state[n][e] = {});
              else
                for (const e in this.deletedStates[n]) {
                  if (null === this.deletedStates[n][e]) this.state[n][e] = {};
                  else
                    for (const t of Object.keys(this.deletedStates[n][e]))
                      delete this.state[n][e][t];
                  t[e] = this.state[n][e];
                }
              (r[n] = r[n] || {}), e.e(r[n], t);
            }
            if (
              ((this.stateChanges = {}),
              (this.deletedStates = {}),
              0 !== Object.keys(r).length)
            )
              for (const e in t) t[e].setFeatureState(r, i);
          }
        }
        const ft = 89.25;
        function mt(t, i) {
          const r = e.ai(i.lat, -e.aj, e.aj);
          return new e.P(e.X(i.lng) * t, e.W(r) * t);
        }
        function _t(t, i) {
          return new e.a5(i.x / t, i.y / t).toLngLat();
        }
        function gt(t) {
          return (
            t.cameraToCenterDistance *
            Math.min(
              0.85 * Math.tan(e.ak(90 - t.pitch)),
              Math.tan(e.ak(ft - t.pitch))
            )
          );
        }
        function yt(t, i) {
          const r = t.canonical,
            n = i / e.al(r.z),
            o = r.x + Math.pow(2, r.z) * t.wrap,
            a = e.am(new Float64Array(16));
          return (
            e.N(a, a, [o * n, r.y * n, 0]),
            e.O(a, a, [n / e.a3, n / e.a3, 1]),
            a
          );
        }
        function xt(t, i, r, n, o) {
          const a = e.a5.fromLngLat(t, i),
            s = o * e.an(1, t.lat),
            l = s * Math.cos(e.ak(r)),
            c = Math.sqrt(s * s - l * l),
            h = c * Math.sin(e.ak(-n)),
            u = c * Math.cos(e.ak(-n));
          return new e.a5(a.x + h, a.y + u, a.z + l);
        }
        function vt(t, e, i) {
          const r = e.intersectsFrustum(t);
          if (!i || 0 === r) return r;
          const n = e.intersectsPlane(i);
          return 0 === n ? 0 : 2 === r && 2 === n ? 2 : 1;
        }
        function bt(t, e, i) {
          let r = 0;
          const n = (i - e) / 10;
          for (let o = 0; o < 10; o++)
            r += n * Math.pow(Math.cos(e + ((o + 0.5) / 10) * (i - e)), t);
          return r;
        }
        function wt(t, i) {
          return function (r, n, o, a, s) {
            const l =
                2 *
                ((t - 1) / e.ao(Math.cos(e.ak(ft - s)) / Math.cos(e.ak(ft))) -
                  1),
              c = Math.acos(o / a),
              h = 2 * bt(l - 1, 0, e.ak(s / 2)),
              u = Math.min(e.ak(ft), c + e.ak(s / 2)),
              d = bt(l - 1, Math.min(u, c - e.ak(s / 2)), u),
              p = Math.atan(n / o),
              f = Math.hypot(n, o);
            let m = r;
            return (
              (m += e.ao(a / f / Math.max(0.5, Math.cos(e.ak(s / 2))))),
              (m += (l * e.ao(Math.cos(p))) / 2),
              (m -= e.ao(Math.max(1, d / h / i)) / 2),
              m
            );
          };
        }
        const Tt = wt(9.314, 3);
        function Pt(t, i) {
          const r = (i.roundZoom ? Math.round : Math.floor)(
            t.zoom + e.ao(t.tileSize / i.tileSize)
          );
          return Math.max(0, r);
        }
        function St(t, i) {
          const r = t.getCameraFrustum(),
            n = t.getClippingPlane(),
            o = t.screenPointToMercatorCoordinate(t.getCameraPoint()),
            a = e.a5.fromLngLat(t.center, t.elevation);
          o.z =
            a.z +
            (Math.cos(t.pitchInRadians) * t.cameraToCenterDistance) /
              t.worldSize;
          const s = t.getCoveringTilesDetailsProvider(),
            l = s.allowVariableZoom(t, i),
            c = Pt(t, i),
            h = i.minzoom || 0,
            u = void 0 !== i.maxzoom ? i.maxzoom : t.maxZoom,
            d = Math.min(Math.max(0, c), u),
            p = Math.pow(2, d),
            f = [p * o.x, p * o.y, 0],
            m = [p * a.x, p * a.y, 0],
            _ = Math.hypot(a.x - o.x, a.y - o.y),
            g = Math.abs(a.z - o.z),
            y = Math.hypot(_, g),
            x = (t) => ({ zoom: 0, x: 0, y: 0, wrap: t, fullyVisible: !1 }),
            v = [],
            b = [];
          if (t.renderWorldCopies && s.allowWorldCopies())
            for (let e = 1; e <= 3; e++) v.push(x(-e)), v.push(x(e));
          for (v.push(x(0)); v.length > 0; ) {
            const p = v.pop(),
              _ = p.x,
              x = p.y;
            let w = p.fullyVisible;
            const T = { x: _, y: x, z: p.zoom },
              P = s.getTileBoundingVolume(T, p.wrap, t.elevation, i);
            if (!w) {
              const t = vt(r, P, n);
              if (0 === t) continue;
              w = 2 === t;
            }
            const S = s.distanceToTile2d(o.x, o.y, T, P);
            let M = c;
            l &&
              (M = (i.calculateTileZoom || Tt)(
                t.zoom + e.ao(t.tileSize / i.tileSize),
                S,
                g,
                y,
                t.fov
              )),
              (M = (i.roundZoom ? Math.round : Math.floor)(M)),
              (M = Math.max(0, M));
            const I = Math.min(M, u);
            if (((p.wrap = s.getWrap(a, T, p.wrap)), p.zoom >= I)) {
              if (p.zoom < h) continue;
              const t = d - p.zoom,
                r = f[0] - 0.5 - (_ << t),
                n = f[1] - 0.5 - (x << t),
                o = i.reparseOverscaled ? Math.max(p.zoom, M) : p.zoom;
              b.push({
                tileID: new e.a0(
                  p.zoom === u ? o : p.zoom,
                  p.wrap,
                  p.zoom,
                  _,
                  x
                ),
                distanceSq: e.ap([m[0] - 0.5 - _, m[1] - 0.5 - x]),
                tileDistanceToCamera: Math.sqrt(r * r + n * n),
              });
            } else
              for (let t = 0; t < 4; t++)
                v.push({
                  zoom: p.zoom + 1,
                  x: (_ << 1) + (t % 2),
                  y: (x << 1) + (t >> 1),
                  wrap: p.wrap,
                  fullyVisible: w,
                });
          }
          return b
            .sort((t, e) => t.distanceSq - e.distanceSq)
            .map((t) => t.tileID);
        }
        const Mt = e.a6.fromPoints([new e.P(0, 0), new e.P(e.a3, e.a3)]);
        class It extends e.E {
          constructor(t, e, i) {
            super(),
              (this.id = t),
              (this.dispatcher = i),
              this.on('data', (t) => this._dataHandler(t)),
              this.on('dataloading', () => {
                this._sourceErrored = !1;
              }),
              this.on('error', () => {
                this._sourceErrored = this._source.loaded();
              }),
              (this._source = ((t, e, i, r) => {
                const n = new (nt(e.type))(t, e, i, r);
                if (n.id !== t)
                  throw new Error(
                    `Expected Source id to be ${t} instead of ${n.id}`
                  );
                return n;
              })(t, e, i, this)),
              (this._tiles = {}),
              (this._cache = new dt(0, (t) => this._unloadTile(t))),
              (this._timers = {}),
              (this._maxTileCacheSize = null),
              (this._maxTileCacheZoomLevels = null),
              (this._rasterFadeDuration = 0),
              (this._maxFadingAncestorLevels = 5),
              (this._state = new pt()),
              (this._didEmitContent = !1),
              (this._updated = !1);
          }
          onAdd(t) {
            (this.map = t),
              (this._maxTileCacheSize = t ? t._maxTileCacheSize : null),
              (this._maxTileCacheZoomLevels = t
                ? t._maxTileCacheZoomLevels
                : null),
              this._source && this._source.onAdd && this._source.onAdd(t);
          }
          onRemove(t) {
            this.clearTiles(),
              this._source && this._source.onRemove && this._source.onRemove(t);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded) return !1;
            if (!this._source.loaded()) return !1;
            if (
              !(
                (void 0 === this.used && void 0 === this.usedForTerrain) ||
                this.used ||
                this.usedForTerrain
              )
            )
              return !0;
            if (!this._updated) return !1;
            for (const t in this._tiles) {
              const e = this._tiles[t];
              if ('loaded' !== e.state && 'errored' !== e.state) return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            (this._paused = !1),
              (this._shouldReloadOnResume = !1),
              t && this.reload(),
              this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t, i, r) {
            return e._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(t), this._tileLoaded(t, i, r);
              } catch (i) {
                (t.state = 'errored'),
                  404 !== i.status
                    ? this._source.fire(new e.k(i, { tile: t }))
                    : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(t) {
            this._source.unloadTile && this._source.unloadTile(t);
          }
          _abortTile(t) {
            this._source.abortTile && this._source.abortTile(t),
              this._source.fire(
                new e.l('dataabort', {
                  tile: t,
                  coord: t.tileID,
                  dataType: 'source',
                })
              );
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(),
              this._state.coalesceChanges(
                this._tiles,
                this.map ? this.map.painter : null
              );
            for (const e in this._tiles) {
              const i = this._tiles[e];
              i.upload(t), i.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles)
              .map((t) => t.tileID)
              .sort(Ct)
              .map((t) => t.key);
          }
          getRenderableIds(t) {
            const i = [];
            for (const e in this._tiles)
              this._isIdRenderable(e, t) && i.push(this._tiles[e]);
            return t
              ? i
                  .sort((t, i) => {
                    const r = t.tileID,
                      n = i.tileID,
                      o = new e.P(r.canonical.x, r.canonical.y)._rotate(
                        -this.transform.bearingInRadians
                      ),
                      a = new e.P(n.canonical.x, n.canonical.y)._rotate(
                        -this.transform.bearingInRadians
                      );
                    return (
                      r.overscaledZ - n.overscaledZ || a.y - o.y || a.x - o.x
                    );
                  })
                  .map((t) => t.tileID.key)
              : i
                  .map((t) => t.tileID)
                  .sort(Ct)
                  .map((t) => t.key);
          }
          hasRenderableParent(t) {
            const e = t.overscaledZ - 1;
            if (e >= this._source.minzoom) {
              const i = this.getLoadedTile(t.scaledTo(e));
              if (i) return this._isIdRenderable(i.tileID.key);
            }
            return !1;
          }
          _isIdRenderable(t, e = !1) {
            var i;
            return null === (i = this._tiles[t]) || void 0 === i
              ? void 0
              : i.isRenderable(e);
          }
          reload(t, e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const i in this._tiles)
                (e &&
                  this._source.shouldReloadTile &&
                  !this._source.shouldReloadTile(this._tiles[i], e)) ||
                  (t
                    ? this._reloadTile(i, 'expired')
                    : 'errored' !== this._tiles[i].state &&
                      this._reloadTile(i, 'reloading'));
            }
          }
          _reloadTile(t, i) {
            return e._(this, void 0, void 0, function* () {
              const e = this._tiles[t];
              e &&
                ('loading' !== e.state && (e.state = i),
                yield this._loadTile(e, t, i));
            });
          }
          _tileLoaded(t, i, r) {
            (t.timeAdded = l()),
              t.selfFading &&
                (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration),
              'expired' === r && (t.refreshedUponExpiration = !0),
              this._setTileReloadTimer(i, t),
              'raster-dem' === this.getSource().type &&
                t.dem &&
                this._backfillDEM(t),
              this._state.initializeTileState(
                t,
                this.map ? this.map.painter : null
              ),
              t.aborted ||
                this._source.fire(
                  new e.l('data', {
                    dataType: 'source',
                    tile: t,
                    coord: t.tileID,
                  })
                );
          }
          _backfillDEM(t) {
            const e = this.getRenderableIds();
            for (let r = 0; r < e.length; r++) {
              const n = e[r];
              if (t.neighboringTiles && t.neighboringTiles[n]) {
                const e = this.getTileByID(n);
                i(t, e), i(e, t);
              }
            }
            function i(t, e) {
              (t.needsHillshadePrepare = !0), (t.needsTerrainPrepare = !0);
              let i = e.tileID.canonical.x - t.tileID.canonical.x;
              const r = e.tileID.canonical.y - t.tileID.canonical.y,
                n = Math.pow(2, t.tileID.canonical.z),
                o = e.tileID.key;
              (0 === i && 0 === r) ||
                Math.abs(r) > 1 ||
                (Math.abs(i) > 1 &&
                  (1 === Math.abs(i + n)
                    ? (i += n)
                    : 1 === Math.abs(i - n) && (i -= n)),
                e.dem &&
                  t.dem &&
                  (t.dem.backfillBorder(e.dem, i, r),
                  t.neighboringTiles &&
                    t.neighboringTiles[o] &&
                    (t.neighboringTiles[o].backfilled = !0)));
            }
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          _retainLoadedChildren(t, e) {
            const i = Object.values(t),
              r = this._getLoadedDescendents(i),
              n = {};
            for (const o of i) {
              const t = r[o.key];
              if (!(null == t ? void 0 : t.length)) {
                n[o.key] = o;
                continue;
              }
              const i = o.overscaledZ + It.maxUnderzooming,
                a = t.filter((t) => t.tileID.overscaledZ <= i);
              if (!a.length) {
                n[o.key] = o;
                continue;
              }
              const s = Math.min(...a.map((t) => t.tileID.overscaledZ)),
                l = a
                  .filter((t) => t.tileID.overscaledZ === s)
                  .map((t) => t.tileID);
              for (const r of l) e[r.key] = r;
              this._areDescendentsComplete(l, s, o.overscaledZ) ||
                (n[o.key] = o);
            }
            return n;
          }
          _getLoadedDescendents(t) {
            var e;
            const i = {};
            for (const r in this._tiles) {
              const n = this._tiles[r];
              if (n.hasData())
                for (const r of t)
                  n.tileID.isChildOf(r) &&
                    (i[(e = r.key)] || (i[e] = [])).push(n);
            }
            return i;
          }
          _areDescendentsComplete(t, e, i) {
            return 1 === t.length && t[0].isOverscaled()
              ? t[0].overscaledZ === e
              : Math.pow(4, e - i) === t.length;
          }
          getLoadedTile(t) {
            const e = this._tiles[t.key];
            return (null == e ? void 0 : e.hasData()) ? e : null;
          }
          updateCacheSize(t) {
            const i = Math.ceil(t.width / this._source.tileSize) + 1,
              r = Math.ceil(t.height / this._source.tileSize) + 1,
              n = Math.floor(
                i *
                  r *
                  (null === this._maxTileCacheZoomLevels
                    ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS
                    : this._maxTileCacheZoomLevels)
              ),
              o =
                'number' == typeof this._maxTileCacheSize
                  ? Math.min(this._maxTileCacheSize, n)
                  : n;
            this._cache.setMaxSize(o);
          }
          handleWrapJump(t) {
            const e = Math.round(
              (t - (void 0 === this._prevLng ? t : this._prevLng)) / 360
            );
            if (((this._prevLng = t), e)) {
              const t = {};
              for (const i in this._tiles) {
                const r = this._tiles[i];
                (r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e)),
                  (t[r.tileID.key] = r);
              }
              (this._tiles = t), this._resetTileReloadTimers();
            }
          }
          update(t, i) {
            if (!this._sourceLoaded || this._paused) return;
            let r;
            (this.transform = t),
              (this.terrain = i),
              this.updateCacheSize(t),
              this.handleWrapJump(this.transform.center.lng),
              this.used || this.usedForTerrain
                ? this._source.tileID
                  ? (r = t
                      .getVisibleUnwrappedCoordinates(this._source.tileID)
                      .map(
                        (t) =>
                          new e.a0(
                            t.canonical.z,
                            t.wrap,
                            t.canonical.z,
                            t.canonical.x,
                            t.canonical.y
                          )
                      ))
                  : ((r = St(t, {
                      tileSize: this.usedForTerrain
                        ? this.tileSize
                        : this._source.tileSize,
                      minzoom: this._source.minzoom,
                      maxzoom: this._source.maxzoom,
                      roundZoom: !this.usedForTerrain && this._source.roundZoom,
                      reparseOverscaled: this._source.reparseOverscaled,
                      terrain: i,
                      calculateTileZoom: this._source.calculateTileZoom,
                    })),
                    this._source.hasTile &&
                      (r = r.filter((t) => this._source.hasTile(t))))
                : (r = []),
              this.usedForTerrain && (r = this._addTerrainIdealTiles(r));
            const n = 0 === r.length && !this._updated && this._didEmitContent;
            (this._updated = !0),
              n &&
                this.fire(
                  new e.l('data', {
                    sourceDataType: 'idle',
                    dataType: 'source',
                    sourceId: this.id,
                  })
                );
            const o = Pt(t, this._source),
              a = this._updateRetainedTiles(r, o),
              s = At(this._source.type);
            s &&
              this._rasterFadeDuration > 0 &&
              !i &&
              this._updateFadingTiles(r, a),
              s ? this._cleanUpRasterTiles(a) : this._cleanUpVectorTiles(a);
          }
          _cleanUpRasterTiles(t) {
            for (const e in this._tiles) t[e] || this._removeTile(e);
          }
          _cleanUpVectorTiles(t) {
            for (const e in this._tiles) {
              const i = this._tiles[e];
              t[e]
                ? i.clearSymbolFadeHold()
                : i.hasSymbolBuckets
                ? i.holdingForSymbolFade()
                  ? i.symbolFadeFinished() && this._removeTile(e)
                  : i.setSymbolHoldDuration(this.map._fadeDuration)
                : this._removeTile(e);
            }
          }
          _addTerrainIdealTiles(t) {
            const e = [];
            for (const i of t)
              if (i.canonical.z > this._source.minzoom) {
                const t = i.scaledTo(i.canonical.z - 1);
                e.push(t);
                const r = i.scaledTo(
                  Math.max(this._source.minzoom, Math.min(i.canonical.z, 5))
                );
                e.push(r);
              }
            return t.concat(e);
          }
          releaseSymbolFadeTiles() {
            for (const t in this._tiles)
              this._tiles[t].holdingForSymbolFade() && this._removeTile(t);
          }
          _updateRetainedTiles(t, e) {
            var i;
            const r = {},
              n = {},
              o = Math.max(e - It.maxOverzooming, this._source.minzoom);
            let a = {};
            for (const s of t) {
              const t = this._addTile(s);
              (r[s.key] = s), t.hasData() || (a[s.key] = s);
            }
            a = this._retainLoadedChildren(a, r);
            for (const s in a) {
              const t = a[s];
              let e = this._tiles[s],
                l = null == e ? void 0 : e.wasRequested();
              for (let a = t.overscaledZ - 1; a >= o; --a) {
                const o = t.scaledTo(a);
                if (n[o.key]) break;
                if (
                  ((n[o.key] = !0),
                  (e = this.getTile(o)),
                  !e && l && (e = this._addTile(o)),
                  e)
                ) {
                  const t = e.hasData();
                  if (
                    ((t ||
                      !(null === (i = this.map) || void 0 === i
                        ? void 0
                        : i.cancelPendingTileRequestsWhileZooming) ||
                      l) &&
                      (r[o.key] = o),
                    (l = e.wasRequested()),
                    t)
                  )
                    break;
                }
              }
            }
            return r;
          }
          _updateFadingTiles(t, i) {
            const r = l(),
              n = e.aq(t);
            for (const e of t) {
              const t = this._tiles[e.key];
              (t.fadingDirection !== ht.Departing && 0 !== t.fadeOpacity) ||
                t.resetFadeLogic(),
                this._updateFadingAncestor(t, i, r) ||
                  this._updateFadingDescendents(t, i, r) ||
                  this._updateFadingEdge(t, n, r) ||
                  t.resetFadeLogic();
            }
          }
          _updateFadingAncestor(t, e, i) {
            if (!t.hasData()) return !1;
            const {
              tileID: r,
              fadingRole: n,
              fadingDirection: o,
              fadingParentID: a,
            } = t;
            if (n === ct.Base && o === ht.Incoming && a)
              return (e[a.key] = a), !0;
            const s = Math.max(
              r.overscaledZ - this._maxFadingAncestorLevels,
              this._source.minzoom
            );
            for (let l = r.overscaledZ - 1; l >= s; l--) {
              const n = r.scaledTo(l),
                o = this.getLoadedTile(n);
              if (o)
                return (
                  t.setCrossFadeLogic({
                    fadingRole: ct.Base,
                    fadingDirection: ht.Incoming,
                    fadingParentID: o.tileID,
                    fadeEndTime: i + this._rasterFadeDuration,
                  }),
                  o.setCrossFadeLogic({
                    fadingRole: ct.Parent,
                    fadingDirection: ht.Departing,
                    fadeEndTime: i + this._rasterFadeDuration,
                  }),
                  (e[n.key] = n),
                  !0
                );
            }
            return !1;
          }
          _updateFadingDescendents(t, e, i) {
            if (!t.hasData()) return !1;
            const r = t.tileID.children(this._source.maxzoom);
            let n = this._updateFadingChildren(t, r, e, i);
            if (n) return !0;
            for (const o of r) {
              const r = o.children(this._source.maxzoom);
              this._updateFadingChildren(t, r, e, i) && (n = !0);
            }
            return n;
          }
          _updateFadingChildren(t, e, i, r) {
            if (e[0].overscaledZ >= this._source.maxzoom) return !1;
            let n = !1;
            for (const o of e) {
              const e = this.getLoadedTile(o);
              if (!e) continue;
              const {
                fadingRole: a,
                fadingDirection: s,
                fadingParentID: l,
              } = e;
              (a === ct.Base && s === ht.Departing && l) ||
                (e.setCrossFadeLogic({
                  fadingRole: ct.Base,
                  fadingDirection: ht.Departing,
                  fadingParentID: t.tileID,
                  fadeEndTime: r + this._rasterFadeDuration,
                }),
                t.setCrossFadeLogic({
                  fadingRole: ct.Parent,
                  fadingDirection: ht.Incoming,
                  fadeEndTime: r + this._rasterFadeDuration,
                })),
                (i[o.key] = o),
                (n = !0);
            }
            return n;
          }
          _updateFadingEdge(t, e, i) {
            const r = t.tileID;
            return (
              !!t.selfFading ||
              (!t.hasData() &&
                !!e.has(r) &&
                (t.setSelfFadeLogic(i + this._rasterFadeDuration), !0))
            );
          }
          _addTile(t) {
            let i = this._tiles[t.key];
            if (i) return i;
            (i = this._cache.getAndRemove(t)),
              i &&
                (i.resetFadeLogic(),
                this._setTileReloadTimer(t.key, i),
                (i.tileID = t),
                this._state.initializeTileState(
                  i,
                  this.map ? this.map.painter : null
                ));
            const r = i;
            return (
              i ||
                ((i = new ut(t, this._source.tileSize * t.overscaleFactor())),
                this._loadTile(i, t.key, i.state)),
              i.uses++,
              (this._tiles[t.key] = i),
              r ||
                this._source.fire(
                  new e.l('dataloading', {
                    tile: i,
                    coord: i.tileID,
                    dataType: 'source',
                  })
                ),
              i
            );
          }
          _setTileReloadTimer(t, e) {
            this._clearTileReloadTimer(t);
            const i = e.getExpiryTimeout();
            i &&
              (this._timers[t] = setTimeout(() => {
                this._reloadTile(t, 'expired'), delete this._timers[t];
              }, i));
          }
          _clearTileReloadTimer(t) {
            const e = this._timers[t];
            e && (clearTimeout(e), delete this._timers[t]);
          }
          _resetTileReloadTimers() {
            for (const t in this._timers)
              clearTimeout(this._timers[t]), delete this._timers[t];
            for (const t in this._tiles)
              this._setTileReloadTimer(t, this._tiles[t]);
          }
          refreshTiles(t) {
            for (const e in this._tiles)
              (this._isIdRenderable(e) || 'errored' == this._tiles[e].state) &&
                t.some((t) => t.equals(this._tiles[e].tileID.canonical)) &&
                this._reloadTile(e, 'expired');
          }
          _removeTile(t) {
            const e = this._tiles[t];
            e &&
              (e.uses--,
              delete this._tiles[t],
              this._clearTileReloadTimer(t),
              e.uses > 0 ||
                (e.hasData() && 'reloading' !== e.state
                  ? this._cache.add(e.tileID, e, e.getExpiryTimeout())
                  : ((e.aborted = !0),
                    this._abortTile(e),
                    this._unloadTile(e))));
          }
          _dataHandler(t) {
            'source' === t.dataType &&
              ('metadata' !== t.sourceDataType
                ? 'content' === t.sourceDataType &&
                  this._sourceLoaded &&
                  !this._paused &&
                  (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions),
                  this.transform && this.update(this.transform, this.terrain),
                  (this._didEmitContent = !0))
                : (this._sourceLoaded = !0));
          }
          clearTiles() {
            (this._shouldReloadOnResume = !1), (this._paused = !1);
            for (const t in this._tiles) this._removeTile(t);
            this._cache.reset();
          }
          tilesIn(t, i, r) {
            const n = [],
              o = this.transform;
            if (!o) return n;
            const a = o.getCoveringTilesDetailsProvider().allowWorldCopies(),
              s = r ? o.getCameraQueryGeometry(t) : t,
              l = (t) => o.screenPointToMercatorCoordinate(t, this.terrain),
              c = this.transformBbox(t, l, !a),
              h = this.transformBbox(s, l, !a),
              u = this.getIds(),
              d = e.a6.fromPoints(h);
            for (let p = 0; p < u.length; p++) {
              const t = this._tiles[u[p]];
              if (t.holdingForSymbolFade()) continue;
              const r = a
                  ? [t.tileID]
                  : [t.tileID.unwrapTo(-1), t.tileID.unwrapTo(0)],
                s = Math.pow(2, o.zoom - t.tileID.overscaledZ),
                l = (i * t.queryPadding * e.a3) / t.tileSize / s;
              for (const i of r) {
                const r = d.map((t) => i.getTilePoint(new e.a5(t.x, t.y)));
                if ((r.expandBy(l), r.intersects(Mt))) {
                  const e = c.map((t) => i.getTilePoint(t)),
                    r = h.map((t) => i.getTilePoint(t));
                  n.push({
                    tile: t,
                    tileID: a ? i : i.unwrapTo(0),
                    queryGeometry: e,
                    cameraQueryGeometry: r,
                    scale: s,
                  });
                }
              }
            }
            return n;
          }
          transformBbox(t, i, r) {
            let n = t.map(i);
            if (r) {
              const r = e.a6.fromPoints(t);
              r.shrinkBy(0.001 * Math.min(r.width(), r.height()));
              const o = r.map(i);
              e.a6.fromPoints(n).covers(o) ||
                (n = n.map((t) =>
                  t.x > 0.5 ? new e.a5(t.x - 1, t.y, t.z) : t
                ));
            }
            return n;
          }
          getVisibleCoordinates(t) {
            const e = this.getRenderableIds(t).map(
              (t) => this._tiles[t].tileID
            );
            return this.transform && this.transform.populateCache(e), e;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (At(this._source.type) && this._rasterFadeDuration > 0) {
              const t = l();
              for (const e in this._tiles)
                if (this._tiles[e].fadeEndTime >= t) return !0;
            }
            return !1;
          }
          setRasterFadeDuration(t) {
            this._rasterFadeDuration = t;
          }
          setFeatureState(t, e, i) {
            this._state.updateState((t = t || '_geojsonTileLayer'), e, i);
          }
          removeFeatureState(t, e, i) {
            this._state.removeFeatureState(
              (t = t || '_geojsonTileLayer'),
              e,
              i
            );
          }
          getFeatureState(t, e) {
            return this._state.getState((t = t || '_geojsonTileLayer'), e);
          }
          setDependencies(t, e, i) {
            const r = this._tiles[t];
            r && r.setDependencies(e, i);
          }
          reloadTilesForDependencies(t, e) {
            for (const i in this._tiles)
              this._tiles[i].hasDependency(t, e) &&
                this._reloadTile(i, 'reloading');
            this._cache.filter((i) => !i.hasDependency(t, e));
          }
        }
        function Ct(t, e) {
          const i = Math.abs(2 * t.wrap) - +(t.wrap < 0),
            r = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return (
            t.overscaledZ - e.overscaledZ ||
            r - i ||
            e.canonical.y - t.canonical.y ||
            e.canonical.x - t.canonical.x
          );
        }
        function At(t) {
          return 'raster' === t || 'image' === t || 'video' === t;
        }
        (It.maxOverzooming = 10), (It.maxUnderzooming = 3);
        class Et {
          constructor(t, e) {
            this.reset(t, e);
          }
          reset(t, e) {
            (this.points = t || []), (this._distances = [0]);
            for (let i = 1; i < this.points.length; i++)
              this._distances[i] =
                this._distances[i - 1] +
                this.points[i].dist(this.points[i - 1]);
            (this.length = this._distances[this._distances.length - 1]),
              (this.padding = Math.min(e || 0, 0.5 * this.length)),
              (this.paddedLength = this.length - 2 * this.padding);
          }
          lerp(t) {
            if (1 === this.points.length) return this.points[0];
            t = e.ai(t, 0, 1);
            let i = 1,
              r = this._distances[i];
            const n = t * this.paddedLength + this.padding;
            for (; r < n && i < this._distances.length; )
              r = this._distances[++i];
            const o = i - 1,
              a = this._distances[o],
              s = r - a,
              l = s > 0 ? (n - a) / s : 0;
            return this.points[o].mult(1 - l).add(this.points[i].mult(l));
          }
        }
        function zt(t, e) {
          let i = !0;
          return (
            'always' === t || ('never' !== t && 'never' !== e) || (i = !1), i
          );
        }
        class kt {
          constructor(t, e, i) {
            const r = (this.boxCells = []),
              n = (this.circleCells = []);
            (this.xCellCount = Math.ceil(t / i)),
              (this.yCellCount = Math.ceil(e / i));
            for (let o = 0; o < this.xCellCount * this.yCellCount; o++)
              r.push([]), n.push([]);
            (this.circleKeys = []),
              (this.boxKeys = []),
              (this.bboxes = []),
              (this.circles = []),
              (this.width = t),
              (this.height = e),
              (this.xScale = this.xCellCount / t),
              (this.yScale = this.yCellCount / e),
              (this.boxUid = 0),
              (this.circleUid = 0);
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, e, i, r, n) {
            this._forEachCell(e, i, r, n, this._insertBoxCell, this.boxUid++),
              this.boxKeys.push(t),
              this.bboxes.push(e),
              this.bboxes.push(i),
              this.bboxes.push(r),
              this.bboxes.push(n);
          }
          insertCircle(t, e, i, r) {
            this._forEachCell(
              e - r,
              i - r,
              e + r,
              i + r,
              this._insertCircleCell,
              this.circleUid++
            ),
              this.circleKeys.push(t),
              this.circles.push(e),
              this.circles.push(i),
              this.circles.push(r);
          }
          _insertBoxCell(t, e, i, r, n, o) {
            this.boxCells[n].push(o);
          }
          _insertCircleCell(t, e, i, r, n, o) {
            this.circleCells[n].push(o);
          }
          _query(t, e, i, r, n, o, a) {
            if (i < 0 || t > this.width || r < 0 || e > this.height) return [];
            const s = [];
            if (t <= 0 && e <= 0 && this.width <= i && this.height <= r) {
              if (n) return [{ key: null, x1: t, y1: e, x2: i, y2: r }];
              for (let t = 0; t < this.boxKeys.length; t++)
                s.push({
                  key: this.boxKeys[t],
                  x1: this.bboxes[4 * t],
                  y1: this.bboxes[4 * t + 1],
                  x2: this.bboxes[4 * t + 2],
                  y2: this.bboxes[4 * t + 3],
                });
              for (let t = 0; t < this.circleKeys.length; t++) {
                const e = this.circles[3 * t],
                  i = this.circles[3 * t + 1],
                  r = this.circles[3 * t + 2];
                s.push({
                  key: this.circleKeys[t],
                  x1: e - r,
                  y1: i - r,
                  x2: e + r,
                  y2: i + r,
                });
              }
            } else this._forEachCell(t, e, i, r, this._queryCell, s, { hitTest: n, overlapMode: o, seenUids: { box: {}, circle: {} } }, a);
            return s;
          }
          query(t, e, i, r) {
            return this._query(t, e, i, r, !1, null);
          }
          hitTest(t, e, i, r, n, o) {
            return this._query(t, e, i, r, !0, n, o).length > 0;
          }
          hitTestCircle(t, e, i, r, n) {
            const o = t - i,
              a = t + i,
              s = e - i,
              l = e + i;
            if (a < 0 || o > this.width || l < 0 || s > this.height) return !1;
            const c = [];
            return (
              this._forEachCell(
                o,
                s,
                a,
                l,
                this._queryCellCircle,
                c,
                {
                  hitTest: !0,
                  overlapMode: r,
                  circle: { x: t, y: e, radius: i },
                  seenUids: { box: {}, circle: {} },
                },
                n
              ),
              c.length > 0
            );
          }
          _queryCell(t, e, i, r, n, o, a, s) {
            const { seenUids: l, hitTest: c, overlapMode: h } = a,
              u = this.boxCells[n];
            if (null !== u) {
              const n = this.bboxes;
              for (const a of u)
                if (!l.box[a]) {
                  l.box[a] = !0;
                  const u = 4 * a,
                    d = this.boxKeys[a];
                  if (
                    t <= n[u + 2] &&
                    e <= n[u + 3] &&
                    i >= n[u + 0] &&
                    r >= n[u + 1] &&
                    (!s || s(d)) &&
                    (!c || !zt(h, d.overlapMode)) &&
                    (o.push({
                      key: d,
                      x1: n[u],
                      y1: n[u + 1],
                      x2: n[u + 2],
                      y2: n[u + 3],
                    }),
                    c)
                  )
                    return !0;
                }
            }
            const d = this.circleCells[n];
            if (null !== d) {
              const n = this.circles;
              for (const a of d)
                if (!l.circle[a]) {
                  l.circle[a] = !0;
                  const u = 3 * a,
                    d = this.circleKeys[a];
                  if (
                    this._circleAndRectCollide(
                      n[u],
                      n[u + 1],
                      n[u + 2],
                      t,
                      e,
                      i,
                      r
                    ) &&
                    (!s || s(d)) &&
                    (!c || !zt(h, d.overlapMode))
                  ) {
                    const t = n[u],
                      e = n[u + 1],
                      i = n[u + 2];
                    if (
                      (o.push({
                        key: d,
                        x1: t - i,
                        y1: e - i,
                        x2: t + i,
                        y2: e + i,
                      }),
                      c)
                    )
                      return !0;
                  }
                }
            }
            return !1;
          }
          _queryCellCircle(t, e, i, r, n, o, a, s) {
            const { circle: l, seenUids: c, overlapMode: h } = a,
              u = this.boxCells[n];
            if (null !== u) {
              const t = this.bboxes;
              for (const e of u)
                if (!c.box[e]) {
                  c.box[e] = !0;
                  const i = 4 * e,
                    r = this.boxKeys[e];
                  if (
                    this._circleAndRectCollide(
                      l.x,
                      l.y,
                      l.radius,
                      t[i + 0],
                      t[i + 1],
                      t[i + 2],
                      t[i + 3]
                    ) &&
                    (!s || s(r)) &&
                    !zt(h, r.overlapMode)
                  )
                    return o.push(!0), !0;
                }
            }
            const d = this.circleCells[n];
            if (null !== d) {
              const t = this.circles;
              for (const e of d)
                if (!c.circle[e]) {
                  c.circle[e] = !0;
                  const i = 3 * e,
                    r = this.circleKeys[e];
                  if (
                    this._circlesCollide(
                      t[i],
                      t[i + 1],
                      t[i + 2],
                      l.x,
                      l.y,
                      l.radius
                    ) &&
                    (!s || s(r)) &&
                    !zt(h, r.overlapMode)
                  )
                    return o.push(!0), !0;
                }
            }
          }
          _forEachCell(t, e, i, r, n, o, a, s) {
            const l = this._convertToXCellCoord(t),
              c = this._convertToYCellCoord(e),
              h = this._convertToXCellCoord(i),
              u = this._convertToYCellCoord(r);
            for (let d = l; d <= h; d++)
              for (let l = c; l <= u; l++)
                if (n.call(this, t, e, i, r, this.xCellCount * l + d, o, a, s))
                  return;
          }
          _convertToXCellCoord(t) {
            return Math.max(
              0,
              Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))
            );
          }
          _convertToYCellCoord(t) {
            return Math.max(
              0,
              Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))
            );
          }
          _circlesCollide(t, e, i, r, n, o) {
            const a = r - t,
              s = n - e,
              l = i + o;
            return l * l > a * a + s * s;
          }
          _circleAndRectCollide(t, e, i, r, n, o, a) {
            const s = (o - r) / 2,
              l = Math.abs(t - (r + s));
            if (l > s + i) return !1;
            const c = (a - n) / 2,
              h = Math.abs(e - (n + c));
            if (h > c + i) return !1;
            if (l <= s || h <= c) return !0;
            const u = l - s,
              d = h - c;
            return u * u + d * d <= i * i;
          }
        }
        function Dt(t, i, n) {
          const o = e.M();
          if (!t) {
            const { vecSouth: t, vecEast: e } = Lt(i),
              n = r();
            (n[0] = e[0]),
              (n[1] = e[1]),
              (n[2] = t[0]),
              (n[3] = t[1]),
              (a = n),
              (d = (l = (s = n)[0]) * (u = s[3]) - (h = s[2]) * (c = s[1])) &&
                ((a[0] = u * (d = 1 / d)),
                (a[1] = -c * d),
                (a[2] = -h * d),
                (a[3] = l * d)),
              (o[0] = n[0]),
              (o[1] = n[1]),
              (o[4] = n[2]),
              (o[5] = n[3]);
          }
          var a, s, l, c, h, u, d;
          return e.O(o, o, [1 / n, 1 / n, 1]), o;
        }
        function Rt(t, i, r, n) {
          if (t) {
            const t = e.M();
            if (!i) {
              const { vecSouth: e, vecEast: i } = Lt(r);
              (t[0] = i[0]), (t[1] = i[1]), (t[4] = e[0]), (t[5] = e[1]);
            }
            return e.O(t, t, [n, n, 1]), t;
          }
          return r.pixelsToClipSpaceMatrix;
        }
        function Lt(t) {
          const i = Math.cos(t.rollInRadians),
            r = Math.sin(t.rollInRadians),
            n = Math.cos(t.pitchInRadians),
            o = Math.cos(t.bearingInRadians),
            a = Math.sin(t.bearingInRadians),
            s = e.av();
          (s[0] = -o * n * r - a * i), (s[1] = -a * n * r + o * i);
          const l = e.aw(s);
          l < 1e-9 ? e.ax(s) : e.ay(s, s, 1 / l);
          const c = e.av();
          (c[0] = o * n * i - a * r), (c[1] = a * n * i + o * r);
          const h = e.aw(c);
          return (
            h < 1e-9 ? e.ax(c) : e.ay(c, c, 1 / h), { vecEast: c, vecSouth: s }
          );
        }
        function Ft(t, i, r, n) {
          let o;
          n
            ? ((o = [t, i, n(t, i), 1]), e.aA(o, o, r))
            : ((o = [t, i, 0, 1]), Qt(o, o, r));
          const a = o[3];
          return {
            point: new e.P(o[0] / a, o[1] / a),
            signedDistanceFromCamera: a,
            isOccluded: !1,
          };
        }
        function Bt(t, e) {
          return 0.5 + (t / e) * 0.5;
        }
        function Ot(t, e) {
          return t.x >= -e[0] && t.x <= e[0] && t.y >= -e[1] && t.y <= e[1];
        }
        function jt(t, i, r, n, o, a, s, l, c, h, u, d, p) {
          const f = r ? t.textSizeData : t.iconSizeData,
            m = e.ar(f, i.transform.zoom),
            _ = [(256 / i.width) * 2 + 1, (256 / i.height) * 2 + 1],
            g = r
              ? t.text.dynamicLayoutVertexArray
              : t.icon.dynamicLayoutVertexArray;
          g.clear();
          const y = t.lineVertexArray,
            x = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
            v = i.transform.width / i.transform.height;
          let b = !1;
          for (let w = 0; w < x.length; w++) {
            const r = x.get(w);
            if (r.hidden || (r.writingMode === e.as.vertical && !b)) {
              Jt(r.numGlyphs, g);
              continue;
            }
            b = !1;
            const T = new e.P(r.anchorX, r.anchorY),
              P = {
                getElevation: p,
                pitchedLabelPlaneMatrix: n,
                lineVertexArray: y,
                pitchWithMap: a,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1,
                },
                transform: i.transform,
                tileAnchorPoint: T,
                unwrappedTileID: c,
                width: h,
                height: u,
                translation: d,
              },
              S = Wt(r.anchorX, r.anchorY, P);
            if (!Ot(S.point, _)) {
              Jt(r.numGlyphs, g);
              continue;
            }
            const M = Bt(
                i.transform.cameraToCenterDistance,
                S.signedDistanceFromCamera
              ),
              I = e.at(f, m, r),
              C = a
                ? (I *
                    i.transform.getPitchedTextCorrection(
                      r.anchorX,
                      r.anchorY,
                      c
                    )) /
                  M
                : I * M,
              A = Ut({
                projectionContext: P,
                pitchedLabelPlaneMatrixInverse: o,
                symbol: r,
                fontSize: C,
                flip: !1,
                keepUpright: s,
                glyphOffsetArray: t.glyphOffsetArray,
                dynamicLayoutVertexArray: g,
                aspectRatio: v,
                rotateToLine: l,
              });
            (b = A.useVertical),
              (A.notEnoughRoom ||
                b ||
                (A.needsFlipping &&
                  Ut({
                    projectionContext: P,
                    pitchedLabelPlaneMatrixInverse: o,
                    symbol: r,
                    fontSize: C,
                    flip: !0,
                    keepUpright: s,
                    glyphOffsetArray: t.glyphOffsetArray,
                    dynamicLayoutVertexArray: g,
                    aspectRatio: v,
                    rotateToLine: l,
                  }).notEnoughRoom)) &&
                Jt(r.numGlyphs, g);
          }
          r
            ? t.text.dynamicLayoutVertexBuffer.updateData(g)
            : t.icon.dynamicLayoutVertexBuffer.updateData(g);
        }
        function Nt(t, e, i, r, n, o, a, s) {
          const l = o.glyphStartIndex + o.numGlyphs,
            c = o.lineStartIndex,
            h = o.lineStartIndex + o.lineLength,
            u = e.getoffsetX(o.glyphStartIndex),
            d = e.getoffsetX(l - 1),
            p = Xt(t * u, i, r, n, o.segment, c, h, s, a);
          if (!p) return null;
          const f = Xt(t * d, i, r, n, o.segment, c, h, s, a);
          return f
            ? s.projectionCache.anyProjectionOccluded
              ? null
              : { first: p, last: f }
            : null;
        }
        function Vt(t, i, r, n) {
          return t === e.as.horizontal &&
            Math.abs(r.y - i.y) > Math.abs(r.x - i.x) * n
            ? { useVertical: !0 }
            : (t === e.as.vertical ? i.y < r.y : i.x > r.x)
            ? { needsFlipping: !0 }
            : null;
        }
        function Ut(t) {
          const {
              projectionContext: i,
              pitchedLabelPlaneMatrixInverse: r,
              symbol: n,
              fontSize: o,
              flip: a,
              keepUpright: s,
              glyphOffsetArray: l,
              dynamicLayoutVertexArray: c,
              aspectRatio: h,
              rotateToLine: u,
            } = t,
            d = o / 24,
            p = n.lineOffsetX * d,
            f = n.lineOffsetY * d;
          let m;
          if (n.numGlyphs > 1) {
            const t = n.glyphStartIndex + n.numGlyphs,
              e = n.lineStartIndex,
              o = n.lineStartIndex + n.lineLength,
              c = Nt(d, l, p, f, a, n, u, i);
            if (!c) return { notEnoughRoom: !0 };
            const _ = qt(c.first.point.x, c.first.point.y, i, r),
              g = qt(c.last.point.x, c.last.point.y, i, r);
            if (s && !a) {
              const t = Vt(n.writingMode, _, g, h);
              if (t) return t;
            }
            m = [c.first];
            for (let r = n.glyphStartIndex + 1; r < t - 1; r++) {
              const t = Xt(d * l.getoffsetX(r), p, f, a, n.segment, e, o, i, u);
              if (!t) return { notEnoughRoom: !0 };
              m.push(t);
            }
            m.push(c.last);
          } else {
            if (s && !a) {
              const t = $t(i.tileAnchorPoint.x, i.tileAnchorPoint.y, i).point,
                o = n.lineStartIndex + n.segment + 1,
                a = new e.P(
                  i.lineVertexArray.getx(o),
                  i.lineVertexArray.gety(o)
                ),
                s = $t(a.x, a.y, i),
                l =
                  s.signedDistanceFromCamera > 0
                    ? s.point
                    : Gt(i.tileAnchorPoint, a, t, 1, i),
                c = qt(t.x, t.y, i, r),
                u = qt(l.x, l.y, i, r),
                d = Vt(n.writingMode, c, u, h);
              if (d) return d;
            }
            const t = Xt(
              d * l.getoffsetX(n.glyphStartIndex),
              p,
              f,
              a,
              n.segment,
              n.lineStartIndex,
              n.lineStartIndex + n.lineLength,
              i,
              u
            );
            if (!t || i.projectionCache.anyProjectionOccluded)
              return { notEnoughRoom: !0 };
            m = [t];
          }
          for (const _ of m) e.az(c, _.point, _.angle);
          return {};
        }
        function Gt(t, e, i, r, n) {
          const o = t.add(t.sub(e)._unit()),
            a = $t(o.x, o.y, n).point,
            s = i.sub(a);
          return i.add(s._mult(r / s.mag()));
        }
        function Zt(t, i, r) {
          const n = i.projectionCache;
          if (n.projections[t]) return n.projections[t];
          const o = new e.P(
              i.lineVertexArray.getx(t),
              i.lineVertexArray.gety(t)
            ),
            a = $t(o.x, o.y, i);
          if (a.signedDistanceFromCamera > 0)
            return (
              (n.projections[t] = a.point),
              (n.anyProjectionOccluded =
                n.anyProjectionOccluded || a.isOccluded),
              a.point
            );
          const s = t - r.direction;
          return Gt(
            0 === r.distanceFromAnchor
              ? i.tileAnchorPoint
              : new e.P(i.lineVertexArray.getx(s), i.lineVertexArray.gety(s)),
            o,
            r.previousVertex,
            r.absOffsetX - r.distanceFromAnchor + 1,
            i
          );
        }
        function $t(t, e, i) {
          const r = t + i.translation[0],
            n = e + i.translation[1];
          let o;
          return (
            i.pitchWithMap
              ? ((o = Ft(r, n, i.pitchedLabelPlaneMatrix, i.getElevation)),
                (o.isOccluded = !1))
              : ((o = i.transform.projectTileCoordinates(
                  r,
                  n,
                  i.unwrappedTileID,
                  i.getElevation
                )),
                (o.point.x = (0.5 * o.point.x + 0.5) * i.width),
                (o.point.y = (0.5 * -o.point.y + 0.5) * i.height)),
            o
          );
        }
        function qt(t, i, r, n) {
          if (r.pitchWithMap) {
            const o = [t, i, 0, 1];
            return (
              e.aA(o, o, n),
              r.transform.projectTileCoordinates(
                o[0] / o[3],
                o[1] / o[3],
                r.unwrappedTileID,
                r.getElevation
              ).point
            );
          }
          return { x: (t / r.width) * 2 - 1, y: 1 - (i / r.height) * 2 };
        }
        function Wt(t, e, i) {
          return i.transform.projectTileCoordinates(
            t,
            e,
            i.unwrappedTileID,
            i.getElevation
          );
        }
        function Yt(t, e, i) {
          return t
            ._unit()
            ._perp()
            ._mult(e * i);
        }
        function Ht(t, i, r, n, o, a, s, l, c) {
          if (l.projectionCache.offsets[t]) return l.projectionCache.offsets[t];
          const h = r.add(i);
          if (t + c.direction < n || t + c.direction >= o)
            return (l.projectionCache.offsets[t] = h), h;
          const u = Zt(t + c.direction, l, c),
            d = Yt(u.sub(r), s, c.direction),
            p = r.add(d),
            f = u.add(d);
          return (
            (l.projectionCache.offsets[t] = e.aB(a, h, p, f) || h),
            l.projectionCache.offsets[t]
          );
        }
        function Xt(t, e, i, r, n, o, a, s, l) {
          const c = r ? t - e : t + e;
          let h = c > 0 ? 1 : -1,
            u = 0;
          r && ((h *= -1), (u = Math.PI)), h < 0 && (u += Math.PI);
          let d,
            p = h > 0 ? o + n : o + n + 1;
          s.projectionCache.cachedAnchorPoint
            ? (d = s.projectionCache.cachedAnchorPoint)
            : ((d = $t(s.tileAnchorPoint.x, s.tileAnchorPoint.y, s).point),
              (s.projectionCache.cachedAnchorPoint = d));
          let f,
            m,
            _ = d,
            g = d,
            y = 0,
            x = 0;
          const v = Math.abs(c),
            b = [];
          let w;
          for (; y + x <= v; ) {
            if (((p += h), p < o || p >= a)) return null;
            (y += x), (g = _), (m = f);
            const t = {
              absOffsetX: v,
              direction: h,
              distanceFromAnchor: y,
              previousVertex: g,
            };
            if (((_ = Zt(p, s, t)), 0 === i)) b.push(g), (w = _.sub(g));
            else {
              let e;
              const r = _.sub(g);
              (e =
                0 === r.mag() ? Yt(Zt(p + h, s, t).sub(_), i, h) : Yt(r, i, h)),
                m || (m = g.add(e)),
                (f = Ht(p, e, _, o, a, m, i, s, t)),
                b.push(m),
                (w = f.sub(m));
            }
            x = w.mag();
          }
          const T = w._mult((v - y) / x)._add(m || g),
            P = u + Math.atan2(_.y - g.y, _.x - g.x);
          return b.push(T), { point: T, angle: l ? P : 0, path: b };
        }
        const Kt = new Float32Array([
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
          -1 / 0,
          -1 / 0,
          0,
        ]);
        function Jt(t, e) {
          for (let i = 0; i < t; i++) {
            const t = e.length;
            e.resize(t + 4), e.float32.set(Kt, 3 * t);
          }
        }
        function Qt(t, e, i) {
          const r = e[0],
            n = e[1];
          return (
            (t[0] = i[0] * r + i[4] * n + i[12]),
            (t[1] = i[1] * r + i[5] * n + i[13]),
            (t[3] = i[3] * r + i[7] * n + i[15]),
            t
          );
        }
        const te = 100;
        class ee {
          constructor(
            t,
            e = new kt(t.width + 200, t.height + 200, 25),
            i = new kt(t.width + 200, t.height + 200, 25)
          ) {
            (this.transform = t),
              (this.grid = e),
              (this.ignoredGrid = i),
              (this.pitchFactor =
                Math.cos((t.pitch * Math.PI) / 180) * t.cameraToCenterDistance),
              (this.screenRightBoundary = t.width + te),
              (this.screenBottomBoundary = t.height + te),
              (this.gridRightBoundary = t.width + 200),
              (this.gridBottomBoundary = t.height + 200),
              (this.perspectiveRatioCutoff = 0.6);
          }
          placeCollisionBox(t, e, i, r, n, o, a, s, l, c, h, u) {
            const d = this.projectAndGetPerspectiveRatio(
                t.anchorPointX + s[0],
                t.anchorPointY + s[1],
                n,
                c,
                u
              ),
              p = i * d.perspectiveRatio;
            let f;
            if (o || a)
              f = this._projectCollisionBox(t, p, r, n, o, a, s, d, c, h, u);
            else {
              const e = d.x + (h ? h.x * p : 0),
                i = d.y + (h ? h.y * p : 0);
              f = {
                allPointsOccluded: !1,
                box: [e + t.x1 * p, i + t.y1 * p, e + t.x2 * p, i + t.y2 * p],
              };
            }
            const [m, _, g, y] = f.box,
              x = o ? f.allPointsOccluded : d.isOccluded;
            let v = x;
            return (
              v || (v = d.perspectiveRatio < this.perspectiveRatioCutoff),
              v || (v = !this.isInsideGrid(m, _, g, y)),
              v || ('always' !== e && this.grid.hitTest(m, _, g, y, e, l))
                ? {
                    box: [m, _, g, y],
                    placeable: !1,
                    offscreen: !1,
                    occluded: x,
                  }
                : {
                    box: [m, _, g, y],
                    placeable: !0,
                    offscreen: this.isOffscreen(m, _, g, y),
                    occluded: x,
                  }
            );
          }
          placeCollisionCircles(t, i, r, n, o, a, s, l, c, h, u, d, p, f) {
            const m = [],
              _ = new e.P(i.anchorX, i.anchorY),
              g = this.getPerspectiveRatio(_.x, _.y, a, f),
              y =
                (c
                  ? (o *
                      this.transform.getPitchedTextCorrection(
                        i.anchorX,
                        i.anchorY,
                        a
                      )) /
                    g
                  : o * g) / e.aF,
              x = {
                getElevation: f,
                pitchedLabelPlaneMatrix: s,
                lineVertexArray: r,
                pitchWithMap: c,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1,
                },
                transform: this.transform,
                tileAnchorPoint: _,
                unwrappedTileID: a,
                width: this.transform.width,
                height: this.transform.height,
                translation: p,
              },
              v = Nt(y, n, i.lineOffsetX * y, i.lineOffsetY * y, !1, i, !1, x);
            let b = !1,
              w = !1,
              T = !0;
            if (v) {
              const i = 0.5 * u * g + d,
                r = new e.P(-100, -100),
                n = new e.P(
                  this.screenRightBoundary,
                  this.screenBottomBoundary
                ),
                o = new Et(),
                a = v.first,
                s = v.last;
              let p = [];
              for (let t = a.path.length - 1; t >= 1; t--) p.push(a.path[t]);
              for (let t = 1; t < s.path.length; t++) p.push(s.path[t]);
              const f = 2.5 * i;
              if (c) {
                const t = this.projectPathToScreenSpace(p, x);
                p = t.some((t) => t.signedDistanceFromCamera <= 0)
                  ? []
                  : t.map((t) => t.point);
              }
              let _ = [];
              if (p.length > 0) {
                const t = p[0].clone(),
                  i = p[0].clone();
                for (let e = 1; e < p.length; e++)
                  (t.x = Math.min(t.x, p[e].x)),
                    (t.y = Math.min(t.y, p[e].y)),
                    (i.x = Math.max(i.x, p[e].x)),
                    (i.y = Math.max(i.y, p[e].y));
                _ =
                  t.x >= r.x && i.x <= n.x && t.y >= r.y && i.y <= n.y
                    ? [p]
                    : i.x < r.x || t.x > n.x || i.y < r.y || t.y > n.y
                    ? []
                    : e.aC([p], r.x, r.y, n.x, n.y);
              }
              for (const e of _) {
                o.reset(e, 0.25 * i);
                let r = 0;
                r = o.length <= 0.5 * i ? 1 : Math.ceil(o.paddedLength / f) + 1;
                for (let e = 0; e < r; e++) {
                  const n = e / Math.max(r - 1, 1),
                    a = o.lerp(n),
                    s = a.x + te,
                    c = a.y + te;
                  m.push(s, c, i, 0);
                  const u = s - i,
                    d = c - i,
                    p = s + i,
                    f = c + i;
                  if (
                    ((T = T && this.isOffscreen(u, d, p, f)),
                    (w = w || this.isInsideGrid(u, d, p, f)),
                    'always' !== t &&
                      this.grid.hitTestCircle(s, c, i, t, h) &&
                      ((b = !0), !l))
                  )
                    return { circles: [], offscreen: !1, collisionDetected: b };
                }
              }
            }
            return {
              circles:
                (!l && b) || !w || g < this.perspectiveRatioCutoff ? [] : m,
              offscreen: T,
              collisionDetected: b,
            };
          }
          projectPathToScreenSpace(t, i) {
            const r = (function (t, i) {
              const r = e.M();
              return (
                e.au(r, i.pitchedLabelPlaneMatrix),
                t.map((t) => {
                  const e = Ft(t.x, t.y, r, i.getElevation),
                    n = i.transform.projectTileCoordinates(
                      e.point.x,
                      e.point.y,
                      i.unwrappedTileID,
                      i.getElevation
                    );
                  return (
                    (n.point.x = (0.5 * n.point.x + 0.5) * i.width),
                    (n.point.y = (0.5 * -n.point.y + 0.5) * i.height),
                    n
                  );
                })
              );
            })(t, i);
            return (function (t) {
              let e = 0,
                i = 0,
                r = 0,
                n = 0;
              for (let o = 0; o < t.length; o++)
                t[o].isOccluded
                  ? ((r = o + 1), (n = 0))
                  : (n++, n > i && ((i = n), (e = r)));
              return t.slice(e, e + i);
            })(r);
          }
          queryRenderedSymbols(t) {
            if (
              0 === t.length ||
              (0 === this.grid.keysLength() &&
                0 === this.ignoredGrid.keysLength())
            )
              return {};
            const i = [],
              r = new e.a6();
            for (const u of t) {
              const t = new e.P(u.x + te, u.y + te);
              r.extend(t), i.push(t);
            }
            const { minX: n, minY: o, maxX: a, maxY: s } = r,
              l = this.grid
                .query(n, o, a, s)
                .concat(this.ignoredGrid.query(n, o, a, s)),
              c = {},
              h = {};
            for (const u of l) {
              const t = u.key;
              if (
                (void 0 === c[t.bucketInstanceId] &&
                  (c[t.bucketInstanceId] = {}),
                c[t.bucketInstanceId][t.featureIndex])
              )
                continue;
              const r = [
                new e.P(u.x1, u.y1),
                new e.P(u.x2, u.y1),
                new e.P(u.x2, u.y2),
                new e.P(u.x1, u.y2),
              ];
              e.aD(i, r) &&
                ((c[t.bucketInstanceId][t.featureIndex] = !0),
                void 0 === h[t.bucketInstanceId] &&
                  (h[t.bucketInstanceId] = []),
                h[t.bucketInstanceId].push(t.featureIndex));
            }
            return h;
          }
          insertCollisionBox(t, e, i, r, n, o) {
            (i ? this.ignoredGrid : this.grid).insert(
              {
                bucketInstanceId: r,
                featureIndex: n,
                collisionGroupID: o,
                overlapMode: e,
              },
              t[0],
              t[1],
              t[2],
              t[3]
            );
          }
          insertCollisionCircles(t, e, i, r, n, o) {
            const a = i ? this.ignoredGrid : this.grid,
              s = {
                bucketInstanceId: r,
                featureIndex: n,
                collisionGroupID: o,
                overlapMode: e,
              };
            for (let l = 0; l < t.length; l += 4)
              a.insertCircle(s, t[l], t[l + 1], t[l + 2]);
          }
          projectAndGetPerspectiveRatio(t, i, r, n, o) {
            if (o) {
              let r;
              n
                ? ((r = [t, i, n(t, i), 1]), e.aA(r, r, o))
                : ((r = [t, i, 0, 1]), Qt(r, r, o));
              const a = r[3];
              return {
                x: ((r[0] / a + 1) / 2) * this.transform.width + te,
                y: ((-r[1] / a + 1) / 2) * this.transform.height + te,
                perspectiveRatio:
                  0.5 + (this.transform.cameraToCenterDistance / a) * 0.5,
                isOccluded: !1,
                signedDistanceFromCamera: a,
              };
            }
            {
              const e = this.transform.projectTileCoordinates(t, i, r, n);
              return {
                x: ((e.point.x + 1) / 2) * this.transform.width + te,
                y: ((1 - e.point.y) / 2) * this.transform.height + te,
                perspectiveRatio:
                  0.5 +
                  (this.transform.cameraToCenterDistance /
                    e.signedDistanceFromCamera) *
                    0.5,
                isOccluded: e.isOccluded,
                signedDistanceFromCamera: e.signedDistanceFromCamera,
              };
            }
          }
          getPerspectiveRatio(t, e, i, r) {
            const n = this.transform.projectTileCoordinates(t, e, i, r);
            return (
              0.5 +
              (this.transform.cameraToCenterDistance /
                n.signedDistanceFromCamera) *
                0.5
            );
          }
          isOffscreen(t, e, i, r) {
            return (
              i < te ||
              t >= this.screenRightBoundary ||
              r < te ||
              e > this.screenBottomBoundary
            );
          }
          isInsideGrid(t, e, i, r) {
            return (
              i >= 0 &&
              t < this.gridRightBoundary &&
              r >= 0 &&
              e < this.gridBottomBoundary
            );
          }
          getViewportMatrix() {
            const t = e.am([]);
            return e.N(t, t, [-100, -100, 0]), t;
          }
          _projectCollisionBox(t, i, r, n, o, a, s, l, c, h, u) {
            let d = 1,
              p = 0,
              f = 0,
              m = 1;
            const _ = t.anchorPointX + s[0],
              g = t.anchorPointY + s[1];
            if (a && !o) {
              const t = this.projectAndGetPerspectiveRatio(_ + 1, g, n, c, u),
                e = t.x - l.x,
                i = Math.atan((t.y - l.y) / e) + (e < 0 ? Math.PI : 0),
                r = Math.sin(i),
                o = Math.cos(i);
              (d = o), (p = r), (f = -r), (m = o);
            } else if (!a && o) {
              const t = Lt(this.transform);
              (d = t.vecEast[0]),
                (p = t.vecEast[1]),
                (f = t.vecSouth[0]),
                (m = t.vecSouth[1]);
            }
            let y = l.x,
              x = l.y,
              v = i;
            o &&
              ((y = _),
              (x = g),
              (v = Math.pow(2, -(this.transform.zoom - r.overscaledZ))),
              (v *= this.transform.getPitchedTextCorrection(_, g, n)),
              h ||
                (v *= e.ai(
                  0.5 +
                    (l.signedDistanceFromCamera /
                      this.transform.cameraToCenterDistance) *
                      0.5,
                  0,
                  4
                ))),
              h &&
                ((y += d * h.x * v + f * h.y * v),
                (x += p * h.x * v + m * h.y * v));
            const b = t.x1 * v,
              w = t.x2 * v,
              T = (b + w) / 2,
              P = t.y1 * v,
              S = t.y2 * v,
              M = (P + S) / 2,
              I = [
                { offsetX: b, offsetY: P },
                { offsetX: T, offsetY: P },
                { offsetX: w, offsetY: P },
                { offsetX: w, offsetY: M },
                { offsetX: w, offsetY: S },
                { offsetX: T, offsetY: S },
                { offsetX: b, offsetY: S },
                { offsetX: b, offsetY: M },
              ];
            let C = [];
            for (const { offsetX: E, offsetY: z } of I)
              C.push(new e.P(y + d * E + f * z, x + p * E + m * z));
            let A = !1;
            if (o) {
              const t = C.map((t) =>
                this.projectAndGetPerspectiveRatio(t.x, t.y, n, c, u)
              );
              (A = t.some((t) => !t.isOccluded)),
                (C = t.map((t) => new e.P(t.x, t.y)));
            } else A = !0;
            return { box: e.aE(C), allPointsOccluded: !A };
          }
        }
        class ie {
          constructor(t, e, i, r) {
            (this.opacity = t
              ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e)))
              : r && i
              ? 1
              : 0),
              (this.placed = i);
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class re {
          constructor(t, e, i, r, n) {
            (this.text = new ie(t ? t.text : null, e, i, n)),
              (this.icon = new ie(t ? t.icon : null, e, r, n));
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class ne {
          constructor(t, e, i) {
            (this.text = t), (this.icon = e), (this.skipFade = i);
          }
        }
        class oe {
          constructor(t, e, i, r, n) {
            (this.bucketInstanceId = t),
              (this.featureIndex = e),
              (this.sourceLayerIndex = i),
              (this.bucketIndex = r),
              (this.tileID = n);
          }
        }
        class ae {
          constructor(t) {
            (this.crossSourceCollisions = t),
              (this.maxGroupID = 0),
              (this.collisionGroups = {});
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const e = ++this.maxGroupID;
              this.collisionGroups[t] = {
                ID: e,
                predicate: (t) => t.collisionGroupID === e,
              };
            }
            return this.collisionGroups[t];
          }
        }
        function se(t, i, r, n, o) {
          const { horizontalAlign: a, verticalAlign: s } = e.aL(t);
          return new e.P(-(a - 0.5) * i + n[0] * o, -(s - 0.5) * r + n[1] * o);
        }
        class le {
          constructor(t, e, i, r, n) {
            (this.transform = t.clone()),
              (this.terrain = e),
              (this.collisionIndex = new ee(this.transform)),
              (this.placements = {}),
              (this.opacities = {}),
              (this.variableOffsets = {}),
              (this.stale = !1),
              (this.commitTime = 0),
              (this.fadeDuration = i),
              (this.retainedQueryData = {}),
              (this.collisionGroups = new ae(r)),
              (this.collisionCircleArrays = {}),
              (this.collisionBoxArrays = new Map()),
              (this.prevPlacement = n),
              n && (n.prevPlacement = void 0),
              (this.placedOrientations = {});
          }
          _getTerrainElevationFunc(t) {
            const e = this.terrain;
            return e ? (i, r) => e.getElevation(t, i, r) : null;
          }
          getBucketParts(t, i, r, n) {
            const o = r.getBucket(i),
              a = r.latestFeatureIndex;
            if (!o || !a || i.id !== o.layerIds[0]) return;
            const s = r.collisionBoxArray,
              l = o.layers[0].layout,
              c = o.layers[0].paint,
              h = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ),
              u = r.tileSize / e.a3,
              d = r.tileID.toUnwrapped(),
              p = 'map' === l.get('text-rotation-alignment'),
              f = e.aG(r, 1, this.transform.zoom),
              m = e.aH(
                this.collisionIndex.transform,
                r,
                c.get('text-translate'),
                c.get('text-translate-anchor')
              ),
              _ = e.aH(
                this.collisionIndex.transform,
                r,
                c.get('icon-translate'),
                c.get('icon-translate-anchor')
              ),
              g = Dt(p, this.transform, f);
            this.retainedQueryData[o.bucketInstanceId] = new oe(
              o.bucketInstanceId,
              a,
              o.sourceLayerIndex,
              o.index,
              r.tileID
            );
            const y = {
              bucket: o,
              layout: l,
              translationText: m,
              translationIcon: _,
              unwrappedTileID: d,
              pitchedLabelPlaneMatrix: g,
              scale: h,
              textPixelRatio: u,
              holdingForFade: r.holdingForSymbolFade(),
              collisionBoxArray: s,
              partiallyEvaluatedTextSize: e.ar(
                o.textSizeData,
                this.transform.zoom
              ),
              collisionGroup: this.collisionGroups.get(o.sourceID),
            };
            if (n)
              for (const e of o.sortKeyRanges) {
                const {
                  sortKey: i,
                  symbolInstanceStart: r,
                  symbolInstanceEnd: n,
                } = e;
                t.push({
                  sortKey: i,
                  symbolInstanceStart: r,
                  symbolInstanceEnd: n,
                  parameters: y,
                });
              }
            else
              t.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: o.symbolInstances.length,
                parameters: y,
              });
          }
          attemptAnchorPlacement(
            t,
            i,
            r,
            n,
            o,
            a,
            s,
            l,
            c,
            h,
            u,
            d,
            p,
            f,
            m,
            _,
            g,
            y,
            x,
            v
          ) {
            const b = e.aI[t.textAnchor],
              w = [t.textOffset0, t.textOffset1],
              T = se(b, r, n, w, o),
              P = this.collisionIndex.placeCollisionBox(
                i,
                d,
                l,
                c,
                h,
                s,
                a,
                _,
                u.predicate,
                x,
                T,
                v
              );
            if (
              (!y ||
                this.collisionIndex.placeCollisionBox(
                  y,
                  d,
                  l,
                  c,
                  h,
                  s,
                  a,
                  g,
                  u.predicate,
                  x,
                  T,
                  v
                ).placeable) &&
              P.placeable
            ) {
              let t;
              if (
                (this.prevPlacement &&
                  this.prevPlacement.variableOffsets[p.crossTileID] &&
                  this.prevPlacement.placements[p.crossTileID] &&
                  this.prevPlacement.placements[p.crossTileID].text &&
                  (t =
                    this.prevPlacement.variableOffsets[p.crossTileID].anchor),
                0 === p.crossTileID)
              )
                throw new Error("symbolInstance.crossTileID can't be 0");
              return (
                (this.variableOffsets[p.crossTileID] = {
                  textOffset: w,
                  width: r,
                  height: n,
                  anchor: b,
                  textBoxScale: o,
                  prevAnchor: t,
                }),
                this.markUsedJustification(f, b, p, m),
                f.allowVerticalPlacement &&
                  (this.markUsedOrientation(f, m, p),
                  (this.placedOrientations[p.crossTileID] = m)),
                { shift: T, placedGlyphBoxes: P }
              );
            }
          }
          placeLayerBucketPart(t, i, r) {
            const {
                bucket: n,
                layout: o,
                translationText: a,
                translationIcon: s,
                unwrappedTileID: l,
                pitchedLabelPlaneMatrix: c,
                textPixelRatio: h,
                holdingForFade: u,
                collisionBoxArray: d,
                partiallyEvaluatedTextSize: p,
                collisionGroup: f,
              } = t.parameters,
              m = o.get('text-optional'),
              _ = o.get('icon-optional'),
              g = e.aJ(o, 'text-overlap', 'text-allow-overlap'),
              y = 'always' === g,
              x = e.aJ(o, 'icon-overlap', 'icon-allow-overlap'),
              v = 'always' === x,
              b = 'map' === o.get('text-rotation-alignment'),
              w = 'map' === o.get('text-pitch-alignment'),
              T = 'none' !== o.get('icon-text-fit'),
              P = 'viewport-y' === o.get('symbol-z-order'),
              S = y && (v || !n.hasIconData() || _),
              M = v && (y || !n.hasTextData() || m);
            !n.collisionArrays && d && n.deserializeCollisionBoxes(d);
            const I = this.retainedQueryData[n.bucketInstanceId].tileID,
              C = this._getTerrainElevationFunc(I),
              A = this.transform.getFastPathSimpleProjectionMatrix(I),
              E = (t, d, v) => {
                var P, E;
                if (i[t.crossTileID]) return;
                if (u)
                  return void (this.placements[t.crossTileID] = new ne(
                    !1,
                    !1,
                    !1
                  ));
                let z = !1,
                  k = !1,
                  D = !0,
                  R = null,
                  L = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1,
                  },
                  F = { placeable: !1 },
                  B = null,
                  O = null,
                  j = null,
                  N = 0,
                  V = 0,
                  U = 0;
                d.textFeatureIndex
                  ? (N = d.textFeatureIndex)
                  : t.useRuntimeCollisionCircles && (N = t.featureIndex),
                  d.verticalTextFeatureIndex &&
                    (V = d.verticalTextFeatureIndex);
                const G = d.textBox;
                if (G) {
                  const i = (i) => {
                      let r = e.as.horizontal;
                      if (
                        n.allowVerticalPlacement &&
                        !i &&
                        this.prevPlacement
                      ) {
                        const e =
                          this.prevPlacement.placedOrientations[t.crossTileID];
                        e &&
                          ((this.placedOrientations[t.crossTileID] = e),
                          (r = e),
                          this.markUsedOrientation(n, r, t));
                      }
                      return r;
                    },
                    o = (i, r) => {
                      if (
                        n.allowVerticalPlacement &&
                        t.numVerticalGlyphVertices > 0 &&
                        d.verticalTextBox
                      ) {
                        for (const t of n.writingModes)
                          if (
                            (t === e.as.vertical
                              ? ((L = r()), (F = L))
                              : (L = i()),
                            L && L.placeable)
                          )
                            break;
                      } else L = i();
                    },
                    c = t.textAnchorOffsetStartIndex,
                    u = t.textAnchorOffsetEndIndex;
                  if (u === c) {
                    const r = (e, i) => {
                      const r = this.collisionIndex.placeCollisionBox(
                        e,
                        g,
                        h,
                        I,
                        l,
                        w,
                        b,
                        a,
                        f.predicate,
                        C,
                        void 0,
                        A
                      );
                      return (
                        r &&
                          r.placeable &&
                          (this.markUsedOrientation(n, i, t),
                          (this.placedOrientations[t.crossTileID] = i)),
                        r
                      );
                    };
                    o(
                      () => r(G, e.as.horizontal),
                      () => {
                        const i = d.verticalTextBox;
                        return n.allowVerticalPlacement &&
                          t.numVerticalGlyphVertices > 0 &&
                          i
                          ? r(i, e.as.vertical)
                          : { box: null, offscreen: null };
                      }
                    ),
                      i(L && L.placeable);
                  } else {
                    let p =
                      e.aI[
                        null ===
                          (E =
                            null === (P = this.prevPlacement) || void 0 === P
                              ? void 0
                              : P.variableOffsets[t.crossTileID]) ||
                        void 0 === E
                          ? void 0
                          : E.anchor
                      ];
                    const m = (e, i, o) => {
                      const d = e.x2 - e.x1,
                        m = e.y2 - e.y1,
                        _ = t.textBoxScale,
                        y = T && 'never' === x ? i : null;
                      let v = null,
                        P = 'never' === g ? 1 : 2,
                        S = 'never';
                      p && P++;
                      for (let r = 0; r < P; r++) {
                        for (let i = c; i < u; i++) {
                          const r = n.textAnchorOffsets.get(i);
                          if (p && r.textAnchor !== p) continue;
                          const c = this.attemptAnchorPlacement(
                            r,
                            e,
                            d,
                            m,
                            _,
                            b,
                            w,
                            h,
                            I,
                            l,
                            f,
                            S,
                            t,
                            n,
                            o,
                            a,
                            s,
                            y,
                            C
                          );
                          if (c && ((v = c.placedGlyphBoxes), v && v.placeable))
                            return (z = !0), (R = c.shift), v;
                        }
                        p ? (p = null) : (S = g);
                      }
                      return (
                        r &&
                          !v &&
                          (v = {
                            box: this.collisionIndex.placeCollisionBox(
                              G,
                              'always',
                              h,
                              I,
                              l,
                              w,
                              b,
                              a,
                              f.predicate,
                              C,
                              void 0,
                              A
                            ).box,
                            offscreen: !1,
                            placeable: !1,
                            occluded: !1,
                          }),
                        v
                      );
                    };
                    o(
                      () => m(G, d.iconBox, e.as.horizontal),
                      () => {
                        const i = d.verticalTextBox;
                        return n.allowVerticalPlacement &&
                          (!L || !L.placeable) &&
                          t.numVerticalGlyphVertices > 0 &&
                          i
                          ? m(i, d.verticalIconBox, e.as.vertical)
                          : { box: null, occluded: !0, offscreen: null };
                      }
                    ),
                      L && ((z = L.placeable), (D = L.offscreen));
                    const _ = i(L && L.placeable);
                    if (!z && this.prevPlacement) {
                      const e =
                        this.prevPlacement.variableOffsets[t.crossTileID];
                      e &&
                        ((this.variableOffsets[t.crossTileID] = e),
                        this.markUsedJustification(n, e.anchor, t, _));
                    }
                  }
                }
                if (
                  ((B = L),
                  (z = B && B.placeable),
                  (D = B && B.offscreen),
                  t.useRuntimeCollisionCircles &&
                    t.centerJustifiedTextSymbolIndex >= 0)
                ) {
                  const i = n.text.placedSymbolArray.get(
                      t.centerJustifiedTextSymbolIndex
                    ),
                    s = e.at(n.textSizeData, p, i),
                    h = o.get('text-padding');
                  (O = this.collisionIndex.placeCollisionCircles(
                    g,
                    i,
                    n.lineVertexArray,
                    n.glyphOffsetArray,
                    s,
                    l,
                    c,
                    r,
                    w,
                    f.predicate,
                    t.collisionCircleDiameter,
                    h,
                    a,
                    C
                  )),
                    O.circles.length &&
                      O.collisionDetected &&
                      !r &&
                      e.w(
                        'Collisions detected, but collision boxes are not shown'
                      ),
                    (z = y || (O.circles.length > 0 && !O.collisionDetected)),
                    (D = D && O.offscreen);
                }
                if (
                  (d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox)
                ) {
                  const t = (t) =>
                    this.collisionIndex.placeCollisionBox(
                      t,
                      x,
                      h,
                      I,
                      l,
                      w,
                      b,
                      s,
                      f.predicate,
                      C,
                      T && R ? R : void 0,
                      A
                    );
                  F && F.placeable && d.verticalIconBox
                    ? ((j = t(d.verticalIconBox)), (k = j.placeable))
                    : ((j = t(d.iconBox)), (k = j.placeable)),
                    (D = D && j.offscreen);
                }
                const Z =
                    m ||
                    (0 === t.numHorizontalGlyphVertices &&
                      0 === t.numVerticalGlyphVertices),
                  $ = _ || 0 === t.numIconVertices;
                Z || $
                  ? $
                    ? Z || (k = k && z)
                    : (z = k && z)
                  : (k = z = k && z);
                const q = k && j.placeable;
                if (
                  (z &&
                    B.placeable &&
                    this.collisionIndex.insertCollisionBox(
                      B.box,
                      g,
                      o.get('text-ignore-placement'),
                      n.bucketInstanceId,
                      F && F.placeable && V ? V : N,
                      f.ID
                    ),
                  q &&
                    this.collisionIndex.insertCollisionBox(
                      j.box,
                      x,
                      o.get('icon-ignore-placement'),
                      n.bucketInstanceId,
                      U,
                      f.ID
                    ),
                  O &&
                    z &&
                    this.collisionIndex.insertCollisionCircles(
                      O.circles,
                      g,
                      o.get('text-ignore-placement'),
                      n.bucketInstanceId,
                      N,
                      f.ID
                    ),
                  r &&
                    this.storeCollisionData(n.bucketInstanceId, v, d, B, j, O),
                  0 === t.crossTileID)
                )
                  throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === n.bucketInstanceId)
                  throw new Error("bucket.bucketInstanceId can't be 0");
                (this.placements[t.crossTileID] = new ne(
                  (z || S) && !(null == B ? void 0 : B.occluded),
                  (k || M) && !(null == j ? void 0 : j.occluded),
                  D || n.justReloaded
                )),
                  (i[t.crossTileID] = !0);
              };
            if (P) {
              if (0 !== t.symbolInstanceStart)
                throw new Error('bucket.bucketInstanceId should be 0');
              const e = n.getSortedSymbolIndexes(
                -this.transform.bearingInRadians
              );
              for (let t = e.length - 1; t >= 0; --t) {
                const i = e[t];
                E(n.symbolInstances.get(i), n.collisionArrays[i], i);
              }
            } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) E(n.symbolInstances.get(e), n.collisionArrays[e], e);
            n.justReloaded = !1;
          }
          storeCollisionData(t, e, i, r, n, o) {
            if (i.textBox || i.iconBox) {
              let o, a;
              this.collisionBoxArrays.has(t)
                ? (o = this.collisionBoxArrays.get(t))
                : ((o = new Map()), this.collisionBoxArrays.set(t, o)),
                o.has(e)
                  ? (a = o.get(e))
                  : ((a = { text: null, icon: null }), o.set(e, a)),
                i.textBox && (a.text = r.box),
                i.iconBox && (a.icon = n.box);
            }
            if (o) {
              let e = this.collisionCircleArrays[t];
              void 0 === e && (e = this.collisionCircleArrays[t] = []);
              for (let t = 0; t < o.circles.length; t += 4)
                e.push(o.circles[t + 0] - te),
                  e.push(o.circles[t + 1] - te),
                  e.push(o.circles[t + 2]),
                  e.push(o.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(t, i, r, n) {
            let o;
            o =
              n === e.as.vertical
                ? r.verticalPlacedTextSymbolIndex
                : {
                    left: r.leftJustifiedTextSymbolIndex,
                    center: r.centerJustifiedTextSymbolIndex,
                    right: r.rightJustifiedTextSymbolIndex,
                  }[e.aK(i)];
            const a = [
              r.leftJustifiedTextSymbolIndex,
              r.centerJustifiedTextSymbolIndex,
              r.rightJustifiedTextSymbolIndex,
              r.verticalPlacedTextSymbolIndex,
            ];
            for (const e of a)
              e >= 0 &&
                (t.text.placedSymbolArray.get(e).crossTileID =
                  o >= 0 && e !== o ? 0 : r.crossTileID);
          }
          markUsedOrientation(t, i, r) {
            const n =
                i === e.as.horizontal || i === e.as.horizontalOnly ? i : 0,
              o = i === e.as.vertical ? i : 0,
              a = [
                r.leftJustifiedTextSymbolIndex,
                r.centerJustifiedTextSymbolIndex,
                r.rightJustifiedTextSymbolIndex,
              ];
            for (const e of a)
              t.text.placedSymbolArray.get(e).placedOrientation = n;
            r.verticalPlacedTextSymbolIndex &&
              (t.text.placedSymbolArray.get(
                r.verticalPlacedTextSymbolIndex
              ).placedOrientation = o);
          }
          commit(t) {
            (this.commitTime = t),
              (this.zoomAtLastRecencyCheck = this.transform.zoom);
            const e = this.prevPlacement;
            let i = !1;
            this.prevZoomAdjustment = e
              ? e.zoomAdjustment(this.transform.zoom)
              : 0;
            const r = e ? e.symbolFadeChange(t) : 1,
              n = e ? e.opacities : {},
              o = e ? e.variableOffsets : {},
              a = e ? e.placedOrientations : {};
            for (const s in this.placements) {
              const t = this.placements[s],
                e = n[s];
              e
                ? ((this.opacities[s] = new re(e, r, t.text, t.icon)),
                  (i =
                    i || t.text !== e.text.placed || t.icon !== e.icon.placed))
                : ((this.opacities[s] = new re(
                    null,
                    r,
                    t.text,
                    t.icon,
                    t.skipFade
                  )),
                  (i = i || t.text || t.icon));
            }
            for (const s in n) {
              const t = n[s];
              if (!this.opacities[s]) {
                const e = new re(t, r, !1, !1);
                e.isHidden() ||
                  ((this.opacities[s] = e),
                  (i = i || t.text.placed || t.icon.placed));
              }
            }
            for (const s in o)
              this.variableOffsets[s] ||
                !this.opacities[s] ||
                this.opacities[s].isHidden() ||
                (this.variableOffsets[s] = o[s]);
            for (const s in a)
              this.placedOrientations[s] ||
                !this.opacities[s] ||
                this.opacities[s].isHidden() ||
                (this.placedOrientations[s] = a[s]);
            if (e && void 0 === e.lastPlacementChangeTime)
              throw new Error(
                'Last placement time for previous placement is not defined'
              );
            i
              ? (this.lastPlacementChangeTime = t)
              : 'number' != typeof this.lastPlacementChangeTime &&
                (this.lastPlacementChangeTime = e
                  ? e.lastPlacementChangeTime
                  : t);
          }
          updateLayerOpacities(t, e) {
            const i = {};
            for (const r of e) {
              const e = r.getBucket(t);
              e &&
                r.latestFeatureIndex &&
                t.id === e.layerIds[0] &&
                this.updateBucketOpacities(e, r.tileID, i, r.collisionBoxArray);
            }
          }
          updateBucketOpacities(t, i, r, n) {
            t.hasTextData() &&
              (t.text.opacityVertexArray.clear(),
              (t.text.hasVisibleVertices = !1)),
              t.hasIconData() &&
                (t.icon.opacityVertexArray.clear(),
                (t.icon.hasVisibleVertices = !1)),
              t.hasIconCollisionBoxData() &&
                t.iconCollisionBox.collisionVertexArray.clear(),
              t.hasTextCollisionBoxData() &&
                t.textCollisionBox.collisionVertexArray.clear();
            const o = t.layers[0],
              a = o.layout,
              s = new re(null, 0, !1, !1, !0),
              l = a.get('text-allow-overlap'),
              c = a.get('icon-allow-overlap'),
              h =
                o._unevaluatedLayout.hasValue('text-variable-anchor') ||
                o._unevaluatedLayout.hasValue('text-variable-anchor-offset'),
              u = 'map' === a.get('text-rotation-alignment'),
              d = 'map' === a.get('text-pitch-alignment'),
              p = 'none' !== a.get('icon-text-fit'),
              f = new re(
                null,
                0,
                l && (c || !t.hasIconData() || a.get('icon-optional')),
                c && (l || !t.hasTextData() || a.get('text-optional')),
                !0
              );
            !t.collisionArrays &&
              n &&
              (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) &&
              t.deserializeCollisionBoxes(n);
            const m = (t, e, i) => {
                for (let r = 0; r < e / 4; r++)
                  t.opacityVertexArray.emplaceBack(i);
                t.hasVisibleVertices = t.hasVisibleVertices || i !== ye;
              },
              _ = this.collisionBoxArrays.get(t.bucketInstanceId);
            for (let g = 0; g < t.symbolInstances.length; g++) {
              const i = t.symbolInstances.get(g),
                {
                  numHorizontalGlyphVertices: n,
                  numVerticalGlyphVertices: o,
                  crossTileID: a,
                } = i;
              let l = this.opacities[a];
              r[a] ? (l = s) : l || ((l = f), (this.opacities[a] = l)),
                (r[a] = !0);
              const c = i.numIconVertices > 0,
                y = this.placedOrientations[i.crossTileID],
                x = y === e.as.vertical,
                v = y === e.as.horizontal || y === e.as.horizontalOnly;
              if (n > 0 || o > 0) {
                const e = ge(l.text);
                m(t.text, n, x ? ye : e), m(t.text, o, v ? ye : e);
                const r = l.text.isHidden();
                [
                  i.rightJustifiedTextSymbolIndex,
                  i.centerJustifiedTextSymbolIndex,
                  i.leftJustifiedTextSymbolIndex,
                ].forEach((e) => {
                  e >= 0 &&
                    (t.text.placedSymbolArray.get(e).hidden = r || x ? 1 : 0);
                }),
                  i.verticalPlacedTextSymbolIndex >= 0 &&
                    (t.text.placedSymbolArray.get(
                      i.verticalPlacedTextSymbolIndex
                    ).hidden = r || v ? 1 : 0);
                const a = this.variableOffsets[i.crossTileID];
                a && this.markUsedJustification(t, a.anchor, i, y);
                const s = this.placedOrientations[i.crossTileID];
                s &&
                  (this.markUsedJustification(t, 'left', i, s),
                  this.markUsedOrientation(t, s, i));
              }
              if (c) {
                const e = ge(l.icon),
                  r = !(p && i.verticalPlacedIconSymbolIndex && x);
                i.placedIconSymbolIndex >= 0 &&
                  (m(t.icon, i.numIconVertices, r ? e : ye),
                  (t.icon.placedSymbolArray.get(
                    i.placedIconSymbolIndex
                  ).hidden = l.icon.isHidden())),
                  i.verticalPlacedIconSymbolIndex >= 0 &&
                    (m(t.icon, i.numVerticalIconVertices, r ? ye : e),
                    (t.icon.placedSymbolArray.get(
                      i.verticalPlacedIconSymbolIndex
                    ).hidden = l.icon.isHidden()));
              }
              const b = _ && _.has(g) ? _.get(g) : { text: null, icon: null };
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const i = t.collisionArrays[g];
                if (i) {
                  let r = new e.P(0, 0);
                  if (i.textBox || i.verticalTextBox) {
                    let e = !0;
                    if (h) {
                      const t = this.variableOffsets[a];
                      t
                        ? ((r = se(
                            t.anchor,
                            t.width,
                            t.height,
                            t.textOffset,
                            t.textBoxScale
                          )),
                          u &&
                            r._rotate(
                              d
                                ? -this.transform.bearingInRadians
                                : this.transform.bearingInRadians
                            ))
                        : (e = !1);
                    }
                    if (i.textBox || i.verticalTextBox) {
                      let n;
                      i.textBox && (n = x),
                        i.verticalTextBox && (n = v),
                        ce(
                          t.textCollisionBox.collisionVertexArray,
                          l.text.placed,
                          !e || n,
                          b.text,
                          r.x,
                          r.y
                        );
                    }
                  }
                  if (i.iconBox || i.verticalIconBox) {
                    const e = Boolean(!v && i.verticalIconBox);
                    let n;
                    i.iconBox && (n = e),
                      i.verticalIconBox && (n = !e),
                      ce(
                        t.iconCollisionBox.collisionVertexArray,
                        l.icon.placed,
                        n,
                        b.icon,
                        p ? r.x : 0,
                        p ? r.y : 0
                      );
                  }
                }
              }
            }
            if (
              (t.sortFeatures(-this.transform.bearingInRadians),
              this.retainedQueryData[t.bucketInstanceId] &&
                (this.retainedQueryData[t.bucketInstanceId].featureSortOrder =
                  t.featureSortOrder),
              t.hasTextData() &&
                t.text.opacityVertexBuffer &&
                t.text.opacityVertexBuffer.updateData(
                  t.text.opacityVertexArray
                ),
              t.hasIconData() &&
                t.icon.opacityVertexBuffer &&
                t.icon.opacityVertexBuffer.updateData(
                  t.icon.opacityVertexArray
                ),
              t.hasIconCollisionBoxData() &&
                t.iconCollisionBox.collisionVertexBuffer &&
                t.iconCollisionBox.collisionVertexBuffer.updateData(
                  t.iconCollisionBox.collisionVertexArray
                ),
              t.hasTextCollisionBoxData() &&
                t.textCollisionBox.collisionVertexBuffer &&
                t.textCollisionBox.collisionVertexBuffer.updateData(
                  t.textCollisionBox.collisionVertexArray
                ),
              t.text.opacityVertexArray.length !==
                t.text.layoutVertexArray.length / 4)
            )
              throw new Error(
                `bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`
              );
            if (
              t.icon.opacityVertexArray.length !==
              t.icon.layoutVertexArray.length / 4
            )
              throw new Error(
                `bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`
              );
            t.bucketInstanceId in this.collisionCircleArrays &&
              ((t.collisionCircleArray =
                this.collisionCircleArrays[t.bucketInstanceId]),
              delete this.collisionCircleArrays[t.bucketInstanceId]);
          }
          symbolFadeChange(t) {
            return 0 === this.fadeDuration
              ? 1
              : (t - this.commitTime) / this.fadeDuration +
                  this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return (
              this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
            );
          }
          stillRecent(t, e) {
            const i =
              this.zoomAtLastRecencyCheck === e
                ? 1 - this.zoomAdjustment(e)
                : 1;
            return (
              (this.zoomAtLastRecencyCheck = e),
              this.commitTime + this.fadeDuration * i > t
            );
          }
          setStale() {
            this.stale = !0;
          }
        }
        function ce(t, e, i, r, n, o) {
          (r && 0 !== r.length) || (r = [0, 0, 0, 0]);
          const a = r[0] - te,
            s = r[1] - te,
            l = r[2] - te,
            c = r[3] - te;
          t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, o || 0, a, s),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, o || 0, l, s),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, o || 0, l, c),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, o || 0, a, c);
        }
        const he = Math.pow(2, 25),
          ue = Math.pow(2, 24),
          de = Math.pow(2, 17),
          pe = Math.pow(2, 16),
          fe = Math.pow(2, 9),
          me = Math.pow(2, 8),
          _e = Math.pow(2, 1);
        function ge(t) {
          if (0 === t.opacity && !t.placed) return 0;
          if (1 === t.opacity && t.placed) return 4294967295;
          const e = t.placed ? 1 : 0,
            i = Math.floor(127 * t.opacity);
          return (
            i * he + e * ue + i * de + e * pe + i * fe + e * me + i * _e + e
          );
        }
        const ye = 0;
        class xe {
          constructor(t) {
            (this._sortAcrossTiles =
              'viewport-y' !== t.layout.get('symbol-z-order') &&
              !t.layout.get('symbol-sort-key').isConstant()),
              (this._currentTileIndex = 0),
              (this._currentPartIndex = 0),
              (this._seenCrossTileIDs = {}),
              (this._bucketParts = []);
          }
          continuePlacement(t, e, i, r, n) {
            const o = this._bucketParts;
            for (; this._currentTileIndex < t.length; )
              if (
                (e.getBucketParts(
                  o,
                  r,
                  t[this._currentTileIndex],
                  this._sortAcrossTiles
                ),
                this._currentTileIndex++,
                n())
              )
                return !0;
            for (
              this._sortAcrossTiles &&
              ((this._sortAcrossTiles = !1),
              o.sort((t, e) => t.sortKey - e.sortKey));
              this._currentPartIndex < o.length;

            )
              if (
                (e.placeLayerBucketPart(
                  o[this._currentPartIndex],
                  this._seenCrossTileIDs,
                  i
                ),
                this._currentPartIndex++,
                n())
              )
                return !0;
            return !1;
          }
        }
        class ve {
          constructor(t, e, i, r, n, o, a, s) {
            (this.placement = new le(t, e, o, a, s)),
              (this._currentPlacementIndex = i.length - 1),
              (this._forceFullPlacement = r),
              (this._showCollisionBoxes = n),
              (this._done = !1);
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, e, i) {
            const r = l(),
              n = () => !this._forceFullPlacement && l() - r > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const r = e[t[this._currentPlacementIndex]],
                o = this.placement.collisionIndex.transform.zoom;
              if (
                'symbol' === r.type &&
                (!r.minzoom || r.minzoom <= o) &&
                (!r.maxzoom || r.maxzoom > o)
              ) {
                if (
                  (this._inProgressLayer || (this._inProgressLayer = new xe(r)),
                  this._inProgressLayer.continuePlacement(
                    i[r.source],
                    this.placement,
                    this._showCollisionBoxes,
                    r,
                    n
                  ))
                )
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const be = 512 / e.a3 / 2;
        class we {
          constructor(t, i, r) {
            (this.tileID = t),
              (this.bucketInstanceId = r),
              (this._symbolsByKey = {});
            const n = new Map();
            for (let e = 0; e < i.length; e++) {
              const t = i.get(e),
                r = t.key,
                o = n.get(r);
              o ? o.push(t) : n.set(r, [t]);
            }
            for (const [o, a] of n) {
              const t = {
                positions: a.map((t) => ({
                  x: Math.floor(t.anchorX * be),
                  y: Math.floor(t.anchorY * be),
                })),
                crossTileIDs: a.map((t) => t.crossTileID),
              };
              if (t.positions.length > 128) {
                const i = new e.aM(t.positions.length, 16, Uint16Array);
                for (const { x: e, y: r } of t.positions) i.add(e, r);
                i.finish(), delete t.positions, (t.index = i);
              }
              this._symbolsByKey[o] = t;
            }
          }
          getScaledCoordinates(t, i) {
            const { x: r, y: n, z: o } = this.tileID.canonical,
              { x: a, y: s, z: l } = i.canonical,
              c = be / Math.pow(2, l - o),
              h = (s * e.a3 + t.anchorY) * c,
              u = n * e.a3 * be;
            return {
              x: Math.floor((a * e.a3 + t.anchorX) * c - r * e.a3 * be),
              y: Math.floor(h - u),
            };
          }
          findMatches(t, e, i) {
            const r =
              this.tileID.canonical.z < e.canonical.z
                ? 1
                : Math.pow(2, this.tileID.canonical.z - e.canonical.z);
            for (let n = 0; n < t.length; n++) {
              const o = t.get(n);
              if (o.crossTileID) continue;
              const a = this._symbolsByKey[o.key];
              if (!a) continue;
              const s = this.getScaledCoordinates(o, e);
              if (a.index) {
                const t = a.index
                  .range(s.x - r, s.y - r, s.x + r, s.y + r)
                  .sort();
                for (const e of t) {
                  const t = a.crossTileIDs[e];
                  if (!i[t]) {
                    (i[t] = !0), (o.crossTileID = t);
                    break;
                  }
                }
              } else if (a.positions)
                for (let t = 0; t < a.positions.length; t++) {
                  const e = a.positions[t],
                    n = a.crossTileIDs[t];
                  if (
                    Math.abs(e.x - s.x) <= r &&
                    Math.abs(e.y - s.y) <= r &&
                    !i[n]
                  ) {
                    (i[n] = !0), (o.crossTileID = n);
                    break;
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(
              ({ crossTileIDs: t }) => t
            );
          }
        }
        class Te {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Pe {
          constructor() {
            (this.indexes = {}), (this.usedCrossTileIDs = {}), (this.lng = 0);
          }
          handleWrapJump(t) {
            const e = Math.round((t - this.lng) / 360);
            if (0 !== e)
              for (const i in this.indexes) {
                const t = this.indexes[i],
                  r = {};
                for (const i in t) {
                  const n = t[i];
                  (n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e)),
                    (r[n.tileID.key] = n);
                }
                this.indexes[i] = r;
              }
            this.lng = t;
          }
          addBucket(t, e, i) {
            if (
              this.indexes[t.overscaledZ] &&
              this.indexes[t.overscaledZ][t.key]
            ) {
              if (
                this.indexes[t.overscaledZ][t.key].bucketInstanceId ===
                e.bucketInstanceId
              )
                return !1;
              this.removeBucketCrossTileIDs(
                t.overscaledZ,
                this.indexes[t.overscaledZ][t.key]
              );
            }
            for (let n = 0; n < e.symbolInstances.length; n++)
              e.symbolInstances.get(n).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] ||
              (this.usedCrossTileIDs[t.overscaledZ] = {});
            const r = this.usedCrossTileIDs[t.overscaledZ];
            for (const n in this.indexes) {
              const i = this.indexes[n];
              if (Number(n) > t.overscaledZ)
                for (const n in i) {
                  const o = i[n];
                  o.tileID.isChildOf(t) &&
                    o.findMatches(e.symbolInstances, t, r);
                }
              else {
                const o = i[t.scaledTo(Number(n)).key];
                o && o.findMatches(e.symbolInstances, t, r);
              }
            }
            for (let n = 0; n < e.symbolInstances.length; n++) {
              const t = e.symbolInstances.get(n);
              t.crossTileID ||
                ((t.crossTileID = i.generate()), (r[t.crossTileID] = !0));
            }
            return (
              void 0 === this.indexes[t.overscaledZ] &&
                (this.indexes[t.overscaledZ] = {}),
              (this.indexes[t.overscaledZ][t.key] = new we(
                t,
                e.symbolInstances,
                e.bucketInstanceId
              )),
              !0
            );
          }
          removeBucketCrossTileIDs(t, e) {
            for (const i of e.getCrossTileIDsLists())
              for (const e of i) delete this.usedCrossTileIDs[t][e];
          }
          removeStaleBuckets(t) {
            let e = !1;
            for (const i in this.indexes) {
              const r = this.indexes[i];
              for (const n in r)
                t[r[n].bucketInstanceId] ||
                  (this.removeBucketCrossTileIDs(i, r[n]),
                  delete r[n],
                  (e = !0));
            }
            return e;
          }
        }
        class Se {
          constructor() {
            (this.layerIndexes = {}),
              (this.crossTileIDs = new Te()),
              (this.maxBucketInstanceId = 0),
              (this.bucketsInCurrentPlacement = {});
          }
          addLayer(t, e, i) {
            let r = this.layerIndexes[t.id];
            void 0 === r && (r = this.layerIndexes[t.id] = new Pe());
            let n = !1;
            const o = {};
            r.handleWrapJump(i);
            for (const a of e) {
              const e = a.getBucket(t);
              e &&
                t.id === e.layerIds[0] &&
                (e.bucketInstanceId ||
                  (e.bucketInstanceId = ++this.maxBucketInstanceId),
                r.addBucket(a.tileID, e, this.crossTileIDs) && (n = !0),
                (o[e.bucketInstanceId] = !0));
            }
            return r.removeStaleBuckets(o) && (n = !0), n;
          }
          pruneUnusedLayers(t) {
            const e = {};
            t.forEach((t) => {
              e[t] = !0;
            });
            for (const i in this.layerIndexes)
              e[i] || delete this.layerIndexes[i];
          }
        }
        var Me = 'void main() {fragColor=vec4(1.0);}';
        const Ie = {
          prelude: Ce(
            '#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;',
            '#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;'
          ),
          projectionMercator: Ce(
            '',
            'float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}'
          ),
          projectionGlobe: Ce(
            '',
            '#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}'
          ),
          background: Ce(
            'uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}'
          ),
          backgroundPattern: Ce(
            'uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}'
          ),
          circle: Ce(
            'in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}'
          ),
          clippingMask: Ce(
            Me,
            'in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}'
          ),
          heatmap: Ce(
            'uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}'
          ),
          heatmapTexture: Ce(
            'uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}',
            'uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}'
          ),
          collisionBox: Ce(
            'in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}',
            'in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}'
          ),
          collisionCircle: Ce(
            'in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}',
            'in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}'
          ),
          colorRelief: Ce(
            '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}'
          ),
          debug: Ce(
            'uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}',
            'in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}'
          ),
          depth: Ce(
            Me,
            'in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}'
          ),
          fill: Ce(
            '#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}'
          ),
          fillOutline: Ce(
            'in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}'
          ),
          fillOutlinePattern: Ce(
            'uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}'
          ),
          fillPattern: Ce(
            '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}'
          ),
          fillExtrusion: Ce(
            'in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}'
          ),
          fillExtrusionPattern: Ce(
            'uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}'
          ),
          hillshadePrepare: Ce(
            '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}'
          ),
          hillshade: Ce(
            'uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}'
          ),
          line: Ce(
            'uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            '\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}'
          ),
          lineGradient: Ce(
            'uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            '\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}'
          ),
          linePattern: Ce(
            '#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}'
          ),
          lineSDF: Ce(
            'uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}'
          ),
          lineGradientSDF: Ce(
            'uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            '\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}'
          ),
          raster: Ce(
            'uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'
          ),
          symbolIcon: Ce(
            'uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}'
          ),
          symbolSDF: Ce(
            '#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}'
          ),
          symbolTextAndIcon: Ce(
            '#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}',
            'in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}'
          ),
          terrain: Ce(
            'uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}',
            'in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}'
          ),
          terrainDepth: Ce(
            'in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}',
            'in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}'
          ),
          terrainCoords: Ce(
            'precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}',
            'in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}'
          ),
          projectionErrorMeasurement: Ce(
            'in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}',
            'in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}'
          ),
          atmosphere: Ce(
            'in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}',
            'in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}'
          ),
          sky: Ce(
            'uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}',
            'in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}'
          ),
        };
        function Ce(t, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            r = e.match(/in ([\w]+) ([\w]+)/g),
            n = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            a = o ? o.concat(n) : n,
            s = {};
          return {
            fragmentSource: (t = t.replace(
              i,
              (t, e, i, r, n) => (
                (s[n] = !0),
                'define' === e
                  ? `\n#ifndef HAS_UNIFORM_u_${n}\nin ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                  : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
              )
            )),
            vertexSource: (e = e.replace(i, (t, e, i, r, n) => {
              const o = 'float' === r ? 'vec2' : 'vec4',
                a = n.match(/color/) ? 'color' : o;
              return s[n]
                ? 'define' === e
                  ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nin ${i} ${o} a_${n};\nout ${i} ${r} ${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                  : 'vec4' === a
                  ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                  : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                : 'define' === e
                ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nin ${i} ${o} a_${n};\n#else\nuniform ${i} ${r} u_${n};\n#endif\n`
                : 'vec4' === a
                ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = a_${n};\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`
                : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${r} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${r} ${n} = u_${n};\n#endif\n`;
            })),
            staticAttributes: r,
            staticUniforms: a,
          };
        }
        class Ae {
          constructor(t, e, i) {
            (this.vertexBuffer = t),
              (this.indexBuffer = e),
              (this.segments = i);
          }
          destroy() {
            this.vertexBuffer.destroy(),
              this.indexBuffer.destroy(),
              this.segments.destroy(),
              (this.vertexBuffer = null),
              (this.indexBuffer = null),
              (this.segments = null);
          }
        }
        var Ee = e.aN([{ name: 'a_pos', type: 'Int16', components: 2 }]);
        const ze = '#define PROJECTION_MERCATOR',
          ke = 'mercator';
        class De {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return 'mercator';
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return ke;
          }
          get shaderDefine() {
            return ze;
          }
          get shaderPreludeCode() {
            return Ie.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Ie.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return e.aO.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {}
          updateGPUdependent(t) {}
          getMeshFromTileID(t, i, r, n, o) {
            if (this._cachedMesh) return this._cachedMesh;
            const a = new e.aP();
            a.emplaceBack(0, 0),
              a.emplaceBack(e.a3, 0),
              a.emplaceBack(0, e.a3),
              a.emplaceBack(e.a3, e.a3);
            const s = t.createVertexBuffer(a, Ee.members),
              l = e.aQ.simpleSegment(0, 0, 4, 2),
              c = new e.aR();
            c.emplaceBack(1, 0, 2), c.emplaceBack(1, 2, 3);
            const h = t.createIndexBuffer(c);
            return (this._cachedMesh = new Ae(s, h, l)), this._cachedMesh;
          }
          recalculate() {}
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(t) {}
        }
        class Re {
          constructor(t = 0, e = 0, i = 0, r = 0) {
            if (
              isNaN(t) ||
              t < 0 ||
              isNaN(e) ||
              e < 0 ||
              isNaN(i) ||
              i < 0 ||
              isNaN(r) ||
              r < 0
            )
              throw new Error(
                'Invalid value for edge-insets, top, bottom, left and right must all be numbers'
              );
            (this.top = t),
              (this.bottom = e),
              (this.left = i),
              (this.right = r);
          }
          interpolate(t, i, r) {
            return (
              null != i.top &&
                null != t.top &&
                (this.top = e.F.number(t.top, i.top, r)),
              null != i.bottom &&
                null != t.bottom &&
                (this.bottom = e.F.number(t.bottom, i.bottom, r)),
              null != i.left &&
                null != t.left &&
                (this.left = e.F.number(t.left, i.left, r)),
              null != i.right &&
                null != t.right &&
                (this.right = e.F.number(t.right, i.right, r)),
              this
            );
          }
          getCenter(t, i) {
            const r = e.ai((this.left + t - this.right) / 2, 0, t),
              n = e.ai((this.top + i - this.bottom) / 2, 0, i);
            return new e.P(r, n);
          }
          equals(t) {
            return (
              this.top === t.top &&
              this.bottom === t.bottom &&
              this.left === t.left &&
              this.right === t.right
            );
          }
          clone() {
            return new Re(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right,
            };
          }
        }
        function Le(t, e) {
          if (!t.renderWorldCopies || t.lngRange) return;
          const i = e.lng - t.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
        }
        function Fe(t) {
          return Math.max(0, Math.floor(t));
        }
        class Be {
          constructor(t, i) {
            var r;
            (this._callbacks = t),
              (this._tileSize = 512),
              (this._renderWorldCopies =
                void 0 === (null == i ? void 0 : i.renderWorldCopies) ||
                !!(null == i ? void 0 : i.renderWorldCopies)),
              (this._minZoom = (null == i ? void 0 : i.minZoom) || 0),
              (this._maxZoom = (null == i ? void 0 : i.maxZoom) || 22),
              (this._minPitch =
                null == (null == i ? void 0 : i.minPitch)
                  ? 0
                  : null == i
                  ? void 0
                  : i.minPitch),
              (this._maxPitch =
                null == (null == i ? void 0 : i.maxPitch)
                  ? 60
                  : null == i
                  ? void 0
                  : i.maxPitch),
              (this._constrain =
                null !== (r = null == i ? void 0 : i.constrain) && void 0 !== r
                  ? r
                  : this._callbacks.constrain),
              this.setMaxBounds(),
              (this._width = 0),
              (this._height = 0),
              (this._center = new e.U(0, 0)),
              (this._elevation = 0),
              (this._zoom = 0),
              (this._tileZoom = Fe(this._zoom)),
              (this._scale = e.al(this._zoom)),
              (this._bearingInRadians = 0),
              (this._fovInRadians = 0.6435011087932844),
              (this._pitchInRadians = 0),
              (this._rollInRadians = 0),
              (this._unmodified = !0),
              (this._edgeInsets = new Re()),
              (this._minElevationForCurrentTile = 0),
              (this._autoCalculateNearFarZ = !0);
          }
          apply(t, i, r) {
            (this._latRange = t.latRange),
              (this._lngRange = t.lngRange),
              (this._width = t.width),
              (this._height = t.height),
              (this._center = t.center),
              (this._elevation = t.elevation),
              (this._minElevationForCurrentTile = t.minElevationForCurrentTile),
              (this._zoom = t.zoom),
              (this._tileZoom = Fe(this._zoom)),
              (this._scale = e.al(this._zoom)),
              (this._bearingInRadians = t.bearingInRadians),
              (this._fovInRadians = t.fovInRadians),
              (this._pitchInRadians = t.pitchInRadians),
              (this._rollInRadians = t.rollInRadians),
              (this._unmodified = t.unmodified),
              (this._edgeInsets = new Re(
                t.padding.top,
                t.padding.bottom,
                t.padding.left,
                t.padding.right
              )),
              (this._minZoom = t.minZoom),
              (this._maxZoom = t.maxZoom),
              (this._minPitch = t.minPitch),
              (this._maxPitch = t.maxPitch),
              (this._renderWorldCopies = t.renderWorldCopies),
              (this._cameraToCenterDistance = t.cameraToCenterDistance),
              (this._nearZ = t.nearZ),
              (this._farZ = t.farZ),
              (this._autoCalculateNearFarZ = !r && t.autoCalculateNearFarZ),
              i && this.constrainInternal(),
              this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(t) {
            this._minElevationForCurrentTile = t;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(t) {
            this._minZoom !== t &&
              ((this._minZoom = t),
              this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(t) {
            this._maxZoom !== t &&
              ((this._maxZoom = t),
              this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(t) {
            this._minPitch !== t &&
              ((this._minPitch = t), this.setPitch(Math.max(this.pitch, t)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(t) {
            this._maxPitch !== t &&
              ((this._maxPitch = t), this.setPitch(Math.min(this.pitch, t)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(t) {
            void 0 === t ? (t = !0) : null === t && (t = !1),
              (this._renderWorldCopies = t);
          }
          get constrain() {
            return this._constrain;
          }
          setConstrain(t) {
            t || (t = this._callbacks.constrain),
              (this._constrain = t),
              this.constrainInternal(),
              this._calcMatrices();
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.P(this._width, this._height);
          }
          get bearing() {
            return (this._bearingInRadians / Math.PI) * 180;
          }
          setBearing(t) {
            const i = (e.V(t, -180, 180) * Math.PI) / 180;
            var n, o, a, s, l, c, h, u, d;
            this._bearingInRadians !== i &&
              ((this._unmodified = !1),
              (this._bearingInRadians = i),
              this._calcMatrices(),
              (this._rotationMatrix = r()),
              (n = this._rotationMatrix),
              (a = -this._bearingInRadians),
              (s = (o = this._rotationMatrix)[0]),
              (l = o[1]),
              (c = o[2]),
              (h = o[3]),
              (u = Math.sin(a)),
              (d = Math.cos(a)),
              (n[0] = s * d + c * u),
              (n[1] = l * d + h * u),
              (n[2] = s * -u + c * d),
              (n[3] = l * -u + h * d));
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return (this._pitchInRadians / Math.PI) * 180;
          }
          setPitch(t) {
            const i = (e.ai(t, this.minPitch, this.maxPitch) / 180) * Math.PI;
            this._pitchInRadians !== i &&
              ((this._unmodified = !1),
              (this._pitchInRadians = i),
              this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return (this._rollInRadians / Math.PI) * 180;
          }
          setRoll(t) {
            const e = (t / 180) * Math.PI;
            this._rollInRadians !== e &&
              ((this._unmodified = !1),
              (this._rollInRadians = e),
              this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return e.aS(this._fovInRadians);
          }
          setFov(t) {
            (t = e.ai(t, 0.1, 150)),
              this.fov !== t &&
                ((this._unmodified = !1),
                (this._fovInRadians = e.ak(t)),
                this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(t) {
            const i = this.constrain(this._center, t).zoom;
            this._zoom !== i &&
              ((this._unmodified = !1),
              (this._zoom = i),
              (this._tileZoom = Math.max(0, Math.floor(i))),
              (this._scale = e.al(i)),
              this.constrainInternal(),
              this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(t) {
            (t.lat === this._center.lat && t.lng === this._center.lng) ||
              ((this._unmodified = !1),
              (this._center = t),
              this.constrainInternal(),
              this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(t) {
            t !== this._elevation &&
              ((this._elevation = t),
              this.constrainInternal(),
              this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(t) {
            this._edgeInsets.equals(t) ||
              ((this._unmodified = !1),
              this._edgeInsets.interpolate(this._edgeInsets, t, 1),
              this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(t, e) {
            (this._autoCalculateNearFarZ = !1),
              (this._nearZ = t),
              (this._farZ = e),
              this._calcMatrices();
          }
          clearNearFarZOverride() {
            (this._autoCalculateNearFarZ = !0), this._calcMatrices();
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, e, i) {
            (this._unmodified = !1),
              this._edgeInsets.interpolate(t, e, i),
              this.constrainInternal(),
              this._calcMatrices();
          }
          resize(t, e, i = !0) {
            (this._width = t),
              (this._height = e),
              i && this.constrainInternal(),
              this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange &&
              2 === this._latRange.length &&
              this._lngRange &&
              2 === this._lngRange.length
              ? new q(
                  [this._lngRange[0], this._latRange[0]],
                  [this._lngRange[1], this._latRange[1]]
                )
              : null;
          }
          setMaxBounds(t) {
            t
              ? ((this._lngRange = [t.getWest(), t.getEast()]),
                (this._latRange = [t.getSouth(), t.getNorth()]),
                this.constrainInternal())
              : ((this._lngRange = null), (this._latRange = [-e.aj, e.aj]));
          }
          getCameraQueryGeometry(t, i) {
            if (1 === i.length) return [i[0], t];
            {
              const {
                minX: r,
                minY: n,
                maxX: o,
                maxY: a,
              } = e.a6.fromPoints(i).extend(t);
              return [
                new e.P(r, n),
                new e.P(o, n),
                new e.P(o, a),
                new e.P(r, a),
                new e.P(r, n),
              ];
            }
          }
          constrainInternal() {
            if (
              !this.center ||
              !this._width ||
              !this._height ||
              this._constraining
            )
              return;
            this._constraining = !0;
            const t = this._unmodified,
              { center: e, zoom: i } = this.constrain(this.center, this.zoom);
            this.setCenter(e),
              this.setZoom(i),
              (this._unmodified = t),
              (this._constraining = !1);
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let t = e.am(new Float64Array(16));
              e.O(t, t, [this._width / 2, -this._height / 2, 1]),
                e.N(t, t, [1, -1, 0]),
                (this._clipSpaceToPixelsMatrix = t),
                (t = e.am(new Float64Array(16))),
                e.O(t, t, [1, -1, 1]),
                e.N(t, t, [-1, -1, 0]),
                e.O(t, t, [2 / this._width, 2 / this._height, 1]),
                (this._pixelsToClipSpaceMatrix = t),
                (this._cameraToCenterDistance =
                  (0.5 / Math.tan(this.fovInRadians / 2)) * this._height);
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(t, i, r, n) {
            const o = void 0 !== r ? r : this.bearing,
              a = (n = void 0 !== n ? n : this.pitch),
              s = e.a5.fromLngLat(t, i),
              l = -Math.cos(e.ak(a)),
              c = Math.sin(e.ak(a)),
              h = c * Math.sin(e.ak(o)),
              u = -c * Math.cos(e.ak(o));
            let d = this.elevation;
            const p = i - d;
            let f;
            l * p >= 0 || Math.abs(l) < 0.1
              ? ((f = 1e4), (d = i + f * l))
              : (f = -p / l);
            let m,
              _,
              g = e.aT(1, s.y),
              y = 0;
            do {
              if (((y += 1), y > 10)) break;
              (_ = f / g),
                (m = new e.a5(s.x + h * _, s.y + u * _)),
                (g = 1 / m.meterInMercatorCoordinateUnits());
            } while (Math.abs(f - _ * g) > 1e-12);
            return {
              center: m.toLngLat(),
              elevation: d,
              zoom: e.ao(
                this.height /
                  2 /
                  Math.tan(this.fovInRadians / 2) /
                  _ /
                  this.tileSize
              ),
            };
          }
          recalculateZoomAndCenter(t) {
            if (this.elevation - t == 0) return;
            const i = e.an(1, this.center.lat) * this.worldSize,
              r = this.cameraToCenterDistance / i,
              n = e.a5.fromLngLat(this.center, this.elevation),
              o = xt(this.center, this.elevation, this.pitch, this.bearing, r);
            this._elevation = t;
            const a = this.calculateCenterFromCameraLngLatAlt(
              o.toLngLat(),
              e.aT(o.z, n.y),
              this.bearing,
              this.pitch
            );
            (this._elevation = a.elevation),
              (this._center = a.center),
              this.setZoom(a.zoom);
          }
          getCameraPoint() {
            const t =
              Math.tan(this.pitchInRadians) *
              (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(
              new e.P(
                t * Math.sin(this.rollInRadians),
                t * Math.cos(this.rollInRadians)
              )
            );
          }
          getCameraAltitude() {
            return (
              (Math.cos(this.pitchInRadians) * this._cameraToCenterDistance) /
                this._pixelPerMeter +
              this.elevation
            );
          }
          getCameraLngLat() {
            const t = e.an(1, this.center.lat) * this.worldSize;
            return xt(
              this.center,
              this.elevation,
              this.pitch,
              this.bearing,
              this.cameraToCenterDistance / t
            ).toLngLat();
          }
          getMercatorTileCoordinates(t) {
            if (!t) return [0, 0, 1, 1];
            const i =
              t.canonical.z >= 0
                ? 1 << t.canonical.z
                : Math.pow(2, t.canonical.z);
            return [
              t.canonical.x / i,
              t.canonical.y / i,
              1 / i / e.a3,
              1 / i / e.a3,
            ];
          }
        }
        class Oe {
          constructor(t, i) {
            (this.min = t),
              (this.max = i),
              (this.center = e.aU([], e.aV([], this.min, this.max), 0.5));
          }
          quadrant(t) {
            const i = [t % 2 == 0, t < 2],
              r = e.aW(this.min),
              n = e.aW(this.max);
            for (let e = 0; e < i.length; e++)
              (r[e] = i[e] ? this.min[e] : this.center[e]),
                (n[e] = i[e] ? this.center[e] : this.max[e]);
            return (n[2] = this.max[2]), new Oe(r, n);
          }
          distanceX(t) {
            return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
          }
          distanceY(t) {
            return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
          }
          intersectsFrustum(t) {
            let e = !0;
            for (let i = 0; i < t.planes.length; i++) {
              const r = this.intersectsPlane(t.planes[i]);
              if (0 === r) return 0;
              1 === r && (e = !1);
            }
            return e
              ? 2
              : t.aabb.min[0] > this.max[0] ||
                t.aabb.min[1] > this.max[1] ||
                t.aabb.min[2] > this.max[2] ||
                t.aabb.max[0] < this.min[0] ||
                t.aabb.max[1] < this.min[1] ||
                t.aabb.max[2] < this.min[2]
              ? 0
              : 1;
          }
          intersectsPlane(t) {
            let e = t[3],
              i = t[3];
            for (let r = 0; r < 3; r++)
              t[r] > 0
                ? ((e += t[r] * this.min[r]), (i += t[r] * this.max[r]))
                : ((i += t[r] * this.min[r]), (e += t[r] * this.max[r]));
            return e >= 0 ? 2 : i < 0 ? 0 : 1;
          }
        }
        class je {
          distanceToTile2d(t, e, i, r) {
            const n = r.distanceX([t, e]),
              o = r.distanceY([t, e]);
            return Math.hypot(n, o);
          }
          getWrap(t, e, i) {
            return i;
          }
          getTileBoundingVolume(t, i, r, n) {
            var o, a;
            let s = 0,
              l = 0;
            if (null == n ? void 0 : n.terrain) {
              const c = new e.a0(t.z, i, t.z, t.x, t.y),
                h = n.terrain.getMinMaxElevation(c);
              (s =
                null !== (o = h.minElevation) && void 0 !== o
                  ? o
                  : Math.min(0, r)),
                (l =
                  null !== (a = h.maxElevation) && void 0 !== a
                    ? a
                    : Math.max(0, r));
            }
            const c = 1 << t.z;
            return new Oe(
              [i + t.x / c, t.y / c, s],
              [i + (t.x + 1) / c, (t.y + 1) / c, l]
            );
          }
          allowVariableZoom(t, i) {
            const r =
                (t.fov *
                  (Math.abs(Math.cos(t.rollInRadians)) * t.height +
                    Math.abs(Math.sin(t.rollInRadians)) * t.width)) /
                t.height,
              n = e.ai(78.5 - r / 2, 0, 60);
            return !!i.terrain || t.pitch > n;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {}
        }
        class Ne {
          constructor(t, e, i) {
            (this.points = t), (this.planes = e), (this.aabb = i);
          }
          static fromInvProjectionMatrix(t, i = 1, r = 0, n, o) {
            const a = o
                ? [
                    [6, 5, 4],
                    [0, 1, 2],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ]
                : [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ],
              s = Math.pow(2, r),
              l = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1],
              ].map((r) =>
                (function (t, i, r, n) {
                  const o = e.aA([], t, i),
                    a = (1 / o[3] / r) * n;
                  return e.a$(o, o, [a, a, 1 / o[3], a]);
                })(r, t, i, s)
              );
            n &&
              (function (t, i, r, n) {
                const o = n ? 4 : 0,
                  a = n ? 0 : 4;
                let s = 0;
                const l = [],
                  c = [];
                for (let d = 0; d < 4; d++) {
                  const i = e.aX([], t[d + a], t[d + o]),
                    r = e.b0(i);
                  e.aU(i, i, 1 / r), l.push(r), c.push(i);
                }
                for (let d = 0; d < 4; d++) {
                  const i = e.b1(t[d + o], c[d], r);
                  s = null !== i && i >= 0 ? Math.max(s, i) : Math.max(s, l[d]);
                }
                const h = (function (t, i) {
                    const r = e.aX([], t[i[0]], t[i[1]]),
                      n = e.aX([], t[i[2]], t[i[1]]),
                      o = [0, 0, 0, 0];
                    return (
                      e.aY(o, e.aZ([], r, n)), (o[3] = -e.a_(o, t[i[0]])), o
                    );
                  })(t, i),
                  u = (function (t, i) {
                    const r = e.b2(t),
                      n = e.b3([], t, 1 / r),
                      o = e.aX([], i, e.aU([], n, e.a_(i, n))),
                      a = e.b2(o);
                    if (a > 0) {
                      const t = Math.sqrt(1 - n[3] * n[3]),
                        r = e.aU([], n, -n[3]),
                        s = e.aV([], r, e.aU([], o, t / a));
                      return e.b4(i, s);
                    }
                    return null;
                  })(r, h);
                if (null !== u) {
                  const t = u / e.a_(c[0], h);
                  s = Math.min(s, t);
                }
                for (let e = 0; e < 4; e++) {
                  const i = Math.min(s, l[e]);
                  t[e + a] = [
                    t[e + o][0] + c[e][0] * i,
                    t[e + o][1] + c[e][1] * i,
                    t[e + o][2] + c[e][2] * i,
                    1,
                  ];
                }
              })(l, a[0], n, o);
            const c = a.map((t) => {
                const i = e.aX([], l[t[0]], l[t[1]]),
                  r = e.aX([], l[t[2]], l[t[1]]),
                  n = e.aY([], e.aZ([], i, r)),
                  o = -e.a_(n, l[t[1]]);
                return n.concat(o);
              }),
              h = [
                Number.POSITIVE_INFINITY,
                Number.POSITIVE_INFINITY,
                Number.POSITIVE_INFINITY,
              ],
              u = [
                Number.NEGATIVE_INFINITY,
                Number.NEGATIVE_INFINITY,
                Number.NEGATIVE_INFINITY,
              ];
            for (const e of l)
              for (let t = 0; t < 3; t++)
                (h[t] = Math.min(h[t], e[t])), (u[t] = Math.max(u[t], e[t]));
            return new Ne(l, c, new Oe(h, u));
          }
        }
        class Ve {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, e, i) {
            return this._helper.interpolatePadding(t, e, i);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, e, i = !0) {
            this._helper.resize(t, e, i);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrain(t) {
            this._helper.setConstrain(t);
          }
          overrideNearFarZ(t, e) {
            this._helper.overrideNearFarZ(t, e);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              t
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t, e) {}
          constructor(t) {
            (this._posMatrixCache = new Map()),
              (this._alignedPosMatrixCache = new Map()),
              (this._fogMatrixCacheF32 = new Map()),
              (this.defaultConstrain = (t, i) => {
                i = e.ai(+i, this.minZoom, this.maxZoom);
                const r = { center: new e.U(t.lng, t.lat), zoom: i };
                let n = this._helper._lngRange;
                if (!this._helper._renderWorldCopies && null === n) {
                  const t = 180 - 1e-10;
                  n = [-t, t];
                }
                const o = this.tileSize * e.al(r.zoom);
                let a = 0,
                  s = o,
                  l = 0,
                  c = o,
                  h = 0,
                  u = 0;
                const { x: d, y: p } = this.size;
                if (this._helper._latRange) {
                  const t = this._helper._latRange;
                  (a = e.W(t[1]) * o),
                    (s = e.W(t[0]) * o),
                    s - a < p && (h = p / (s - a));
                }
                n &&
                  ((l = e.V(e.X(n[0]) * o, 0, o)),
                  (c = e.V(e.X(n[1]) * o, 0, o)),
                  c < l && (c += o),
                  c - l < d && (u = d / (c - l)));
                const { x: f, y: m } = mt(o, t);
                let _, g;
                const y = Math.max(u || 0, h || 0);
                if (y) {
                  const t = new e.P(u ? (c + l) / 2 : f, h ? (s + a) / 2 : m);
                  return (r.center = _t(o, t).wrap()), (r.zoom += e.ao(y)), r;
                }
                if (this._helper._latRange) {
                  const t = p / 2;
                  m - t < a && (g = a + t), m + t > s && (g = s - t);
                }
                if (n) {
                  const t = (l + c) / 2;
                  let i = f;
                  this._helper._renderWorldCopies &&
                    (i = e.V(f, t - o / 2, t + o / 2));
                  const r = d / 2;
                  i - r < l && (_ = l + r), i + r > c && (_ = c - r);
                }
                if (void 0 !== _ || void 0 !== g) {
                  const t = new e.P(null != _ ? _ : f, null != g ? g : m);
                  r.center = _t(o, t).wrap();
                }
                return r;
              }),
              (this._helper = new Be(
                {
                  calcMatrices: () => {
                    this._calcMatrices();
                  },
                  constrain: (t, e) => this.defaultConstrain(t, e),
                },
                t
              )),
              (this._coveringTilesDetailsProvider = new je());
          }
          clone() {
            const t = new Ve();
            return t.apply(this), t;
          }
          apply(t, e, i) {
            this._helper.apply(t, e, i);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(t) {
            const i = [new e.b5(0, t)];
            if (this._helper._renderWorldCopies) {
              const r = this.screenPointToMercatorCoordinate(new e.P(0, 0)),
                n = this.screenPointToMercatorCoordinate(
                  new e.P(this._helper._width, 0)
                ),
                o = this.screenPointToMercatorCoordinate(
                  new e.P(this._helper._width, this._helper._height)
                ),
                a = this.screenPointToMercatorCoordinate(
                  new e.P(0, this._helper._height)
                ),
                s = Math.floor(Math.min(r.x, n.x, o.x, a.x)),
                l = Math.floor(Math.max(r.x, n.x, o.x, a.x)),
                c = 1;
              for (let h = s - c; h <= l + c; h++)
                0 !== h && i.push(new e.b5(h, t));
            }
            return i;
          }
          getCameraFrustum() {
            return Ne.fromInvProjectionMatrix(
              this._invViewProjMatrix,
              this.worldSize
            );
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            const e = this.screenPointToLocation(this.centerPoint, t),
              i = t
                ? t.getElevationForLngLatZoom(e, this._helper._tileZoom)
                : 0;
            this._helper.recalculateZoomAndCenter(i);
          }
          setLocationAtPoint(t, i) {
            const r = e.an(this.elevation, this.center.lat),
              n = this.screenPointToMercatorCoordinateAtZ(i, r),
              o = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r),
              a = e.a5.fromLngLat(t),
              s = new e.a5(a.x - (n.x - o.x), a.y - (n.y - o.y));
            this.setCenter(null == s ? void 0 : s.toLngLat()),
              this._helper._renderWorldCopies &&
                this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(t, i) {
            return i
              ? this.coordinatePoint(
                  e.a5.fromLngLat(t),
                  i.getElevationForLngLatZoom(t, this._helper._tileZoom),
                  this._pixelMatrix3D
                )
              : this.coordinatePoint(e.a5.fromLngLat(t));
          }
          screenPointToLocation(t, e) {
            var i;
            return null === (i = this.screenPointToMercatorCoordinate(t, e)) ||
              void 0 === i
              ? void 0
              : i.toLngLat();
          }
          screenPointToMercatorCoordinate(t, e) {
            if (e) {
              const i = e.pointCoordinate(t);
              if (null != i) return i;
            }
            return this.screenPointToMercatorCoordinateAtZ(t);
          }
          screenPointToMercatorCoordinateAtZ(t, i) {
            const r = i || 0,
              n = [t.x, t.y, 0, 1],
              o = [t.x, t.y, 1, 1];
            e.aA(n, n, this._pixelMatrixInverse),
              e.aA(o, o, this._pixelMatrixInverse);
            const a = n[3],
              s = o[3],
              l = n[1] / a,
              c = o[1] / s,
              h = n[2] / a,
              u = o[2] / s,
              d = h === u ? 0 : (r - h) / (u - h);
            return new e.a5(
              e.F.number(n[0] / a, o[0] / s, d) / this.worldSize,
              e.F.number(l, c, d) / this.worldSize,
              r
            );
          }
          coordinatePoint(t, i = 0, r = this._pixelMatrix) {
            const n = [t.x * this.worldSize, t.y * this.worldSize, i, 1];
            return e.aA(n, n, r), new e.P(n[0] / n[3], n[1] / n[3]);
          }
          getBounds() {
            const t = Math.max(0, this._helper._height / 2 - gt(this));
            return new q()
              .extend(this.screenPointToLocation(new e.P(0, t)))
              .extend(
                this.screenPointToLocation(new e.P(this._helper._width, t))
              )
              .extend(
                this.screenPointToLocation(
                  new e.P(this._helper._width, this._helper._height)
                )
              )
              .extend(
                this.screenPointToLocation(new e.P(0, this._helper._height))
              );
          }
          isPointOnMapSurface(t, e) {
            return e
              ? null != e.pointCoordinate(t)
              : t.y > this.height / 2 - gt(this);
          }
          calculatePosMatrix(t, i = !1, r) {
            var n;
            const o =
                null !== (n = t.key) && void 0 !== n
                  ? n
                  : e.b6(
                      t.wrap,
                      t.canonical.z,
                      t.canonical.z,
                      t.canonical.x,
                      t.canonical.y
                    ),
              a = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a.has(o)) {
              const t = a.get(o);
              return r ? t.f32 : t.f64;
            }
            const s = yt(t, this.worldSize);
            e.Q(s, i ? this._alignedProjMatrix : this._viewProjMatrix, s);
            const l = { f64: s, f32: new Float32Array(s) };
            return a.set(o, l), r ? l.f32 : l.f64;
          }
          calculateFogMatrix(t) {
            const i = t.key,
              r = this._fogMatrixCacheF32;
            if (r.has(i)) return r.get(i);
            const n = yt(t, this.worldSize);
            return (
              e.Q(n, this._fogMatrix, n),
              r.set(i, new Float32Array(n)),
              r.get(i)
            );
          }
          calculateCenterFromCameraLngLatAlt(t, e, i, r) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
          }
          _calculateNearFarZIfNeeded(t, i, r) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const n = Math.min(
                this.elevation,
                this.minElevationForCurrentTile,
                this.getCameraAltitude() - 100
              ),
              o = t - (n * this._helper._pixelPerMeter) / Math.cos(i),
              a = n < 0 ? o : t,
              s = Math.PI / 2 + this.pitchInRadians,
              l =
                ((e.ak(this.fov) *
                  (Math.abs(Math.cos(e.ak(this.roll))) * this.height +
                    Math.abs(Math.sin(e.ak(this.roll))) * this.width)) /
                  this.height) *
                (0.5 + r.y / this.height),
              c =
                (Math.sin(l) * a) /
                Math.sin(e.ai(Math.PI - s - l, 0.01, Math.PI - 0.01)),
              h = gt(this),
              u = Math.atan(h / this._helper.cameraToCenterDistance),
              d = e.ak(0.75),
              p = u > d ? 2 * u * (0.5 + r.y / (2 * h)) : d,
              f =
                (Math.sin(p) * a) /
                Math.sin(e.ai(Math.PI - s - p, 0.01, Math.PI - 0.01)),
              m = Math.min(c, f);
            (this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * m + a)),
              (this._helper._nearZ = this._helper._height / 50);
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const t = this.centerOffset,
              i = mt(this.worldSize, this.center),
              r = i.x,
              n = i.y;
            this._helper._pixelPerMeter =
              e.an(1, this.center.lat) * this.worldSize;
            const o = e.ak(Math.min(this.pitch, ft)),
              a = Math.max(
                this._helper.cameraToCenterDistance / 2,
                this._helper.cameraToCenterDistance +
                  (this._helper._elevation * this._helper._pixelPerMeter) /
                    Math.cos(o)
              );
            let s;
            this._calculateNearFarZIfNeeded(a, o, t),
              (s = new Float64Array(16)),
              e.b7(
                s,
                this.fovInRadians,
                this._helper._width / this._helper._height,
                this._helper._nearZ,
                this._helper._farZ
              ),
              (this._invProjMatrix = new Float64Array(16)),
              e.au(this._invProjMatrix, s),
              (s[8] = (2 * -t.x) / this._helper._width),
              (s[9] = (2 * t.y) / this._helper._height),
              (this._projectionMatrix = e.b8(s)),
              e.O(s, s, [1, -1, 1]),
              e.N(s, s, [0, 0, -this._helper.cameraToCenterDistance]),
              e.b9(s, s, -this.rollInRadians),
              e.ba(s, s, this.pitchInRadians),
              e.b9(s, s, -this.bearingInRadians),
              e.N(s, s, [-r, -n, 0]),
              (this._mercatorMatrix = e.O([], s, [
                this.worldSize,
                this.worldSize,
                this.worldSize,
              ])),
              e.O(s, s, [1, 1, this._helper._pixelPerMeter]),
              (this._pixelMatrix = e.Q(
                new Float64Array(16),
                this.clipSpaceToPixelsMatrix,
                s
              )),
              e.N(s, s, [0, 0, -this.elevation]),
              (this._viewProjMatrix = s),
              (this._invViewProjMatrix = e.au([], s));
            const l = [0, 0, -1, 1];
            e.aA(l, l, this._invViewProjMatrix),
              (this._cameraPosition = [l[0] / l[3], l[1] / l[3], l[2] / l[3]]),
              (this._fogMatrix = new Float64Array(16)),
              e.b7(
                this._fogMatrix,
                this.fovInRadians,
                this.width / this.height,
                a,
                this._helper._farZ
              ),
              (this._fogMatrix[8] = (2 * -t.x) / this.width),
              (this._fogMatrix[9] = (2 * t.y) / this.height),
              e.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
              e.N(this._fogMatrix, this._fogMatrix, [
                0,
                0,
                -this.cameraToCenterDistance,
              ]),
              e.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
              e.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
              e.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
              e.N(this._fogMatrix, this._fogMatrix, [-r, -n, 0]),
              e.O(this._fogMatrix, this._fogMatrix, [
                1,
                1,
                this._helper._pixelPerMeter,
              ]),
              e.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
              (this._pixelMatrix3D = e.Q(
                new Float64Array(16),
                this.clipSpaceToPixelsMatrix,
                s
              ));
            const c = (this._helper._width % 2) / 2,
              h = (this._helper._height % 2) / 2,
              u = Math.cos(this.bearingInRadians),
              d = Math.sin(-this.bearingInRadians),
              p = r - Math.round(r) + u * c + d * h,
              f = n - Math.round(n) + u * h + d * c,
              m = new Float64Array(s);
            if (
              (e.N(m, m, [p > 0.5 ? p - 1 : p, f > 0.5 ? f - 1 : f, 0]),
              (this._alignedProjMatrix = m),
              (s = e.au(new Float64Array(16), this._pixelMatrix)),
              !s)
            )
              throw new Error('failed to invert matrix');
            (this._pixelMatrixInverse = s), this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(),
              this._alignedPosMatrixCache.clear(),
              this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const t = this.screenPointToMercatorCoordinate(new e.P(0, 0)),
              i = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
            return (
              e.aA(i, i, this._pixelMatrix)[3] /
              this._helper.cameraToCenterDistance
            );
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const t = e.an(1, this.center.lat) * this.worldSize;
            return xt(
              this.center,
              this.elevation,
              this.pitch,
              this.bearing,
              this._helper.cameraToCenterDistance / t
            ).toLngLat();
          }
          lngLatToCameraDepth(t, i) {
            const r = e.a5.fromLngLat(t),
              n = [r.x * this.worldSize, r.y * this.worldSize, i, 1];
            return e.aA(n, n, this._viewProjMatrix), n[2] / n[3];
          }
          getProjectionData(t) {
            const {
                overscaledTileID: i,
                aligned: r,
                applyTerrainMatrix: n,
              } = t,
              o = this._helper.getMercatorTileCoordinates(i),
              a = i ? this.calculatePosMatrix(i, r, !0) : null;
            let s;
            return (
              (s =
                i && i.terrainRttPosMatrix32f && n
                  ? i.terrainRttPosMatrix32f
                  : a || e.bb()),
              {
                mainMatrix: s,
                tileMercatorCoords: o,
                clippingPlane: [0, 0, 0, 0],
                projectionTransition: 0,
                fallbackMatrix: s,
              }
            );
          }
          isLocationOccluded(t) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(t, e, i) {
            return 1;
          }
          transformLightDirection(t) {
            return e.aW(t);
          }
          getRayDirectionFromPixel(t) {
            throw new Error('Not implemented.');
          }
          projectTileCoordinates(t, i, r, n) {
            const o = this.calculatePosMatrix(r);
            let a;
            n
              ? ((a = [t, i, n(t, i), 1]), e.aA(a, a, o))
              : ((a = [t, i, 0, 1]), Qt(a, a, o));
            const s = a[3];
            return {
              point: new e.P(a[0] / s, a[1] / s),
              signedDistanceFromCamera: s,
              isOccluded: !1,
            };
          }
          populateCache(t) {
            for (const e of t) this.calculatePosMatrix(e);
          }
          getMatrixForModel(t, i) {
            const r = e.a5.fromLngLat(t, i),
              n = r.meterInMercatorCoordinateUnits(),
              o = e.bc();
            return (
              e.N(o, o, [r.x, r.y, r.z]),
              e.b9(o, o, Math.PI),
              e.ba(o, o, Math.PI / 2),
              e.O(o, o, [-n, n, n]),
              o
            );
          }
          getProjectionDataForCustomLayer(t = !0) {
            const i = new e.a0(0, 0, 0, 0, 0),
              r = this.getProjectionData({
                overscaledTileID: i,
                applyGlobeMatrix: t,
              }),
              n = yt(i, this.worldSize);
            e.Q(n, this._viewProjMatrix, n),
              (r.tileMercatorCoords = [0, 0, 1, 1]);
            const o = [
                e.a3,
                e.a3,
                this.worldSize / this._helper.pixelsPerMeter,
              ],
              a = e.bd();
            return e.O(a, n, o), (r.fallbackMatrix = a), (r.mainMatrix = a), r;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.calculatePosMatrix(t);
          }
        }
        function Ue() {
          e.w(
            'Map cannot fit within canvas with the given bounds, padding, and/or offset.'
          );
        }
        function Ge(t) {
          if (t.useSlerp)
            if (t.k < 1) {
              const i = e.be(
                  t.startEulerAngles.roll,
                  t.startEulerAngles.pitch,
                  t.startEulerAngles.bearing
                ),
                r = e.be(
                  t.endEulerAngles.roll,
                  t.endEulerAngles.pitch,
                  t.endEulerAngles.bearing
                ),
                n = new Float64Array(4);
              e.bf(n, i, r, t.k);
              const o = e.bg(n);
              t.tr.setRoll(o.roll),
                t.tr.setPitch(o.pitch),
                t.tr.setBearing(o.bearing);
            } else
              t.tr.setRoll(t.endEulerAngles.roll),
                t.tr.setPitch(t.endEulerAngles.pitch),
                t.tr.setBearing(t.endEulerAngles.bearing);
          else
            t.tr.setRoll(
              e.F.number(t.startEulerAngles.roll, t.endEulerAngles.roll, t.k)
            ),
              t.tr.setPitch(
                e.F.number(
                  t.startEulerAngles.pitch,
                  t.endEulerAngles.pitch,
                  t.k
                )
              ),
              t.tr.setBearing(
                e.F.number(
                  t.startEulerAngles.bearing,
                  t.endEulerAngles.bearing,
                  t.k
                )
              );
        }
        function Ze(t, i, r, n, o) {
          const a = o.padding,
            s = mt(o.worldSize, r.getNorthWest()),
            l = mt(o.worldSize, r.getNorthEast()),
            c = mt(o.worldSize, r.getSouthEast()),
            h = mt(o.worldSize, r.getSouthWest()),
            u = e.ak(-n),
            d = s.rotate(u),
            p = l.rotate(u),
            f = c.rotate(u),
            m = h.rotate(u),
            _ = new e.P(
              Math.max(d.x, p.x, m.x, f.x),
              Math.max(d.y, p.y, m.y, f.y)
            ),
            g = new e.P(
              Math.min(d.x, p.x, m.x, f.x),
              Math.min(d.y, p.y, m.y, f.y)
            ),
            y = _.sub(g),
            x = (o.width - (a.left + a.right + i.left + i.right)) / y.x,
            v = (o.height - (a.top + a.bottom + i.top + i.bottom)) / y.y;
          if (v < 0 || x < 0) return void Ue();
          const b = Math.min(e.ao(o.scale * Math.min(x, v)), t.maxZoom),
            w = e.P.convert(t.offset),
            T = new e.P((i.left - i.right) / 2, (i.top - i.bottom) / 2).rotate(
              e.ak(n)
            ),
            P = w.add(T).mult(o.scale / e.al(b));
          return {
            center: _t(o.worldSize, s.add(c).div(2).sub(P)),
            zoom: b,
            bearing: n,
          };
        }
        class $e {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(t, e) {
            const i = t.mag(),
              r = Math.abs(gt(e));
            return {
              easingOffset: t.mult(Math.min((0.75 * r) / i, 1)),
              easingCenter: e.center,
            };
          }
          handleMapControlsRollPitchBearingZoom(t, e) {
            t.bearingDelta && e.setBearing(e.bearing + t.bearingDelta),
              t.pitchDelta && e.setPitch(e.pitch + t.pitchDelta),
              t.rollDelta && e.setRoll(e.roll + t.rollDelta),
              t.zoomDelta && e.setZoom(e.zoom + t.zoomDelta);
          }
          handleMapControlsPan(t, e, i) {
            t.around.distSqr(e.centerPoint) < 0.01 ||
              e.setLocationAtPoint(i, t.around);
          }
          cameraForBoxAndBearing(t, e, i, r, n) {
            return Ze(t, e, i, r, n);
          }
          handleJumpToCenterZoom(t, i) {
            t.zoom !== (void 0 !== i.zoom ? +i.zoom : t.zoom) &&
              t.setZoom(+i.zoom),
              void 0 !== i.center && t.setCenter(e.U.convert(i.center));
          }
          handleEaseTo(t, i) {
            const r = t.zoom,
              n = t.padding,
              o = { roll: t.roll, pitch: t.pitch, bearing: t.bearing },
              a = {
                roll: void 0 === i.roll ? t.roll : i.roll,
                pitch: void 0 === i.pitch ? t.pitch : i.pitch,
                bearing: void 0 === i.bearing ? t.bearing : i.bearing,
              },
              s = void 0 !== i.zoom,
              l = !t.isPaddingEqual(i.padding);
            let c = !1;
            const h = s ? +i.zoom : t.zoom;
            let u = t.centerPoint.add(i.offsetAsPoint);
            const d = t.screenPointToLocation(u),
              { center: p, zoom: f } = t.constrain(
                e.U.convert(i.center || d),
                null != h ? h : r
              );
            Le(t, p);
            const m = mt(t.worldSize, d),
              _ = mt(t.worldSize, p).sub(m),
              g = e.al(f - r);
            return (
              (c = f !== r),
              {
                easeFunc: (s) => {
                  if (
                    (c && t.setZoom(e.F.number(r, f, s)),
                    e.bh(o, a) ||
                      Ge({
                        startEulerAngles: o,
                        endEulerAngles: a,
                        tr: t,
                        k: s,
                        useSlerp: o.roll != a.roll,
                      }),
                    l &&
                      (t.interpolatePadding(n, i.padding, s),
                      (u = t.centerPoint.add(i.offsetAsPoint))),
                    i.around)
                  )
                    t.setLocationAtPoint(i.around, i.aroundPoint);
                  else {
                    const i = e.al(t.zoom - r),
                      n = f > r ? Math.min(2, g) : Math.max(0.5, g),
                      o = Math.pow(n, 1 - s),
                      a = _t(t.worldSize, m.add(_.mult(s * o)).mult(i));
                    t.setLocationAtPoint(t.renderWorldCopies ? a.wrap() : a, u);
                  }
                },
                isZooming: c,
                elevationCenter: p,
              }
            );
          }
          handleFlyTo(t, i) {
            const r = void 0 !== i.zoom,
              n = t.zoom,
              o = t.constrain(
                e.U.convert(i.center || i.locationAtOffset),
                r ? +i.zoom : n
              ),
              a = o.center,
              s = o.zoom;
            Le(t, a);
            const l = mt(t.worldSize, i.locationAtOffset),
              c = mt(t.worldSize, a).sub(l),
              h = c.mag(),
              u = e.al(s - n);
            let d;
            if (void 0 !== i.minZoom) {
              const r = Math.min(+i.minZoom, n, s),
                o = t.constrain(a, r).zoom;
              d = e.al(o - n);
            }
            return {
              easeFunc: (i, r, o, h) => {
                t.setZoom(1 === i ? s : n + e.ao(r));
                const u =
                  1 === i ? a : _t(t.worldSize, l.add(c.mult(o)).mult(r));
                t.setLocationAtPoint(t.renderWorldCopies ? u.wrap() : u, h);
              },
              scaleOfZoom: u,
              targetCenter: a,
              scaleOfMinZoom: d,
              pixelPathLength: h,
            };
          }
        }
        class qe {
          constructor(t, e, i) {
            (this.blendFunction = t), (this.blendColor = e), (this.mask = i);
          }
        }
        (qe.Replace = [1, 0]),
          (qe.disabled = new qe(qe.Replace, e.bi.transparent, [
            !1,
            !1,
            !1,
            !1,
          ])),
          (qe.unblended = new qe(qe.Replace, e.bi.transparent, [
            !0,
            !0,
            !0,
            !0,
          ])),
          (qe.alphaBlended = new qe([1, 771], e.bi.transparent, [
            !0,
            !0,
            !0,
            !0,
          ]));
        const We = 2305;
        class Ye {
          constructor(t, e, i) {
            (this.enable = t), (this.mode = e), (this.frontFace = i);
          }
        }
        (Ye.disabled = new Ye(!1, 1029, We)),
          (Ye.backCCW = new Ye(!0, 1029, We)),
          (Ye.frontCCW = new Ye(!0, 1028, We));
        class He {
          constructor(t, e, i) {
            (this.func = t), (this.mask = e), (this.range = i);
          }
        }
        (He.ReadOnly = !1),
          (He.ReadWrite = !0),
          (He.disabled = new He(519, He.ReadOnly, [0, 1]));
        const Xe = 7680;
        class Ke {
          constructor(t, e, i, r, n, o) {
            (this.test = t),
              (this.ref = e),
              (this.mask = i),
              (this.fail = r),
              (this.depthFail = n),
              (this.pass = o);
          }
        }
        Ke.disabled = new Ke({ func: 519, mask: 0 }, 0, 0, Xe, Xe, Xe);
        const Je = new WeakMap();
        function Qe(t) {
          var e;
          if (Je.has(t)) return Je.get(t);
          {
            const i =
              null === (e = t.getParameter(t.VERSION)) || void 0 === e
                ? void 0
                : e.startsWith('WebGL 2.0');
            return Je.set(t, i), i;
          }
        }
        class ti {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(t) {
            (this._readbackWaitFrames = 4),
              (this._measureWaitFrames = 6),
              (this._texWidth = 1),
              (this._texHeight = 1),
              (this._measuredError = 0),
              (this._updateCount = 0),
              (this._lastReadbackFrame = -1e3),
              (this._readbackQueue = null),
              (this._cachedRenderContext = t);
            const i = t.context,
              r = i.gl;
            (this._texFormat = r.RGBA), (this._texType = r.UNSIGNED_BYTE);
            const n = new e.aP();
            n.emplaceBack(-1, -1), n.emplaceBack(2, -1), n.emplaceBack(-1, 2);
            const o = new e.aR();
            o.emplaceBack(0, 1, 2),
              (this._fullscreenTriangle = new Ae(
                i.createVertexBuffer(n, Ee.members),
                i.createIndexBuffer(o),
                e.aQ.simpleSegment(0, 0, n.length, o.length)
              )),
              (this._resultBuffer = new Uint8Array(4)),
              i.activeTexture.set(r.TEXTURE1);
            const a = r.createTexture();
            r.bindTexture(r.TEXTURE_2D, a),
              r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
              r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
              r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST),
              r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST),
              r.texImage2D(
                r.TEXTURE_2D,
                0,
                this._texFormat,
                this._texWidth,
                this._texHeight,
                0,
                this._texFormat,
                this._texType,
                null
              ),
              (this._fbo = i.createFramebuffer(
                this._texWidth,
                this._texHeight,
                !1,
                !1
              )),
              this._fbo.colorAttachment.set(a),
              Qe(r) &&
                ((this._pbo = r.createBuffer()),
                r.bindBuffer(r.PIXEL_PACK_BUFFER, this._pbo),
                r.bufferData(r.PIXEL_PACK_BUFFER, 4, r.STREAM_READ),
                r.bindBuffer(r.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const t = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(),
              this._fbo.destroy(),
              t.deleteBuffer(this._pbo),
              (this._fullscreenTriangle = null),
              (this._fbo = null),
              (this._pbo = null),
              (this._resultBuffer = null);
          }
          updateErrorLoop(t, e) {
            const i = this._updateCount;
            return (
              this._readbackQueue
                ? i >=
                    this._readbackQueue.frameNumberIssued +
                      this._readbackWaitFrames && this._tryReadback()
                : i >= this._lastReadbackFrame + this._measureWaitFrames &&
                  this._renderErrorTexture(t, e),
              this._updateCount++,
              this._measuredError
            );
          }
          _bindFramebuffer() {
            const t = this._cachedRenderContext.context,
              e = t.gl;
            t.activeTexture.set(e.TEXTURE1),
              e.bindTexture(e.TEXTURE_2D, this._fbo.colorAttachment.get()),
              t.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(t, i) {
            const r = this._cachedRenderContext.context,
              n = r.gl;
            if (
              (this._bindFramebuffer(),
              r.viewport.set([0, 0, this._texWidth, this._texHeight]),
              r.clear({ color: e.bi.transparent }),
              this._cachedRenderContext
                .useProgram('projectionErrorMeasurement')
                .draw(
                  r,
                  n.TRIANGLES,
                  He.disabled,
                  Ke.disabled,
                  qe.unblended,
                  Ye.disabled,
                  ((t, e) => ({ u_input: t, u_output_expected: e }))(t, i),
                  null,
                  null,
                  '$clipping',
                  this._fullscreenTriangle.vertexBuffer,
                  this._fullscreenTriangle.indexBuffer,
                  this._fullscreenTriangle.segments
                ),
              this._pbo && Qe(n))
            ) {
              n.bindBuffer(n.PIXEL_PACK_BUFFER, this._pbo),
                n.readBuffer(n.COLOR_ATTACHMENT0),
                n.readPixels(
                  0,
                  0,
                  this._texWidth,
                  this._texHeight,
                  this._texFormat,
                  this._texType,
                  0
                ),
                n.bindBuffer(n.PIXEL_PACK_BUFFER, null);
              const t = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);
              n.flush(),
                (this._readbackQueue = {
                  frameNumberIssued: this._updateCount,
                  sync: t,
                });
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const t = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Qe(t)) {
              const i = t.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === t.WAIT_FAILED)
                return (
                  e.w('WebGL2 clientWaitSync failed.'),
                  (this._readbackQueue = null),
                  void (this._lastReadbackFrame = this._updateCount)
                );
              if (i === t.TIMEOUT_EXPIRED) return;
              t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo),
                t.getBufferSubData(
                  t.PIXEL_PACK_BUFFER,
                  0,
                  this._resultBuffer,
                  0,
                  4
                ),
                t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            (this._readbackQueue = null),
              (this._measuredError = ti._parseRGBA8float(this._resultBuffer)),
              (this._lastReadbackFrame = this._updateCount);
          }
          static _parseRGBA8float(t) {
            let e = 0;
            return (
              (e += t[0] / 256),
              (e += t[1] / 65536),
              (e += t[2] / 16777216),
              t[3] < 127 && (e = -e),
              e / 128
            );
          }
        }
        const ei = e.a3 / 128;
        function ii(t, i) {
          const r = void 0 !== t.granularity ? Math.max(t.granularity, 1) : 1,
            n = r + (t.generateBorders ? 2 : 0),
            o =
              r +
              (t.extendToNorthPole || t.generateBorders ? 1 : 0) +
              (t.extendToSouthPole || t.generateBorders ? 1 : 0),
            a = n + 1,
            s = o + 1,
            l = t.generateBorders ? -1 : 0,
            c = t.generateBorders || t.extendToNorthPole ? -1 : 0,
            h = r + (t.generateBorders ? 1 : 0),
            u = r + (t.generateBorders || t.extendToSouthPole ? 1 : 0),
            d = a * s,
            p = n * o * 6,
            f = a * s > 65536;
          if (f && '16bit' === i)
            throw new Error(
              'Granularity is too large and meshes would not fit inside 16 bit vertex indices.'
            );
          const m = f || '32bit' === i,
            _ = new Int16Array(2 * d);
          let g = 0;
          for (let v = c; v <= u; v++)
            for (let i = l; i <= h; i++) {
              let n = (i / r) * e.a3;
              -1 === i && (n = -ei), i === r + 1 && (n = e.a3 + ei);
              let o = (v / r) * e.a3;
              -1 === v && (o = t.extendToNorthPole ? e.bk : -ei),
                v === r + 1 && (o = t.extendToSouthPole ? e.bl : e.a3 + ei),
                (_[g++] = n),
                (_[g++] = o);
            }
          const y = m ? new Uint32Array(p) : new Uint16Array(p);
          let x = 0;
          for (let e = 0; e < o; e++)
            for (let t = 0; t < n; t++) {
              const i = t + 1 + e * a,
                r = t + (e + 1) * a,
                n = t + 1 + (e + 1) * a;
              (y[x++] = t + e * a),
                (y[x++] = r),
                (y[x++] = i),
                (y[x++] = i),
                (y[x++] = r),
                (y[x++] = n);
            }
          return {
            vertices: _.buffer.slice(0),
            indices: y.buffer.slice(0),
            uses32bitIndices: m,
          };
        }
        const ri = new e.aO({
          fill: new e.bm(128, 2),
          line: new e.bm(512, 0),
          tile: new e.bm(128, 32),
          stencil: new e.bm(128, 1),
          circle: 3,
        });
        class ni {
          constructor() {
            (this._tileMeshCache = {}),
              (this._errorCorrectionUsable = 0),
              (this._errorMeasurementLastValue = 0),
              (this._errorCorrectionPreviousValue = 0),
              (this._errorMeasurementLastChangeTime = -1e3);
          }
          get name() {
            return 'vertical-perspective';
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return 'globe';
          }
          get shaderDefine() {
            return '#define GLOBE';
          }
          get shaderPreludeCode() {
            return Ie.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Ie.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return ri;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(t) {
            this._errorMeasurement || (this._errorMeasurement = new ti(t));
            const i = e.W(this._errorQueryLatitudeDegrees),
              r =
                2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) -
                0.5 * Math.PI,
              n = this._errorMeasurement.updateErrorLoop(i, r),
              o = l();
            n !== this._errorMeasurementLastValue &&
              ((this._errorCorrectionPreviousValue =
                this._errorCorrectionUsable),
              (this._errorMeasurementLastValue = n),
              (this._errorMeasurementLastChangeTime = o));
            const a = Math.min(
              Math.max(
                (o - this._errorMeasurementLastChangeTime) / 1e3 / 0.5,
                0
              ),
              1
            );
            this._errorCorrectionUsable = e.bn(
              this._errorCorrectionPreviousValue,
              -this._errorMeasurementLastValue,
              e.bo(a)
            );
          }
          _getMeshKey(t) {
            return `${t.granularity.toString(
              36
            )}_${t.generateBorders ? 'b' : ''}${t.extendToNorthPole ? 'n' : ''}${t.extendToSouthPole ? 's' : ''}`;
          }
          getMeshFromTileID(t, e, i, r, n) {
            const o = (
              'stencil' === n ? ri.stencil : ri.tile
            ).getGranularityForZoomLevel(e.z);
            return this._getMesh(t, {
              granularity: o,
              generateBorders: i,
              extendToNorthPole: 0 === e.y && r,
              extendToSouthPole: e.y === (1 << e.z) - 1 && r,
            });
          }
          _getMesh(t, i) {
            const r = this._getMeshKey(i);
            if (r in this._tileMeshCache) return this._tileMeshCache[r];
            const n = (function (t, i) {
              const r = ii(i, '16bit'),
                n = e.aP.deserialize({
                  arrayBuffer: r.vertices,
                  length: r.vertices.byteLength / 2 / 2,
                }),
                o = e.aR.deserialize({
                  arrayBuffer: r.indices,
                  length: r.indices.byteLength / 2 / 3,
                });
              return new Ae(
                t.createVertexBuffer(n, Ee.members),
                t.createIndexBuffer(o),
                e.aQ.simpleSegment(0, 0, n.length, o.length)
              );
            })(t, i);
            return (this._tileMeshCache[r] = n), n;
          }
          recalculate(t) {}
          hasTransition() {
            const t = l();
            let e = !1;
            return (
              (e = e || (t - this._errorMeasurementLastChangeTime) / 1e3 < 0.7),
              (e =
                e ||
                (this._errorMeasurement &&
                  this._errorMeasurement.awaitingQuery)),
              e
            );
          }
          setErrorQueryLatitudeDegrees(t) {
            this._errorQueryLatitudeDegrees = t;
          }
        }
        const oi = new e.r({ type: new e.D(e.t.projection.type) });
        class ai extends e.E {
          constructor(t) {
            super(),
              (this._transitionable = new e.x(oi, void 0)),
              this.setProjection(t),
              (this._transitioning = this._transitionable.untransitioned()),
              this.recalculate(new e.G(0)),
              (this._mercatorProjection = new De()),
              (this._verticalPerspectiveProjection = new ni());
          }
          get transitionState() {
            const t = this.properties.get('type');
            if ('string' == typeof t && 'mercator' === t) return 0;
            if ('string' == typeof t && 'vertical-perspective' === t) return 1;
            if (t instanceof e.bp) {
              if ('vertical-perspective' === t.from && 'mercator' === t.to)
                return 1 - t.transition;
              if ('mercator' === t.from && 'vertical-perspective' === t.to)
                return t.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this
              ._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering
              ? this._verticalPerspectiveProjection
              : this._mercatorProjection;
          }
          get name() {
            return 'globe';
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(),
              this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(t) {
            this._mercatorProjection.updateGPUdependent(t),
              this._verticalPerspectiveProjection.updateGPUdependent(t);
          }
          getMeshFromTileID(t, e, i, r, n) {
            return this.currentProjection.getMeshFromTileID(t, e, i, r, n);
          }
          setProjection(t) {
            this._transitionable.setValue(
              'type',
              (null == t ? void 0 : t.type) || 'mercator'
            );
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(
              t,
              this._transitioning
            );
          }
          hasTransition() {
            return (
              this._transitioning.hasTransition() ||
              this.currentProjection.hasTransition()
            );
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          setErrorQueryLatitudeDegrees(t) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t),
              this._mercatorProjection.setErrorQueryLatitudeDegrees(t);
          }
        }
        function si(t) {
          const e = hi(t.worldSize, t.center.lat);
          return 2 * Math.PI * e;
        }
        function li(t, i, r, n, o) {
          const a = 1 / (1 << o),
            s = (i / e.a3) * a + n * a,
            l = e.br(
              ((t / e.a3) * a + r * a) * Math.PI * 2 + Math.PI,
              2 * Math.PI
            ),
            c =
              2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) -
              0.5 * Math.PI,
            h = Math.cos(c),
            u = new Float64Array(3);
          return (
            (u[0] = Math.sin(l) * h),
            (u[1] = Math.sin(c)),
            (u[2] = Math.cos(l) * h),
            u
          );
        }
        function ci(t) {
          return (function (t, e) {
            const i = Math.cos(e),
              r = new Float64Array(3);
            return (
              (r[0] = Math.sin(t) * i),
              (r[1] = Math.sin(e)),
              (r[2] = Math.cos(t) * i),
              r
            );
          })((t.lng * Math.PI) / 180, (t.lat * Math.PI) / 180);
        }
        function hi(t, e) {
          return t / (2 * Math.PI) / Math.cos((e * Math.PI) / 180);
        }
        function ui(t) {
          const i = (Math.asin(t[1]) / Math.PI) * 180,
            r = Math.sqrt(t[0] * t[0] + t[2] * t[2]);
          if (r > 1e-6) {
            const n = t[0] / r,
              o = Math.acos(t[2] / r),
              a = ((n > 0 ? o : -o) / Math.PI) * 180;
            return new e.U(e.V(a, -180, 180), i);
          }
          return new e.U(0, i);
        }
        function di(t) {
          return Math.cos((t * Math.PI) / 180);
        }
        function pi(t, i) {
          const r = di(t),
            n = di(i);
          return e.ao(n / r);
        }
        function fi(t, i) {
          const r = t.rotate(i.bearingInRadians),
            n = i.zoom + pi(i.center.lat, 0),
            o = e.bn(
              1 / di(i.center.lat),
              1 / di(Math.min(Math.abs(i.center.lat), 60)),
              e.bq(n, 7, 3, 0, 1)
            ),
            a =
              360 /
              si({ worldSize: i.worldSize, center: { lat: i.center.lat } });
          return new e.U(
            i.center.lng - r.x * a * o,
            e.ai(i.center.lat + r.y * a, -e.aj, e.aj)
          );
        }
        function mi(t) {
          const e = 0.5 * t,
            i = Math.sin(e),
            r = Math.cos(e);
          return Math.log(i + r) - Math.log(r - i);
        }
        function _i(t, i, r, n) {
          const o = t.lat + r * n;
          if (Math.abs(r) > 1) {
            const a =
                ((Math.sign(t.lat + r) !== Math.sign(t.lat)
                  ? -Math.abs(t.lat)
                  : Math.abs(t.lat)) *
                  Math.PI) /
                180,
              s = (Math.abs(t.lat + r) * Math.PI) / 180,
              l = mi(a + n * (s - a)),
              c = mi(a),
              h = mi(s);
            return new e.U(t.lng + i * ((l - c) / (h - c)), o);
          }
          return new e.U(t.lng + i * n, o);
        }
        class gi {
          constructor(t) {
            (this._cachePrevious = new Map()),
              (this._cache = new Map()),
              (this._hadAnyChanges = !1),
              (this._boundingVolumeFactory = t);
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const t = this._cachePrevious;
            (this._cachePrevious = this._cache),
              (this._cache = t),
              this._cache.clear(),
              (this._hadAnyChanges = !1);
          }
          getTileBoundingVolume(t, e, i, r) {
            const n = `${t.z}_${t.x}_${t.y}_${
                (null == r ? void 0 : r.terrain) ? 't' : ''
              }`,
              o = this._cache.get(n);
            if (o) return o;
            const a = this._cachePrevious.get(n);
            if (a) return this._cache.set(n, a), a;
            const s = this._boundingVolumeFactory(t, e, i, r);
            return this._cache.set(n, s), (this._hadAnyChanges = !0), s;
          }
        }
        class yi {
          constructor(t, e, i, r) {
            (this.min = i),
              (this.max = r),
              (this.points = t),
              (this.planes = e);
          }
          static fromAabb(t, e) {
            const i = [];
            for (let r = 0; r < 8; r++)
              i.push([
                1 & ~r ? t[0] : e[0],
                1 == ((r >> 1) & 1) ? e[1] : t[1],
                1 == ((r >> 2) & 1) ? e[2] : t[2],
              ]);
            return new yi(
              i,
              [
                [-1, 0, 0, e[0]],
                [1, 0, 0, -t[0]],
                [0, -1, 0, e[1]],
                [0, 1, 0, -t[1]],
                [0, 0, -1, e[2]],
                [0, 0, 1, -t[2]],
              ],
              t,
              e
            );
          }
          static fromCenterSizeAngles(t, i, r) {
            const n = e.bu([], r[0], r[1], r[2]),
              o = e.bv([], [i[0], 0, 0], n),
              a = e.bv([], [0, i[1], 0], n),
              s = e.bv([], [0, 0, i[2]], n),
              l = [...t],
              c = [...t];
            for (let e = 0; e < 8; e++)
              for (let i = 0; i < 3; i++) {
                const r =
                  t[i] +
                  o[i] * (1 & ~e ? -1 : 1) +
                  a[i] * (1 == ((e >> 1) & 1) ? 1 : -1) +
                  s[i] * (1 == ((e >> 2) & 1) ? 1 : -1);
                (l[i] = Math.min(l[i], r)), (c[i] = Math.max(c[i], r));
              }
            const h = [];
            for (let u = 0; u < 8; u++) {
              const i = [...t];
              e.aV(i, i, e.aU([], o, 1 & ~u ? -1 : 1)),
                e.aV(i, i, e.aU([], a, 1 == ((u >> 1) & 1) ? 1 : -1)),
                e.aV(i, i, e.aU([], s, 1 == ((u >> 2) & 1) ? 1 : -1)),
                h.push(i);
            }
            return new yi(
              h,
              [
                [...o, -e.a_(o, h[0])],
                [...a, -e.a_(a, h[0])],
                [...s, -e.a_(s, h[0])],
                [-o[0], -o[1], -o[2], -e.a_(o, h[7])],
                [-a[0], -a[1], -a[2], -e.a_(a, h[7])],
                [-s[0], -s[1], -s[2], -e.a_(s, h[7])],
              ],
              l,
              c
            );
          }
          intersectsFrustum(t) {
            let e = !0;
            const i = this.points.length,
              r = this.planes.length,
              n = t.planes.length,
              o = t.points.length;
            for (let a = 0; a < n; a++) {
              const r = t.planes[a];
              let n = 0;
              for (let t = 0; t < i; t++) {
                const e = this.points[t];
                r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0 && n++;
              }
              if (0 === n) return 0;
              n < i && (e = !1);
            }
            if (e) return 2;
            for (let a = 0; a < r; a++) {
              const e = this.planes[a];
              let i = 0;
              for (let r = 0; r < o; r++) {
                const n = t.points[r];
                e[0] * n[0] + e[1] * n[1] + e[2] * n[2] + e[3] >= 0 && i++;
              }
              if (0 === i) return 0;
            }
            return 1;
          }
          intersectsPlane(t) {
            const e = this.points.length;
            let i = 0;
            for (let r = 0; r < e; r++) {
              const e = this.points[r];
              t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] >= 0 && i++;
            }
            return i === e ? 2 : 0 === i ? 0 : 1;
          }
        }
        function xi(t, e, i) {
          const r = t - e;
          return r < 0 ? -r : Math.max(0, r - i);
        }
        function vi(t, e, i, r, n) {
          const o = t - i;
          let a;
          return (
            (a =
              o < 0
                ? Math.min(-o, 1 + o - n)
                : o > 1
                ? Math.min(Math.max(o - n, 0), 1 - o)
                : 0),
            Math.max(a, xi(e, r, n))
          );
        }
        class bi {
          constructor() {
            this._boundingVolumeCache = new gi(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(t, e, i, r) {
            const n = 1 << i.z,
              o = 1 / n,
              a = i.x / n,
              s = i.y / n;
            let l = 2;
            return (
              (l = Math.min(l, vi(t, e, a, s, o))),
              (l = Math.min(l, vi(t, e, a + 0.5, -s - o, o))),
              (l = Math.min(l, vi(t, e, a + 0.5, 2 - s - o, o))),
              l
            );
          }
          getWrap(t, e, i) {
            const r = 1 << e.z,
              n = 1 / r,
              o = e.x / r,
              a = xi(t.x, o, n),
              s = xi(t.x, o - 1, n),
              l = xi(t.x, o + 1, n),
              c = Math.min(a, s, l);
            return c === l ? 1 : c === s ? -1 : 0;
          }
          allowVariableZoom(t, e) {
            return Pt(t, e) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(t, e, i, r) {
            return this._boundingVolumeCache.getTileBoundingVolume(t, e, i, r);
          }
          _computeTileBoundingVolume(t, i, r, n) {
            var o, a;
            let s = 0,
              l = 0;
            if (null == n ? void 0 : n.terrain) {
              const c = new e.a0(t.z, i, t.z, t.x, t.y),
                h = n.terrain.getMinMaxElevation(c);
              (s =
                null !== (o = h.minElevation) && void 0 !== o
                  ? o
                  : Math.min(0, r)),
                (l =
                  null !== (a = h.maxElevation) && void 0 !== a
                    ? a
                    : Math.max(0, r));
            }
            if (((s /= e.bx), (l /= e.bx), (s += 1), (l += 1), t.z <= 0))
              return yi.fromAabb([-l, -l, -l], [l, l, l]);
            if (1 === t.z)
              return yi.fromAabb(
                [0 === t.x ? -l : 0, 0 === t.y ? 0 : -l, -l],
                [0 === t.x ? 0 : l, 0 === t.y ? l : 0, l]
              );
            {
              const i = [
                  li(0, 0, t.x, t.y, t.z),
                  li(e.a3, 0, t.x, t.y, t.z),
                  li(e.a3, e.a3, t.x, t.y, t.z),
                  li(0, e.a3, t.x, t.y, t.z),
                ],
                r = [];
              for (const t of i) r.push(e.aU([], t, l));
              if (l !== s) for (const t of i) r.push(e.aU([], t, s));
              0 === t.y && r.push([0, 1, 0]),
                t.y === (1 << t.z) - 1 && r.push([0, -1, 0]);
              const n = [1, 1, 1],
                o = [-1, -1, -1];
              for (const t of r)
                for (let e = 0; e < 3; e++)
                  (n[e] = Math.min(n[e], t[e])), (o[e] = Math.max(o[e], t[e]));
              const a = li(e.a3 / 2, e.a3 / 2, t.x, t.y, t.z),
                c = e.aZ([], [0, 1, 0], a);
              e.aY(c, c);
              const h = e.aZ([], a, c);
              e.aY(h, h);
              const u = e.aZ([], i[2], i[1]);
              e.aY(u, u);
              const d = e.aZ([], i[0], i[3]);
              e.aY(d, d),
                r.push(e.aU([], a, l)),
                t.y >= (1 << t.z) / 2 &&
                  r.push(e.aU([], li(e.a3 / 2, 0, t.x, t.y, t.z), l)),
                t.y < (1 << t.z) / 2 &&
                  r.push(e.aU([], li(e.a3 / 2, e.a3, t.x, t.y, t.z), l));
              const p = wi(a, r),
                f = wi(h, r),
                m = [-a[0], -a[1], -a[2], p.max],
                _ = [a[0], a[1], a[2], -p.min],
                g = [-h[0], -h[1], -h[2], f.max],
                y = [h[0], h[1], h[2], -f.min],
                x = [...u, 0],
                v = [...d, 0],
                b = [];
              return (
                0 === t.y
                  ? b.push(e.bw(v, x, m), e.bw(v, x, _))
                  : b.push(
                      e.bw(g, x, m),
                      e.bw(g, x, _),
                      e.bw(g, v, m),
                      e.bw(g, v, _)
                    ),
                t.y === (1 << t.z) - 1
                  ? b.push(e.bw(v, x, m), e.bw(v, x, _))
                  : b.push(
                      e.bw(y, x, m),
                      e.bw(y, x, _),
                      e.bw(y, v, m),
                      e.bw(y, v, _)
                    ),
                new yi(b, [m, _, g, y, x, v], n, o)
              );
            }
          }
        }
        function wi(t, i) {
          let r = 1 / 0,
            n = -1 / 0;
          for (const o of i) {
            const i = e.a_(t, o);
            (r = Math.min(r, i)), (n = Math.max(n, i));
          }
          return { min: r, max: n };
        }
        class Ti {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, e, i) {
            return this._helper.interpolatePadding(t, e, i);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, e) {
            this._helper.resize(t, e);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrain(t) {
            this._helper.setConstrain(t);
          }
          overrideNearFarZ(t, e) {
            this._helper.overrideNearFarZ(t, e);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              t
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t) {}
          constructor(t) {
            (this._cachedClippingPlane = e.by()),
              (this._projectionMatrix = e.bc()),
              (this._globeViewProjMatrix32f = e.bb()),
              (this._globeViewProjMatrixNoCorrection = e.bc()),
              (this._globeViewProjMatrixNoCorrectionInverted = e.bc()),
              (this._globeProjMatrixInverted = e.bc()),
              (this._cameraPosition = e.bs()),
              (this._globeLatitudeErrorCorrectionRadians = 0),
              (this.defaultConstrain = (t, i) => {
                const r = e.ai(t.lat, -e.aj, e.aj),
                  n = e.ai(+i, this.minZoom + pi(0, r), this.maxZoom);
                return { center: new e.U(t.lng, r), zoom: n };
              }),
              (this._helper = new Be(
                {
                  calcMatrices: () => {
                    this._calcMatrices();
                  },
                  constrain: (t, e) => this.defaultConstrain(t, e),
                },
                t
              )),
              (this._coveringTilesDetailsProvider = new bi());
          }
          clone() {
            const t = new Ti();
            return t.apply(this), t;
          }
          apply(t, e) {
            (this._globeLatitudeErrorCorrectionRadians = e || 0),
              this._helper.apply(t);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const t = e.bs();
            return (
              (t[0] = this._cameraPosition[0]),
              (t[1] = this._cameraPosition[1]),
              (t[2] = this._cameraPosition[2]),
              t
            );
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(t) {
            const { overscaledTileID: e, applyGlobeMatrix: i } = t,
              r = this._helper.getMercatorTileCoordinates(e);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: r,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: i ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f,
            };
          }
          _computeClippingPlane(t) {
            const i = this.pitchInRadians,
              r = this.cameraToCenterDistance / t,
              n = Math.sin(i) * r,
              o = Math.cos(i) * r + 1,
              a = (1 / Math.sqrt(n * n + o * o)) * 1;
            let s = -n,
              l = o;
            const c = Math.sqrt(s * s + l * l);
            (s /= c), (l /= c);
            const h = [0, s, l];
            e.bz(h, h, [0, 0, 0], -this.bearingInRadians),
              e.bA(h, h, [0, 0, 0], (-1 * this.center.lat * Math.PI) / 180),
              e.bB(h, h, [0, 0, 0], (this.center.lng * Math.PI) / 180);
            const u = 1 / e.b0(h);
            return e.aU(h, h, u), [...h, -a * u];
          }
          isLocationOccluded(t) {
            return !this.isSurfacePointVisible(ci(t));
          }
          transformLightDirection(t) {
            const i = (this._helper._center.lng * Math.PI) / 180,
              r = (this._helper._center.lat * Math.PI) / 180,
              n = Math.cos(r),
              o = [Math.sin(i) * n, Math.sin(r), Math.cos(i) * n],
              a = [o[2], 0, -o[0]],
              s = [0, 0, 0];
            e.aZ(s, a, o), e.aY(a, a), e.aY(s, s);
            const l = [0, 0, 0];
            return (
              e.aY(l, [
                a[0] * t[0] + s[0] * t[1] + o[0] * t[2],
                a[1] * t[0] + s[1] * t[1] + o[1] * t[2],
                a[2] * t[0] + s[2] * t[1] + o[2] * t[2],
              ]),
              l
            );
          }
          getPixelScale() {
            return 1 / Math.cos((this._helper._center.lat * Math.PI) / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos((this._helper._center.lat * Math.PI) / 180);
          }
          getPitchedTextCorrection(t, i, r) {
            const n = (function (t, i, r) {
                const n = 1 / (1 << r.z);
                return new e.a5(
                  (t / e.a3) * n + r.x * n,
                  (i / e.a3) * n + r.y * n
                );
              })(t, i, r.canonical),
              o =
                ((a = n.y),
                [
                  e.br(n.x * Math.PI * 2 + Math.PI, 2 * Math.PI),
                  2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) -
                    0.5 * Math.PI,
                ]);
            var a;
            return this.getCircleRadiusCorrection() / Math.cos(o[1]);
          }
          projectTileCoordinates(t, i, r, n) {
            const o = r.canonical,
              a = li(t, i, o.x, o.y, o.z),
              s = 1 + (n ? n(t, i) : 0) / e.bx,
              l = [a[0] * s, a[1] * s, a[2] * s, 1];
            e.aA(l, l, this._globeViewProjMatrixNoCorrection);
            const c = this._cachedClippingPlane,
              h = c[0] * a[0] + c[1] * a[1] + c[2] * a[2] + c[3] < 0;
            return {
              point: new e.P(l[0] / l[3], l[1] / l[3]),
              signedDistanceFromCamera: l[3],
              isOccluded: h,
            };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const t = hi(this.worldSize, this.center.lat),
              i = e.bd(),
              r = e.bd();
            this._helper.autoCalculateNearFarZ &&
              ((this._helper._nearZ = 0.5),
              (this._helper._farZ = this.cameraToCenterDistance + 2 * t)),
              e.b7(
                i,
                this.fovInRadians,
                this.width / this.height,
                this._helper._nearZ,
                this._helper._farZ
              );
            const n = this.centerOffset;
            (i[8] = (2 * -n.x) / this._helper._width),
              (i[9] = (2 * n.y) / this._helper._height),
              (this._projectionMatrix = e.b8(i)),
              (this._globeProjMatrixInverted = e.bd()),
              e.au(this._globeProjMatrixInverted, i),
              e.N(i, i, [0, 0, -this.cameraToCenterDistance]),
              e.b9(i, i, this.rollInRadians),
              e.ba(i, i, -this.pitchInRadians),
              e.b9(i, i, this.bearingInRadians),
              e.N(i, i, [0, 0, -t]);
            const o = e.bs();
            (o[0] = t),
              (o[1] = t),
              (o[2] = t),
              e.ba(r, i, (this.center.lat * Math.PI) / 180),
              e.bC(r, r, (-this.center.lng * Math.PI) / 180),
              e.O(r, r, o),
              (this._globeViewProjMatrixNoCorrection = r),
              e.ba(
                i,
                i,
                (this.center.lat * Math.PI) / 180 -
                  this._globeLatitudeErrorCorrectionRadians
              ),
              e.bC(i, i, (-this.center.lng * Math.PI) / 180),
              e.O(i, i, o),
              (this._globeViewProjMatrix32f = new Float32Array(i)),
              (this._globeViewProjMatrixNoCorrectionInverted = e.bd()),
              e.au(this._globeViewProjMatrixNoCorrectionInverted, r);
            const a = e.bs();
            (this._cameraPosition = e.bs()),
              (this._cameraPosition[2] = this.cameraToCenterDistance / t),
              e.bz(
                this._cameraPosition,
                this._cameraPosition,
                a,
                -this.rollInRadians
              ),
              e.bA(
                this._cameraPosition,
                this._cameraPosition,
                a,
                this.pitchInRadians
              ),
              e.bz(
                this._cameraPosition,
                this._cameraPosition,
                a,
                -this.bearingInRadians
              ),
              e.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
              e.bA(
                this._cameraPosition,
                this._cameraPosition,
                a,
                (-this.center.lat * Math.PI) / 180
              ),
              e.bB(
                this._cameraPosition,
                this._cameraPosition,
                a,
                (this.center.lng * Math.PI) / 180
              ),
              (this._cachedClippingPlane = this._computeClippingPlane(t));
            const s = e.b8(this._globeViewProjMatrixNoCorrectionInverted);
            e.O(s, s, [1, 1, -1]),
              (this._cachedFrustum = Ne.fromInvProjectionMatrix(
                s,
                1,
                0,
                this._cachedClippingPlane,
                !0
              ));
          }
          calculateFogMatrix(t) {
            e.w('calculateFogMatrix is not supported on globe projection.');
            const i = e.bd();
            return e.am(i), i;
          }
          getVisibleUnwrappedCoordinates(t) {
            return [new e.b5(0, t)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            t &&
              e.w(
                'terrain is not fully supported on vertical perspective projection.'
              ),
              this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const r = ci(t);
            e.aU(r, r, 1 + i / e.bx);
            const n = e.by();
            return (
              e.aA(
                n,
                [r[0], r[1], r[2], 1],
                this._globeViewProjMatrixNoCorrection
              ),
              n[2] / n[3]
            );
          }
          populateCache(t) {}
          getBounds() {
            const t = 0.5 * this.width,
              i = 0.5 * this.height,
              r = [
                new e.P(0, 0),
                new e.P(t, 0),
                new e.P(this.width, 0),
                new e.P(this.width, i),
                new e.P(this.width, this.height),
                new e.P(t, this.height),
                new e.P(0, this.height),
                new e.P(0, i),
              ],
              n = [];
            for (const e of r) n.push(this.unprojectScreenPoint(e));
            let o = 0,
              a = 0,
              s = 0,
              l = 0;
            const c = this.center;
            for (const u of n) {
              const t = e.bD(c.lng, u.lng),
                i = e.bD(c.lat, u.lat);
              t < a && (a = t),
                t > o && (o = t),
                i < l && (l = i),
                i > s && (s = i);
            }
            const h = [c.lng + a, c.lat + l, c.lng + o, c.lat + s];
            return (
              this.isSurfacePointOnScreen([0, 1, 0]) &&
                ((h[3] = 90), (h[0] = -180), (h[2] = 180)),
              this.isSurfacePointOnScreen([0, -1, 0]) &&
                ((h[1] = -90), (h[0] = -180), (h[2] = 180)),
              new q(h)
            );
          }
          calculateCenterFromCameraLngLatAlt(t, e, i, r) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
          }
          setLocationAtPoint(t, i) {
            const r = ci(this.unprojectScreenPoint(i)),
              n = ci(t),
              o = e.bs();
            e.bE(o);
            const a = e.bs();
            e.bB(a, r, o, (-this.center.lng * Math.PI) / 180),
              e.bA(a, a, o, (this.center.lat * Math.PI) / 180);
            const s = n[0] * n[0] + n[2] * n[2],
              l = a[0] * a[0];
            if (s < l) return;
            const c = Math.sqrt(s - l),
              h = -c,
              u = e.bF(n[0], n[2], a[0], c),
              d = e.bF(n[0], n[2], a[0], h),
              p = e.bs();
            e.bB(p, n, o, -u);
            const f = e.bF(p[1], p[2], a[1], a[2]),
              m = e.bs();
            e.bB(m, n, o, -d);
            const _ = e.bF(m[1], m[2], a[1], a[2]),
              g = 0.5 * Math.PI,
              y = f >= -g && f <= g,
              x = _ >= -g && _ <= g;
            let v, b;
            if (y && x) {
              const t = (this.center.lng * Math.PI) / 180,
                i = (this.center.lat * Math.PI) / 180;
              e.bG(u, t) + e.bG(f, i) < e.bG(d, t) + e.bG(_, i)
                ? ((v = u), (b = f))
                : ((v = d), (b = _));
            } else if (y) (v = u), (b = f);
            else {
              if (!x) return;
              (v = d), (b = _);
            }
            const w = (v / Math.PI) * 180,
              T = (b / Math.PI) * 180,
              P = this.center.lat;
            this.setCenter(new e.U(w, e.ai(T, -90, 90))),
              this.setZoom(this.zoom + pi(P, this.center.lat));
          }
          locationToScreenPoint(t, i) {
            const r = ci(t);
            if (i) {
              const n = i.getElevationForLngLatZoom(t, this._helper._tileZoom);
              e.aU(r, r, 1 + n / e.bx);
            }
            return this._projectSurfacePointToScreen(r);
          }
          _projectSurfacePointToScreen(t) {
            const i = e.by();
            return (
              e.aA(i, [...t, 1], this._globeViewProjMatrixNoCorrection),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              new e.P(
                (0.5 * i[0] + 0.5) * this.width,
                (0.5 * -i[1] + 0.5) * this.height
              )
            );
          }
          screenPointToMercatorCoordinate(t, i) {
            if (i) {
              const e = i.pointCoordinate(t);
              if (e) return e;
            }
            return e.a5.fromLngLat(this.unprojectScreenPoint(t));
          }
          screenPointToLocation(t, e) {
            var i;
            return null === (i = this.screenPointToMercatorCoordinate(t, e)) ||
              void 0 === i
              ? void 0
              : i.toLngLat();
          }
          isPointOnMapSurface(t, e) {
            const i = this._cameraPosition,
              r = this.getRayDirectionFromPixel(t);
            return !!this.rayPlanetIntersection(i, r);
          }
          getRayDirectionFromPixel(t) {
            const i = e.by();
            (i[0] = (t.x / this.width) * 2 - 1),
              (i[1] = -1 * ((t.y / this.height) * 2 - 1)),
              (i[2] = 1),
              (i[3] = 1),
              e.aA(i, i, this._globeViewProjMatrixNoCorrectionInverted),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              (i[2] /= i[3]);
            const r = e.bs();
            (r[0] = i[0] - this._cameraPosition[0]),
              (r[1] = i[1] - this._cameraPosition[1]),
              (r[2] = i[2] - this._cameraPosition[2]);
            const n = e.bs();
            return e.aY(n, r), n;
          }
          isSurfacePointVisible(t) {
            const e = this._cachedClippingPlane;
            return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] >= 0;
          }
          isSurfacePointOnScreen(t) {
            if (!this.isSurfacePointVisible(t)) return !1;
            const i = e.by();
            return (
              e.aA(i, [...t, 1], this._globeViewProjMatrixNoCorrection),
              (i[0] /= i[3]),
              (i[1] /= i[3]),
              (i[2] /= i[3]),
              i[0] > -1 &&
                i[0] < 1 &&
                i[1] > -1 &&
                i[1] < 1 &&
                i[2] > -1 &&
                i[2] < 1
            );
          }
          rayPlanetIntersection(t, i) {
            const r = e.a_(t, i),
              n = e.bs(),
              o = e.bs();
            e.aU(o, i, r), e.aX(n, t, o);
            const a = 1 - e.a_(n, n);
            if (a < 0) return null;
            const s = e.a_(t, t) - 1,
              l = -r + (r < 0 ? 1 : -1) * Math.sqrt(a),
              c = s / l,
              h = l;
            return { tMin: Math.min(c, h), tMax: Math.max(c, h) };
          }
          unprojectScreenPoint(t) {
            const i = this._cameraPosition,
              r = this.getRayDirectionFromPixel(t),
              n = this.rayPlanetIntersection(i, r);
            if (n) {
              const t = e.bs();
              e.aV(t, i, [r[0] * n.tMin, r[1] * n.tMin, r[2] * n.tMin]);
              const o = e.bs();
              return e.aY(o, t), ui(o);
            }
            const o = this._cachedClippingPlane,
              a = o[0] * r[0] + o[1] * r[1] + o[2] * r[2],
              s = -e.b4(o, i) / a,
              l = e.bs();
            if (s > 0) e.aV(l, i, [r[0] * s, r[1] * s, r[2] * s]);
            else {
              const t = e.bs();
              e.aV(t, i, [2 * r[0], 2 * r[1], 2 * r[2]]);
              const n = e.b4(this._cachedClippingPlane, t);
              e.aX(l, t, [
                this._cachedClippingPlane[0] * n,
                this._cachedClippingPlane[1] * n,
                this._cachedClippingPlane[2] * n,
              ]);
            }
            const c = (function (t) {
              const i = e.bs();
              return (
                (i[0] = t[0] * -t[3]),
                (i[1] = t[1] * -t[3]),
                (i[2] = t[2] * -t[3]),
                { center: i, radius: Math.sqrt(1 - t[3] * t[3]) }
              );
            })(o);
            return ui(
              (function (t, i, r) {
                const n = e.bs();
                e.aX(n, r, t);
                const o = e.bs();
                return e.bt(o, t, n, i / e.b2(n)), o;
              })(c.center, c.radius, l)
            );
          }
          getMatrixForModel(t, i) {
            const r = e.U.convert(t),
              n = 1 / e.bx,
              o = e.bc();
            return (
              e.bC(o, o, (r.lng / 180) * Math.PI),
              e.ba(o, o, (-r.lat / 180) * Math.PI),
              e.N(o, o, [0, 0, 1 + i / e.bx]),
              e.ba(o, o, 0.5 * Math.PI),
              e.O(o, o, [n, n, n]),
              o
            );
          }
          getProjectionDataForCustomLayer(t = !0) {
            const i = this.getProjectionData({
              overscaledTileID: new e.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: t,
            });
            return (i.tileMercatorCoords = [0, 0, 1, 1]), i;
          }
          getFastPathSimpleProjectionMatrix(t) {}
        }
        class Pi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, e, i) {
            return this._helper.interpolatePadding(t, e, i);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, e, i = !0) {
            this._helper.resize(t, e, i);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrain(t) {
            this._helper.setConstrain(t);
          }
          overrideNearFarZ(t, e) {
            this._helper.overrideNearFarZ(t, e);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(
              this.getCameraPoint(),
              t
            );
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(t, e) {
            (this._globeness = t),
              (this._globeLatitudeErrorCorrectionRadians = e),
              this._calcMatrices(),
              this._verticalPerspectiveTransform
                .getCoveringTilesDetailsProvider()
                .prepareNextFrame(),
              this._mercatorTransform
                .getCoveringTilesDetailsProvider()
                .prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering
              ? this._verticalPerspectiveTransform
              : this._mercatorTransform;
          }
          constructor(t) {
            (this._globeLatitudeErrorCorrectionRadians = 0),
              (this._globeness = 1),
              (this.defaultConstrain = (t, e) =>
                this.currentTransform.defaultConstrain(t, e)),
              (this._helper = new Be(
                {
                  calcMatrices: () => {
                    this._calcMatrices();
                  },
                  constrain: (t, e) => this.defaultConstrain(t, e),
                },
                t
              )),
              (this._globeness = 1),
              (this._mercatorTransform = new Ve()),
              (this._verticalPerspectiveTransform = new Ti());
          }
          clone() {
            const t = new Pi();
            return (
              (t._globeness = this._globeness),
              (t._globeLatitudeErrorCorrectionRadians =
                this._globeLatitudeErrorCorrectionRadians),
              t.apply(this),
              t
            );
          }
          apply(t) {
            this._helper.apply(t),
              this._mercatorTransform.apply(this),
              this._verticalPerspectiveTransform.apply(
                this,
                this._globeLatitudeErrorCorrectionRadians
              );
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(t) {
            const e = this._mercatorTransform.getProjectionData(t),
              i = this._verticalPerspectiveTransform.getProjectionData(t);
            return {
              mainMatrix: this.isGlobeRendering ? i.mainMatrix : e.mainMatrix,
              clippingPlane: i.clippingPlane,
              tileMercatorCoords: i.tileMercatorCoords,
              projectionTransition: t.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: e.fallbackMatrix,
            };
          }
          isLocationOccluded(t) {
            return this.currentTransform.isLocationOccluded(t);
          }
          transformLightDirection(t) {
            return this.currentTransform.transformLightDirection(t);
          }
          getPixelScale() {
            return e.bn(
              this._mercatorTransform.getPixelScale(),
              this._verticalPerspectiveTransform.getPixelScale(),
              this._globeness
            );
          }
          getCircleRadiusCorrection() {
            return e.bn(
              this._mercatorTransform.getCircleRadiusCorrection(),
              this._verticalPerspectiveTransform.getCircleRadiusCorrection(),
              this._globeness
            );
          }
          getPitchedTextCorrection(t, i, r) {
            const n = this._mercatorTransform.getPitchedTextCorrection(t, i, r),
              o = this._verticalPerspectiveTransform.getPitchedTextCorrection(
                t,
                i,
                r
              );
            return e.bn(n, o, this._globeness);
          }
          projectTileCoordinates(t, e, i, r) {
            return this.currentTransform.projectTileCoordinates(t, e, i, r);
          }
          _calcMatrices() {
            this._helper._width &&
              this._helper._height &&
              (this._verticalPerspectiveTransform.apply(
                this,
                this._globeLatitudeErrorCorrectionRadians
              ),
              (this._helper._nearZ = this._verticalPerspectiveTransform.nearZ),
              (this._helper._farZ = this._verticalPerspectiveTransform.farZ),
              this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
              (this._helper._nearZ = this._mercatorTransform.nearZ),
              (this._helper._farZ = this._mercatorTransform.farZ));
          }
          calculateFogMatrix(t) {
            return this.currentTransform.calculateFogMatrix(t);
          }
          getVisibleUnwrappedCoordinates(t) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(t);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(t) {
            this._mercatorTransform.recalculateZoomAndCenter(t),
              this._verticalPerspectiveTransform.recalculateZoomAndCenter(t);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, e) {
            return this.currentTransform.lngLatToCameraDepth(t, e);
          }
          populateCache(t) {
            this._mercatorTransform.populateCache(t),
              this._verticalPerspectiveTransform.populateCache(t);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(t, e, i, r) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, e, i, r);
          }
          setLocationAtPoint(t, e) {
            if (!this.isGlobeRendering)
              return (
                this._mercatorTransform.setLocationAtPoint(t, e),
                void this.apply(this._mercatorTransform)
              );
            this._verticalPerspectiveTransform.setLocationAtPoint(t, e),
              this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(t, e) {
            return this.currentTransform.locationToScreenPoint(t, e);
          }
          screenPointToMercatorCoordinate(t, e) {
            return this.currentTransform.screenPointToMercatorCoordinate(t, e);
          }
          screenPointToLocation(t, e) {
            return this.currentTransform.screenPointToLocation(t, e);
          }
          isPointOnMapSurface(t, e) {
            return this.currentTransform.isPointOnMapSurface(t, e);
          }
          getRayDirectionFromPixel(t) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(
              t
            );
          }
          getMatrixForModel(t, e) {
            return this.currentTransform.getMatrixForModel(t, e);
          }
          getProjectionDataForCustomLayer(t = !0) {
            const e =
              this._mercatorTransform.getProjectionDataForCustomLayer(t);
            if (!this.isGlobeRendering) return e;
            const i =
              this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(
                t
              );
            return (i.fallbackMatrix = e.mainMatrix), i;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(t);
          }
        }
        class Si {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(t, i) {
            const r = fi(t, i);
            return (
              Math.abs(r.lng - i.center.lng) > 180 &&
                (r.lng =
                  i.center.lng + 179.5 * Math.sign(r.lng - i.center.lng)),
              { easingCenter: r, easingOffset: new e.P(0, 0) }
            );
          }
          handleMapControlsRollPitchBearingZoom(t, i) {
            const r = t.around,
              n = i.screenPointToLocation(r);
            t.bearingDelta && i.setBearing(i.bearing + t.bearingDelta),
              t.pitchDelta && i.setPitch(i.pitch + t.pitchDelta),
              t.rollDelta && i.setRoll(i.roll + t.rollDelta);
            const o = i.zoom;
            t.zoomDelta && i.setZoom(i.zoom + t.zoomDelta);
            const a = i.zoom - o;
            if (0 === a) return;
            const s = e.bD(i.center.lng, n.lng),
              l = s / (Math.abs(s / 180) + 1),
              c = e.bD(i.center.lat, n.lat),
              h = i.getRayDirectionFromPixel(r),
              u = i.cameraPosition,
              d = -1 * e.a_(u, h),
              p = e.bs();
            e.aV(p, u, [h[0] * d, h[1] * d, h[2] * d]);
            const f = e.b0(p) - 1,
              m = Math.exp(0.5 * -Math.max(f - 0.3, 0)),
              _ = hi(i.worldSize, i.center.lat) / Math.min(i.width, i.height),
              g = e.bq(_, 0.9, 0.5, 1, 0.25),
              y = (1 - e.al(-a)) * Math.min(m, g),
              x = i.center.lat,
              v = i.zoom,
              b = new e.U(
                i.center.lng + l * y,
                e.ai(i.center.lat + c * y, -e.aj, e.aj)
              );
            i.setLocationAtPoint(n, r);
            const w = i.center,
              T = e.bq(Math.abs(s), 45, 85, 0, 1),
              P = e.bq(_, 0.75, 0.35, 0, 1),
              S = Math.pow(Math.max(T, P), 0.25),
              M = e.bD(w.lng, b.lng),
              I = e.bD(w.lat, b.lat);
            i.setCenter(new e.U(w.lng + M * S, w.lat + I * S).wrap()),
              i.setZoom(v + pi(x, i.center.lat));
          }
          handleMapControlsPan(t, e, i) {
            if (!t.panDelta) return;
            const r = e.center.lat,
              n = e.zoom;
            e.setCenter(fi(t.panDelta, e).wrap()),
              e.setZoom(n + pi(r, e.center.lat));
          }
          cameraForBoxAndBearing(t, i, r, n, o) {
            const a = Ze(t, i, r, n, o),
              s = (i.left / o.width) * 2 - 1,
              l = ((o.width - i.right) / o.width) * 2 - 1,
              c = (i.top / o.height) * -2 + 1,
              h = ((o.height - i.bottom) / o.height) * -2 + 1,
              u = e.bD(r.getWest(), r.getEast()) < 0,
              d = u ? r.getEast() : r.getWest(),
              p = u ? r.getWest() : r.getEast(),
              f = Math.max(r.getNorth(), r.getSouth()),
              m = Math.min(r.getNorth(), r.getSouth()),
              _ = d + 0.5 * e.bD(d, p),
              g = f + 0.5 * e.bD(f, m),
              y = o.clone();
            y.setCenter(a.center),
              y.setBearing(a.bearing),
              y.setPitch(0),
              y.setRoll(0),
              y.setZoom(a.zoom);
            const x = y.modelViewProjectionMatrix,
              v = [
                ci(r.getNorthWest()),
                ci(r.getNorthEast()),
                ci(r.getSouthWest()),
                ci(r.getSouthEast()),
                ci(new e.U(p, g)),
                ci(new e.U(d, g)),
                ci(new e.U(_, f)),
                ci(new e.U(_, m)),
              ],
              b = ci(a.center);
            let w = Number.POSITIVE_INFINITY;
            for (const e of v)
              s < 0 &&
                (w = Si.getLesserNonNegativeNonNull(
                  w,
                  Si.solveVectorScale(e, b, x, 'x', s)
                )),
                l > 0 &&
                  (w = Si.getLesserNonNegativeNonNull(
                    w,
                    Si.solveVectorScale(e, b, x, 'x', l)
                  )),
                c > 0 &&
                  (w = Si.getLesserNonNegativeNonNull(
                    w,
                    Si.solveVectorScale(e, b, x, 'y', c)
                  )),
                h < 0 &&
                  (w = Si.getLesserNonNegativeNonNull(
                    w,
                    Si.solveVectorScale(e, b, x, 'y', h)
                  ));
            if (Number.isFinite(w) && 0 !== w)
              return (a.zoom = y.zoom + e.ao(w)), a;
            Ue();
          }
          handleJumpToCenterZoom(t, i) {
            const r = t.center.lat,
              n = t.constrain(
                i.center ? e.U.convert(i.center) : t.center,
                t.zoom
              ).center;
            t.setCenter(n.wrap());
            const o = void 0 !== i.zoom ? +i.zoom : t.zoom + pi(r, n.lat);
            t.zoom !== o && t.setZoom(o);
          }
          handleEaseTo(t, i) {
            const r = t.zoom,
              n = t.center,
              o = t.padding,
              a = { roll: t.roll, pitch: t.pitch, bearing: t.bearing },
              s = {
                roll: void 0 === i.roll ? t.roll : i.roll,
                pitch: void 0 === i.pitch ? t.pitch : i.pitch,
                bearing: void 0 === i.bearing ? t.bearing : i.bearing,
              },
              l = void 0 !== i.zoom,
              c = !t.isPaddingEqual(i.padding);
            let h = !1;
            const u = i.center ? e.U.convert(i.center) : n,
              d = t.constrain(u, r).center;
            Le(t, d);
            const p = t.clone();
            p.setCenter(d),
              p.setZoom(l ? +i.zoom : r + pi(n.lat, u.lat)),
              p.setBearing(i.bearing);
            const f = new e.P(
              e.ai(t.centerPoint.x + i.offsetAsPoint.x, 0, t.width),
              e.ai(t.centerPoint.y + i.offsetAsPoint.y, 0, t.height)
            );
            p.setLocationAtPoint(d, f);
            const m = (i.offset && i.offsetAsPoint.mag()) > 0 ? p.center : d,
              _ = l ? +i.zoom : r + pi(n.lat, m.lat),
              g = r + pi(n.lat, 0),
              y = _ + pi(m.lat, 0),
              x = e.bD(n.lng, m.lng),
              v = e.bD(n.lat, m.lat),
              b = e.al(y - g);
            return (
              (h = _ !== r),
              {
                easeFunc: (r) => {
                  if (
                    (e.bh(a, s) ||
                      Ge({
                        startEulerAngles: a,
                        endEulerAngles: s,
                        tr: t,
                        k: r,
                        useSlerp: a.roll != s.roll,
                      }),
                    c && t.interpolatePadding(o, i.padding, r),
                    i.around)
                  )
                    e.w(
                      'Easing around a point is not supported under globe projection.'
                    ),
                      t.setLocationAtPoint(i.around, i.aroundPoint);
                  else {
                    const e = y > g ? Math.min(2, b) : Math.max(0.5, b),
                      i = Math.pow(e, 1 - r),
                      o = _i(n, x, v, r * i);
                    t.setCenter(o.wrap());
                  }
                  if (h) {
                    const i = e.F.number(g, y, r) + pi(0, t.center.lat);
                    t.setZoom(i);
                  }
                },
                isZooming: h,
                elevationCenter: m,
              }
            );
          }
          handleFlyTo(t, i) {
            const r = void 0 !== i.zoom,
              n = t.center,
              o = t.zoom,
              a = t.padding,
              s = !t.isPaddingEqual(i.padding),
              l = t.constrain(
                e.U.convert(i.center || i.locationAtOffset),
                o
              ).center,
              c = r ? +i.zoom : t.zoom + pi(t.center.lat, l.lat),
              h = t.clone();
            h.setCenter(l), h.setZoom(c), h.setBearing(i.bearing);
            const u = new e.P(
              e.ai(t.centerPoint.x + i.offsetAsPoint.x, 0, t.width),
              e.ai(t.centerPoint.y + i.offsetAsPoint.y, 0, t.height)
            );
            h.setLocationAtPoint(l, u);
            const d = h.center;
            Le(t, d);
            const p = (function (t, i, r) {
                const n = ci(i),
                  o = ci(r),
                  a = e.a_(n, o),
                  s = Math.acos(a),
                  l = si(t);
                return (s / (2 * Math.PI)) * l;
              })(t, n, d),
              f = o + pi(n.lat, 0),
              m = c + pi(d.lat, 0),
              _ = e.al(m - f);
            let g;
            if ('number' == typeof i.minZoom) {
              const r = +i.minZoom + pi(d.lat, 0),
                n = Math.min(r, f, m) + pi(0, d.lat),
                o = t.constrain(d, n).zoom + pi(d.lat, 0);
              g = e.al(o - f);
            }
            const y = e.bD(n.lng, d.lng),
              x = e.bD(n.lat, d.lat);
            return {
              easeFunc: (r, o, l, h) => {
                const u = _i(n, y, x, l);
                s && t.interpolatePadding(a, i.padding, r);
                const p = 1 === r ? d : u;
                t.setCenter(p.wrap());
                const m = f + e.ao(o);
                t.setZoom(1 === r ? c : m + pi(0, p.lat));
              },
              scaleOfZoom: _,
              targetCenter: d,
              scaleOfMinZoom: g,
              pixelPathLength: p,
            };
          }
          static solveVectorScale(t, e, i, r, n) {
            const o =
                'x' === r
                  ? [i[0], i[4], i[8], i[12]]
                  : [i[1], i[5], i[9], i[13]],
              a = [i[3], i[7], i[11], i[15]],
              s = t[0] * o[0] + t[1] * o[1] + t[2] * o[2],
              l = t[0] * a[0] + t[1] * a[1] + t[2] * a[2],
              c = e[0] * o[0] + e[1] * o[1] + e[2] * o[2],
              h = e[0] * a[0] + e[1] * a[1] + e[2] * a[2];
            return c + n * l === s + n * h ||
              a[3] * (s - c) + o[3] * (h - l) + s * h == c * l
              ? null
              : (c + o[3] - n * h - n * a[3]) / (c - s - n * h + n * l);
          }
          static getLesserNonNegativeNonNull(t, e) {
            return null !== e && e >= 0 && e < t ? e : t;
          }
        }
        class Mi {
          constructor(t) {
            (this._globe = t),
              (this._mercatorCameraHelper = new $e()),
              (this._verticalPerspectiveCameraHelper = new Si());
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls
              ? this._verticalPerspectiveCameraHelper
              : this._mercatorCameraHelper;
          }
          handlePanInertia(t, e) {
            return this.currentHelper.handlePanInertia(t, e);
          }
          handleMapControlsRollPitchBearingZoom(t, e) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(
              t,
              e
            );
          }
          handleMapControlsPan(t, e, i) {
            this.currentHelper.handleMapControlsPan(t, e, i);
          }
          cameraForBoxAndBearing(t, e, i, r, n) {
            return this.currentHelper.cameraForBoxAndBearing(t, e, i, r, n);
          }
          handleJumpToCenterZoom(t, e) {
            this.currentHelper.handleJumpToCenterZoom(t, e);
          }
          handleEaseTo(t, e) {
            return this.currentHelper.handleEaseTo(t, e);
          }
          handleFlyTo(t, e) {
            return this.currentHelper.handleFlyTo(t, e);
          }
        }
        const Ii = (t, i) =>
            e.z(t, i && i.filter((t) => 'source.canvas' !== t.identifier)),
          Ci = e.bH();
        class Ai extends e.E {
          constructor(t, i = {}) {
            var r, n;
            super(),
              (this._rtlPluginLoaded = () => {
                for (const t in this.tileManagers) {
                  const e = this.tileManagers[t].getSource().type;
                  ('vector' !== e && 'geojson' !== e) ||
                    this.tileManagers[t].reload();
                }
              }),
              (this.map = t),
              (this.dispatcher = new j(O(), t._getMapId())),
              this.dispatcher.registerMessageHandler('GG', (t, e) =>
                this.getGlyphs(t, e)
              ),
              this.dispatcher.registerMessageHandler('GI', (t, e) =>
                this.getImages(t, e)
              ),
              this.dispatcher.registerMessageHandler('GDA', (t, e) =>
                this.getDashes(t, e)
              ),
              (this.imageManager = new b()),
              this.imageManager.setEventedParent(this);
            const o =
              (null === (r = t._container) || void 0 === r ? void 0 : r.lang) ||
              ('undefined' != typeof document &&
                (null === (n = document.documentElement) || void 0 === n
                  ? void 0
                  : n.lang)) ||
              void 0;
            (this.glyphManager = new M(
              t._requestManager,
              i.localIdeographFontFamily,
              o
            )),
              (this.lineAtlas = new k(256, 512)),
              (this.crossTileSymbolIndex = new Se()),
              (this._spritesImagesIds = {}),
              (this._layers = {}),
              (this._order = []),
              (this.tileManagers = {}),
              (this.zoomHistory = new e.bI()),
              (this._loaded = !1),
              (this._availableImages = []),
              (this._globalState = {}),
              this._resetUpdates(),
              this.dispatcher.broadcast('SR', e.bJ()),
              lt().on(ot, this._rtlPluginLoaded),
              this.on('data', (t) => {
                if ('source' !== t.dataType || 'metadata' !== t.sourceDataType)
                  return;
                const e = this.tileManagers[t.sourceId];
                if (!e) return;
                const i = e.getSource();
                if (i && i.vectorLayerIds)
                  for (const r in this._layers) {
                    const t = this._layers[r];
                    t.source === i.id && this._validateLayer(t);
                  }
              });
          }
          setGlobalStateProperty(t, i) {
            var r, n, o;
            this._checkLoaded();
            const a =
              null === i
                ? null !==
                    (o =
                      null ===
                        (n =
                          null === (r = this.stylesheet.state) || void 0 === r
                            ? void 0
                            : r[t]) || void 0 === n
                        ? void 0
                        : n.default) && void 0 !== o
                  ? o
                  : null
                : i;
            if (e.bK(a, this._globalState[t])) return this;
            (this._globalState[t] = a), this._applyGlobalStateChanges([t]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(t) {
            this._checkLoaded();
            const i = [];
            for (const r in t)
              !e.bK(this._globalState[r], t[r].default) &&
                (i.push(r), (this._globalState[r] = t[r].default));
            this._applyGlobalStateChanges(i);
          }
          _applyGlobalStateChanges(t) {
            if (0 === t.length) return;
            const e = new Set(),
              i = {};
            for (const r of t) {
              i[r] = this._globalState[r];
              for (const t in this._layers) {
                const i = this._layers[t],
                  n = i.getLayoutAffectingGlobalStateRefs(),
                  o = i.getPaintAffectingGlobalStateRefs();
                if ((n.has(r) && e.add(i.source), o.has(r)))
                  for (const { name: t, value: e } of o.get(r))
                    this._updatePaintProperty(i, t, e);
              }
            }
            this.dispatcher.broadcast('UGS', i);
            for (const r in this.tileManagers)
              e.has(r) && (this._reloadSource(r), (this._changed = !0));
          }
          loadURL(t, i = {}, r) {
            this.fire(new e.l('dataloading', { dataType: 'style' })),
              (i.validate = 'boolean' != typeof i.validate || i.validate);
            const n = this.map._requestManager.transformRequest(t, 'Style');
            this._loadStyleRequest = new AbortController();
            const o = this._loadStyleRequest;
            e.j(n, this._loadStyleRequest)
              .then((t) => {
                (this._loadStyleRequest = null), this._load(t.data, i, r);
              })
              .catch((t) => {
                (this._loadStyleRequest = null),
                  t && !o.signal.aborted && this.fire(new e.k(t));
              });
          }
          loadJSON(t, i = {}, r) {
            this.fire(new e.l('dataloading', { dataType: 'style' })),
              (this._frameRequest = new AbortController()),
              a
                .frameAsync(this._frameRequest)
                .then(() => {
                  (this._frameRequest = null),
                    (i.validate = !1 !== i.validate),
                    this._load(t, i, r);
                })
                .catch(() => {});
          }
          loadEmpty() {
            this.fire(new e.l('dataloading', { dataType: 'style' })),
              this._load(Ci, { validate: !1 });
          }
          _load(t, i, r) {
            var n, o;
            let a = i.transformStyle ? i.transformStyle(r, t) : t;
            if (!i.validate || !Ii(this, e.B(a))) {
              (a = Object.assign({}, a)),
                (this._loaded = !0),
                (this.stylesheet = a);
              for (const t in a.sources)
                this.addSource(t, a.sources[t], { validate: !1 });
              a.sprite
                ? this._loadSprite(a.sprite)
                : this.imageManager.setLoaded(!0),
                this.glyphManager.setURL(a.glyphs),
                this._createLayers(),
                (this.light = new A(this.stylesheet.light)),
                this._setProjectionInternal(
                  (null === (n = this.stylesheet.projection) || void 0 === n
                    ? void 0
                    : n.type) || 'mercator'
                ),
                (this.sky = new z(this.stylesheet.sky)),
                this.map.setTerrain(
                  null !== (o = this.stylesheet.terrain) && void 0 !== o
                    ? o
                    : null
                ),
                this.fire(new e.l('data', { dataType: 'style' })),
                this.fire(new e.l('style.load'));
            }
          }
          _createLayers() {
            var t, i, r;
            const n = e.bL(this.stylesheet.layers);
            this.setGlobalState(
              null !== (t = this.stylesheet.state) && void 0 !== t ? t : null
            ),
              this.dispatcher.broadcast('SL', n),
              (this._order = n.map((t) => t.id)),
              (this._layers = {}),
              (this._serializedLayers = null);
            for (const o of n) {
              const t = e.bM(o, this._globalState);
              if (
                (t.setEventedParent(this, { layer: { id: o.id } }),
                (this._layers[o.id] = t),
                e.bN(t) && this.tileManagers[t.source])
              ) {
                const e =
                  null !==
                    (r =
                      null === (i = o.paint) || void 0 === i
                        ? void 0
                        : i['raster-fade-duration']) && void 0 !== r
                    ? r
                    : t.paint.get('raster-fade-duration');
                this.tileManagers[t.source].setRasterFadeDuration(e);
              }
            }
          }
          _loadSprite(t, i = !1, r) {
            let n;
            this.imageManager.setLoaded(!1),
              (this._spriteRequest = new AbortController()),
              (function (t, i, r, n) {
                return e._(this, void 0, void 0, function* () {
                  const o = y(t),
                    s = r > 1 ? '@2x' : '',
                    l = {},
                    c = {};
                  for (const { id: t, url: r } of o) {
                    const o = i.transformRequest(
                      x(r, s, '.json'),
                      'SpriteJSON'
                    );
                    l[t] = e.j(o, n);
                    const a = i.transformRequest(
                      x(r, s, '.png'),
                      'SpriteImage'
                    );
                    c[t] = _.getImage(a, n);
                  }
                  return (
                    yield Promise.all([
                      ...Object.values(l),
                      ...Object.values(c),
                    ]),
                    (function (t, i) {
                      return e._(this, void 0, void 0, function* () {
                        const e = {};
                        for (const r in t) {
                          e[r] = {};
                          const n = a.getImageCanvasContext((yield i[r]).data),
                            o = (yield t[r]).data;
                          for (const t in o) {
                            const {
                              width: i,
                              height: a,
                              x: s,
                              y: l,
                              sdf: c,
                              pixelRatio: h,
                              stretchX: u,
                              stretchY: d,
                              content: p,
                              textFitWidth: f,
                              textFitHeight: m,
                            } = o[t];
                            e[r][t] = {
                              data: null,
                              pixelRatio: h,
                              sdf: c,
                              stretchX: u,
                              stretchY: d,
                              content: p,
                              textFitWidth: f,
                              textFitHeight: m,
                              spriteData: {
                                width: i,
                                height: a,
                                x: s,
                                y: l,
                                context: n,
                              },
                            };
                          }
                        }
                        return e;
                      });
                    })(l, c)
                  );
                });
              })(
                t,
                this.map._requestManager,
                this.map.getPixelRatio(),
                this._spriteRequest
              )
                .then((t) => {
                  if (((this._spriteRequest = null), t))
                    for (const e in t) {
                      this._spritesImagesIds[e] = [];
                      const r = this._spritesImagesIds[e]
                        ? this._spritesImagesIds[e].filter((e) => !(e in t))
                        : [];
                      for (const t of r)
                        this.imageManager.removeImage(t),
                          (this._changedImages[t] = !0);
                      for (const n in t[e]) {
                        const r = 'default' === e ? n : `${e}:${n}`;
                        this._spritesImagesIds[e].push(r),
                          r in this.imageManager.images
                            ? this.imageManager.updateImage(r, t[e][n], !1)
                            : this.imageManager.addImage(r, t[e][n]),
                          i && (this._changedImages[r] = !0);
                      }
                    }
                })
                .catch((t) => {
                  (this._spriteRequest = null), (n = t), this.fire(new e.k(n));
                })
                .finally(() => {
                  this.imageManager.setLoaded(!0),
                    (this._availableImages = this.imageManager.listImages()),
                    i && (this._changed = !0),
                    this.dispatcher.broadcast('SI', this._availableImages),
                    this.fire(new e.l('data', { dataType: 'style' })),
                    r && r(n);
                });
          }
          _unloadSprite() {
            for (const t of Object.values(this._spritesImagesIds).flat())
              this.imageManager.removeImage(t), (this._changedImages[t] = !0);
            (this._spritesImagesIds = {}),
              (this._availableImages = this.imageManager.listImages()),
              (this._changed = !0),
              this.dispatcher.broadcast('SI', this._availableImages),
              this.fire(new e.l('data', { dataType: 'style' }));
          }
          _validateLayer(t) {
            const i = this.tileManagers[t.source];
            if (!i) return;
            const r = t.sourceLayer;
            if (!r) return;
            const n = i.getSource();
            ('geojson' === n.type ||
              (n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(r))) &&
              this.fire(
                new e.k(
                  new Error(
                    `Source layer "${r}" does not exist on source "${n.id}" as specified by style layer "${t.id}".`
                  )
                )
              );
          }
          loaded() {
            if (!this._loaded) return !1;
            if (Object.keys(this._updatedSources).length) return !1;
            for (const t in this.tileManagers)
              if (!this.tileManagers[t].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t, i = !1) {
            const r = this._serializedAllLayers();
            if (!t || 0 === t.length) return Object.values(i ? e.bO(r) : r);
            const n = [];
            for (const o of t)
              if (r[o]) {
                const t = i ? e.bO(r[o]) : r[o];
                n.push(t);
              }
            return n;
          }
          _serializedAllLayers() {
            let t = this._serializedLayers;
            if (t) return t;
            t = this._serializedLayers = {};
            const e = Object.keys(this._layers);
            for (const i of e) {
              const e = this._layers[i];
              'custom' !== e.type && (t[i] = e.serialize());
            }
            return t;
          }
          hasTransitions() {
            var t, e, i;
            if (
              null === (t = this.light) || void 0 === t
                ? void 0
                : t.hasTransition()
            )
              return !0;
            if (
              null === (e = this.sky) || void 0 === e
                ? void 0
                : e.hasTransition()
            )
              return !0;
            if (
              null === (i = this.projection) || void 0 === i
                ? void 0
                : i.hasTransition()
            )
              return !0;
            for (const r in this.tileManagers)
              if (this.tileManagers[r].hasTransition()) return !0;
            for (const r in this._layers)
              if (this._layers[r].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error('Style is not done loading.');
          }
          update(t) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const e = Object.keys(this._updatedLayers),
                i = Object.keys(this._removedLayers);
              (e.length || i.length) && this._updateWorkerLayers(e, i);
              for (const t in this._updatedSources) {
                const e = this._updatedSources[t];
                if ('reload' === e) this._reloadSource(t);
                else {
                  if ('clear' !== e) throw new Error(`Invalid action ${e}`);
                  this._clearSource(t);
                }
              }
              this._updateTilesForChangedImages(),
                this._updateTilesForChangedGlyphs();
              for (const r in this._updatedPaintProps)
                this._layers[r].updateTransitions(t);
              this.light.updateTransitions(t),
                this.sky.updateTransitions(t),
                this._resetUpdates();
            }
            const r = {};
            for (const e in this.tileManagers) {
              const t = this.tileManagers[e];
              (r[e] = t.used), (t.used = !1);
            }
            for (const e of this._order) {
              const i = this._layers[e];
              i.recalculate(t, this._availableImages),
                !i.isHidden(t.zoom) &&
                  i.source &&
                  (this.tileManagers[i.source].used = !0);
            }
            for (const n in r) {
              const t = this.tileManagers[n];
              !!r[n] != !!t.used &&
                t.fire(
                  new e.l('data', {
                    sourceDataType: 'visibility',
                    dataType: 'source',
                    sourceId: n,
                  })
                );
            }
            this.light.recalculate(t),
              this.sky.recalculate(t),
              this.projection.recalculate(t),
              (this.z = t.zoom),
              i && this.fire(new e.l('data', { dataType: 'style' }));
          }
          _updateTilesForChangedImages() {
            const t = Object.keys(this._changedImages);
            if (t.length) {
              for (const e in this.tileManagers)
                this.tileManagers[e].reloadTilesForDependencies(
                  ['icons', 'patterns'],
                  t
                );
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t in this.tileManagers)
                this.tileManagers[t].reloadTilesForDependencies(
                  ['glyphs'],
                  ['']
                );
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(t, e) {
            this.dispatcher.broadcast('UL', {
              layers: this._serializeByIds(t, !1),
              removedIds: e,
            });
          }
          _resetUpdates() {
            (this._changed = !1),
              (this._updatedLayers = {}),
              (this._removedLayers = {}),
              (this._updatedSources = {}),
              (this._updatedPaintProps = {}),
              (this._changedImages = {}),
              (this._glyphsDidChange = !1);
          }
          setState(t, i = {}) {
            var r;
            this._checkLoaded();
            const n = this.serialize();
            if (
              ((t = i.transformStyle ? i.transformStyle(n, t) : t),
              (null === (r = i.validate) || void 0 === r || r) &&
                Ii(this, e.B(t)))
            )
              return !1;
            (t = e.bO(t)).layers = e.bL(t.layers);
            const o = e.bP(n, t),
              a = this._getOperationsToPerform(o);
            if (a.unimplemented.length > 0)
              throw new Error(`Unimplemented: ${a.unimplemented.join(', ')}.`);
            if (0 === a.operations.length) return !1;
            for (const e of a.operations) e();
            return (this.stylesheet = t), (this._serializedLayers = null), !0;
          }
          _getOperationsToPerform(t) {
            const e = [],
              i = [];
            for (const r of t)
              switch (r.command) {
                case 'setCenter':
                case 'setZoom':
                case 'setBearing':
                case 'setPitch':
                case 'setRoll':
                  continue;
                case 'addLayer':
                  e.push(() => this.addLayer.apply(this, r.args));
                  break;
                case 'removeLayer':
                  e.push(() => this.removeLayer.apply(this, r.args));
                  break;
                case 'setPaintProperty':
                  e.push(() => this.setPaintProperty.apply(this, r.args));
                  break;
                case 'setLayoutProperty':
                  e.push(() => this.setLayoutProperty.apply(this, r.args));
                  break;
                case 'setFilter':
                  e.push(() => this.setFilter.apply(this, r.args));
                  break;
                case 'addSource':
                  e.push(() => this.addSource.apply(this, r.args));
                  break;
                case 'removeSource':
                  e.push(() => this.removeSource.apply(this, r.args));
                  break;
                case 'setLayerZoomRange':
                  e.push(() => this.setLayerZoomRange.apply(this, r.args));
                  break;
                case 'setLight':
                  e.push(() => this.setLight.apply(this, r.args));
                  break;
                case 'setGeoJSONSourceData':
                  e.push(() => this.setGeoJSONSourceData.apply(this, r.args));
                  break;
                case 'setGlyphs':
                  e.push(() => this.setGlyphs.apply(this, r.args));
                  break;
                case 'setSprite':
                  e.push(() => this.setSprite.apply(this, r.args));
                  break;
                case 'setTerrain':
                  e.push(() => this.map.setTerrain.apply(this, r.args));
                  break;
                case 'setSky':
                  e.push(() => this.setSky.apply(this, r.args));
                  break;
                case 'setProjection':
                  this.setProjection.apply(this, r.args);
                  break;
                case 'setGlobalState':
                  e.push(() => this.setGlobalState.apply(this, r.args));
                  break;
                case 'setTransition':
                  e.push(() => {});
                  break;
                default:
                  i.push(r.command);
              }
            return { operations: e, unimplemented: i };
          }
          addImage(t, i) {
            if (this.getImage(t))
              return this.fire(
                new e.k(new Error(`An image named "${t}" already exists.`))
              );
            this.imageManager.addImage(t, i), this._afterImageUpdated(t);
          }
          updateImage(t, e) {
            this.imageManager.updateImage(t, e);
          }
          getImage(t) {
            return this.imageManager.getImage(t);
          }
          removeImage(t) {
            if (!this.getImage(t))
              return this.fire(
                new e.k(new Error(`An image named "${t}" does not exist.`))
              );
            this.imageManager.removeImage(t), this._afterImageUpdated(t);
          }
          _afterImageUpdated(t) {
            (this._availableImages = this.imageManager.listImages()),
              (this._changedImages[t] = !0),
              (this._changed = !0),
              this.dispatcher.broadcast('SI', this._availableImages),
              this.fire(new e.l('data', { dataType: 'style' }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t, i, r = {}) {
            if ((this._checkLoaded(), void 0 !== this.tileManagers[t]))
              throw new Error(`Source "${t}" already exists.`);
            if (!i.type)
              throw new Error(
                `The type property must be defined, but only the following properties were given: ${Object.keys(
                  i
                ).join(', ')}.`
              );
            if (
              ['vector', 'raster', 'geojson', 'video', 'image'].indexOf(
                i.type
              ) >= 0 &&
              this._validate(e.B.source, `sources.${t}`, i, null, r)
            )
              return;
            this.map &&
              this.map._collectResourceTiming &&
              (i.collectResourceTiming = !0);
            const n = (this.tileManagers[t] = new It(t, i, this.dispatcher));
            (n.style = this),
              n.setEventedParent(this, () => ({
                isSourceLoaded: n.loaded(),
                source: n.serialize(),
                sourceId: t,
              })),
              n.onAdd(this.map),
              (this._changed = !0);
          }
          removeSource(t) {
            if ((this._checkLoaded(), void 0 === this.tileManagers[t]))
              throw new Error('There is no source with this ID');
            for (const r in this._layers)
              if (this._layers[r].source === t)
                return this.fire(
                  new e.k(
                    new Error(
                      `Source "${t}" cannot be removed while layer "${r}" is using it.`
                    )
                  )
                );
            const i = this.tileManagers[t];
            delete this.tileManagers[t],
              delete this._updatedSources[t],
              i.fire(
                new e.l('data', {
                  sourceDataType: 'metadata',
                  dataType: 'source',
                  sourceId: t,
                })
              ),
              i.setEventedParent(null),
              i.onRemove(this.map),
              (this._changed = !0);
          }
          setGeoJSONSourceData(t, e) {
            if ((this._checkLoaded(), void 0 === this.tileManagers[t]))
              throw new Error(`There is no source with this ID=${t}`);
            const i = this.tileManagers[t].getSource();
            if ('geojson' !== i.type)
              throw new Error(
                `geojsonSource.type is ${i.type}, which is !== 'geojson`
              );
            i.setData(e), (this._changed = !0);
          }
          getSource(t) {
            return this.tileManagers[t] && this.tileManagers[t].getSource();
          }
          addLayer(t, i, r = {}) {
            this._checkLoaded();
            const n = t.id;
            if (this.getLayer(n))
              return void this.fire(
                new e.k(new Error(`Layer "${n}" already exists on this map.`))
              );
            let o;
            if ('custom' === t.type) {
              if (Ii(this, e.bQ(t))) return;
              o = e.bM(t, this._globalState);
            } else {
              if (
                ('source' in t &&
                  'object' == typeof t.source &&
                  (this.addSource(n, t.source),
                  (t = e.bO(t)),
                  (t = e.e(t, { source: n }))),
                this._validate(
                  e.B.layer,
                  `layers.${n}`,
                  t,
                  { arrayIndex: -1 },
                  r
                ))
              )
                return;
              (o = e.bM(t, this._globalState)),
                this._validateLayer(o),
                o.setEventedParent(this, { layer: { id: n } });
            }
            const a = i ? this._order.indexOf(i) : this._order.length;
            if (i && -1 === a)
              this.fire(
                new e.k(
                  new Error(
                    `Cannot add layer "${n}" before non-existing layer "${i}".`
                  )
                )
              );
            else {
              if (
                (this._order.splice(a, 0, n),
                (this._layerOrderChanged = !0),
                (this._layers[n] = o),
                this._removedLayers[n] && o.source && 'custom' !== o.type)
              ) {
                const t = this._removedLayers[n];
                delete this._removedLayers[n],
                  t.type !== o.type
                    ? (this._updatedSources[o.source] = 'clear')
                    : ((this._updatedSources[o.source] = 'reload'),
                      this.tileManagers[o.source].pause());
              }
              this._updateLayer(o), o.onAdd && o.onAdd(this.map);
            }
          }
          moveLayer(t, i) {
            if ((this._checkLoaded(), (this._changed = !0), !this._layers[t]))
              return void this.fire(
                new e.k(
                  new Error(
                    `The layer '${t}' does not exist in the map's style and cannot be moved.`
                  )
                )
              );
            if (t === i) return;
            const r = this._order.indexOf(t);
            this._order.splice(r, 1);
            const n = i ? this._order.indexOf(i) : this._order.length;
            i && -1 === n
              ? this.fire(
                  new e.k(
                    new Error(
                      `Cannot move layer "${t}" before non-existing layer "${i}".`
                    )
                  )
                )
              : (this._order.splice(n, 0, t), (this._layerOrderChanged = !0));
          }
          removeLayer(t) {
            this._checkLoaded();
            const i = this._layers[t];
            if (!i)
              return void this.fire(
                new e.k(new Error(`Cannot remove non-existing layer "${t}".`))
              );
            i.setEventedParent(null);
            const r = this._order.indexOf(t);
            this._order.splice(r, 1),
              (this._layerOrderChanged = !0),
              (this._changed = !0),
              (this._removedLayers[t] = i),
              delete this._layers[t],
              this._serializedLayers && delete this._serializedLayers[t],
              delete this._updatedLayers[t],
              delete this._updatedPaintProps[t],
              i.onRemove && i.onRemove(this.map);
          }
          getLayer(t) {
            return this._layers[t];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t) {
            return t in this._layers;
          }
          setLayerZoomRange(t, i, r) {
            this._checkLoaded();
            const n = this.getLayer(t);
            n
              ? (n.minzoom === i && n.maxzoom === r) ||
                (null != i && (n.minzoom = i),
                null != r && (n.maxzoom = r),
                this._updateLayer(n))
              : this.fire(
                  new e.k(
                    new Error(
                      `Cannot set the zoom range of non-existing layer "${t}".`
                    )
                  )
                );
          }
          setFilter(t, i, r = {}) {
            this._checkLoaded();
            const n = this.getLayer(t);
            if (n) {
              if (!e.bK(n.filter, i))
                return null == i
                  ? (n.setFilter(void 0), void this._updateLayer(n))
                  : void (
                      this._validate(
                        e.B.filter,
                        `layers.${n.id}.filter`,
                        i,
                        null,
                        r
                      ) || (n.setFilter(e.bO(i)), this._updateLayer(n))
                    );
            } else this.fire(new e.k(new Error(`Cannot filter non-existing layer "${t}".`)));
          }
          getFilter(t) {
            return e.bO(this.getLayer(t).filter);
          }
          setLayoutProperty(t, i, r, n = {}) {
            this._checkLoaded();
            const o = this.getLayer(t);
            o
              ? e.bK(o.getLayoutProperty(i), r) ||
                (o.setLayoutProperty(i, r, n), this._updateLayer(o))
              : this.fire(
                  new e.k(new Error(`Cannot style non-existing layer "${t}".`))
                );
          }
          getLayoutProperty(t, i) {
            const r = this.getLayer(t);
            if (r) return r.getLayoutProperty(i);
            this.fire(
              new e.k(
                new Error(`Cannot get style of non-existing layer "${t}".`)
              )
            );
          }
          setPaintProperty(t, i, r, n = {}) {
            this._checkLoaded();
            const o = this.getLayer(t);
            o
              ? e.bK(o.getPaintProperty(i), r) ||
                this._updatePaintProperty(o, i, r, n)
              : this.fire(
                  new e.k(new Error(`Cannot style non-existing layer "${t}".`))
                );
          }
          _updatePaintProperty(t, i, r, n = {}) {
            t.setPaintProperty(i, r, n) && this._updateLayer(t),
              e.bN(t) &&
                'raster-fade-duration' === i &&
                this.tileManagers[t.source].setRasterFadeDuration(r),
              (this._changed = !0),
              (this._updatedPaintProps[t.id] = !0),
              (this._serializedLayers = null);
          }
          getPaintProperty(t, e) {
            return this.getLayer(t).getPaintProperty(e);
          }
          setFeatureState(t, i) {
            this._checkLoaded();
            const r = t.source,
              n = t.sourceLayer,
              o = this.tileManagers[r];
            if (void 0 === o)
              return void this.fire(
                new e.k(
                  new Error(
                    `The source '${r}' does not exist in the map's style.`
                  )
                )
              );
            const a = o.getSource().type;
            'geojson' === a && n
              ? this.fire(
                  new e.k(
                    new Error(
                      'GeoJSON sources cannot have a sourceLayer parameter.'
                    )
                  )
                )
              : 'vector' !== a || n
              ? (void 0 === t.id &&
                  this.fire(
                    new e.k(
                      new Error('The feature id parameter must be provided.')
                    )
                  ),
                o.setFeatureState(n, t.id, i))
              : this.fire(
                  new e.k(
                    new Error(
                      'The sourceLayer parameter must be provided for vector source types.'
                    )
                  )
                );
          }
          removeFeatureState(t, i) {
            this._checkLoaded();
            const r = t.source,
              n = this.tileManagers[r];
            if (void 0 === n)
              return void this.fire(
                new e.k(
                  new Error(
                    `The source '${r}' does not exist in the map's style.`
                  )
                )
              );
            const o = n.getSource().type,
              a = 'vector' === o ? t.sourceLayer : void 0;
            'vector' !== o || a
              ? i && 'string' != typeof t.id && 'number' != typeof t.id
                ? this.fire(
                    new e.k(
                      new Error(
                        'A feature id is required to remove its specific state property.'
                      )
                    )
                  )
                : n.removeFeatureState(a, t.id, i)
              : this.fire(
                  new e.k(
                    new Error(
                      'The sourceLayer parameter must be provided for vector source types.'
                    )
                  )
                );
          }
          getFeatureState(t) {
            this._checkLoaded();
            const i = t.source,
              r = t.sourceLayer,
              n = this.tileManagers[i];
            if (void 0 !== n)
              return 'vector' !== n.getSource().type || r
                ? (void 0 === t.id &&
                    this.fire(
                      new e.k(
                        new Error('The feature id parameter must be provided.')
                      )
                    ),
                  n.getFeatureState(r, t.id))
                : void this.fire(
                    new e.k(
                      new Error(
                        'The sourceLayer parameter must be provided for vector source types.'
                      )
                    )
                  );
            this.fire(
              new e.k(
                new Error(
                  `The source '${i}' does not exist in the map's style.`
                )
              )
            );
          }
          getTransition() {
            return e.e(
              { duration: 300, delay: 0 },
              this.stylesheet && this.stylesheet.transition
            );
          }
          serialize() {
            if (!this._loaded) return;
            const t = e.bR(this.tileManagers, (t) => t.serialize()),
              i = this._serializeByIds(this._order, !0),
              r = this.map.getTerrain() || void 0,
              n = this.stylesheet;
            return e.bS(
              {
                version: n.version,
                name: n.name,
                metadata: n.metadata,
                light: n.light,
                sky: n.sky,
                center: n.center,
                zoom: n.zoom,
                bearing: n.bearing,
                pitch: n.pitch,
                sprite: n.sprite,
                glyphs: n.glyphs,
                transition: n.transition,
                projection: n.projection,
                sources: t,
                layers: i,
                terrain: r,
              },
              (t) => void 0 !== t
            );
          }
          _updateLayer(t) {
            (this._updatedLayers[t.id] = !0),
              t.source &&
                !this._updatedSources[t.source] &&
                'raster' !== this.tileManagers[t.source].getSource().type &&
                ((this._updatedSources[t.source] = 'reload'),
                this.tileManagers[t.source].pause()),
              (this._serializedLayers = null),
              (this._changed = !0);
          }
          _flattenAndSortRenderedFeatures(t) {
            const e = (t) => 'fill-extrusion' === this._layers[t].type,
              i = {},
              r = [];
            for (let o = this._order.length - 1; o >= 0; o--) {
              const n = this._order[o];
              if (e(n)) {
                i[n] = o;
                for (const e of t) {
                  const t = e[n];
                  if (t) for (const e of t) r.push(e);
                }
              }
            }
            r.sort((t, e) => e.intersectionZ - t.intersectionZ);
            const n = [];
            for (let o = this._order.length - 1; o >= 0; o--) {
              const a = this._order[o];
              if (e(a))
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t].feature;
                  if (i[e.layer.id] < o) break;
                  n.push(e), r.pop();
                }
              else
                for (const e of t) {
                  const t = e[a];
                  if (t) for (const e of t) n.push(e.feature);
                }
            }
            return n;
          }
          queryRenderedFeatures(t, i, r) {
            i &&
              i.filter &&
              this._validate(
                e.B.filter,
                'queryRenderedFeatures.filter',
                i.filter,
                null,
                i
              );
            const n = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set))
                return (
                  this.fire(
                    new e.k(
                      new Error(
                        'parameters.layers must be an Array or a Set of strings'
                      )
                    )
                  ),
                  []
                );
              for (const t of i.layers) {
                const i = this._layers[t];
                if (!i)
                  return (
                    this.fire(
                      new e.k(
                        new Error(
                          `The layer '${t}' does not exist in the map's style and cannot be queried for features.`
                        )
                      )
                    ),
                    []
                  );
                n[i.source] = !0;
              }
            }
            const o = [];
            i.availableImages = this._availableImages;
            const a = this._serializedAllLayers(),
              s =
                i.layers instanceof Set
                  ? i.layers
                  : Array.isArray(i.layers)
                  ? new Set(i.layers)
                  : null,
              l = Object.assign(Object.assign({}, i), {
                layers: s,
                globalState: this._globalState,
              });
            for (const e in this.tileManagers)
              (i.layers && !n[e]) ||
                o.push(
                  U(
                    this.tileManagers[e],
                    this._layers,
                    a,
                    t,
                    l,
                    r,
                    this.map.terrain
                      ? (t, e, i) => this.map.terrain.getElevation(t, e, i)
                      : void 0
                  )
                );
            return (
              this.placement &&
                o.push(
                  (function (t, e, i, r, n, o, a) {
                    const s = {},
                      l = o.queryRenderedSymbols(r),
                      c = [];
                    for (const h of Object.keys(l).map(Number)) c.push(a[h]);
                    c.sort(G);
                    for (const h of c) {
                      const i = h.featureIndex.lookupSymbolFeatures(
                        l[h.bucketInstanceId],
                        e,
                        h.bucketIndex,
                        h.sourceLayerIndex,
                        { filterSpec: n.filter, globalState: n.globalState },
                        n.layers,
                        n.availableImages,
                        t
                      );
                      for (const t in i) {
                        const e = (s[t] = s[t] || []),
                          r = i[t];
                        r.sort((t, e) => {
                          const i = h.featureSortOrder;
                          if (i) {
                            const r = i.indexOf(t.featureIndex);
                            return i.indexOf(e.featureIndex) - r;
                          }
                          return e.featureIndex - t.featureIndex;
                        });
                        for (const t of r) e.push(t);
                      }
                    }
                    return (function (t, e, i) {
                      for (const r in t)
                        for (const n of t[r]) Z(n, i[e[r].source]);
                      return t;
                    })(s, t, i);
                  })(
                    this._layers,
                    a,
                    this.tileManagers,
                    t,
                    l,
                    this.placement.collisionIndex,
                    this.placement.retainedQueryData
                  )
                ),
              this._flattenAndSortRenderedFeatures(o)
            );
          }
          querySourceFeatures(t, i) {
            (null == i ? void 0 : i.filter) &&
              this._validate(
                e.B.filter,
                'querySourceFeatures.filter',
                i.filter,
                null,
                i
              );
            const r = this.tileManagers[t];
            return r
              ? (function (t, e) {
                  const i = t.getRenderableIds().map((e) => t.getTileByID(e)),
                    r = [],
                    n = {};
                  for (let o = 0; o < i.length; o++) {
                    const t = i[o],
                      a = t.tileID.canonical.key;
                    n[a] || ((n[a] = !0), t.querySourceFeatures(r, e));
                  }
                  return r;
                })(
                  r,
                  i
                    ? Object.assign(Object.assign({}, i), {
                        globalState: this._globalState,
                      })
                    : { globalState: this._globalState }
                )
              : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t, i = {}) {
            this._checkLoaded();
            const r = this.light.getLight();
            let n = !1;
            for (const a in t)
              if (!e.bK(t[a], r[a])) {
                n = !0;
                break;
              }
            if (!n) return;
            const o = {
              now: l(),
              transition: e.e(
                { duration: 300, delay: 0 },
                this.stylesheet.transition
              ),
            };
            this.light.setLight(t, i), this.light.updateTransitions(o);
          }
          getProjection() {
            var t;
            return null === (t = this.stylesheet) || void 0 === t
              ? void 0
              : t.projection;
          }
          setProjection(t) {
            if ((this._checkLoaded(), this.projection)) {
              if (this.projection.name === t.type) return;
              this.projection.destroy(), delete this.projection;
            }
            (this.stylesheet.projection = t),
              this._setProjectionInternal(t.type);
          }
          getSky() {
            var t;
            return null === (t = this.stylesheet) || void 0 === t
              ? void 0
              : t.sky;
          }
          setSky(t, i = {}) {
            this._checkLoaded();
            const r = this.getSky();
            let n = !1;
            if (!t && !r) return;
            if (t && !r) n = !0;
            else if (!t && r) n = !0;
            else
              for (const a in t)
                if (!e.bK(t[a], r[a])) {
                  n = !0;
                  break;
                }
            if (!n) return;
            const o = {
              now: l(),
              transition: e.e(
                { duration: 300, delay: 0 },
                this.stylesheet.transition
              ),
            };
            (this.stylesheet.sky = t),
              this.sky.setSky(t, i),
              this.sky.updateTransitions(o);
          }
          _setProjectionInternal(t) {
            const i = (function (t, i) {
              const r = { constrain: i };
              if (Array.isArray(t)) {
                const e = new ai({ type: t });
                return {
                  projection: e,
                  transform: new Pi(r),
                  cameraHelper: new Mi(e),
                };
              }
              switch (t) {
                case 'mercator':
                  return {
                    projection: new De(),
                    transform: new Ve(r),
                    cameraHelper: new $e(),
                  };
                case 'globe': {
                  const t = new ai({
                    type: [
                      'interpolate',
                      ['linear'],
                      ['zoom'],
                      11,
                      'vertical-perspective',
                      12,
                      'mercator',
                    ],
                  });
                  return {
                    projection: t,
                    transform: new Pi(r),
                    cameraHelper: new Mi(t),
                  };
                }
                case 'vertical-perspective':
                  return {
                    projection: new ni(),
                    transform: new Ti(r),
                    cameraHelper: new Si(),
                  };
                default:
                  return (
                    e.w(
                      `Unknown projection name: ${t}. Falling back to mercator projection.`
                    ),
                    {
                      projection: new De(),
                      transform: new Ve(r),
                      cameraHelper: new $e(),
                    }
                  );
              }
            })(t, this.map.transformConstrain);
            (this.projection = i.projection),
              this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const e in this.tileManagers) this.tileManagers[e].reload();
          }
          _validate(t, i, r, n, o = {}) {
            return (
              (!o || !1 !== o.validate) &&
              Ii(
                this,
                t.call(
                  e.B,
                  e.e(
                    {
                      key: i,
                      style: this.serialize(),
                      value: r,
                      styleSpec: e.t,
                    },
                    n
                  )
                )
              )
            );
          }
          _remove(t = !0) {
            this._frameRequest &&
              (this._frameRequest.abort(), (this._frameRequest = null)),
              this._loadStyleRequest &&
                (this._loadStyleRequest.abort(),
                (this._loadStyleRequest = null)),
              this._spriteRequest &&
                (this._spriteRequest.abort(), (this._spriteRequest = null)),
              lt().off(ot, this._rtlPluginLoaded);
            for (const e in this._layers)
              this._layers[e].setEventedParent(null);
            for (const e in this.tileManagers) {
              const t = this.tileManagers[e];
              t.setEventedParent(null), t.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null),
              this.setEventedParent(null),
              t && this.dispatcher.broadcast('RM', void 0),
              this.dispatcher.remove(t);
          }
          _clearSource(t) {
            this.tileManagers[t].clearTiles();
          }
          _reloadSource(t) {
            this.tileManagers[t].resume(), this.tileManagers[t].reload();
          }
          _updateSources(t) {
            for (const e in this.tileManagers)
              this.tileManagers[e].update(t, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t in this.tileManagers) this._reloadSource(t);
          }
          _updatePlacement(t, e, i, r, n = !1) {
            let o = !1,
              a = !1;
            const s = {};
            for (const l of this._order) {
              const e = this._layers[l];
              if ('symbol' !== e.type) continue;
              if (!s[e.source]) {
                const t = this.tileManagers[e.source];
                s[e.source] = t
                  .getRenderableIds(!0)
                  .map((e) => t.getTileByID(e))
                  .sort(
                    (t, e) =>
                      e.tileID.overscaledZ - t.tileID.overscaledZ ||
                      (t.tileID.isLessThan(e.tileID) ? -1 : 1)
                  );
              }
              const i = this.crossTileSymbolIndex.addLayer(
                e,
                s[e.source],
                t.center.lng
              );
              o = o || i;
            }
            if (
              (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
              ((n = n || this._layerOrderChanged || 0 === i) ||
                !this.pauseablePlacement ||
                (this.pauseablePlacement.isDone() &&
                  !this.placement.stillRecent(l(), t.zoom))) &&
                ((this.pauseablePlacement = new ve(
                  t,
                  this.map.terrain,
                  this._order,
                  n,
                  e,
                  i,
                  r,
                  this.placement
                )),
                (this._layerOrderChanged = !1)),
              this.pauseablePlacement.isDone()
                ? this.placement.setStale()
                : (this.pauseablePlacement.continuePlacement(
                    this._order,
                    this._layers,
                    s
                  ),
                  this.pauseablePlacement.isDone() &&
                    ((this.placement = this.pauseablePlacement.commit(l())),
                    (a = !0)),
                  o && this.pauseablePlacement.placement.setStale()),
              a || o)
            )
              for (const l of this._order) {
                const t = this._layers[l];
                'symbol' === t.type &&
                  this.placement.updateLayerOpacities(t, s[t.source]);
              }
            return (
              !this.pauseablePlacement.isDone() ||
              this.placement.hasTransitions(l())
            );
          }
          _releaseSymbolFadeTiles() {
            for (const t in this.tileManagers)
              this.tileManagers[t].releaseSymbolFadeTiles();
          }
          getImages(t, i) {
            return e._(this, void 0, void 0, function* () {
              const t = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const e = this.tileManagers[i.source];
              return e && e.setDependencies(i.tileID.key, i.type, i.icons), t;
            });
          }
          getGlyphs(t, i) {
            return e._(this, void 0, void 0, function* () {
              const t = yield this.glyphManager.getGlyphs(i.stacks),
                e = this.tileManagers[i.source];
              return e && e.setDependencies(i.tileID.key, i.type, ['']), t;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t, i = {}) {
            this._checkLoaded(),
              (t && this._validate(e.B.glyphs, 'glyphs', t, null, i)) ||
                ((this._glyphsDidChange = !0),
                (this.stylesheet.glyphs = t),
                (this.glyphManager.entries = {}),
                this.glyphManager.setURL(t));
          }
          getDashes(t, i) {
            return e._(this, void 0, void 0, function* () {
              const t = {};
              for (const [e, r] of Object.entries(i.dashes))
                t[e] = this.lineAtlas.getDash(r.dasharray, r.round);
              return t;
            });
          }
          addSprite(t, i, r = {}, n) {
            this._checkLoaded();
            const o = [{ id: t, url: i }],
              a = [...y(this.stylesheet.sprite), ...o];
            this._validate(e.B.sprite, 'sprite', a, null, r) ||
              ((this.stylesheet.sprite = a), this._loadSprite(o, !0, n));
          }
          removeSprite(t) {
            this._checkLoaded();
            const i = y(this.stylesheet.sprite);
            if (i.find((e) => e.id === t)) {
              if (this._spritesImagesIds[t])
                for (const e of this._spritesImagesIds[t])
                  this.imageManager.removeImage(e),
                    (this._changedImages[e] = !0);
              i.splice(
                i.findIndex((e) => e.id === t),
                1
              ),
                (this.stylesheet.sprite = i.length > 0 ? i : void 0),
                delete this._spritesImagesIds[t],
                (this._availableImages = this.imageManager.listImages()),
                (this._changed = !0),
                this.dispatcher.broadcast('SI', this._availableImages),
                this.fire(new e.l('data', { dataType: 'style' }));
            } else this.fire(new e.k(new Error(`Sprite "${t}" doesn't exists on this map.`)));
          }
          getSprite() {
            return y(this.stylesheet.sprite);
          }
          setSprite(t, i = {}, r) {
            this._checkLoaded(),
              (t && this._validate(e.B.sprite, 'sprite', t, null, i)) ||
                ((this.stylesheet.sprite = t),
                t
                  ? this._loadSprite(t, !0, r)
                  : (this._unloadSprite(), r && r(null)));
          }
        }
        var Ei = e.aN([
          { name: 'a_pos', type: 'Int16', components: 2 },
          { name: 'a_texture_pos', type: 'Int16', components: 2 },
        ]);
        class zi {
          constructor() {
            (this.boundProgram = null),
              (this.boundLayoutVertexBuffer = null),
              (this.boundPaintVertexBuffers = []),
              (this.boundIndexBuffer = null),
              (this.boundVertexOffset = null),
              (this.boundDynamicVertexBuffer = null),
              (this.vao = null);
          }
          bind(t, e, i, r, n, o, a, s, l) {
            this.context = t;
            let c = this.boundPaintVertexBuffers.length !== r.length;
            for (let h = 0; !c && h < r.length; h++)
              this.boundPaintVertexBuffers[h] !== r[h] && (c = !0);
            !this.vao ||
            this.boundProgram !== e ||
            this.boundLayoutVertexBuffer !== i ||
            c ||
            this.boundIndexBuffer !== n ||
            this.boundVertexOffset !== o ||
            this.boundDynamicVertexBuffer !== a ||
            this.boundDynamicVertexBuffer2 !== s ||
            this.boundDynamicVertexBuffer3 !== l
              ? this.freshBind(e, i, r, n, o, a, s, l)
              : (t.bindVertexArray.set(this.vao),
                a && a.bind(),
                n && n.dynamicDraw && n.bind(),
                s && s.bind(),
                l && l.bind());
          }
          freshBind(t, e, i, r, n, o, a, s) {
            const l = t.numAttributes,
              c = this.context,
              h = c.gl;
            this.vao && this.destroy(),
              (this.vao = c.createVertexArray()),
              c.bindVertexArray.set(this.vao),
              (this.boundProgram = t),
              (this.boundLayoutVertexBuffer = e),
              (this.boundPaintVertexBuffers = i),
              (this.boundIndexBuffer = r),
              (this.boundVertexOffset = n),
              (this.boundDynamicVertexBuffer = o),
              (this.boundDynamicVertexBuffer2 = a),
              (this.boundDynamicVertexBuffer3 = s),
              e.enableAttributes(h, t);
            for (const u of i) u.enableAttributes(h, t);
            o && o.enableAttributes(h, t),
              a && a.enableAttributes(h, t),
              s && s.enableAttributes(h, t),
              e.bind(),
              e.setVertexAttribPointers(h, t, n);
            for (const u of i) u.bind(), u.setVertexAttribPointers(h, t, n);
            o && (o.bind(), o.setVertexAttribPointers(h, t, n)),
              r && r.bind(),
              a && (a.bind(), a.setVertexAttribPointers(h, t, n)),
              s && (s.bind(), s.setVertexAttribPointers(h, t, n)),
              (c.currentNumAttributes = l);
          }
          destroy() {
            this.vao &&
              (this.context.deleteVertexArray(this.vao), (this.vao = null));
          }
        }
        const ki = (t, i, r, n, o) => ({
            u_texture: 0,
            u_ele_delta: t,
            u_fog_matrix: i,
            u_fog_color: r ? r.properties.get('fog-color') : e.bi.white,
            u_fog_ground_blend: r ? r.properties.get('fog-ground-blend') : 1,
            u_fog_ground_blend_opacity: o
              ? 0
              : r
              ? r.calculateFogBlendOpacity(n)
              : 0,
            u_horizon_color: r ? r.properties.get('horizon-color') : e.bi.white,
            u_horizon_fog_blend: r ? r.properties.get('horizon-fog-blend') : 1,
            u_is_globe_mode: o ? 1 : 0,
          }),
          Di = {
            mainMatrix: 'u_projection_matrix',
            tileMercatorCoords: 'u_projection_tile_mercator_coords',
            clippingPlane: 'u_projection_clipping_plane',
            projectionTransition: 'u_projection_transition',
            fallbackMatrix: 'u_projection_fallback_matrix',
          };
        function Ri(t) {
          const e = [];
          for (let i = 0; i < t.length; i++) {
            if (null === t[i]) continue;
            const r = t[i].split(' ');
            e.push(r.pop());
          }
          return e;
        }
        class Li {
          constructor(t, i, r, n, o, a, s, l, c = []) {
            const h = t.gl;
            this.program = h.createProgram();
            const u = Ri(i.staticAttributes),
              d = r ? r.getBinderAttributes() : [],
              p = u.concat(d),
              f = Ie.prelude.staticUniforms
                ? Ri(Ie.prelude.staticUniforms)
                : [],
              m = s.staticUniforms ? Ri(s.staticUniforms) : [],
              _ = i.staticUniforms ? Ri(i.staticUniforms) : [],
              g = r ? r.getBinderUniforms() : [],
              y = f.concat(m).concat(_).concat(g),
              x = [];
            for (const e of y) x.indexOf(e) < 0 && x.push(e);
            const v = r ? r.defines() : [];
            Qe(h) && v.unshift('#version 300 es'),
              o && v.push('#define OVERDRAW_INSPECTOR;'),
              a && v.push('#define TERRAIN3D;'),
              l && v.push(l),
              c && v.push(...c);
            let b = v
                .concat(
                  Ie.prelude.fragmentSource,
                  s.fragmentSource,
                  i.fragmentSource
                )
                .join('\n'),
              w = v
                .concat(Ie.prelude.vertexSource, s.vertexSource, i.vertexSource)
                .join('\n');
            Qe(h) ||
              ((b = (function (t) {
                return t
                  .replace(/\bin\s/g, 'varying ')
                  .replace('out highp vec4 fragColor;', '')
                  .replace(/fragColor/g, 'gl_FragColor')
                  .replace(/texture\(/g, 'texture2D(');
              })(b)),
              (w = (function (t) {
                return t
                  .replace(/\bin\s/g, 'attribute ')
                  .replace(/\bout\s/g, 'varying ')
                  .replace(/texture\(/g, 'texture2D(');
              })(w)));
            const T = h.createShader(h.FRAGMENT_SHADER);
            if (h.isContextLost()) return void (this.failedToCreate = !0);
            if (
              (h.shaderSource(T, b),
              h.compileShader(T),
              !h.getShaderParameter(T, h.COMPILE_STATUS))
            )
              throw new Error(
                `Could not compile fragment shader: ${h.getShaderInfoLog(T)}`
              );
            h.attachShader(this.program, T);
            const P = h.createShader(h.VERTEX_SHADER);
            if (h.isContextLost()) return void (this.failedToCreate = !0);
            if (
              (h.shaderSource(P, w),
              h.compileShader(P),
              !h.getShaderParameter(P, h.COMPILE_STATUS))
            )
              throw new Error(
                `Could not compile vertex shader: ${h.getShaderInfoLog(P)}`
              );
            h.attachShader(this.program, P), (this.attributes = {});
            const S = {};
            this.numAttributes = p.length;
            for (let e = 0; e < this.numAttributes; e++)
              p[e] &&
                (h.bindAttribLocation(this.program, e, p[e]),
                (this.attributes[p[e]] = e));
            if (
              (h.linkProgram(this.program),
              !h.getProgramParameter(this.program, h.LINK_STATUS))
            )
              throw new Error(
                `Program failed to link: ${h.getProgramInfoLog(this.program)}`
              );
            h.deleteShader(P), h.deleteShader(T);
            for (let e = 0; e < x.length; e++) {
              const t = x[e];
              if (t && !S[t]) {
                const e = h.getUniformLocation(this.program, t);
                e && (S[t] = e);
              }
            }
            (this.fixedUniforms = n(t, S)),
              (this.terrainUniforms = ((t, i) => ({
                u_depth: new e.bT(t, i.u_depth),
                u_terrain: new e.bT(t, i.u_terrain),
                u_terrain_dim: new e.bj(t, i.u_terrain_dim),
                u_terrain_matrix: new e.bV(t, i.u_terrain_matrix),
                u_terrain_unpack: new e.bW(t, i.u_terrain_unpack),
                u_terrain_exaggeration: new e.bj(t, i.u_terrain_exaggeration),
              }))(t, S)),
              (this.projectionUniforms = ((t, i) => ({
                u_projection_matrix: new e.bV(t, i.u_projection_matrix),
                u_projection_tile_mercator_coords: new e.bW(
                  t,
                  i.u_projection_tile_mercator_coords
                ),
                u_projection_clipping_plane: new e.bW(
                  t,
                  i.u_projection_clipping_plane
                ),
                u_projection_transition: new e.bj(t, i.u_projection_transition),
                u_projection_fallback_matrix: new e.bV(
                  t,
                  i.u_projection_fallback_matrix
                ),
              }))(t, S)),
              (this.binderUniforms = r ? r.getUniforms(t, S) : []);
          }
          draw(t, e, i, r, n, o, a, s, l, c, h, u, d, p, f, m, _, g, y) {
            const x = t.gl;
            if (this.failedToCreate) return;
            if (
              (t.program.set(this.program),
              t.setDepthMode(i),
              t.setStencilMode(r),
              t.setColorMode(n),
              t.setCullFace(o),
              s)
            ) {
              t.activeTexture.set(x.TEXTURE2),
                x.bindTexture(x.TEXTURE_2D, s.depthTexture),
                t.activeTexture.set(x.TEXTURE3),
                x.bindTexture(x.TEXTURE_2D, s.texture);
              for (const t in this.terrainUniforms)
                this.terrainUniforms[t].set(s[t]);
            }
            if (l) for (const b in l) this.projectionUniforms[Di[b]].set(l[b]);
            if (a)
              for (const b in this.fixedUniforms)
                this.fixedUniforms[b].set(a[b]);
            m && m.setUniforms(t, this.binderUniforms, p, { zoom: f });
            let v = 0;
            switch (e) {
              case x.LINES:
                v = 2;
                break;
              case x.TRIANGLES:
                v = 3;
                break;
              case x.LINE_STRIP:
                v = 1;
            }
            for (const b of d.get()) {
              const i = b.vaos || (b.vaos = {});
              (i[c] || (i[c] = new zi())).bind(
                t,
                this,
                h,
                m ? m.getPaintVertexBuffers() : [],
                u,
                b.vertexOffset,
                _,
                g,
                y
              ),
                x.drawElements(
                  e,
                  b.primitiveLength * v,
                  x.UNSIGNED_SHORT,
                  b.primitiveOffset * v * 2
                );
            }
          }
        }
        function Fi(t, i, r) {
          const n = 1 / e.aG(r, 1, i.transform.tileZoom),
            o = Math.pow(2, r.tileID.overscaledZ),
            a = (r.tileSize * Math.pow(2, i.transform.tileZoom)) / o,
            s = a * (r.tileID.canonical.x + r.tileID.wrap * o),
            l = a * r.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: r.imageAtlasTexture.size,
            u_scale: [n, t.fromScale, t.toScale],
            u_fade: t.t,
            u_pixel_coord_upper: [s >> 16, l >> 16],
            u_pixel_coord_lower: [65535 & s, 65535 & l],
          };
        }
        const Bi = (t, i, r, n) => {
            const o = t.style.light,
              a = o.properties.get('position'),
              s = [a.x, a.y, a.z],
              l = e.bZ();
            'viewport' === o.properties.get('anchor') &&
              e.b_(l, t.transform.bearingInRadians),
              e.b$(s, s, l);
            const c = t.transform.transformLightDirection(s),
              h = o.properties.get('color');
            return {
              u_lightpos: s,
              u_lightpos_globe: c,
              u_lightintensity: o.properties.get('intensity'),
              u_lightcolor: [h.r, h.g, h.b],
              u_vertical_gradient: +i,
              u_opacity: r,
              u_fill_translate: n,
            };
          },
          Oi = (t, i, r, n, o, a, s) =>
            e.e(Bi(t, i, r, n), Fi(a, t, s), {
              u_height_factor: -Math.pow(2, o.overscaledZ) / s.tileSize / 8,
            }),
          ji = (t, i, r, n) => e.e(Fi(i, t, r), { u_fill_translate: n }),
          Ni = (t, e) => ({ u_world: t, u_fill_translate: e }),
          Vi = (t, i, r, n, o) => e.e(ji(t, i, r, o), { u_world: n }),
          Ui = (t, i, r, n, o) => {
            const a = t.transform;
            let s,
              l,
              c = 0;
            if ('map' === r.paint.get('circle-pitch-alignment')) {
              const t = e.aG(i, 1, a.zoom);
              (s = !0),
                (l = [t, t]),
                (c =
                  (t / (e.a3 * Math.pow(2, i.tileID.overscaledZ))) *
                  2 *
                  Math.PI *
                  o);
            } else (s = !1), (l = a.pixelsToGLUnits);
            return {
              u_camera_to_center_distance: a.cameraToCenterDistance,
              u_scale_with_map: +('map' === r.paint.get('circle-pitch-scale')),
              u_pitch_with_map: +s,
              u_device_pixel_ratio: t.pixelRatio,
              u_extrude_scale: l,
              u_globe_extrude_scale: c,
              u_translate: n,
            };
          },
          Gi = (t) => ({ u_pixel_extrude_scale: [1 / t.width, 1 / t.height] }),
          Zi = (t) => ({ u_viewport_size: [t.width, t.height] }),
          $i = (t, e = 1) => ({ u_color: t, u_overlay: 0, u_overlay_scale: e }),
          qi = (t, i, r, n) => {
            const o =
              (e.aG(t, 1, i) / (e.a3 * Math.pow(2, t.tileID.overscaledZ))) *
              2 *
              Math.PI *
              n;
            return {
              u_extrude_scale: e.aG(t, 1, i),
              u_intensity: r,
              u_globe_extrude_scale: o,
            };
          },
          Wi = (t, i, r, n) => {
            const o = e.M();
            e.c0(o, 0, t.width, t.height, 0, 0, 1);
            const a = t.context.gl;
            return {
              u_matrix: o,
              u_world: [a.drawingBufferWidth, a.drawingBufferHeight],
              u_image: r,
              u_color_ramp: n,
              u_opacity: i.paint.get('heatmap-opacity'),
            };
          },
          Yi = (t, e, i) => {
            const r = i.paint.get('hillshade-accent-color');
            let n;
            switch (i.paint.get('hillshade-method')) {
              case 'basic':
                n = 4;
                break;
              case 'combined':
                n = 1;
                break;
              case 'igor':
                n = 2;
                break;
              case 'multidirectional':
                n = 3;
                break;
              default:
                n = 0;
            }
            const o = i.getIlluminationProperties();
            for (let a = 0; a < o.directionRadians.length; a++)
              'viewport' === i.paint.get('hillshade-illumination-anchor') &&
                (o.directionRadians[a] += t.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: Xi(0, e.tileID),
              u_exaggeration: i.paint.get('hillshade-exaggeration'),
              u_altitudes: o.altitudeRadians,
              u_azimuths: o.directionRadians,
              u_accent: r,
              u_method: n,
              u_highlights: o.highlightColor,
              u_shadows: o.shadowColor,
            };
          },
          Hi = (t, i) => {
            const r = i.stride,
              n = e.M();
            return (
              e.c0(n, 0, e.a3, -e.a3, 0, 0, 1),
              e.N(n, n, [0, -e.a3, 0]),
              {
                u_matrix: n,
                u_image: 1,
                u_dimension: [r, r],
                u_zoom: t.overscaledZ,
                u_unpack: i.getUnpackVector(),
              }
            );
          };
        function Xi(t, i) {
          const r = Math.pow(2, i.canonical.z),
            n = i.canonical.y;
          return [
            new e.a5(0, n / r).toLngLat().lat,
            new e.a5(0, (n + 1) / r).toLngLat().lat,
          ];
        }
        const Ki = (t, e, i = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: i,
            u_opacity: t.paint.get('color-relief-opacity'),
          }),
          Ji = (t, i, r, n) => {
            const o = t.transform;
            return {
              u_translation: nr(t, i, r),
              u_ratio: n / e.aG(i, 1, o.zoom),
              u_device_pixel_ratio: t.pixelRatio,
              u_units_to_pixels: [
                1 / o.pixelsToGLUnits[0],
                1 / o.pixelsToGLUnits[1],
              ],
            };
          },
          Qi = (t, i, r, n, o) =>
            e.e(Ji(t, i, r, n), { u_image: 0, u_image_height: o }),
          tr = (t, i, r, n, o) => {
            const a = t.transform,
              s = rr(i, a);
            return {
              u_translation: nr(t, i, r),
              u_texsize: i.imageAtlasTexture.size,
              u_ratio: n / e.aG(i, 1, a.zoom),
              u_device_pixel_ratio: t.pixelRatio,
              u_image: 0,
              u_scale: [s, o.fromScale, o.toScale],
              u_fade: o.t,
              u_units_to_pixels: [
                1 / a.pixelsToGLUnits[0],
                1 / a.pixelsToGLUnits[1],
              ],
            };
          },
          er = (t, i, r, n, o) => {
            const a = rr(i, t.transform);
            return e.e(Ji(t, i, r, n), {
              u_tileratio: a,
              u_crossfade_from: o.fromScale,
              u_crossfade_to: o.toScale,
              u_image: 0,
              u_mix: o.t,
              u_lineatlas_width: t.lineAtlas.width,
              u_lineatlas_height: t.lineAtlas.height,
            });
          },
          ir = (t, i, r, n, o, a) => {
            const s = rr(i, t.transform);
            return e.e(Ji(t, i, r, n), {
              u_image: 0,
              u_image_height: a,
              u_tileratio: s,
              u_crossfade_from: o.fromScale,
              u_crossfade_to: o.toScale,
              u_image_dash: 1,
              u_mix: o.t,
              u_lineatlas_width: t.lineAtlas.width,
              u_lineatlas_height: t.lineAtlas.height,
            });
          };
        function rr(t, i) {
          return 1 / e.aG(t, 1, i.tileZoom);
        }
        function nr(t, i, r) {
          return e.aH(
            t.transform,
            i,
            r.paint.get('line-translate'),
            r.paint.get('line-translate-anchor')
          );
        }
        const or = (t, e, i, r, n) => {
          return {
            u_tl_parent: t,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: i.mix,
            u_opacity: i.opacity * r.paint.get('raster-opacity'),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: r.paint.get('raster-brightness-min'),
            u_brightness_high: r.paint.get('raster-brightness-max'),
            u_saturation_factor:
              ((a = r.paint.get('raster-saturation')),
              a > 0 ? 1 - 1 / (1.001 - a) : -a),
            u_contrast_factor:
              ((o = r.paint.get('raster-contrast')),
              o > 0 ? 1 / (1 - o) : 1 + o),
            u_spin_weights: ar(r.paint.get('raster-hue-rotate')),
            u_coords_top: [n[0].x, n[0].y, n[1].x, n[1].y],
            u_coords_bottom: [n[3].x, n[3].y, n[2].x, n[2].y],
          };
          var o, a;
        };
        function ar(t) {
          t *= Math.PI / 180;
          const e = Math.sin(t),
            i = Math.cos(t);
          return [
            (2 * i + 1) / 3,
            (-Math.sqrt(3) * e - i + 1) / 3,
            (Math.sqrt(3) * e - i + 1) / 3,
          ];
        }
        const sr = (t, e, i, r, n, o, a, s, l, c, h, u, d) => {
            const p = a.transform;
            return {
              u_is_size_zoom_constant: +('constant' === t || 'source' === t),
              u_is_size_feature_constant: +('constant' === t || 'camera' === t),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: p.cameraToCenterDistance,
              u_pitch: (p.pitch / 360) * 2 * Math.PI,
              u_rotate_symbol: +i,
              u_aspect_ratio: p.width / p.height,
              u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1,
              u_label_plane_matrix: s,
              u_coord_matrix: l,
              u_is_text: +h,
              u_pitch_with_map: +r,
              u_is_along_line: n,
              u_is_variable_anchor: o,
              u_texsize: u,
              u_texture: 0,
              u_translation: c,
              u_pitched_scale: d,
            };
          },
          lr = (t, i, r, n, o, a, s, l, c, h, u, d, p, f) => {
            const m = s.transform;
            return e.e(sr(t, i, r, n, o, a, s, l, c, h, u, d, f), {
              u_gamma_scale: n
                ? Math.cos((m.pitch * Math.PI) / 180) * m.cameraToCenterDistance
                : 1,
              u_device_pixel_ratio: s.pixelRatio,
              u_is_halo: 1,
            });
          },
          cr = (t, i, r, n, o, a, s, l, c, h, u, d, p) =>
            e.e(lr(t, i, r, n, o, a, s, l, c, h, !0, u, 0, p), {
              u_texsize_icon: d,
              u_texture_icon: 1,
            }),
          hr = (t, e) => ({ u_opacity: t, u_color: e }),
          ur = (t, i, r, n, o) =>
            e.e(
              (function (t, i, r, n) {
                const o = r.imageManager.getPattern(t.from.toString()),
                  a = r.imageManager.getPattern(t.to.toString()),
                  { width: s, height: l } = r.imageManager.getPixelSize(),
                  c = Math.pow(2, n.tileID.overscaledZ),
                  h = (n.tileSize * Math.pow(2, r.transform.tileZoom)) / c,
                  u = h * (n.tileID.canonical.x + n.tileID.wrap * c),
                  d = h * n.tileID.canonical.y;
                return {
                  u_image: 0,
                  u_pattern_tl_a: o.tl,
                  u_pattern_br_a: o.br,
                  u_pattern_tl_b: a.tl,
                  u_pattern_br_b: a.br,
                  u_texsize: [s, l],
                  u_mix: i.t,
                  u_pattern_size_a: o.displaySize,
                  u_pattern_size_b: a.displaySize,
                  u_scale_a: i.fromScale,
                  u_scale_b: i.toScale,
                  u_tile_units_to_pixels: 1 / e.aG(n, 1, r.transform.tileZoom),
                  u_pixel_coord_upper: [u >> 16, d >> 16],
                  u_pixel_coord_lower: [65535 & u, 65535 & d],
                };
              })(r, o, i, n),
              { u_opacity: t }
            ),
          dr = (t, e) => {},
          pr = {
            fillExtrusion: (t, i) => ({
              u_lightpos: new e.bX(t, i.u_lightpos),
              u_lightpos_globe: new e.bX(t, i.u_lightpos_globe),
              u_lightintensity: new e.bj(t, i.u_lightintensity),
              u_lightcolor: new e.bX(t, i.u_lightcolor),
              u_vertical_gradient: new e.bj(t, i.u_vertical_gradient),
              u_opacity: new e.bj(t, i.u_opacity),
              u_fill_translate: new e.bY(t, i.u_fill_translate),
            }),
            fillExtrusionPattern: (t, i) => ({
              u_lightpos: new e.bX(t, i.u_lightpos),
              u_lightpos_globe: new e.bX(t, i.u_lightpos_globe),
              u_lightintensity: new e.bj(t, i.u_lightintensity),
              u_lightcolor: new e.bX(t, i.u_lightcolor),
              u_vertical_gradient: new e.bj(t, i.u_vertical_gradient),
              u_height_factor: new e.bj(t, i.u_height_factor),
              u_opacity: new e.bj(t, i.u_opacity),
              u_fill_translate: new e.bY(t, i.u_fill_translate),
              u_image: new e.bT(t, i.u_image),
              u_texsize: new e.bY(t, i.u_texsize),
              u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
              u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
              u_scale: new e.bX(t, i.u_scale),
              u_fade: new e.bj(t, i.u_fade),
            }),
            fill: (t, i) => ({
              u_fill_translate: new e.bY(t, i.u_fill_translate),
            }),
            fillPattern: (t, i) => ({
              u_image: new e.bT(t, i.u_image),
              u_texsize: new e.bY(t, i.u_texsize),
              u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
              u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
              u_scale: new e.bX(t, i.u_scale),
              u_fade: new e.bj(t, i.u_fade),
              u_fill_translate: new e.bY(t, i.u_fill_translate),
            }),
            fillOutline: (t, i) => ({
              u_world: new e.bY(t, i.u_world),
              u_fill_translate: new e.bY(t, i.u_fill_translate),
            }),
            fillOutlinePattern: (t, i) => ({
              u_world: new e.bY(t, i.u_world),
              u_image: new e.bT(t, i.u_image),
              u_texsize: new e.bY(t, i.u_texsize),
              u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
              u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
              u_scale: new e.bX(t, i.u_scale),
              u_fade: new e.bj(t, i.u_fade),
              u_fill_translate: new e.bY(t, i.u_fill_translate),
            }),
            circle: (t, i) => ({
              u_camera_to_center_distance: new e.bj(
                t,
                i.u_camera_to_center_distance
              ),
              u_scale_with_map: new e.bT(t, i.u_scale_with_map),
              u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
              u_extrude_scale: new e.bY(t, i.u_extrude_scale),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_globe_extrude_scale: new e.bj(t, i.u_globe_extrude_scale),
              u_translate: new e.bY(t, i.u_translate),
            }),
            collisionBox: (t, i) => ({
              u_pixel_extrude_scale: new e.bY(t, i.u_pixel_extrude_scale),
            }),
            collisionCircle: (t, i) => ({
              u_viewport_size: new e.bY(t, i.u_viewport_size),
            }),
            debug: (t, i) => ({
              u_color: new e.bU(t, i.u_color),
              u_overlay: new e.bT(t, i.u_overlay),
              u_overlay_scale: new e.bj(t, i.u_overlay_scale),
            }),
            depth: dr,
            clippingMask: dr,
            heatmap: (t, i) => ({
              u_extrude_scale: new e.bj(t, i.u_extrude_scale),
              u_intensity: new e.bj(t, i.u_intensity),
              u_globe_extrude_scale: new e.bj(t, i.u_globe_extrude_scale),
            }),
            heatmapTexture: (t, i) => ({
              u_matrix: new e.bV(t, i.u_matrix),
              u_world: new e.bY(t, i.u_world),
              u_image: new e.bT(t, i.u_image),
              u_color_ramp: new e.bT(t, i.u_color_ramp),
              u_opacity: new e.bj(t, i.u_opacity),
            }),
            hillshade: (t, i) => ({
              u_image: new e.bT(t, i.u_image),
              u_latrange: new e.bY(t, i.u_latrange),
              u_exaggeration: new e.bj(t, i.u_exaggeration),
              u_altitudes: new e.c2(t, i.u_altitudes),
              u_azimuths: new e.c2(t, i.u_azimuths),
              u_accent: new e.bU(t, i.u_accent),
              u_method: new e.bT(t, i.u_method),
              u_shadows: new e.c1(t, i.u_shadows),
              u_highlights: new e.c1(t, i.u_highlights),
            }),
            hillshadePrepare: (t, i) => ({
              u_matrix: new e.bV(t, i.u_matrix),
              u_image: new e.bT(t, i.u_image),
              u_dimension: new e.bY(t, i.u_dimension),
              u_zoom: new e.bj(t, i.u_zoom),
              u_unpack: new e.bW(t, i.u_unpack),
            }),
            colorRelief: (t, i) => ({
              u_image: new e.bT(t, i.u_image),
              u_unpack: new e.bW(t, i.u_unpack),
              u_dimension: new e.bY(t, i.u_dimension),
              u_elevation_stops: new e.bT(t, i.u_elevation_stops),
              u_color_stops: new e.bT(t, i.u_color_stops),
              u_color_ramp_size: new e.bT(t, i.u_color_ramp_size),
              u_opacity: new e.bj(t, i.u_opacity),
            }),
            line: (t, i) => ({
              u_translation: new e.bY(t, i.u_translation),
              u_ratio: new e.bj(t, i.u_ratio),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
            }),
            lineGradient: (t, i) => ({
              u_translation: new e.bY(t, i.u_translation),
              u_ratio: new e.bj(t, i.u_ratio),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
              u_image: new e.bT(t, i.u_image),
              u_image_height: new e.bj(t, i.u_image_height),
            }),
            linePattern: (t, i) => ({
              u_translation: new e.bY(t, i.u_translation),
              u_texsize: new e.bY(t, i.u_texsize),
              u_ratio: new e.bj(t, i.u_ratio),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_image: new e.bT(t, i.u_image),
              u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
              u_scale: new e.bX(t, i.u_scale),
              u_fade: new e.bj(t, i.u_fade),
            }),
            lineSDF: (t, i) => ({
              u_translation: new e.bY(t, i.u_translation),
              u_ratio: new e.bj(t, i.u_ratio),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
              u_image: new e.bT(t, i.u_image),
              u_mix: new e.bj(t, i.u_mix),
              u_tileratio: new e.bj(t, i.u_tileratio),
              u_crossfade_from: new e.bj(t, i.u_crossfade_from),
              u_crossfade_to: new e.bj(t, i.u_crossfade_to),
              u_lineatlas_width: new e.bj(t, i.u_lineatlas_width),
              u_lineatlas_height: new e.bj(t, i.u_lineatlas_height),
            }),
            lineGradientSDF: (t, i) => ({
              u_translation: new e.bY(t, i.u_translation),
              u_ratio: new e.bj(t, i.u_ratio),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_units_to_pixels: new e.bY(t, i.u_units_to_pixels),
              u_image: new e.bT(t, i.u_image),
              u_image_height: new e.bj(t, i.u_image_height),
              u_tileratio: new e.bj(t, i.u_tileratio),
              u_crossfade_from: new e.bj(t, i.u_crossfade_from),
              u_crossfade_to: new e.bj(t, i.u_crossfade_to),
              u_image_dash: new e.bT(t, i.u_image_dash),
              u_mix: new e.bj(t, i.u_mix),
              u_lineatlas_width: new e.bj(t, i.u_lineatlas_width),
              u_lineatlas_height: new e.bj(t, i.u_lineatlas_height),
            }),
            raster: (t, i) => ({
              u_tl_parent: new e.bY(t, i.u_tl_parent),
              u_scale_parent: new e.bj(t, i.u_scale_parent),
              u_buffer_scale: new e.bj(t, i.u_buffer_scale),
              u_fade_t: new e.bj(t, i.u_fade_t),
              u_opacity: new e.bj(t, i.u_opacity),
              u_image0: new e.bT(t, i.u_image0),
              u_image1: new e.bT(t, i.u_image1),
              u_brightness_low: new e.bj(t, i.u_brightness_low),
              u_brightness_high: new e.bj(t, i.u_brightness_high),
              u_saturation_factor: new e.bj(t, i.u_saturation_factor),
              u_contrast_factor: new e.bj(t, i.u_contrast_factor),
              u_spin_weights: new e.bX(t, i.u_spin_weights),
              u_coords_top: new e.bW(t, i.u_coords_top),
              u_coords_bottom: new e.bW(t, i.u_coords_bottom),
            }),
            symbolIcon: (t, i) => ({
              u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
              u_is_size_feature_constant: new e.bT(
                t,
                i.u_is_size_feature_constant
              ),
              u_size_t: new e.bj(t, i.u_size_t),
              u_size: new e.bj(t, i.u_size),
              u_camera_to_center_distance: new e.bj(
                t,
                i.u_camera_to_center_distance
              ),
              u_pitch: new e.bj(t, i.u_pitch),
              u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
              u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
              u_fade_change: new e.bj(t, i.u_fade_change),
              u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
              u_coord_matrix: new e.bV(t, i.u_coord_matrix),
              u_is_text: new e.bT(t, i.u_is_text),
              u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
              u_is_along_line: new e.bT(t, i.u_is_along_line),
              u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
              u_texsize: new e.bY(t, i.u_texsize),
              u_texture: new e.bT(t, i.u_texture),
              u_translation: new e.bY(t, i.u_translation),
              u_pitched_scale: new e.bj(t, i.u_pitched_scale),
            }),
            symbolSDF: (t, i) => ({
              u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
              u_is_size_feature_constant: new e.bT(
                t,
                i.u_is_size_feature_constant
              ),
              u_size_t: new e.bj(t, i.u_size_t),
              u_size: new e.bj(t, i.u_size),
              u_camera_to_center_distance: new e.bj(
                t,
                i.u_camera_to_center_distance
              ),
              u_pitch: new e.bj(t, i.u_pitch),
              u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
              u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
              u_fade_change: new e.bj(t, i.u_fade_change),
              u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
              u_coord_matrix: new e.bV(t, i.u_coord_matrix),
              u_is_text: new e.bT(t, i.u_is_text),
              u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
              u_is_along_line: new e.bT(t, i.u_is_along_line),
              u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
              u_texsize: new e.bY(t, i.u_texsize),
              u_texture: new e.bT(t, i.u_texture),
              u_gamma_scale: new e.bj(t, i.u_gamma_scale),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_is_halo: new e.bT(t, i.u_is_halo),
              u_translation: new e.bY(t, i.u_translation),
              u_pitched_scale: new e.bj(t, i.u_pitched_scale),
            }),
            symbolTextAndIcon: (t, i) => ({
              u_is_size_zoom_constant: new e.bT(t, i.u_is_size_zoom_constant),
              u_is_size_feature_constant: new e.bT(
                t,
                i.u_is_size_feature_constant
              ),
              u_size_t: new e.bj(t, i.u_size_t),
              u_size: new e.bj(t, i.u_size),
              u_camera_to_center_distance: new e.bj(
                t,
                i.u_camera_to_center_distance
              ),
              u_pitch: new e.bj(t, i.u_pitch),
              u_rotate_symbol: new e.bT(t, i.u_rotate_symbol),
              u_aspect_ratio: new e.bj(t, i.u_aspect_ratio),
              u_fade_change: new e.bj(t, i.u_fade_change),
              u_label_plane_matrix: new e.bV(t, i.u_label_plane_matrix),
              u_coord_matrix: new e.bV(t, i.u_coord_matrix),
              u_is_text: new e.bT(t, i.u_is_text),
              u_pitch_with_map: new e.bT(t, i.u_pitch_with_map),
              u_is_along_line: new e.bT(t, i.u_is_along_line),
              u_is_variable_anchor: new e.bT(t, i.u_is_variable_anchor),
              u_texsize: new e.bY(t, i.u_texsize),
              u_texsize_icon: new e.bY(t, i.u_texsize_icon),
              u_texture: new e.bT(t, i.u_texture),
              u_texture_icon: new e.bT(t, i.u_texture_icon),
              u_gamma_scale: new e.bj(t, i.u_gamma_scale),
              u_device_pixel_ratio: new e.bj(t, i.u_device_pixel_ratio),
              u_is_halo: new e.bT(t, i.u_is_halo),
              u_translation: new e.bY(t, i.u_translation),
              u_pitched_scale: new e.bj(t, i.u_pitched_scale),
            }),
            background: (t, i) => ({
              u_opacity: new e.bj(t, i.u_opacity),
              u_color: new e.bU(t, i.u_color),
            }),
            backgroundPattern: (t, i) => ({
              u_opacity: new e.bj(t, i.u_opacity),
              u_image: new e.bT(t, i.u_image),
              u_pattern_tl_a: new e.bY(t, i.u_pattern_tl_a),
              u_pattern_br_a: new e.bY(t, i.u_pattern_br_a),
              u_pattern_tl_b: new e.bY(t, i.u_pattern_tl_b),
              u_pattern_br_b: new e.bY(t, i.u_pattern_br_b),
              u_texsize: new e.bY(t, i.u_texsize),
              u_mix: new e.bj(t, i.u_mix),
              u_pattern_size_a: new e.bY(t, i.u_pattern_size_a),
              u_pattern_size_b: new e.bY(t, i.u_pattern_size_b),
              u_scale_a: new e.bj(t, i.u_scale_a),
              u_scale_b: new e.bj(t, i.u_scale_b),
              u_pixel_coord_upper: new e.bY(t, i.u_pixel_coord_upper),
              u_pixel_coord_lower: new e.bY(t, i.u_pixel_coord_lower),
              u_tile_units_to_pixels: new e.bj(t, i.u_tile_units_to_pixels),
            }),
            terrain: (t, i) => ({
              u_texture: new e.bT(t, i.u_texture),
              u_ele_delta: new e.bj(t, i.u_ele_delta),
              u_fog_matrix: new e.bV(t, i.u_fog_matrix),
              u_fog_color: new e.bU(t, i.u_fog_color),
              u_fog_ground_blend: new e.bj(t, i.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new e.bj(
                t,
                i.u_fog_ground_blend_opacity
              ),
              u_horizon_color: new e.bU(t, i.u_horizon_color),
              u_horizon_fog_blend: new e.bj(t, i.u_horizon_fog_blend),
              u_is_globe_mode: new e.bj(t, i.u_is_globe_mode),
            }),
            terrainDepth: (t, i) => ({
              u_ele_delta: new e.bj(t, i.u_ele_delta),
            }),
            terrainCoords: (t, i) => ({
              u_texture: new e.bT(t, i.u_texture),
              u_terrain_coords_id: new e.bj(t, i.u_terrain_coords_id),
              u_ele_delta: new e.bj(t, i.u_ele_delta),
            }),
            projectionErrorMeasurement: (t, i) => ({
              u_input: new e.bj(t, i.u_input),
              u_output_expected: new e.bj(t, i.u_output_expected),
            }),
            atmosphere: (t, i) => ({
              u_sun_pos: new e.bX(t, i.u_sun_pos),
              u_atmosphere_blend: new e.bj(t, i.u_atmosphere_blend),
              u_globe_position: new e.bX(t, i.u_globe_position),
              u_globe_radius: new e.bj(t, i.u_globe_radius),
              u_inv_proj_matrix: new e.bV(t, i.u_inv_proj_matrix),
            }),
            sky: (t, i) => ({
              u_sky_color: new e.bU(t, i.u_sky_color),
              u_horizon_color: new e.bU(t, i.u_horizon_color),
              u_horizon: new e.bY(t, i.u_horizon),
              u_horizon_normal: new e.bY(t, i.u_horizon_normal),
              u_sky_horizon_blend: new e.bj(t, i.u_sky_horizon_blend),
              u_sky_blend: new e.bj(t, i.u_sky_blend),
            }),
          };
        class fr {
          constructor(t, e, i) {
            this.context = t;
            const r = t.gl;
            (this.buffer = r.createBuffer()),
              (this.dynamicDraw = Boolean(i)),
              this.context.unbindVAO(),
              t.bindElementBuffer.set(this.buffer),
              r.bufferData(
                r.ELEMENT_ARRAY_BUFFER,
                e.arrayBuffer,
                this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW
              ),
              this.dynamicDraw || delete e.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            const e = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error(
                'Attempted to update data while not in dynamic mode.'
              );
            this.context.unbindVAO(),
              this.bind(),
              e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer &&
              (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const mr = {
          Int8: 'BYTE',
          Uint8: 'UNSIGNED_BYTE',
          Int16: 'SHORT',
          Uint16: 'UNSIGNED_SHORT',
          Int32: 'INT',
          Uint32: 'UNSIGNED_INT',
          Float32: 'FLOAT',
        };
        class _r {
          constructor(t, e, i, r) {
            (this.length = e.length),
              (this.attributes = i),
              (this.itemSize = e.bytesPerElement),
              (this.dynamicDraw = r),
              (this.context = t);
            const n = t.gl;
            (this.buffer = n.createBuffer()),
              t.bindVertexBuffer.set(this.buffer),
              n.bufferData(
                n.ARRAY_BUFFER,
                e.arrayBuffer,
                this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW
              ),
              this.dynamicDraw || delete e.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            if (t.length !== this.length)
              throw new Error(
                `Length of new data is ${t.length}, which doesn't match current length of ${this.length}`
              );
            const e = this.context.gl;
            this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, e) {
            for (let i = 0; i < this.attributes.length; i++) {
              const r = e.attributes[this.attributes[i].name];
              void 0 !== r && t.enableVertexAttribArray(r);
            }
          }
          setVertexAttribPointers(t, e, i) {
            for (let r = 0; r < this.attributes.length; r++) {
              const n = this.attributes[r],
                o = e.attributes[n.name];
              void 0 !== o &&
                t.vertexAttribPointer(
                  o,
                  n.components,
                  t[mr[n.type]],
                  !1,
                  this.itemSize,
                  n.offset + this.itemSize * (i || 0)
                );
            }
          }
          destroy() {
            this.buffer &&
              (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class gr {
          constructor(t) {
            (this.gl = t.gl),
              (this.default = this.getDefault()),
              (this.current = this.default),
              (this.dirty = !1);
          }
          get() {
            return this.current;
          }
          set(t) {}
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class yr extends gr {
          getDefault() {
            return e.bi.transparent;
          }
          set(t) {
            const e = this.current;
            (t.r !== e.r ||
              t.g !== e.g ||
              t.b !== e.b ||
              t.a !== e.a ||
              this.dirty) &&
              (this.gl.clearColor(t.r, t.g, t.b, t.a),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class xr extends gr {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.clearDepth(t), (this.current = t), (this.dirty = !1));
          }
        }
        class vr extends gr {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.clearStencil(t), (this.current = t), (this.dirty = !1));
          }
        }
        class br extends gr {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t) {
            const e = this.current;
            (t[0] !== e[0] ||
              t[1] !== e[1] ||
              t[2] !== e[2] ||
              t[3] !== e[3] ||
              this.dirty) &&
              (this.gl.colorMask(t[0], t[1], t[2], t[3]),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class wr extends gr {
          getDefault() {
            return !0;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.depthMask(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Tr extends gr {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.stencilMask(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Pr extends gr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const e = this.current;
            (t.func !== e.func ||
              t.ref !== e.ref ||
              t.mask !== e.mask ||
              this.dirty) &&
              (this.gl.stencilFunc(t.func, t.ref, t.mask),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class Sr extends gr {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const e = this.current;
            (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) &&
              (this.gl.stencilOp(t[0], t[1], t[2]),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class Mr extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Ir extends gr {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const e = this.current;
            (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
              (this.gl.depthRange(t[0], t[1]),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class Cr extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Ar extends gr {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.depthFunc(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Er extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            t ? e.enable(e.BLEND) : e.disable(e.BLEND),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class zr extends gr {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO];
          }
          set(t) {
            const e = this.current;
            (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
              (this.gl.blendFunc(t[0], t[1]),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class kr extends gr {
          getDefault() {
            return e.bi.transparent;
          }
          set(t) {
            const e = this.current;
            (t.r !== e.r ||
              t.g !== e.g ||
              t.b !== e.b ||
              t.a !== e.a ||
              this.dirty) &&
              (this.gl.blendColor(t.r, t.g, t.b, t.a),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class Dr extends gr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.blendEquation(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Rr extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Lr extends gr {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.cullFace(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Fr extends gr {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.frontFace(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Br extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.useProgram(t), (this.current = t), (this.dirty = !1));
          }
        }
        class Or extends gr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) &&
              (this.gl.activeTexture(t), (this.current = t), (this.dirty = !1));
          }
        }
        class jr extends gr {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const e = this.current;
            (t[0] !== e[0] ||
              t[1] !== e[1] ||
              t[2] !== e[2] ||
              t[3] !== e[3] ||
              this.dirty) &&
              (this.gl.viewport(t[0], t[1], t[2], t[3]),
              (this.current = t),
              (this.dirty = !1));
          }
        }
        class Nr extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.bindFramebuffer(e.FRAMEBUFFER, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Vr extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.bindRenderbuffer(e.RENDERBUFFER, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Ur extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.bindTexture(e.TEXTURE_2D, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Gr extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.bindBuffer(e.ARRAY_BUFFER, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Zr extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            const e = this.gl;
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class $r extends gr {
          getDefault() {
            return null;
          }
          set(t) {
            var e;
            if (t === this.current && !this.dirty) return;
            const i = this.gl;
            Qe(i)
              ? i.bindVertexArray(t)
              : null === (e = i.getExtension('OES_vertex_array_object')) ||
                void 0 === e ||
                e.bindVertexArrayOES(t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class qr extends gr {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.pixelStorei(e.UNPACK_ALIGNMENT, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Wr extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Yr extends gr {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const e = this.gl;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Hr extends gr {
          constructor(t, e) {
            super(t), (this.context = t), (this.parent = e);
          }
          getDefault() {
            return null;
          }
        }
        class Xr extends Hr {
          setDirty() {
            this.dirty = !0;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e = this.gl;
            e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_2D,
              t,
              0
            ),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Kr extends Hr {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e = this.gl;
            e.framebufferRenderbuffer(
              e.FRAMEBUFFER,
              e.DEPTH_ATTACHMENT,
              e.RENDERBUFFER,
              t
            ),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        class Jr extends Hr {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e = this.gl;
            e.framebufferRenderbuffer(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.RENDERBUFFER,
              t
            ),
              (this.current = t),
              (this.dirty = !1);
          }
        }
        const Qr = 'Framebuffer is not complete';
        class tn {
          constructor(t, e, i, r, n) {
            (this.context = t), (this.width = e), (this.height = i);
            const o = t.gl,
              a = (this.framebuffer = o.createFramebuffer());
            if (((this.colorAttachment = new Xr(t, a)), r))
              this.depthAttachment = n ? new Jr(t, a) : new Kr(t, a);
            else if (n) throw new Error('Stencil cannot be set without depth');
            if (
              o.checkFramebufferStatus(o.FRAMEBUFFER) !== o.FRAMEBUFFER_COMPLETE
            )
              throw new Error(Qr);
          }
          destroy() {
            const t = this.context.gl,
              e = this.colorAttachment.get();
            if ((e && t.deleteTexture(e), this.depthAttachment)) {
              const e = this.depthAttachment.get();
              e && t.deleteRenderbuffer(e);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class en {
          constructor(t) {
            var e, i;
            if (
              ((this.gl = t),
              (this.clearColor = new yr(this)),
              (this.clearDepth = new xr(this)),
              (this.clearStencil = new vr(this)),
              (this.colorMask = new br(this)),
              (this.depthMask = new wr(this)),
              (this.stencilMask = new Tr(this)),
              (this.stencilFunc = new Pr(this)),
              (this.stencilOp = new Sr(this)),
              (this.stencilTest = new Mr(this)),
              (this.depthRange = new Ir(this)),
              (this.depthTest = new Cr(this)),
              (this.depthFunc = new Ar(this)),
              (this.blend = new Er(this)),
              (this.blendFunc = new zr(this)),
              (this.blendColor = new kr(this)),
              (this.blendEquation = new Dr(this)),
              (this.cullFace = new Rr(this)),
              (this.cullFaceSide = new Lr(this)),
              (this.frontFace = new Fr(this)),
              (this.program = new Br(this)),
              (this.activeTexture = new Or(this)),
              (this.viewport = new jr(this)),
              (this.bindFramebuffer = new Nr(this)),
              (this.bindRenderbuffer = new Vr(this)),
              (this.bindTexture = new Ur(this)),
              (this.bindVertexBuffer = new Gr(this)),
              (this.bindElementBuffer = new Zr(this)),
              (this.bindVertexArray = new $r(this)),
              (this.pixelStoreUnpack = new qr(this)),
              (this.pixelStoreUnpackPremultiplyAlpha = new Wr(this)),
              (this.pixelStoreUnpackFlipY = new Yr(this)),
              (this.extTextureFilterAnisotropic =
                t.getExtension('EXT_texture_filter_anisotropic') ||
                t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')),
              this.extTextureFilterAnisotropic &&
                (this.extTextureFilterAnisotropicMax = t.getParameter(
                  this.extTextureFilterAnisotropic
                    .MAX_TEXTURE_MAX_ANISOTROPY_EXT
                )),
              (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)),
              Qe(t))
            ) {
              this.HALF_FLOAT = t.HALF_FLOAT;
              const r = t.getExtension('EXT_color_buffer_half_float');
              (this.RGBA16F =
                null !== (e = t.RGBA16F) && void 0 !== e
                  ? e
                  : null == r
                  ? void 0
                  : r.RGBA16F_EXT),
                (this.RGB16F =
                  null !== (i = t.RGB16F) && void 0 !== i
                    ? i
                    : null == r
                    ? void 0
                    : r.RGB16F_EXT),
                t.getExtension('EXT_color_buffer_float');
            } else {
              t.getExtension('EXT_color_buffer_half_float'),
                t.getExtension('OES_texture_half_float_linear');
              const e = t.getExtension('OES_texture_half_float');
              this.HALF_FLOAT = null == e ? void 0 : e.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(),
              this.clearColor.setDefault(),
              this.clearDepth.setDefault(),
              this.clearStencil.setDefault(),
              this.colorMask.setDefault(),
              this.depthMask.setDefault(),
              this.stencilMask.setDefault(),
              this.stencilFunc.setDefault(),
              this.stencilOp.setDefault(),
              this.stencilTest.setDefault(),
              this.depthRange.setDefault(),
              this.depthTest.setDefault(),
              this.depthFunc.setDefault(),
              this.blend.setDefault(),
              this.blendFunc.setDefault(),
              this.blendColor.setDefault(),
              this.blendEquation.setDefault(),
              this.cullFace.setDefault(),
              this.cullFaceSide.setDefault(),
              this.frontFace.setDefault(),
              this.program.setDefault(),
              this.activeTexture.setDefault(),
              this.bindFramebuffer.setDefault(),
              this.pixelStoreUnpack.setDefault(),
              this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
              this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            (this.clearColor.dirty = !0),
              (this.clearDepth.dirty = !0),
              (this.clearStencil.dirty = !0),
              (this.colorMask.dirty = !0),
              (this.depthMask.dirty = !0),
              (this.stencilMask.dirty = !0),
              (this.stencilFunc.dirty = !0),
              (this.stencilOp.dirty = !0),
              (this.stencilTest.dirty = !0),
              (this.depthRange.dirty = !0),
              (this.depthTest.dirty = !0),
              (this.depthFunc.dirty = !0),
              (this.blend.dirty = !0),
              (this.blendFunc.dirty = !0),
              (this.blendColor.dirty = !0),
              (this.blendEquation.dirty = !0),
              (this.cullFace.dirty = !0),
              (this.cullFaceSide.dirty = !0),
              (this.frontFace.dirty = !0),
              (this.program.dirty = !0),
              (this.activeTexture.dirty = !0),
              (this.viewport.dirty = !0),
              (this.bindFramebuffer.dirty = !0),
              (this.bindRenderbuffer.dirty = !0),
              (this.bindTexture.dirty = !0),
              (this.bindVertexBuffer.dirty = !0),
              (this.bindElementBuffer.dirty = !0),
              (this.bindVertexArray.dirty = !0),
              (this.pixelStoreUnpack.dirty = !0),
              (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
              (this.pixelStoreUnpackFlipY.dirty = !0);
          }
          createIndexBuffer(t, e) {
            return new fr(this, t, e);
          }
          createVertexBuffer(t, e, i) {
            return new _r(this, t, e, i);
          }
          createRenderbuffer(t, e, i) {
            const r = this.gl,
              n = r.createRenderbuffer();
            return (
              this.bindRenderbuffer.set(n),
              r.renderbufferStorage(r.RENDERBUFFER, t, e, i),
              this.bindRenderbuffer.set(null),
              n
            );
          }
          createFramebuffer(t, e, i, r) {
            return new tn(this, t, e, i, r);
          }
          clear({ color: t, depth: e, stencil: i }) {
            const r = this.gl;
            let n = 0;
            t &&
              ((n |= r.COLOR_BUFFER_BIT),
              this.clearColor.set(t),
              this.colorMask.set([!0, !0, !0, !0])),
              void 0 !== e &&
                ((n |= r.DEPTH_BUFFER_BIT),
                this.depthRange.set([0, 1]),
                this.clearDepth.set(e),
                this.depthMask.set(!0)),
              void 0 !== i &&
                ((n |= r.STENCIL_BUFFER_BIT),
                this.clearStencil.set(i),
                this.stencilMask.set(255)),
              r.clear(n);
          }
          setCullFace(t) {
            !1 === t.enable
              ? this.cullFace.set(!1)
              : (this.cullFace.set(!0),
                this.cullFaceSide.set(t.mode),
                this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask
              ? (this.depthTest.set(!0),
                this.depthFunc.set(t.func),
                this.depthMask.set(t.mask),
                this.depthRange.set(t.range))
              : this.depthTest.set(!1);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask
              ? (this.stencilTest.set(!0),
                this.stencilMask.set(t.mask),
                this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                this.stencilFunc.set({
                  func: t.test.func,
                  ref: t.ref,
                  mask: t.test.mask,
                }))
              : this.stencilTest.set(!1);
          }
          setColorMode(t) {
            e.bK(t.blendFunction, qe.Replace)
              ? this.blend.set(!1)
              : (this.blend.set(!0),
                this.blendFunc.set(t.blendFunction),
                this.blendColor.set(t.blendColor)),
              this.colorMask.set(t.mask);
          }
          createVertexArray() {
            var t;
            return Qe(this.gl)
              ? this.gl.createVertexArray()
              : null ===
                  (t = this.gl.getExtension('OES_vertex_array_object')) ||
                void 0 === t
              ? void 0
              : t.createVertexArrayOES();
          }
          deleteVertexArray(t) {
            var e;
            return Qe(this.gl)
              ? this.gl.deleteVertexArray(t)
              : null ===
                  (e = this.gl.getExtension('OES_vertex_array_object')) ||
                void 0 === e
              ? void 0
              : e.deleteVertexArrayOES(t);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let rn;
        function nn(t, i, r, n, o) {
          const a = t.context,
            s = t.transform,
            l = a.gl,
            c = t.useProgram('collisionBox'),
            h = [];
          let u = 0,
            d = 0;
          for (let e = 0; e < n.length; e++) {
            const p = n[e],
              f = i.getTile(p).getBucket(r);
            if (!f) continue;
            const m = o ? f.textCollisionBox : f.iconCollisionBox,
              _ = f.collisionCircleArray;
            _.length > 0 &&
              (h.push({ circleArray: _, circleOffset: d, coord: p }),
              (u += _.length / 4),
              (d = u)),
              m &&
                c.draw(
                  a,
                  l.LINES,
                  He.disabled,
                  Ke.disabled,
                  t.colorModeForRenderPass(),
                  Ye.disabled,
                  Gi(t.transform),
                  t.style.map.terrain && t.style.map.terrain.getTerrainData(p),
                  s.getProjectionData({
                    overscaledTileID: p,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0,
                  }),
                  r.id,
                  m.layoutVertexBuffer,
                  m.indexBuffer,
                  m.segments,
                  null,
                  t.transform.zoom,
                  null,
                  null,
                  m.collisionVertexBuffer
                );
          }
          if (!o || !h.length) return;
          const p = t.useProgram('collisionCircle'),
            f = new e.c3();
          f.resize(4 * u), f._trim();
          let m = 0;
          for (const e of h)
            for (let t = 0; t < e.circleArray.length / 4; t++) {
              const i = 4 * t,
                r = e.circleArray[i + 0],
                n = e.circleArray[i + 1],
                o = e.circleArray[i + 2],
                a = e.circleArray[i + 3];
              f.emplace(m++, r, n, o, a, 0),
                f.emplace(m++, r, n, o, a, 1),
                f.emplace(m++, r, n, o, a, 2),
                f.emplace(m++, r, n, o, a, 3);
            }
          (!rn || rn.length < 2 * u) &&
            (rn = (function (t) {
              const i = 2 * t,
                r = new e.c5();
              r.resize(i), r._trim();
              for (let e = 0; e < i; e++) {
                const t = 6 * e;
                (r.uint16[t + 0] = 4 * e + 0),
                  (r.uint16[t + 1] = 4 * e + 1),
                  (r.uint16[t + 2] = 4 * e + 2),
                  (r.uint16[t + 3] = 4 * e + 2),
                  (r.uint16[t + 4] = 4 * e + 3),
                  (r.uint16[t + 5] = 4 * e + 0);
              }
              return r;
            })(u));
          const _ = a.createIndexBuffer(rn, !0),
            g = a.createVertexBuffer(f, e.c4.members, !0);
          for (const y of h) {
            const i = Zi(t.transform);
            p.draw(
              a,
              l.TRIANGLES,
              He.disabled,
              Ke.disabled,
              t.colorModeForRenderPass(),
              Ye.disabled,
              i,
              t.style.map.terrain &&
                t.style.map.terrain.getTerrainData(y.coord),
              null,
              r.id,
              g,
              _,
              e.aQ.simpleSegment(
                0,
                2 * y.circleOffset,
                y.circleArray.length,
                y.circleArray.length / 2
              ),
              null,
              t.transform.zoom,
              null,
              null,
              null
            );
          }
          g.destroy(), _.destroy();
        }
        const on = e.am(new Float32Array(16));
        function an(t, i, r, n, o, a) {
          const { horizontalAlign: s, verticalAlign: l } = e.aL(t);
          return new e.P(
            ((-(s - 0.5) * i) / o + n[0]) * a,
            ((-(l - 0.5) * r) / o + n[1]) * a
          );
        }
        function sn(t, i, r, n, o, a) {
          const s = i.tileAnchorPoint.add(
            new e.P(i.translation[0], i.translation[1])
          );
          if (i.pitchWithMap) {
            let t = n.mult(a);
            r || (t = t.rotate(-o));
            const e = s.add(t);
            return Ft(e.x, e.y, i.pitchedLabelPlaneMatrix, i.getElevation)
              .point;
          }
          if (r) {
            const e = $t(
                i.tileAnchorPoint.x + 1,
                i.tileAnchorPoint.y,
                i
              ).point.sub(t),
              r = Math.atan(e.y / e.x) + (e.x < 0 ? Math.PI : 0);
            return t.add(n.rotate(r));
          }
          return t.add(n);
        }
        function ln(t, i, r, n, o, a, s, l, c, h, u, d) {
          const p = t.text.placedSymbolArray,
            f = t.text.dynamicLayoutVertexArray,
            m = t.icon.dynamicLayoutVertexArray,
            _ = {};
          f.clear();
          for (let g = 0; g < p.length; g++) {
            const m = p.get(g),
              y =
                m.hidden ||
                !m.crossTileID ||
                (t.allowVerticalPlacement && !m.placedOrientation)
                  ? null
                  : n[m.crossTileID];
            if (y) {
              const n = new e.P(m.anchorX, m.anchorY),
                p = {
                  getElevation: d,
                  width: o.width,
                  height: o.height,
                  pitchedLabelPlaneMatrix: a,
                  pitchWithMap: r,
                  transform: o,
                  tileAnchorPoint: n,
                  translation: h,
                  unwrappedTileID: u,
                },
                g = r ? Wt(n.x, n.y, p) : $t(n.x, n.y, p),
                x = Bt(o.cameraToCenterDistance, g.signedDistanceFromCamera);
              let v = (e.at(t.textSizeData, l, m) * x) / e.aF;
              r && (v *= t.tilePixelRatio / s);
              const {
                  width: b,
                  height: w,
                  anchor: T,
                  textOffset: P,
                  textBoxScale: S,
                } = y,
                M = an(T, b, w, P, S, v),
                I = o.getPitchedTextCorrection(n.x + h[0], n.y + h[1], u),
                C = sn(g.point, p, i, M, -o.bearingInRadians, I),
                A =
                  t.allowVerticalPlacement &&
                  m.placedOrientation === e.as.vertical
                    ? Math.PI / 2
                    : 0;
              for (let t = 0; t < m.numGlyphs; t++) e.az(f, C, A);
              c &&
                m.associatedIconIndex >= 0 &&
                (_[m.associatedIconIndex] = { shiftedAnchor: C, angle: A });
            } else Jt(m.numGlyphs, f);
          }
          if (c) {
            m.clear();
            const i = t.icon.placedSymbolArray;
            for (let t = 0; t < i.length; t++) {
              const r = i.get(t);
              if (r.hidden) Jt(r.numGlyphs, m);
              else {
                const i = _[t];
                if (i)
                  for (let t = 0; t < r.numGlyphs; t++)
                    e.az(m, i.shiftedAnchor, i.angle);
                else Jt(r.numGlyphs, m);
              }
            }
            t.icon.dynamicLayoutVertexBuffer.updateData(m);
          }
          t.text.dynamicLayoutVertexBuffer.updateData(f);
        }
        function cn(t, e, i) {
          return i.iconsInText && e
            ? 'symbolTextAndIcon'
            : t
            ? 'symbolSDF'
            : 'symbolIcon';
        }
        function hn(t, i, r, n, o, a, s, l, c, h, u, d, p) {
          const f = t.context,
            m = f.gl,
            _ = t.transform,
            g = 'map' === l,
            y = 'map' === c,
            x =
              'viewport' !== l && 'point' !== r.layout.get('symbol-placement'),
            v = g && !y && !x,
            b = !r.layout.get('symbol-sort-key').isConstant();
          let w = !1;
          const T = t.getDepthModeForSublayer(0, He.ReadOnly),
            P =
              r._unevaluatedLayout.hasValue('text-variable-anchor') ||
              r._unevaluatedLayout.hasValue('text-variable-anchor-offset'),
            S = [],
            M = _.getCircleRadiusCorrection();
          for (const I of n) {
            const n = i.getTile(I),
              l = n.getBucket(r);
            if (!l) continue;
            const c = o ? l.text : l.icon;
            if (!c || !c.segments.get().length || !c.hasVisibleVertices)
              continue;
            const u = c.programConfigurations.get(r.id),
              d = o || l.sdfIcons,
              f = o ? l.textSizeData : l.iconSizeData,
              T = y || 0 !== _.pitch,
              C = t.useProgram(cn(d, o, l), u),
              A = e.ar(f, _.zoom),
              E = t.style.map.terrain && t.style.map.terrain.getTerrainData(I);
            let z,
              k,
              D,
              R,
              L = [0, 0],
              F = null;
            if (o)
              (k = n.glyphAtlasTexture),
                (D = m.LINEAR),
                (z = n.glyphAtlasTexture.size),
                l.iconsInText &&
                  ((L = n.imageAtlasTexture.size),
                  (F = n.imageAtlasTexture),
                  (R =
                    T ||
                    t.options.rotating ||
                    t.options.zooming ||
                    'composite' === f.kind ||
                    'camera' === f.kind
                      ? m.LINEAR
                      : m.NEAREST));
            else {
              const e =
                1 !== r.layout.get('icon-size').constantOr(0) ||
                l.iconsNeedLinear;
              (k = n.imageAtlasTexture),
                (D =
                  d || t.options.rotating || t.options.zooming || e || T
                    ? m.LINEAR
                    : m.NEAREST),
                (z = n.imageAtlasTexture.size);
            }
            const B = e.aG(n, 1, t.transform.zoom),
              O = Dt(g, t.transform, B),
              j = e.M();
            e.au(j, O);
            const N = Rt(y, g, t.transform, B),
              V = e.aH(_, n, a, s),
              U = _.getProjectionData({
                overscaledTileID: I,
                applyGlobeMatrix: !p,
                applyTerrainMatrix: !0,
              }),
              G = P && l.hasTextData(),
              Z =
                'none' !== r.layout.get('icon-text-fit') &&
                G &&
                l.hasIconData();
            if (x) {
              const e = t.style.map.terrain
                  ? (e, i) => t.style.map.terrain.getElevation(I, e, i)
                  : null,
                i = 'map' === r.layout.get('text-rotation-alignment');
              jt(
                l,
                t,
                o,
                O,
                j,
                y,
                h,
                i,
                I.toUnwrapped(),
                _.width,
                _.height,
                V,
                e
              );
            }
            const $ = (o && P) || Z,
              q = x || $ ? on : y ? O : t.transform.clipSpaceToPixelsMatrix,
              W =
                d &&
                0 !==
                  r.paint
                    .get(o ? 'text-halo-width' : 'icon-halo-width')
                    .constantOr(1);
            let Y;
            Y = d
              ? l.iconsInText
                ? cr(f.kind, A, v, y, x, $, t, q, N, V, z, L, M)
                : lr(f.kind, A, v, y, x, $, t, q, N, V, o, z, 0, M)
              : sr(f.kind, A, v, y, x, $, t, q, N, V, o, z, M);
            const H = {
              program: C,
              buffers: c,
              uniformValues: Y,
              projectionData: U,
              atlasTexture: k,
              atlasTextureIcon: F,
              atlasInterpolation: D,
              atlasInterpolationIcon: R,
              isSDF: d,
              hasHalo: W,
            };
            if (b && l.canOverlap) {
              w = !0;
              const t = c.segments.get();
              for (const i of t)
                S.push({
                  segments: new e.aQ([i]),
                  sortKey: i.sortKey,
                  state: H,
                  terrainData: E,
                });
            } else
              S.push({
                segments: c.segments,
                sortKey: 0,
                state: H,
                terrainData: E,
              });
          }
          w && S.sort((t, e) => t.sortKey - e.sortKey);
          for (const e of S) {
            const i = e.state;
            if (
              (f.activeTexture.set(m.TEXTURE0),
              i.atlasTexture.bind(i.atlasInterpolation, m.CLAMP_TO_EDGE),
              i.atlasTextureIcon &&
                (f.activeTexture.set(m.TEXTURE1),
                i.atlasTextureIcon &&
                  i.atlasTextureIcon.bind(
                    i.atlasInterpolationIcon,
                    m.CLAMP_TO_EDGE
                  )),
              i.isSDF)
            ) {
              const n = i.uniformValues;
              i.hasHalo &&
                ((n.u_is_halo = 1),
                un(
                  i.buffers,
                  e.segments,
                  r,
                  t,
                  i.program,
                  T,
                  u,
                  d,
                  n,
                  i.projectionData,
                  e.terrainData
                )),
                (n.u_is_halo = 0);
            }
            un(
              i.buffers,
              e.segments,
              r,
              t,
              i.program,
              T,
              u,
              d,
              i.uniformValues,
              i.projectionData,
              e.terrainData
            );
          }
        }
        function un(t, e, i, r, n, o, a, s, l, c, h) {
          const u = r.context;
          n.draw(
            u,
            u.gl.TRIANGLES,
            o,
            a,
            s,
            Ye.backCCW,
            l,
            h,
            c,
            i.id,
            t.layoutVertexBuffer,
            t.indexBuffer,
            e,
            i.paint,
            r.transform.zoom,
            t.programConfigurations.get(i.id),
            t.dynamicLayoutVertexBuffer,
            t.opacityVertexBuffer
          );
        }
        function dn(t, i, r, n, o) {
          const a = t.context,
            s = a.gl,
            l = Ke.disabled,
            c = new qe([s.ONE, s.ONE], e.bi.transparent, [!0, !0, !0, !0]),
            h = i.getBucket(r);
          if (!h) return;
          const u = n.key;
          let d = r.heatmapFbos.get(u);
          d || ((d = fn(a, i.tileSize, i.tileSize)), r.heatmapFbos.set(u, d)),
            a.bindFramebuffer.set(d.framebuffer),
            a.viewport.set([0, 0, i.tileSize, i.tileSize]),
            a.clear({ color: e.bi.transparent });
          const p = h.programConfigurations.get(r.id),
            f = t.useProgram('heatmap', p, !o),
            m = t.transform.getProjectionData({
              overscaledTileID: i.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0,
            }),
            _ = t.style.map.terrain.getTerrainData(n);
          f.draw(
            a,
            s.TRIANGLES,
            He.disabled,
            l,
            c,
            Ye.disabled,
            qi(i, t.transform.zoom, r.paint.get('heatmap-intensity'), 1),
            _,
            m,
            r.id,
            h.layoutVertexBuffer,
            h.indexBuffer,
            h.segments,
            r.paint,
            t.transform.zoom,
            p
          );
        }
        function pn(t, e, i, r, n) {
          const o = t.context,
            a = o.gl,
            s = t.transform;
          o.setColorMode(t.colorModeForRenderPass());
          const l = mn(o, e),
            c = i.key,
            h = e.heatmapFbos.get(c);
          if (!h) return;
          o.activeTexture.set(a.TEXTURE0),
            a.bindTexture(a.TEXTURE_2D, h.colorAttachment.get()),
            o.activeTexture.set(a.TEXTURE1),
            l.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          const u = s.getProjectionData({
            overscaledTileID: i,
            applyTerrainMatrix: n,
            applyGlobeMatrix: !r,
          });
          t
            .useProgram('heatmapTexture')
            .draw(
              o,
              a.TRIANGLES,
              He.disabled,
              Ke.disabled,
              t.colorModeForRenderPass(),
              Ye.disabled,
              Wi(t, e, 0, 1),
              null,
              u,
              e.id,
              t.rasterBoundsBuffer,
              t.quadTriangleIndexBuffer,
              t.rasterBoundsSegments,
              e.paint,
              s.zoom
            ),
            h.destroy(),
            e.heatmapFbos.delete(c);
        }
        function fn(t, e, i) {
          var r, n;
          const o = t.gl,
            a = o.createTexture();
          o.bindTexture(o.TEXTURE_2D, a),
            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE),
            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE),
            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR),
            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR);
          const s =
              null !== (r = t.HALF_FLOAT) && void 0 !== r ? r : o.UNSIGNED_BYTE,
            l = null !== (n = t.RGBA16F) && void 0 !== n ? n : o.RGBA;
          o.texImage2D(o.TEXTURE_2D, 0, l, e, i, 0, o.RGBA, s, null);
          const c = t.createFramebuffer(e, i, !1, !1);
          return c.colorAttachment.set(a), c;
        }
        function mn(t, i) {
          return (
            i.colorRampTexture ||
              (i.colorRampTexture = new e.T(t, i.colorRamp, t.gl.RGBA)),
            i.colorRampTexture
          );
        }
        function _n(t, i, r, n, o, a, s, l) {
          let c = 256;
          if (o.stepInterpolant) {
            const n = i.getSource().maxzoom,
              o =
                s.canonical.z === n
                  ? Math.ceil(1 << (t.transform.maxZoom - s.canonical.z))
                  : 1;
            c = e.ai(
              e.c7((a.maxLineLength / e.a3) * 1024 * o),
              256,
              r.maxTextureSize
            );
          }
          return (
            (l.gradient = e.c8({
              expression: o.gradientExpression(),
              evaluationKey: 'lineProgress',
              resolution: c,
              image: l.gradient || void 0,
              clips: a.lineClipsArray,
            })),
            l.texture
              ? l.texture.update(l.gradient)
              : (l.texture = new e.T(r, l.gradient, n.RGBA)),
            (l.version = o.gradientVersion),
            l.texture
          );
        }
        function gn(t, e, i, r, n) {
          t.activeTexture.set(e.TEXTURE0),
            i.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE),
            r.updatePaintBuffers(n);
        }
        function yn(t, e, i, r, n, o) {
          (n || t.lineAtlas.dirty) &&
            (e.activeTexture.set(i.TEXTURE0), t.lineAtlas.bind(e)),
            r.updatePaintBuffers(o);
        }
        function xn(t, e, i, r, n, o, a) {
          const s = o.gradients[n.id];
          let l = s.texture;
          n.gradientVersion !== s.version && (l = _n(t, e, i, r, n, o, a, s)),
            i.activeTexture.set(r.TEXTURE0),
            l.bind(n.stepInterpolant ? r.NEAREST : r.LINEAR, r.CLAMP_TO_EDGE);
        }
        function vn(t, e, i, r, n, o, a, s, l) {
          const c = o.gradients[n.id];
          let h = c.texture;
          n.gradientVersion !== c.version && (h = _n(t, e, i, r, n, o, a, c)),
            i.activeTexture.set(r.TEXTURE0),
            h.bind(n.stepInterpolant ? r.NEAREST : r.LINEAR, r.CLAMP_TO_EDGE),
            i.activeTexture.set(r.TEXTURE1),
            t.lineAtlas.bind(i),
            s.updatePaintBuffers(l);
        }
        function bn(t, e, i, r, n) {
          if (!i || !r || !r.imageAtlas) return;
          const o = r.imageAtlas.patternPositions;
          let a = o[i.to.toString()],
            s = o[i.from.toString()];
          if ((!a && s && (a = s), !s && a && (s = a), !a || !s)) {
            const t = n.getPaintProperty(e);
            (a = o[t]), (s = o[t]);
          }
          a && s && t.setConstantPatternPositions(a, s);
        }
        function wn(t, i, r, n, o, a, s, l) {
          const c = t.context.gl,
            h = 'fill-pattern',
            u = r.paint.get(h),
            d = u && u.constantOr(1),
            p = r.getCrossfadeParameters();
          let f, m, _, g, y;
          const x = t.transform,
            v = r.paint.get('fill-translate'),
            b = r.paint.get('fill-translate-anchor');
          s
            ? ((m =
                d && !r.getPaintProperty('fill-outline-color')
                  ? 'fillOutlinePattern'
                  : 'fillOutline'),
              (f = c.LINES))
            : ((m = d ? 'fillPattern' : 'fill'), (f = c.TRIANGLES));
          const w = u.constantOr(null);
          for (const T of n) {
            const n = i.getTile(T);
            if (d && !n.patternsLoaded()) continue;
            const u = n.getBucket(r);
            if (!u) continue;
            const P = u.programConfigurations.get(r.id),
              S = t.useProgram(m, P),
              M = t.style.map.terrain && t.style.map.terrain.getTerrainData(T);
            d &&
              (t.context.activeTexture.set(c.TEXTURE0),
              n.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
              P.updatePaintBuffers(p)),
              bn(P, h, w, n, r);
            const I = x.getProjectionData({
                overscaledTileID: T,
                applyGlobeMatrix: !l,
                applyTerrainMatrix: !0,
              }),
              C = e.aH(x, n, v, b);
            if (s) {
              (g = u.indexBuffer2), (y = u.segments2);
              const e = [c.drawingBufferWidth, c.drawingBufferHeight];
              _ =
                'fillOutlinePattern' === m && d ? Vi(t, p, n, e, C) : Ni(e, C);
            } else
              (g = u.indexBuffer),
                (y = u.segments),
                (_ = d ? ji(t, p, n, C) : { u_fill_translate: C });
            const A = t.stencilModeForClipping(T);
            S.draw(
              t.context,
              f,
              o,
              A,
              a,
              Ye.backCCW,
              _,
              M,
              I,
              r.id,
              u.layoutVertexBuffer,
              g,
              y,
              r.paint,
              t.transform.zoom,
              P
            );
          }
        }
        function Tn(t, i, r, n, o, a, s, l) {
          const c = t.context,
            h = c.gl,
            u = 'fill-extrusion-pattern',
            d = r.paint.get(u),
            p = d.constantOr(1),
            f = r.getCrossfadeParameters(),
            m = r.paint.get('fill-extrusion-opacity'),
            _ = d.constantOr(null),
            g = t.transform;
          for (const y of n) {
            const n = i.getTile(y),
              d = n.getBucket(r);
            if (!d) continue;
            const x =
                t.style.map.terrain && t.style.map.terrain.getTerrainData(y),
              v = d.programConfigurations.get(r.id),
              b = t.useProgram(p ? 'fillExtrusionPattern' : 'fillExtrusion', v);
            p &&
              (t.context.activeTexture.set(h.TEXTURE0),
              n.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE),
              v.updatePaintBuffers(f));
            const w = g.getProjectionData({
              overscaledTileID: y,
              applyGlobeMatrix: !l,
              applyTerrainMatrix: !0,
            });
            bn(v, u, _, n, r);
            const T = e.aH(
                g,
                n,
                r.paint.get('fill-extrusion-translate'),
                r.paint.get('fill-extrusion-translate-anchor')
              ),
              P = r.paint.get('fill-extrusion-vertical-gradient'),
              S = p ? Oi(t, P, m, T, y, f, n) : Bi(t, P, m, T);
            b.draw(
              c,
              c.gl.TRIANGLES,
              o,
              a,
              s,
              Ye.backCCW,
              S,
              x,
              w,
              r.id,
              d.layoutVertexBuffer,
              d.indexBuffer,
              d.segments,
              r.paint,
              t.transform.zoom,
              v,
              t.style.map.terrain && d.centroidVertexBuffer
            );
          }
        }
        function Pn(t, e, i, r, n, o, a, s, l) {
          var c;
          const h = t.style.projection,
            u = t.context,
            d = t.transform,
            p = u.gl,
            f = [
              `#define NUM_ILLUMINATION_SOURCES ${
                i.paint.get('hillshade-highlight-color').values.length
              }`,
            ],
            m = t.useProgram('hillshade', null, !1, f),
            _ = !t.options.moving;
          for (const g of r) {
            const r = e.getTile(g),
              f = r.fbo;
            if (!f) continue;
            const y = h.getMeshFromTileID(u, g.canonical, s, !0, 'raster'),
              x =
                null === (c = t.style.map.terrain) || void 0 === c
                  ? void 0
                  : c.getTerrainData(g);
            u.activeTexture.set(p.TEXTURE0),
              p.bindTexture(p.TEXTURE_2D, f.colorAttachment.get());
            const v = d.getProjectionData({
              overscaledTileID: g,
              aligned: _,
              applyGlobeMatrix: !l,
              applyTerrainMatrix: !0,
            });
            m.draw(
              u,
              p.TRIANGLES,
              o,
              n[g.overscaledZ],
              a,
              Ye.backCCW,
              Yi(t, r, i),
              x,
              v,
              i.id,
              y.vertexBuffer,
              y.indexBuffer,
              y.segments
            );
          }
        }
        function Sn(t, i, r, n, o, a, s, l, c) {
          var h;
          const u = t.style.projection,
            d = t.context,
            p = t.transform,
            f = d.gl,
            m = t.useProgram('colorRelief'),
            _ = !t.options.moving;
          let g = !0,
            y = 0;
          for (const x of n) {
            const n = i.getTile(x),
              v = n.dem;
            if (g) {
              const t = f.getParameter(f.MAX_TEXTURE_SIZE),
                { elevationTexture: e, colorTexture: i } =
                  r.getColorRampTextures(d, t, v.getUnpackVector());
              d.activeTexture.set(f.TEXTURE1),
                e.bind(f.NEAREST, f.CLAMP_TO_EDGE),
                d.activeTexture.set(f.TEXTURE4),
                i.bind(f.LINEAR, f.CLAMP_TO_EDGE),
                (g = !1),
                (y = e.size[0]);
            }
            if (!v || !v.data) continue;
            const b = v.stride,
              w = v.getPixels();
            if (
              (d.activeTexture.set(f.TEXTURE0),
              d.pixelStoreUnpackPremultiplyAlpha.set(!1),
              (n.demTexture = n.demTexture || t.getTileTexture(b)),
              n.demTexture)
            ) {
              const t = n.demTexture;
              t.update(w, { premultiply: !1 }),
                t.bind(f.LINEAR, f.CLAMP_TO_EDGE);
            } else
              (n.demTexture = new e.T(d, w, f.RGBA, { premultiply: !1 })),
                n.demTexture.bind(f.LINEAR, f.CLAMP_TO_EDGE);
            const T = u.getMeshFromTileID(d, x.canonical, l, !0, 'raster'),
              P =
                null === (h = t.style.map.terrain) || void 0 === h
                  ? void 0
                  : h.getTerrainData(x),
              S = p.getProjectionData({
                overscaledTileID: x,
                aligned: _,
                applyGlobeMatrix: !c,
                applyTerrainMatrix: !0,
              });
            m.draw(
              d,
              f.TRIANGLES,
              a,
              o[x.overscaledZ],
              s,
              Ye.backCCW,
              Ki(r, n.dem, y),
              P,
              S,
              r.id,
              T.vertexBuffer,
              T.indexBuffer,
              T.segments
            );
          }
        }
        const Mn = [
          new e.P(0, 0),
          new e.P(e.a3, 0),
          new e.P(e.a3, e.a3),
          new e.P(0, e.a3),
        ];
        function In(t, e, i, r, n, o, a, s, l = !1, c = !1) {
          const h = r[r.length - 1].overscaledZ,
            u = t.context,
            d = u.gl,
            p = t.useProgram('raster'),
            f = t.transform,
            m = t.style.projection,
            _ = t.colorModeForRenderPass(),
            g = !t.options.moving,
            y = i.paint.get('raster-opacity'),
            x = i.paint.get('raster-resampling'),
            v = i.paint.get('raster-fade-duration'),
            b = !!t.style.map.terrain;
          for (const w of r) {
            const r = t.getDepthModeForSublayer(
                w.overscaledZ - h,
                1 === y ? He.ReadWrite : He.ReadOnly,
                d.LESS
              ),
              T = e.getTile(w),
              P = 'nearest' === x ? d.NEAREST : d.LINEAR;
            u.activeTexture.set(d.TEXTURE0),
              T.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST),
              u.activeTexture.set(d.TEXTURE1);
            const {
              parentTile: S,
              parentScaleBy: M,
              parentTopLeft: I,
              fadeValues: C,
            } = Cn(T, e, v, b);
            (T.fadeOpacity = C.tileOpacity),
              S
                ? ((S.fadeOpacity = C.parentTileOpacity),
                  S.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST))
                : T.texture.bind(P, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST),
              T.texture.useMipmap &&
                u.extTextureFilterAnisotropic &&
                t.transform.pitch > 20 &&
                d.texParameterf(
                  d.TEXTURE_2D,
                  u.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                  u.extTextureFilterAnisotropicMax
                );
            const A =
                t.style.map.terrain && t.style.map.terrain.getTerrainData(w),
              E = f.getProjectionData({
                overscaledTileID: w,
                aligned: g,
                applyGlobeMatrix: !c,
                applyTerrainMatrix: !0,
              }),
              z = or(I, M, C.fadeMix, i, s),
              k = m.getMeshFromTileID(u, w.canonical, o, a, 'raster');
            p.draw(
              u,
              d.TRIANGLES,
              r,
              n ? n[w.overscaledZ] : Ke.disabled,
              _,
              l ? Ye.frontCCW : Ye.backCCW,
              z,
              A,
              E,
              i.id,
              k.vertexBuffer,
              k.indexBuffer,
              k.segments
            );
          }
        }
        function Cn(t, i, r, n) {
          const o = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: { opacity: 1, mix: 0 },
            },
          };
          if (0 === r || n) return o;
          if (t.fadingParentID) {
            const n = i.getLoadedTile(t.fadingParentID);
            if (!n) return o;
            const a = Math.pow(2, n.tileID.overscaledZ - t.tileID.overscaledZ),
              s = [
                (t.tileID.canonical.x * a) % 1,
                (t.tileID.canonical.y * a) % 1,
              ],
              c = (function (t, i, r) {
                const n = l(),
                  o = (n - i.timeAdded) / r,
                  a = t.fadingDirection === ht.Incoming,
                  s = e.ai((n - t.timeAdded) / r, 0, 1),
                  c = e.ai(1 - o, 0, 1),
                  h = a ? s : c;
                return {
                  tileOpacity: h,
                  parentTileOpacity: a ? c : s,
                  fadeMix: { opacity: 1, mix: 1 - h },
                };
              })(t, n, r);
            return {
              parentTile: n,
              parentScaleBy: a,
              parentTopLeft: s,
              fadeValues: c,
            };
          }
          if (t.selfFading) {
            const i = (function (t, i) {
              const r = (l() - t.timeAdded) / i,
                n = e.ai(r, 0, 1);
              return { tileOpacity: n, fadeMix: { opacity: n, mix: 0 } };
            })(t, r);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: i,
            };
          }
          return o;
        }
        const An = new e.bi(1, 0, 0, 1),
          En = new e.bi(0, 1, 0, 1),
          zn = new e.bi(0, 0, 1, 1),
          kn = new e.bi(1, 0, 1, 1),
          Dn = new e.bi(0, 1, 1, 1);
        function Rn(t, e, i, r) {
          Fn(t, 0, e + i / 2, t.transform.width, i, r);
        }
        function Ln(t, e, i, r) {
          Fn(t, e - i / 2, 0, i, t.transform.height, r);
        }
        function Fn(t, e, i, r, n, o) {
          const a = t.context,
            s = a.gl;
          s.enable(s.SCISSOR_TEST),
            s.scissor(
              e * t.pixelRatio,
              i * t.pixelRatio,
              r * t.pixelRatio,
              n * t.pixelRatio
            ),
            a.clear({ color: o }),
            s.disable(s.SCISSOR_TEST);
        }
        function Bn(t, i, r) {
          const n = t.context,
            o = n.gl,
            a = t.useProgram('debug'),
            s = He.disabled,
            l = Ke.disabled,
            c = t.colorModeForRenderPass(),
            h = '$debug',
            u = t.style.map.terrain && t.style.map.terrain.getTerrainData(r);
          n.activeTexture.set(o.TEXTURE0);
          const d = i.getTileByID(r.key).latestRawTileData,
            p = Math.floor(((d && d.byteLength) || 0) / 1024),
            f = i.getTile(r).tileSize,
            m =
              (512 / Math.min(f, 512)) *
              (r.overscaledZ / t.transform.zoom) *
              0.5;
          let _ = r.canonical.toString();
          r.overscaledZ !== r.canonical.z && (_ += ` => ${r.overscaledZ}`),
            (function (t, e) {
              t.initDebugOverlayCanvas();
              const i = t.debugOverlayCanvas,
                r = t.context.gl,
                n = t.debugOverlayCanvas.getContext('2d');
              n.clearRect(0, 0, i.width, i.height),
                (n.shadowColor = 'white'),
                (n.shadowBlur = 2),
                (n.lineWidth = 1.5),
                (n.strokeStyle = 'white'),
                (n.textBaseline = 'top'),
                (n.font = 'bold 36px Open Sans, sans-serif'),
                n.fillText(e, 5, 5),
                n.strokeText(e, 5, 5),
                t.debugOverlayTexture.update(i),
                t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
            })(t, `${_} ${p}kB`);
          const g = t.transform.getProjectionData({
            overscaledTileID: r,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0,
          });
          a.draw(
            n,
            o.TRIANGLES,
            s,
            l,
            qe.alphaBlended,
            Ye.disabled,
            $i(e.bi.transparent, m),
            null,
            g,
            h,
            t.debugBuffer,
            t.quadTriangleIndexBuffer,
            t.debugSegments
          ),
            a.draw(
              n,
              o.LINE_STRIP,
              s,
              l,
              c,
              Ye.disabled,
              $i(e.bi.red),
              u,
              g,
              h,
              t.debugBuffer,
              t.tileBorderIndexBuffer,
              t.debugSegments
            );
        }
        function On(t, e, i, r) {
          const { isRenderingGlobe: n } = r,
            o = t.context,
            a = o.gl,
            s = t.transform,
            l = t.colorModeForRenderPass(),
            c = t.getDepthModeFor3D(),
            h = t.useProgram('terrain');
          o.bindFramebuffer.set(null),
            o.viewport.set([0, 0, t.width, t.height]);
          for (const u of i) {
            const i = e.getTerrainMesh(u.tileID),
              r = t.renderToTexture.getTexture(u),
              d = e.getTerrainData(u.tileID);
            o.activeTexture.set(a.TEXTURE0),
              a.bindTexture(a.TEXTURE_2D, r.texture);
            const p = e.getMeshFrameDelta(s.zoom),
              f = s.calculateFogMatrix(u.tileID.toUnwrapped()),
              m = ki(p, f, t.style.sky, s.pitch, n),
              _ = s.getProjectionData({
                overscaledTileID: u.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0,
              });
            h.draw(
              o,
              a.TRIANGLES,
              c,
              Ke.disabled,
              l,
              Ye.backCCW,
              m,
              d,
              _,
              'terrain',
              i.vertexBuffer,
              i.indexBuffer,
              i.segments
            );
          }
        }
        function jn(t, i) {
          if (!i.mesh) {
            const r = new e.aP();
            r.emplaceBack(-1, -1),
              r.emplaceBack(1, -1),
              r.emplaceBack(1, 1),
              r.emplaceBack(-1, 1);
            const n = new e.aR();
            n.emplaceBack(0, 1, 2),
              n.emplaceBack(0, 2, 3),
              (i.mesh = new Ae(
                t.createVertexBuffer(r, Ee.members),
                t.createIndexBuffer(n),
                e.aQ.simpleSegment(0, 0, r.length, n.length)
              ));
          }
          return i.mesh;
        }
        class Nn {
          constructor(t, i) {
            (this.context = new en(t)),
              (this.transform = i),
              (this._tileTextures = {}),
              (this.terrainFacilitator = {
                dirty: !0,
                matrix: e.am(new Float64Array(16)),
                renderTime: 0,
              }),
              this.setup(),
              (this.numSublayers = It.maxUnderzooming + It.maxOverzooming + 1),
              (this.depthEpsilon = 1 / Math.pow(2, 16)),
              (this.crossTileSymbolIndex = new Se());
          }
          resize(t, e, i) {
            if (
              ((this.width = Math.floor(t * i)),
              (this.height = Math.floor(e * i)),
              (this.pixelRatio = i),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.style)
            )
              for (const r of this.style._order) this.style._layers[r].resize();
          }
          setup() {
            const t = this.context,
              i = new e.aP();
            i.emplaceBack(0, 0),
              i.emplaceBack(e.a3, 0),
              i.emplaceBack(0, e.a3),
              i.emplaceBack(e.a3, e.a3),
              (this.tileExtentBuffer = t.createVertexBuffer(i, Ee.members)),
              (this.tileExtentSegments = e.aQ.simpleSegment(0, 0, 4, 2));
            const r = new e.aP();
            r.emplaceBack(0, 0),
              r.emplaceBack(e.a3, 0),
              r.emplaceBack(0, e.a3),
              r.emplaceBack(e.a3, e.a3),
              (this.debugBuffer = t.createVertexBuffer(r, Ee.members)),
              (this.debugSegments = e.aQ.simpleSegment(0, 0, 4, 5));
            const n = new e.ca();
            n.emplaceBack(0, 0, 0, 0),
              n.emplaceBack(e.a3, 0, e.a3, 0),
              n.emplaceBack(0, e.a3, 0, e.a3),
              n.emplaceBack(e.a3, e.a3, e.a3, e.a3),
              (this.rasterBoundsBuffer = t.createVertexBuffer(n, Ei.members)),
              (this.rasterBoundsSegments = e.aQ.simpleSegment(0, 0, 4, 2));
            const o = new e.aP();
            o.emplaceBack(0, 0),
              o.emplaceBack(e.a3, 0),
              o.emplaceBack(0, e.a3),
              o.emplaceBack(e.a3, e.a3),
              (this.rasterBoundsBufferPosOnly = t.createVertexBuffer(
                o,
                Ee.members
              )),
              (this.rasterBoundsSegmentsPosOnly = e.aQ.simpleSegment(
                0,
                0,
                4,
                5
              ));
            const a = new e.aP();
            a.emplaceBack(0, 0),
              a.emplaceBack(1, 0),
              a.emplaceBack(0, 1),
              a.emplaceBack(1, 1),
              (this.viewportBuffer = t.createVertexBuffer(a, Ee.members)),
              (this.viewportSegments = e.aQ.simpleSegment(0, 0, 4, 2));
            const s = new e.cb();
            s.emplaceBack(0),
              s.emplaceBack(1),
              s.emplaceBack(3),
              s.emplaceBack(2),
              s.emplaceBack(0),
              (this.tileBorderIndexBuffer = t.createIndexBuffer(s));
            const l = new e.aR();
            l.emplaceBack(1, 0, 2),
              l.emplaceBack(1, 2, 3),
              (this.quadTriangleIndexBuffer = t.createIndexBuffer(l));
            const c = this.context.gl;
            (this.stencilClearMode = new Ke(
              { func: c.ALWAYS, mask: 0 },
              0,
              255,
              c.ZERO,
              c.ZERO,
              c.ZERO
            )),
              (this.tileExtentMesh = new Ae(
                this.tileExtentBuffer,
                this.quadTriangleIndexBuffer,
                this.tileExtentSegments
              ));
          }
          clearStencil() {
            const t = this.context,
              i = t.gl;
            (this.nextStencilID = 1), (this.currentStencilSource = void 0);
            const r = e.M();
            e.c0(r, 0, this.width, this.height, 0, 0, 1),
              e.O(r, r, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const n = {
              mainMatrix: r,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: r,
            };
            this.useProgram('clippingMask', null, !0).draw(
              t,
              i.TRIANGLES,
              He.disabled,
              this.stencilClearMode,
              qe.disabled,
              Ye.disabled,
              null,
              null,
              n,
              '$clipping',
              this.viewportBuffer,
              this.quadTriangleIndexBuffer,
              this.viewportSegments
            );
          }
          _renderTileClippingMasks(t, e, i) {
            if (
              this.currentStencilSource === t.source ||
              !t.isTileClipped() ||
              !e ||
              !e.length
            )
              return;
            (this.currentStencilSource = t.source),
              this.nextStencilID + e.length > 256 && this.clearStencil();
            const r = this.context;
            r.setColorMode(qe.disabled), r.setDepthMode(He.disabled);
            const n = {};
            for (const o of e) n[o.key] = this.nextStencilID++;
            this._renderTileMasks(n, e, i, !0),
              this._renderTileMasks(n, e, i, !1),
              (this._tileClippingMaskIDs = n);
          }
          _renderTileMasks(t, e, i, r) {
            const n = this.context,
              o = n.gl,
              a = this.style.projection,
              s = this.transform,
              l = this.useProgram('clippingMask');
            for (const c of e) {
              const e = t[c.key],
                h =
                  this.style.map.terrain &&
                  this.style.map.terrain.getTerrainData(c),
                u = a.getMeshFromTileID(
                  this.context,
                  c.canonical,
                  r,
                  !0,
                  'stencil'
                ),
                d = s.getProjectionData({
                  overscaledTileID: c,
                  applyGlobeMatrix: !i,
                  applyTerrainMatrix: !0,
                });
              l.draw(
                n,
                o.TRIANGLES,
                He.disabled,
                new Ke(
                  { func: o.ALWAYS, mask: 0 },
                  e,
                  255,
                  o.KEEP,
                  o.KEEP,
                  o.REPLACE
                ),
                qe.disabled,
                i ? Ye.disabled : Ye.backCCW,
                null,
                h,
                d,
                '$clipping',
                u.vertexBuffer,
                u.indexBuffer,
                u.segments
              );
            }
          }
          _renderTilesDepthBuffer() {
            const t = this.context,
              e = t.gl,
              i = this.style.projection,
              r = this.transform,
              n = this.useProgram('depth'),
              o = this.getDepthModeFor3D(),
              a = St(r, { tileSize: r.tileSize });
            for (const s of a) {
              const a =
                  this.style.map.terrain &&
                  this.style.map.terrain.getTerrainData(s),
                l = i.getMeshFromTileID(
                  this.context,
                  s.canonical,
                  !0,
                  !0,
                  'raster'
                ),
                c = r.getProjectionData({
                  overscaledTileID: s,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0,
                });
              n.draw(
                t,
                e.TRIANGLES,
                o,
                Ke.disabled,
                qe.disabled,
                Ye.backCCW,
                null,
                a,
                c,
                '$clipping',
                l.vertexBuffer,
                l.indexBuffer,
                l.segments
              );
            }
          }
          stencilModeFor3D() {
            (this.currentStencilSource = void 0),
              this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++,
              e = this.context.gl;
            return new Ke(
              { func: e.NOTEQUAL, mask: 255 },
              t,
              255,
              e.KEEP,
              e.KEEP,
              e.REPLACE
            );
          }
          stencilModeForClipping(t) {
            const e = this.context.gl;
            return new Ke(
              { func: e.EQUAL, mask: 255 },
              this._tileClippingMaskIDs[t.key],
              0,
              e.KEEP,
              e.KEEP,
              e.REPLACE
            );
          }
          getStencilConfigForOverlapAndUpdateStencilID(t) {
            const e = this.context.gl,
              i = t.sort((t, e) => e.overscaledZ - t.overscaledZ),
              r = i[i.length - 1].overscaledZ,
              n = i[0].overscaledZ - r + 1;
            if (n > 1) {
              (this.currentStencilSource = void 0),
                this.nextStencilID + n > 256 && this.clearStencil();
              const t = {};
              for (let i = 0; i < n; i++)
                t[i + r] = new Ke(
                  { func: e.GEQUAL, mask: 255 },
                  i + this.nextStencilID,
                  255,
                  e.KEEP,
                  e.KEEP,
                  e.REPLACE
                );
              return (this.nextStencilID += n), [t, i];
            }
            return [{ [r]: Ke.disabled }, i];
          }
          stencilConfigForOverlapTwoPass(t) {
            const e = this.context.gl,
              i = t.sort((t, e) => e.overscaledZ - t.overscaledZ),
              r = i[i.length - 1].overscaledZ,
              n = i[0].overscaledZ - r + 1;
            if ((this.clearStencil(), n > 1)) {
              const t = {},
                o = {};
              for (let i = 0; i < n; i++)
                (t[i + r] = new Ke(
                  { func: e.GREATER, mask: 255 },
                  n + 1 + i,
                  255,
                  e.KEEP,
                  e.KEEP,
                  e.REPLACE
                )),
                  (o[i + r] = new Ke(
                    { func: e.GREATER, mask: 255 },
                    1 + i,
                    255,
                    e.KEEP,
                    e.KEEP,
                    e.REPLACE
                  ));
              return (this.nextStencilID = 2 * n + 1), [t, o, i];
            }
            return (
              (this.nextStencilID = 3),
              [
                {
                  [r]: new Ke(
                    { func: e.GREATER, mask: 255 },
                    2,
                    255,
                    e.KEEP,
                    e.KEEP,
                    e.REPLACE
                  ),
                },
                {
                  [r]: new Ke(
                    { func: e.GREATER, mask: 255 },
                    1,
                    255,
                    e.KEEP,
                    e.KEEP,
                    e.REPLACE
                  ),
                },
                i,
              ]
            );
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            if (this._showOverdrawInspector) {
              const i = 1 / 8;
              return new qe([t.CONSTANT_COLOR, t.ONE], new e.bi(i, i, i, 0), [
                !0,
                !0,
                !0,
                !0,
              ]);
            }
            return 'opaque' === this.renderPass
              ? qe.unblended
              : qe.alphaBlended;
          }
          getDepthModeForSublayer(t, e, i) {
            if (!this.opaquePassEnabledForLayer()) return He.disabled;
            const r =
              1 -
              ((1 + this.currentLayer) * this.numSublayers + t) *
                this.depthEpsilon;
            return new He(i || this.context.gl.LEQUAL, e, [r, r]);
          }
          getDepthModeFor3D() {
            return new He(
              this.context.gl.LEQUAL,
              He.ReadWrite,
              this.depthRangeFor3D
            );
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t, i) {
            var r, n;
            (this.style = t),
              (this.options = i),
              (this.lineAtlas = t.lineAtlas),
              (this.imageManager = t.imageManager),
              (this.glyphManager = t.glyphManager),
              (this.symbolFadeChange = t.placement.symbolFadeChange(l())),
              this.imageManager.beginFrame();
            const o = this.style._order,
              a = this.style.tileManagers,
              s = {},
              c = {},
              h = {},
              u = {
                isRenderingToTexture: !1,
                isRenderingGlobe:
                  (null === (r = t.projection) || void 0 === r
                    ? void 0
                    : r.transitionState) > 0,
              };
            for (const e in a) {
              const t = a[e];
              t.used && t.prepare(this.context),
                (s[e] = t.getVisibleCoordinates(!1)),
                (c[e] = s[e].slice().reverse()),
                (h[e] = t.getVisibleCoordinates(!0).reverse());
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e = 0; e < o.length; e++)
              if (this.style._layers[o[e]].is3D()) {
                this.opaquePassCutoff = e;
                break;
              }
            this.maybeDrawDepthAndCoords(!1),
              this.renderToTexture &&
                (this.renderToTexture.prepareForRender(
                  this.style,
                  this.transform.zoom
                ),
                (this.opaquePassCutoff = 0)),
              (this.renderPass = 'offscreen');
            for (const e of o) {
              const t = this.style._layers[e];
              if (!t.hasOffscreenPass() || t.isHidden(this.transform.zoom))
                continue;
              const i = c[t.source];
              ('custom' === t.type || i.length) &&
                this.renderLayer(this, a[t.source], t, i, u);
            }
            if (
              (null === (n = this.style.projection) ||
                void 0 === n ||
                n.updateGPUdependent({
                  context: this.context,
                  useProgram: (t) => this.useProgram(t),
                }),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.context.bindFramebuffer.set(null),
              this.context.clear({
                color: i.showOverdrawInspector ? e.bi.black : e.bi.transparent,
                depth: 1,
              }),
              this.clearStencil(),
              this.style.sky &&
                (function (t, e) {
                  const i = t.context,
                    r = i.gl,
                    n = ((t, e, i) => {
                      const r = Math.cos(e.rollInRadians),
                        n = Math.sin(e.rollInRadians),
                        o = gt(e),
                        a = e.getProjectionData({
                          overscaledTileID: null,
                          applyGlobeMatrix: !0,
                          applyTerrainMatrix: !0,
                        }).projectionTransition;
                      return {
                        u_sky_color: t.properties.get('sky-color'),
                        u_horizon_color: t.properties.get('horizon-color'),
                        u_horizon: [
                          (e.width / 2 - o * n) * i,
                          (e.height / 2 + o * r) * i,
                        ],
                        u_horizon_normal: [-n, r],
                        u_sky_horizon_blend:
                          ((t.properties.get('sky-horizon-blend') * e.height) /
                            2) *
                          i,
                        u_sky_blend: a,
                      };
                    })(e, t.style.map.transform, t.pixelRatio),
                    o = new He(r.LEQUAL, He.ReadWrite, [0, 1]),
                    a = Ke.disabled,
                    s = t.colorModeForRenderPass(),
                    l = t.useProgram('sky'),
                    c = jn(i, e);
                  l.draw(
                    i,
                    r.TRIANGLES,
                    o,
                    a,
                    s,
                    Ye.disabled,
                    n,
                    null,
                    void 0,
                    'sky',
                    c.vertexBuffer,
                    c.indexBuffer,
                    c.segments
                  );
                })(this, this.style.sky),
              (this._showOverdrawInspector = i.showOverdrawInspector),
              (this.depthRangeFor3D = [
                0,
                1 -
                  (t._order.length + 2) * this.numSublayers * this.depthEpsilon,
              ]),
              !this.renderToTexture)
            )
              for (
                this.renderPass = 'opaque', this.currentLayer = o.length - 1;
                this.currentLayer >= 0;
                this.currentLayer--
              ) {
                const t = this.style._layers[o[this.currentLayer]],
                  e = a[t.source],
                  i = s[t.source];
                this._renderTileClippingMasks(t, i, !1),
                  this.renderLayer(this, e, t, i, u);
              }
            this.renderPass = 'translucent';
            let d = !1;
            for (
              this.currentLayer = 0;
              this.currentLayer < o.length;
              this.currentLayer++
            ) {
              const t = this.style._layers[o[this.currentLayer]],
                e = a[t.source];
              if (
                this.renderToTexture &&
                this.renderToTexture.renderLayer(t, u)
              )
                continue;
              this.opaquePassEnabledForLayer() ||
                d ||
                ((d = !0),
                u.isRenderingGlobe &&
                  !this.style.map.terrain &&
                  this._renderTilesDepthBuffer());
              const i = ('symbol' === t.type ? h : c)[t.source];
              this._renderTileClippingMasks(
                t,
                s[t.source],
                !!this.renderToTexture
              ),
                this.renderLayer(this, e, t, i, u);
            }
            if (
              (u.isRenderingGlobe &&
                (function (t, i, r) {
                  const n = t.context,
                    o = n.gl,
                    a = t.useProgram('atmosphere'),
                    s = new He(o.LEQUAL, He.ReadOnly, [0, 1]),
                    l = t.transform,
                    c = (function (t, i) {
                      const r = t.properties.get('position'),
                        n = [-r.x, -r.y, -r.z],
                        o = e.am(new Float64Array(16));
                      return (
                        'map' === t.properties.get('anchor') &&
                          (e.b9(o, o, i.rollInRadians),
                          e.ba(o, o, -i.pitchInRadians),
                          e.b9(o, o, i.bearingInRadians),
                          e.ba(o, o, (i.center.lat * Math.PI) / 180),
                          e.bC(o, o, (-i.center.lng * Math.PI) / 180)),
                        e.c9(n, n, o),
                        n
                      );
                    })(r, t.transform),
                    h = l.getProjectionData({
                      overscaledTileID: null,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !0,
                    }),
                    u =
                      i.properties.get('atmosphere-blend') *
                      h.projectionTransition;
                  if (0 === u) return;
                  const d = hi(l.worldSize, l.center.lat),
                    p = l.inverseProjectionMatrix,
                    f = new Float64Array(4);
                  (f[3] = 1),
                    e.aA(f, f, l.modelViewProjectionMatrix),
                    (f[0] /= f[3]),
                    (f[1] /= f[3]),
                    (f[2] /= f[3]),
                    (f[3] = 1),
                    e.aA(f, f, p),
                    (f[0] /= f[3]),
                    (f[1] /= f[3]),
                    (f[2] /= f[3]),
                    (f[3] = 1);
                  const m = ((t, e, i, r, n) => ({
                      u_sun_pos: t,
                      u_atmosphere_blend: e,
                      u_globe_position: i,
                      u_globe_radius: r,
                      u_inv_proj_matrix: n,
                    }))(c, u, [f[0], f[1], f[2]], d, p),
                    _ = jn(n, i);
                  a.draw(
                    n,
                    o.TRIANGLES,
                    s,
                    Ke.disabled,
                    qe.alphaBlended,
                    Ye.disabled,
                    m,
                    null,
                    null,
                    'atmosphere',
                    _.vertexBuffer,
                    _.indexBuffer,
                    _.segments
                  );
                })(this, this.style.sky, this.style.light),
              this.options.showTileBoundaries)
            ) {
              const t = (function (t, e) {
                let i = null;
                const r = Object.values(t._layers).flatMap((i) =>
                    i.source && !i.isHidden(e) ? [t.tileManagers[i.source]] : []
                  ),
                  n = r.filter((t) => 'vector' === t.getSource().type),
                  o = r.filter((t) => 'vector' !== t.getSource().type),
                  a = (t) => {
                    (!i || i.getSource().maxzoom < t.getSource().maxzoom) &&
                      (i = t);
                  };
                return n.forEach((t) => a(t)), i || o.forEach((t) => a(t)), i;
              })(this.style, this.transform.zoom);
              t &&
                (function (t, e, i) {
                  for (let r = 0; r < i.length; r++) Bn(t, e, i[r]);
                })(this, t, t.getVisibleCoordinates());
            }
            this.options.showPadding &&
              (function (t) {
                const e = t.transform.padding;
                Rn(t, t.transform.height - (e.top || 0), 3, An),
                  Rn(t, e.bottom || 0, 3, En),
                  Ln(t, e.left || 0, 3, zn),
                  Ln(t, t.transform.width - (e.right || 0), 3, kn);
                const i = t.transform.centerPoint;
                !(function (t, e, i, r) {
                  Fn(t, e - 1, i - 10, 2, 20, r),
                    Fn(t, e - 10, i - 1, 20, 2, r);
                })(t, i.x, t.transform.height - i.y, Dn);
              })(this),
              this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t) {
            if (!this.style || !this.style.map || !this.style.map.terrain)
              return;
            const i = this.terrainFacilitator.matrix,
              r = this.transform.modelViewProjectionMatrix;
            let n = this.terrainFacilitator.dirty;
            n || (n = t ? !e.cc(i, r) : !e.cd(i, r)),
              n ||
                (n = this.style.map.terrain.tileManager.anyTilesAfterTime(
                  this.terrainFacilitator.renderTime
                )),
              n &&
                (e.ce(i, r),
                (this.terrainFacilitator.renderTime = Date.now()),
                (this.terrainFacilitator.dirty = !1),
                (function (t, i) {
                  const r = t.context,
                    n = r.gl,
                    o = t.transform,
                    a = qe.unblended,
                    s = new He(n.LEQUAL, He.ReadWrite, [0, 1]),
                    l = i.tileManager.getRenderableTiles(),
                    c = t.useProgram('terrainDepth');
                  r.bindFramebuffer.set(i.getFramebuffer('depth').framebuffer),
                    r.viewport.set([
                      0,
                      0,
                      t.width / devicePixelRatio,
                      t.height / devicePixelRatio,
                    ]),
                    r.clear({ color: e.bi.transparent, depth: 1 });
                  for (const e of l) {
                    const t = i.getTerrainMesh(e.tileID),
                      l = i.getTerrainData(e.tileID),
                      h = o.getProjectionData({
                        overscaledTileID: e.tileID,
                        applyTerrainMatrix: !1,
                        applyGlobeMatrix: !0,
                      }),
                      u = { u_ele_delta: i.getMeshFrameDelta(o.zoom) };
                    c.draw(
                      r,
                      n.TRIANGLES,
                      s,
                      Ke.disabled,
                      a,
                      Ye.backCCW,
                      u,
                      l,
                      h,
                      'terrain',
                      t.vertexBuffer,
                      t.indexBuffer,
                      t.segments
                    );
                  }
                  r.bindFramebuffer.set(null),
                    r.viewport.set([0, 0, t.width, t.height]);
                })(this, this.style.map.terrain),
                (function (t, i) {
                  const r = t.context,
                    n = r.gl,
                    o = t.transform,
                    a = qe.unblended,
                    s = new He(n.LEQUAL, He.ReadWrite, [0, 1]),
                    l = i.getCoordsTexture(),
                    c = i.tileManager.getRenderableTiles(),
                    h = t.useProgram('terrainCoords');
                  r.bindFramebuffer.set(i.getFramebuffer('coords').framebuffer),
                    r.viewport.set([
                      0,
                      0,
                      t.width / devicePixelRatio,
                      t.height / devicePixelRatio,
                    ]),
                    r.clear({ color: e.bi.transparent, depth: 1 }),
                    (i.coordsIndex = []);
                  for (const e of c) {
                    const t = i.getTerrainMesh(e.tileID),
                      c = i.getTerrainData(e.tileID);
                    r.activeTexture.set(n.TEXTURE0),
                      n.bindTexture(n.TEXTURE_2D, l.texture);
                    const u = {
                        u_terrain_coords_id: (255 - i.coordsIndex.length) / 255,
                        u_texture: 0,
                        u_ele_delta: i.getMeshFrameDelta(o.zoom),
                      },
                      d = o.getProjectionData({
                        overscaledTileID: e.tileID,
                        applyTerrainMatrix: !1,
                        applyGlobeMatrix: !0,
                      });
                    h.draw(
                      r,
                      n.TRIANGLES,
                      s,
                      Ke.disabled,
                      a,
                      Ye.backCCW,
                      u,
                      c,
                      d,
                      'terrain',
                      t.vertexBuffer,
                      t.indexBuffer,
                      t.segments
                    ),
                      i.coordsIndex.push(e.tileID.key);
                  }
                  r.bindFramebuffer.set(null),
                    r.viewport.set([0, 0, t.width, t.height]);
                })(this, this.style.map.terrain));
          }
          renderLayer(t, i, r, n, o) {
            r.isHidden(this.transform.zoom) ||
              (('background' === r.type ||
                'custom' === r.type ||
                (n || []).length) &&
                ((this.id = r.id),
                e.cf(r)
                  ? (function (t, i, r, n, o, a) {
                      if ('translucent' !== t.renderPass) return;
                      const { isRenderingToTexture: s } = a,
                        l = Ke.disabled,
                        c = t.colorModeForRenderPass();
                      (r._unevaluatedLayout.hasValue('text-variable-anchor') ||
                        r._unevaluatedLayout.hasValue(
                          'text-variable-anchor-offset'
                        )) &&
                        (function (t, i, r, n, o, a, s, l, c) {
                          const h = i.transform,
                            u = i.style.map.terrain,
                            d = 'map' === o,
                            p = 'map' === a;
                          for (const f of t) {
                            const t = n.getTile(f),
                              o = t.getBucket(r);
                            if (!o || !o.text || !o.text.segments.get().length)
                              continue;
                            const a = e.ar(o.textSizeData, h.zoom),
                              m = e.aG(t, 1, i.transform.zoom),
                              _ = Dt(d, i.transform, m),
                              g =
                                'none' !== r.layout.get('icon-text-fit') &&
                                o.hasIconData();
                            if (a) {
                              const i = Math.pow(
                                  2,
                                  h.zoom - t.tileID.overscaledZ
                                ),
                                r = u
                                  ? (t, e) => u.getElevation(f, t, e)
                                  : null;
                              ln(
                                o,
                                d,
                                p,
                                c,
                                h,
                                _,
                                i,
                                a,
                                g,
                                e.aH(h, t, s, l),
                                f.toUnwrapped(),
                                r
                              );
                            }
                          }
                        })(
                          n,
                          t,
                          r,
                          i,
                          r.layout.get('text-rotation-alignment'),
                          r.layout.get('text-pitch-alignment'),
                          r.paint.get('text-translate'),
                          r.paint.get('text-translate-anchor'),
                          o
                        ),
                        0 !== r.paint.get('icon-opacity').constantOr(1) &&
                          hn(
                            t,
                            i,
                            r,
                            n,
                            !1,
                            r.paint.get('icon-translate'),
                            r.paint.get('icon-translate-anchor'),
                            r.layout.get('icon-rotation-alignment'),
                            r.layout.get('icon-pitch-alignment'),
                            r.layout.get('icon-keep-upright'),
                            l,
                            c,
                            s
                          ),
                        0 !== r.paint.get('text-opacity').constantOr(1) &&
                          hn(
                            t,
                            i,
                            r,
                            n,
                            !0,
                            r.paint.get('text-translate'),
                            r.paint.get('text-translate-anchor'),
                            r.layout.get('text-rotation-alignment'),
                            r.layout.get('text-pitch-alignment'),
                            r.layout.get('text-keep-upright'),
                            l,
                            c,
                            s
                          ),
                        i.map.showCollisionBoxes &&
                          (nn(t, i, r, n, !0), nn(t, i, r, n, !1));
                    })(t, i, r, n, this.style.placement.variableOffsets, o)
                  : e.cg(r)
                  ? (function (t, i, r, n, o) {
                      if ('translucent' !== t.renderPass) return;
                      const { isRenderingToTexture: a } = o,
                        s = r.paint.get('circle-opacity'),
                        l = r.paint.get('circle-stroke-width'),
                        c = r.paint.get('circle-stroke-opacity'),
                        h = !r.layout.get('circle-sort-key').isConstant();
                      if (
                        0 === s.constantOr(1) &&
                        (0 === l.constantOr(1) || 0 === c.constantOr(1))
                      )
                        return;
                      const u = t.context,
                        d = u.gl,
                        p = t.transform,
                        f = t.getDepthModeForSublayer(0, He.ReadOnly),
                        m = Ke.disabled,
                        _ = t.colorModeForRenderPass(),
                        g = [],
                        y = p.getCircleRadiusCorrection();
                      for (let x = 0; x < n.length; x++) {
                        const o = n[x],
                          s = i.getTile(o),
                          l = s.getBucket(r);
                        if (!l) continue;
                        const c = r.paint.get('circle-translate'),
                          u = r.paint.get('circle-translate-anchor'),
                          d = e.aH(p, s, c, u),
                          f = l.programConfigurations.get(r.id),
                          m = t.useProgram('circle', f),
                          _ = l.layoutVertexBuffer,
                          v = l.indexBuffer,
                          b =
                            t.style.map.terrain &&
                            t.style.map.terrain.getTerrainData(o),
                          w = {
                            programConfiguration: f,
                            program: m,
                            layoutVertexBuffer: _,
                            indexBuffer: v,
                            uniformValues: Ui(t, s, r, d, y),
                            terrainData: b,
                            projectionData: p.getProjectionData({
                              overscaledTileID: o,
                              applyGlobeMatrix: !a,
                              applyTerrainMatrix: !0,
                            }),
                          };
                        if (h) {
                          const t = l.segments.get();
                          for (const i of t)
                            g.push({
                              segments: new e.aQ([i]),
                              sortKey: i.sortKey,
                              state: w,
                            });
                        } else
                          g.push({
                            segments: l.segments,
                            sortKey: 0,
                            state: w,
                          });
                      }
                      h && g.sort((t, e) => t.sortKey - e.sortKey);
                      for (const e of g) {
                        const {
                          programConfiguration: i,
                          program: n,
                          layoutVertexBuffer: o,
                          indexBuffer: a,
                          uniformValues: s,
                          terrainData: l,
                          projectionData: c,
                        } = e.state;
                        n.draw(
                          u,
                          d.TRIANGLES,
                          f,
                          m,
                          _,
                          Ye.backCCW,
                          s,
                          l,
                          c,
                          r.id,
                          o,
                          a,
                          e.segments,
                          r.paint,
                          t.transform.zoom,
                          i
                        );
                      }
                    })(t, i, r, n, o)
                  : e.ch(r)
                  ? (function (t, i, r, n, o) {
                      if (0 === r.paint.get('heatmap-opacity')) return;
                      const a = t.context,
                        { isRenderingToTexture: s, isRenderingGlobe: l } = o;
                      if (t.style.map.terrain) {
                        for (const e of n) {
                          const n = i.getTile(e);
                          i.hasRenderableParent(e) ||
                            ('offscreen' === t.renderPass
                              ? dn(t, n, r, e, l)
                              : 'translucent' === t.renderPass &&
                                pn(t, r, e, s, l));
                        }
                        a.viewport.set([0, 0, t.width, t.height]);
                      } else
                        'offscreen' === t.renderPass
                          ? (function (t, i, r, n) {
                              const o = t.context,
                                a = o.gl,
                                s = t.transform,
                                l = Ke.disabled,
                                c = new qe([a.ONE, a.ONE], e.bi.transparent, [
                                  !0,
                                  !0,
                                  !0,
                                  !0,
                                ]);
                              (function (t, i, r) {
                                const n = t.gl;
                                t.activeTexture.set(n.TEXTURE1),
                                  t.viewport.set([
                                    0,
                                    0,
                                    i.width / 4,
                                    i.height / 4,
                                  ]);
                                let o = r.heatmapFbos.get(e.c6);
                                o
                                  ? (n.bindTexture(
                                      n.TEXTURE_2D,
                                      o.colorAttachment.get()
                                    ),
                                    t.bindFramebuffer.set(o.framebuffer))
                                  : ((o = fn(t, i.width / 4, i.height / 4)),
                                    r.heatmapFbos.set(e.c6, o));
                              })(o, t, r),
                                o.clear({ color: e.bi.transparent });
                              for (let e = 0; e < n.length; e++) {
                                const h = n[e];
                                if (i.hasRenderableParent(h)) continue;
                                const u = i.getTile(h),
                                  d = u.getBucket(r);
                                if (!d) continue;
                                const p = d.programConfigurations.get(r.id),
                                  f = t.useProgram('heatmap', p),
                                  m = s.getProjectionData({
                                    overscaledTileID: h,
                                    applyGlobeMatrix: !0,
                                    applyTerrainMatrix: !1,
                                  }),
                                  _ = s.getCircleRadiusCorrection();
                                f.draw(
                                  o,
                                  a.TRIANGLES,
                                  He.disabled,
                                  l,
                                  c,
                                  Ye.backCCW,
                                  qi(
                                    u,
                                    s.zoom,
                                    r.paint.get('heatmap-intensity'),
                                    _
                                  ),
                                  null,
                                  m,
                                  r.id,
                                  d.layoutVertexBuffer,
                                  d.indexBuffer,
                                  d.segments,
                                  r.paint,
                                  s.zoom,
                                  p
                                );
                              }
                              o.viewport.set([0, 0, t.width, t.height]);
                            })(t, i, r, n)
                          : 'translucent' === t.renderPass &&
                            (function (t, i) {
                              const r = t.context,
                                n = r.gl;
                              r.setColorMode(t.colorModeForRenderPass());
                              const o = i.heatmapFbos.get(e.c6);
                              o &&
                                (r.activeTexture.set(n.TEXTURE0),
                                n.bindTexture(
                                  n.TEXTURE_2D,
                                  o.colorAttachment.get()
                                ),
                                r.activeTexture.set(n.TEXTURE1),
                                mn(r, i).bind(n.LINEAR, n.CLAMP_TO_EDGE),
                                t
                                  .useProgram('heatmapTexture')
                                  .draw(
                                    r,
                                    n.TRIANGLES,
                                    He.disabled,
                                    Ke.disabled,
                                    t.colorModeForRenderPass(),
                                    Ye.disabled,
                                    Wi(t, i, 0, 1),
                                    null,
                                    null,
                                    i.id,
                                    t.viewportBuffer,
                                    t.quadTriangleIndexBuffer,
                                    t.viewportSegments,
                                    i.paint,
                                    t.transform.zoom
                                  ));
                            })(t, r);
                    })(t, i, r, n, o)
                  : e.ci(r)
                  ? (function (t, e, i, r, n) {
                      if ('translucent' !== t.renderPass) return;
                      const { isRenderingToTexture: o } = n,
                        a = i.paint.get('line-opacity'),
                        s = i.paint.get('line-width');
                      if (0 === a.constantOr(1) || 0 === s.constantOr(1))
                        return;
                      const l = t.getDepthModeForSublayer(0, He.ReadOnly),
                        c = t.colorModeForRenderPass(),
                        h = i.paint.get('line-dasharray'),
                        u = h.constantOr(1),
                        d = i.paint.get('line-pattern'),
                        p = d.constantOr(1),
                        f = i.paint.get('line-gradient'),
                        m = i.getCrossfadeParameters();
                      let _;
                      _ = p
                        ? 'linePattern'
                        : u && f
                        ? 'lineGradientSDF'
                        : u
                        ? 'lineSDF'
                        : f
                        ? 'lineGradient'
                        : 'line';
                      const g = t.context,
                        y = g.gl,
                        x = t.transform;
                      let v = !0;
                      for (const b of r) {
                        const r = e.getTile(b);
                        if (p && !r.patternsLoaded()) continue;
                        const n = r.getBucket(i);
                        if (!n) continue;
                        const a = n.programConfigurations.get(i.id),
                          s = t.context.program.get(),
                          w = t.useProgram(_, a),
                          T = v || w.program !== s,
                          P =
                            t.style.map.terrain &&
                            t.style.map.terrain.getTerrainData(b),
                          S = d.constantOr(null),
                          M = h && h.constantOr(null);
                        if (S && r.imageAtlas) {
                          const t = r.imageAtlas,
                            e = t.patternPositions[S.to.toString()],
                            i = t.patternPositions[S.from.toString()];
                          e && i && a.setConstantPatternPositions(e, i);
                        } else if (M) {
                          const e = 'round' === i.layout.get('line-cap'),
                            r = t.lineAtlas.getDash(M.to, e),
                            n = t.lineAtlas.getDash(M.from, e);
                          a.setConstantDashPositions(r, n);
                        }
                        const I = x.getProjectionData({
                            overscaledTileID: b,
                            applyGlobeMatrix: !o,
                            applyTerrainMatrix: !0,
                          }),
                          C = x.getPixelScale();
                        let A;
                        p
                          ? ((A = tr(t, r, i, C, m)), gn(g, y, r, a, m))
                          : u && f
                          ? ((A = ir(t, r, i, C, m, n.lineClipsArray.length)),
                            vn(t, e, g, y, i, n, b, a, m))
                          : u
                          ? ((A = er(t, r, i, C, m)), yn(t, g, y, a, T, m))
                          : f
                          ? ((A = Qi(t, r, i, C, n.lineClipsArray.length)),
                            xn(t, e, g, y, i, n, b))
                          : (A = Ji(t, r, i, C));
                        const E = t.stencilModeForClipping(b);
                        w.draw(
                          g,
                          y.TRIANGLES,
                          l,
                          E,
                          c,
                          Ye.disabled,
                          A,
                          P,
                          I,
                          i.id,
                          n.layoutVertexBuffer,
                          n.indexBuffer,
                          n.segments,
                          i.paint,
                          t.transform.zoom,
                          a,
                          n.layoutVertexBuffer2
                        ),
                          (v = !1);
                      }
                    })(t, i, r, n, o)
                  : e.cj(r)
                  ? (function (t, i, r, n, o) {
                      const a = r.paint.get('fill-color'),
                        s = r.paint.get('fill-opacity');
                      if (0 === s.constantOr(1)) return;
                      const { isRenderingToTexture: l } = o,
                        c = t.colorModeForRenderPass(),
                        h = r.paint.get('fill-pattern'),
                        u =
                          t.opaquePassEnabledForLayer() &&
                          !h.constantOr(1) &&
                          1 === a.constantOr(e.bi.transparent).a &&
                          1 === s.constantOr(0)
                            ? 'opaque'
                            : 'translucent';
                      if (t.renderPass === u) {
                        const e = t.getDepthModeForSublayer(
                          1,
                          'opaque' === t.renderPass ? He.ReadWrite : He.ReadOnly
                        );
                        wn(t, i, r, n, e, c, !1, l);
                      }
                      if (
                        'translucent' === t.renderPass &&
                        r.paint.get('fill-antialias')
                      ) {
                        const e = t.getDepthModeForSublayer(
                          r.getPaintProperty('fill-outline-color') ? 2 : 0,
                          He.ReadOnly
                        );
                        wn(t, i, r, n, e, c, !0, l);
                      }
                    })(t, i, r, n, o)
                  : e.ck(r)
                  ? (function (t, e, i, r, n) {
                      const o = i.paint.get('fill-extrusion-opacity');
                      if (0 === o) return;
                      const { isRenderingToTexture: a } = n;
                      if ('translucent' === t.renderPass) {
                        const n = new He(
                          t.context.gl.LEQUAL,
                          He.ReadWrite,
                          t.depthRangeFor3D
                        );
                        if (
                          1 !== o ||
                          i.paint.get('fill-extrusion-pattern').constantOr(1)
                        )
                          Tn(t, e, i, r, n, Ke.disabled, qe.disabled, a),
                            Tn(
                              t,
                              e,
                              i,
                              r,
                              n,
                              t.stencilModeFor3D(),
                              t.colorModeForRenderPass(),
                              a
                            );
                        else {
                          const o = t.colorModeForRenderPass();
                          Tn(t, e, i, r, n, Ke.disabled, o, a);
                        }
                      }
                    })(t, i, r, n, o)
                  : e.cl(r)
                  ? (function (t, i, r, n, o) {
                      if (
                        'offscreen' !== t.renderPass &&
                        'translucent' !== t.renderPass
                      )
                        return;
                      const { isRenderingToTexture: a } = o,
                        s = t.context,
                        l = t.style.projection.useSubdivision,
                        c = t.getDepthModeForSublayer(0, He.ReadOnly),
                        h = t.colorModeForRenderPass();
                      if ('offscreen' === t.renderPass)
                        !(function (t, i, r, n, o, a, s) {
                          const l = t.context,
                            c = l.gl;
                          for (const h of r) {
                            const r = i.getTile(h),
                              u = r.dem;
                            if (!u || !u.data) continue;
                            if (!r.needsHillshadePrepare) continue;
                            const d = u.dim,
                              p = u.stride,
                              f = u.getPixels();
                            if (
                              (l.activeTexture.set(c.TEXTURE1),
                              l.pixelStoreUnpackPremultiplyAlpha.set(!1),
                              (r.demTexture =
                                r.demTexture || t.getTileTexture(p)),
                              r.demTexture)
                            ) {
                              const t = r.demTexture;
                              t.update(f, { premultiply: !1 }),
                                t.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                            } else
                              (r.demTexture = new e.T(l, f, c.RGBA, {
                                premultiply: !1,
                              })),
                                r.demTexture.bind(c.NEAREST, c.CLAMP_TO_EDGE);
                            l.activeTexture.set(c.TEXTURE0);
                            let m = r.fbo;
                            if (!m) {
                              const t = new e.T(
                                l,
                                { width: d, height: d, data: null },
                                c.RGBA
                              );
                              t.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                                (m = r.fbo = l.createFramebuffer(d, d, !0, !1)),
                                m.colorAttachment.set(t.texture);
                            }
                            l.bindFramebuffer.set(m.framebuffer),
                              l.viewport.set([0, 0, d, d]),
                              t
                                .useProgram('hillshadePrepare')
                                .draw(
                                  l,
                                  c.TRIANGLES,
                                  o,
                                  a,
                                  s,
                                  Ye.disabled,
                                  Hi(r.tileID, u),
                                  null,
                                  null,
                                  n.id,
                                  t.rasterBoundsBuffer,
                                  t.quadTriangleIndexBuffer,
                                  t.rasterBoundsSegments
                                ),
                              (r.needsHillshadePrepare = !1);
                          }
                        })(t, i, n, r, c, Ke.disabled, h),
                          s.viewport.set([0, 0, t.width, t.height]);
                      else if ('translucent' === t.renderPass)
                        if (l) {
                          const [e, o, s] = t.stencilConfigForOverlapTwoPass(n);
                          Pn(t, i, r, s, e, c, h, !1, a),
                            Pn(t, i, r, s, o, c, h, !0, a);
                        } else {
                          const [e, o] =
                            t.getStencilConfigForOverlapAndUpdateStencilID(n);
                          Pn(t, i, r, o, e, c, h, !1, a);
                        }
                    })(t, i, r, n, o)
                  : e.cm(r)
                  ? (function (t, e, i, r, n) {
                      if ('translucent' !== t.renderPass) return;
                      if (!r.length) return;
                      const { isRenderingToTexture: o } = n,
                        a = t.style.projection.useSubdivision,
                        s = t.getDepthModeForSublayer(0, He.ReadOnly),
                        l = t.colorModeForRenderPass();
                      if (a) {
                        const [n, a, c] = t.stencilConfigForOverlapTwoPass(r);
                        Sn(t, e, i, c, n, s, l, !1, o),
                          Sn(t, e, i, c, a, s, l, !0, o);
                      } else {
                        const [n, a] =
                          t.getStencilConfigForOverlapAndUpdateStencilID(r);
                        Sn(t, e, i, a, n, s, l, !1, o);
                      }
                    })(t, i, r, n, o)
                  : e.bN(r)
                  ? (function (t, e, i, r, n) {
                      if ('translucent' !== t.renderPass) return;
                      if (0 === i.paint.get('raster-opacity')) return;
                      if (!r.length) return;
                      const { isRenderingToTexture: o } = n,
                        a = e.getSource(),
                        s = t.style.projection.useSubdivision;
                      if (a instanceof tt)
                        In(
                          t,
                          e,
                          i,
                          r,
                          null,
                          !1,
                          !1,
                          a.tileCoords,
                          a.flippedWindingOrder,
                          o
                        );
                      else if (s) {
                        const [n, a, s] = t.stencilConfigForOverlapTwoPass(r);
                        In(t, e, i, s, n, !1, !0, Mn, !1, o),
                          In(t, e, i, s, a, !0, !0, Mn, !1, o);
                      } else {
                        const [n, a] =
                          t.getStencilConfigForOverlapAndUpdateStencilID(r);
                        In(t, e, i, a, n, !1, !0, Mn, !1, o);
                      }
                    })(t, i, r, n, o)
                  : e.cn(r)
                  ? (function (t, e, i, r, n) {
                      const o = i.paint.get('background-color'),
                        a = i.paint.get('background-opacity');
                      if (0 === a) return;
                      const { isRenderingToTexture: s } = n,
                        l = t.context,
                        c = l.gl,
                        h = t.style.projection,
                        u = t.transform,
                        d = u.tileSize,
                        p = i.paint.get('background-pattern');
                      if (t.isPatternMissing(p)) return;
                      const f =
                        !p &&
                        1 === o.a &&
                        1 === a &&
                        t.opaquePassEnabledForLayer()
                          ? 'opaque'
                          : 'translucent';
                      if (t.renderPass !== f) return;
                      const m = Ke.disabled,
                        _ = t.getDepthModeForSublayer(
                          0,
                          'opaque' === f ? He.ReadWrite : He.ReadOnly
                        ),
                        g = t.colorModeForRenderPass(),
                        y = t.useProgram(
                          p ? 'backgroundPattern' : 'background'
                        ),
                        x =
                          r ||
                          St(u, { tileSize: d, terrain: t.style.map.terrain });
                      p &&
                        (l.activeTexture.set(c.TEXTURE0),
                        t.imageManager.bind(t.context));
                      const v = i.getCrossfadeParameters();
                      for (const b of x) {
                        const e = u.getProjectionData({
                            overscaledTileID: b,
                            applyGlobeMatrix: !s,
                            applyTerrainMatrix: !0,
                          }),
                          r = p
                            ? ur(a, t, p, { tileID: b, tileSize: d }, v)
                            : hr(a, o),
                          n =
                            t.style.map.terrain &&
                            t.style.map.terrain.getTerrainData(b),
                          f = h.getMeshFromTileID(
                            l,
                            b.canonical,
                            !1,
                            !0,
                            'raster'
                          );
                        y.draw(
                          l,
                          c.TRIANGLES,
                          _,
                          m,
                          g,
                          Ye.backCCW,
                          r,
                          n,
                          e,
                          i.id,
                          f.vertexBuffer,
                          f.indexBuffer,
                          f.segments
                        );
                      }
                    })(t, 0, r, n, o)
                  : e.co(r) &&
                    (function (t, e, i, r) {
                      const { isRenderingGlobe: n } = r,
                        o = t.context,
                        a = i.implementation,
                        s = t.style.projection,
                        l = t.transform,
                        c = l.getProjectionDataForCustomLayer(n),
                        h = {
                          farZ: l.farZ,
                          nearZ: l.nearZ,
                          fov: (l.fov * Math.PI) / 180,
                          modelViewProjectionMatrix:
                            l.modelViewProjectionMatrix,
                          projectionMatrix: l.projectionMatrix,
                          shaderData: {
                            variantName: s.shaderVariantName,
                            vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${s.shaderPreludeCode.vertexSource}`,
                            define: s.shaderDefine,
                          },
                          defaultProjectionData: c,
                        },
                        u = a.renderingMode ? a.renderingMode : '2d';
                      if ('offscreen' === t.renderPass) {
                        const e = a.prerender;
                        e &&
                          (t.setCustomLayerDefaults(),
                          o.setColorMode(t.colorModeForRenderPass()),
                          e.call(a, o.gl, h),
                          o.setDirty(),
                          t.setBaseState());
                      } else if ('translucent' === t.renderPass) {
                        t.setCustomLayerDefaults(),
                          o.setColorMode(t.colorModeForRenderPass()),
                          o.setStencilMode(Ke.disabled);
                        const e =
                          '3d' === u
                            ? t.getDepthModeFor3D()
                            : t.getDepthModeForSublayer(0, He.ReadOnly);
                        o.setDepthMode(e),
                          a.render(o.gl, h),
                          o.setDirty(),
                          t.setBaseState(),
                          o.bindFramebuffer.set(null);
                      }
                    })(t, 0, r, o)));
          }
          saveTileTexture(t) {
            const e = this._tileTextures[t.size[0]];
            e ? e.push(t) : (this._tileTextures[t.size[0]] = [t]);
          }
          getTileTexture(t) {
            const e = this._tileTextures[t];
            return e && e.length > 0 ? e.pop() : null;
          }
          isPatternMissing(t) {
            if (!t) return !1;
            if (!t.from || !t.to) return !0;
            const e = this.imageManager.getPattern(t.from.toString()),
              i = this.imageManager.getPattern(t.to.toString());
            return !e || !i;
          }
          useProgram(t, e, i = !1, r = []) {
            this.cache = this.cache || {};
            const n = !!this.style.map.terrain,
              o = this.style.projection,
              a = i ? Ie.projectionMercator : o.shaderPreludeCode,
              s = i ? ze : o.shaderDefine,
              l =
                t +
                (e ? e.cacheKey : '') +
                `/${i ? ke : o.shaderVariantName}` +
                (this._showOverdrawInspector ? '/overdraw' : '') +
                (n ? '/terrain' : '') +
                (r ? `/${r.join('/')}` : '');
            return (
              this.cache[l] ||
                (this.cache[l] = new Li(
                  this.context,
                  Ie[t],
                  e,
                  pr[t],
                  this._showOverdrawInspector,
                  n,
                  a,
                  s,
                  r
                )),
              this.cache[l]
            );
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(),
              this.context.cullFace.setDefault(),
              this.context.activeTexture.setDefault(),
              this.context.pixelStoreUnpack.setDefault(),
              this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
              this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(!1),
              this.context.viewport.set([0, 0, this.width, this.height]),
              this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas &&
              ((this.debugOverlayCanvas = document.createElement('canvas')),
              (this.debugOverlayCanvas.width = 512),
              (this.debugOverlayCanvas.height = 512),
              (this.debugOverlayTexture = new e.T(
                this.context,
                this.debugOverlayCanvas,
                this.context.gl.RGBA
              )));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t, drawingBufferHeight: e } =
              this.context.gl;
            return this.width !== t || this.height !== e;
          }
        }
        function Vn(t, e) {
          let i,
            r = !1,
            n = null,
            o = null;
          const a = () => {
            (n = null), r && (t.apply(o, i), (n = setTimeout(a, e)), (r = !1));
          };
          return (...t) => ((r = !0), (o = this), (i = t), n || a(), n);
        }
        class Un {
          constructor(t) {
            (this._getCurrentHash = () => {
              const t = window.location.hash.replace('#', '');
              if (this._hashName) {
                let e;
                return (
                  t
                    .split('&')
                    .map((t) => t.split('='))
                    .forEach((t) => {
                      t[0] === this._hashName && (e = t);
                    }),
                  ((e && e[1]) || '').split('/')
                );
              }
              return t.split('/');
            }),
              (this._onHashChange = () => {
                const t = this._getCurrentHash();
                if (!this._isValidHash(t)) return !1;
                const e =
                  this._map.dragRotate.isEnabled() &&
                  this._map.touchZoomRotate.isEnabled()
                    ? +(t[3] || 0)
                    : this._map.getBearing();
                return (
                  this._map.jumpTo({
                    center: [+t[2], +t[1]],
                    zoom: +t[0],
                    bearing: e,
                    pitch: +(t[4] || 0),
                  }),
                  !0
                );
              }),
              (this._updateHashUnthrottled = () => {
                const t = window.location.href.replace(
                  /(#.*)?$/,
                  this.getHashString()
                );
                window.history.replaceState(window.history.state, null, t);
              }),
              (this._removeHash = () => {
                const t = this._getCurrentHash();
                if (0 === t.length) return;
                const e = t.join('/');
                let i = e;
                i.split('&').length > 0 && (i = i.split('&')[0]),
                  this._hashName && (i = `${this._hashName}=${e}`);
                let r = window.location.hash.replace(i, '');
                r.startsWith('#&')
                  ? (r = r.slice(0, 1) + r.slice(2))
                  : '#' === r && (r = '');
                let n = window.location.href.replace(/(#.+)?$/, r);
                (n = n.replace('&&', '&')),
                  window.history.replaceState(window.history.state, null, n);
              }),
              (this._updateHash = Vn(this._updateHashUnthrottled, 300)),
              (this._hashName = t && encodeURIComponent(t));
          }
          addTo(t) {
            return (
              (this._map = t),
              addEventListener('hashchange', this._onHashChange, !1),
              this._map.on('moveend', this._updateHash),
              this
            );
          }
          remove() {
            return (
              removeEventListener('hashchange', this._onHashChange, !1),
              this._map.off('moveend', this._updateHash),
              clearTimeout(this._updateHash()),
              this._removeHash(),
              delete this._map,
              this
            );
          }
          getHashString(t) {
            const e = this._map.getCenter(),
              i = Math.round(100 * this._map.getZoom()) / 100,
              r = Math.ceil(
                (i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
              ),
              n = Math.pow(10, r),
              o = Math.round(e.lng * n) / n,
              a = Math.round(e.lat * n) / n,
              s = this._map.getBearing(),
              l = this._map.getPitch();
            let c = '';
            if (
              ((c += t ? `/${o}/${a}/${i}` : `${i}/${a}/${o}`),
              (s || l) && (c += '/' + Math.round(10 * s) / 10),
              l && (c += `/${Math.round(l)}`),
              this._hashName)
            ) {
              const t = this._hashName;
              let e = !1;
              const i = window.location.hash
                .slice(1)
                .split('&')
                .map((i) => {
                  const r = i.split('=')[0];
                  return r === t ? ((e = !0), `${r}=${c}`) : i;
                })
                .filter((t) => t);
              return e || i.push(`${t}=${c}`), `#${i.join('&')}`;
            }
            return `#${c}`;
          }
          _isValidHash(t) {
            if (t.length < 3 || t.some(isNaN)) return !1;
            try {
              new e.U(+t[2], +t[1]);
            } catch (t) {
              return !1;
            }
            const i = +t[0],
              r = +(t[3] || 0),
              n = +(t[4] || 0);
            return (
              i >= this._map.getMinZoom() &&
              i <= this._map.getMaxZoom() &&
              r >= -180 &&
              r <= 180 &&
              n >= this._map.getMinPitch() &&
              n <= this._map.getMaxPitch()
            );
          }
        }
        const Gn = { linearity: 0.3, easing: e.cp(0, 0, 0.3, 1) },
          Zn = e.e({ deceleration: 2500, maxSpeed: 1400 }, Gn),
          $n = e.e({ deceleration: 20, maxSpeed: 1400 }, Gn),
          qn = e.e({ deceleration: 1e3, maxSpeed: 360 }, Gn),
          Wn = e.e({ deceleration: 1e3, maxSpeed: 90 }, Gn),
          Yn = e.e({ deceleration: 1e3, maxSpeed: 360 }, Gn);
        class Hn {
          constructor(t) {
            (this._map = t), this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(),
              this._inertiaBuffer.push({ time: l(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer,
              e = l();
            for (; t.length > 0 && e - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if ((this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
              return;
            const i = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new e.P(0, 0),
              pinchAround: void 0,
              around: void 0,
            };
            for (const { settings: e } of this._inertiaBuffer)
              (i.zoom += e.zoomDelta || 0),
                (i.bearing += e.bearingDelta || 0),
                (i.pitch += e.pitchDelta || 0),
                (i.roll += e.rollDelta || 0),
                e.panDelta && i.pan._add(e.panDelta),
                e.around && (i.around = e.around),
                e.pinchAround && (i.pinchAround = e.pinchAround);
            const r =
                this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                this._inertiaBuffer[0].time,
              n = {};
            if (i.pan.mag()) {
              const o = Kn(i.pan.mag(), r, e.e({}, Zn, t || {})),
                a = i.pan.mult(o.amount / i.pan.mag()),
                s = this._map.cameraHelper.handlePanInertia(
                  a,
                  this._map.transform
                );
              (n.center = s.easingCenter),
                (n.offset = s.easingOffset),
                Xn(n, o);
            }
            if (i.zoom) {
              const t = Kn(i.zoom, r, $n);
              (n.zoom = this._map.transform.zoom + t.amount), Xn(n, t);
            }
            if (i.bearing) {
              const t = Kn(i.bearing, r, qn);
              (n.bearing =
                this._map.transform.bearing + e.ai(t.amount, -179, 179)),
                Xn(n, t);
            }
            if (i.pitch) {
              const t = Kn(i.pitch, r, Wn);
              (n.pitch = this._map.transform.pitch + t.amount), Xn(n, t);
            }
            if (i.roll) {
              const t = Kn(i.roll, r, Yn);
              (n.roll = this._map.transform.roll + e.ai(t.amount, -179, 179)),
                Xn(n, t);
            }
            if (n.zoom || n.bearing) {
              const t = void 0 === i.pinchAround ? i.around : i.pinchAround;
              n.around = t ? this._map.unproject(t) : this._map.getCenter();
            }
            return this.clear(), e.e(n, { noMoveStart: !0 });
          }
        }
        function Xn(t, e) {
          (!t.duration || t.duration < e.duration) &&
            ((t.duration = e.duration), (t.easing = e.easing));
        }
        function Kn(t, i, r) {
          const { maxSpeed: n, linearity: o, deceleration: a } = r,
            s = e.ai((t * o) / (i / 1e3), -n, n),
            l = Math.abs(s) / (a * o);
          return { easing: r.easing, duration: 1e3 * l, amount: s * (l / 2) };
        }
        class Jn extends e.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, i, r, n = {}) {
            r = r instanceof MouseEvent ? r : new MouseEvent(t, r);
            const o = c.mousePos(i.getCanvas(), r),
              a = i.unproject(o);
            super(t, e.e({ point: o, lngLat: a, originalEvent: r }, n)),
              (this._defaultPrevented = !1),
              (this.target = i);
          }
        }
        class Qn extends e.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, i, r) {
            const n = 'touchend' === t ? r.changedTouches : r.touches,
              o = c.touchPos(i.getCanvasContainer(), n),
              a = o.map((t) => i.unproject(t)),
              s = o.reduce(
                (t, e, i, r) => t.add(e.div(r.length)),
                new e.P(0, 0)
              );
            super(t, {
              points: o,
              point: s,
              lngLats: a,
              lngLat: i.unproject(s),
              originalEvent: r,
            }),
              (this._defaultPrevented = !1);
          }
        }
        class to extends e.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, e, i) {
            super(t, { originalEvent: i }), (this._defaultPrevented = !1);
          }
        }
        class eo {
          constructor(t, e) {
            (this._map = t), (this._clickTolerance = e.clickTolerance);
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t) {
            return this._firePreventable(new to(t.type, this._map, t));
          }
          mousedown(t, e) {
            return (
              (this._mousedownPos = e),
              this._firePreventable(new Jn(t.type, this._map, t))
            );
          }
          mouseup(t) {
            this._map.fire(new Jn(t.type, this._map, t));
          }
          click(t, e) {
            (this._mousedownPos &&
              this._mousedownPos.dist(e) >= this._clickTolerance) ||
              this._map.fire(new Jn(t.type, this._map, t));
          }
          dblclick(t) {
            return this._firePreventable(new Jn(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new Jn(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new Jn(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new Qn(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new Qn(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new Qn(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new Qn(t.type, this._map, t));
          }
          _firePreventable(t) {
            if ((this._map.fire(t), t.defaultPrevented)) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class io {
          constructor(t) {
            this._map = t;
          }
          reset() {
            (this._delayContextMenu = !1),
              (this._ignoreContextMenu = !0),
              delete this._contextMenuEvent;
          }
          mousemove(t) {
            this._map.fire(new Jn(t.type, this._map, t));
          }
          mousedown() {
            (this._delayContextMenu = !0), (this._ignoreContextMenu = !1);
          }
          mouseup() {
            (this._delayContextMenu = !1),
              this._contextMenuEvent &&
                (this._map.fire(
                  new Jn('contextmenu', this._map, this._contextMenuEvent)
                ),
                delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu
              ? (this._contextMenuEvent = t)
              : this._ignoreContextMenu ||
                this._map.fire(new Jn(t.type, this._map, t)),
              this._map.listens('contextmenu') && t.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {}
          disable() {}
        }
        class ro {
          constructor(t) {
            this._map = t;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat,
            };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t) {
            return this.transform.screenPointToLocation(
              e.P.convert(t),
              this._map.terrain
            );
          }
        }
        class no {
          constructor(t, e) {
            (this._map = t),
              (this._tr = new ro(t)),
              (this._el = t.getCanvasContainer()),
              (this._container = t.getContainer()),
              (this._clickTolerance = e.clickTolerance || 1);
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t, e) {
            this.isEnabled() &&
              t.shiftKey &&
              0 === t.button &&
              (c.disableDrag(),
              (this._startPos = this._lastPos = e),
              (this._active = !0));
          }
          mousemoveWindow(t, e) {
            if (!this._active) return;
            const i = e;
            if (
              this._lastPos.equals(i) ||
              (!this._box && i.dist(this._startPos) < this._clickTolerance)
            )
              return;
            const r = this._startPos;
            (this._lastPos = i),
              this._box ||
                ((this._box = c.create(
                  'div',
                  'maplibregl-boxzoom',
                  this._container
                )),
                this._container.classList.add('maplibregl-crosshair'),
                this._fireEvent('boxzoomstart', t));
            const n = Math.min(r.x, i.x),
              o = Math.max(r.x, i.x),
              a = Math.min(r.y, i.y),
              s = Math.max(r.y, i.y);
            c.setTransform(this._box, `translate(${n}px,${a}px)`),
              (this._box.style.width = o - n + 'px'),
              (this._box.style.height = s - a + 'px');
          }
          mouseupWindow(t, i) {
            if (!this._active) return;
            if (0 !== t.button) return;
            const r = this._startPos,
              n = i;
            if ((this.reset(), c.suppressClick(), r.x !== n.x || r.y !== n.y))
              return (
                this._map.fire(new e.l('boxzoomend', { originalEvent: t })),
                {
                  cameraAnimation: (t) =>
                    t.fitScreenCoordinates(r, n, this._tr.bearing, {
                      linear: !0,
                    }),
                }
              );
            this._fireEvent('boxzoomcancel', t);
          }
          keydown(t) {
            this._active &&
              27 === t.keyCode &&
              (this.reset(), this._fireEvent('boxzoomcancel', t));
          }
          reset() {
            (this._active = !1),
              this._container.classList.remove('maplibregl-crosshair'),
              this._box && (c.remove(this._box), (this._box = null)),
              c.enableDrag(),
              delete this._startPos,
              delete this._lastPos;
          }
          _fireEvent(t, i) {
            return this._map.fire(new e.l(t, { originalEvent: i }));
          }
        }
        function oo(t, e) {
          if (t.length !== e.length)
            throw new Error(
              `The number of touches and points are not equal - touches ${t.length}, points ${e.length}`
            );
          const i = {};
          for (let r = 0; r < t.length; r++) i[t[r].identifier] = e[r];
          return i;
        }
        class ao {
          constructor(t) {
            this.reset(), (this.numTouches = t.numTouches);
          }
          reset() {
            delete this.centroid,
              delete this.startTime,
              delete this.touches,
              (this.aborted = !1);
          }
          touchstart(t, i, r) {
            (this.centroid || r.length > this.numTouches) &&
              (this.aborted = !0),
              this.aborted ||
                (void 0 === this.startTime && (this.startTime = t.timeStamp),
                r.length === this.numTouches &&
                  ((this.centroid = (function (t) {
                    const i = new e.P(0, 0);
                    for (const e of t) i._add(e);
                    return i.div(t.length);
                  })(i)),
                  (this.touches = oo(r, i))));
          }
          touchmove(t, e, i) {
            if (this.aborted || !this.centroid) return;
            const r = oo(i, e);
            for (const n in this.touches) {
              const t = r[n];
              (!t || t.dist(this.touches[n]) > 30) && (this.aborted = !0);
            }
          }
          touchend(t, e, i) {
            if (
              ((!this.centroid || t.timeStamp - this.startTime > 500) &&
                (this.aborted = !0),
              0 === i.length)
            ) {
              const t = !this.aborted && this.centroid;
              if ((this.reset(), t)) return t;
            }
          }
        }
        class so {
          constructor(t) {
            (this.singleTap = new ao(t)),
              (this.numTaps = t.numTaps),
              this.reset();
          }
          reset() {
            (this.lastTime = 1 / 0),
              delete this.lastTap,
              (this.count = 0),
              this.singleTap.reset();
          }
          touchstart(t, e, i) {
            this.singleTap.touchstart(t, e, i);
          }
          touchmove(t, e, i) {
            this.singleTap.touchmove(t, e, i);
          }
          touchend(t, e, i) {
            const r = this.singleTap.touchend(t, e, i);
            if (r) {
              const e = t.timeStamp - this.lastTime < 500,
                i = !this.lastTap || this.lastTap.dist(r) < 30;
              if (
                ((e && i) || this.reset(),
                this.count++,
                (this.lastTime = t.timeStamp),
                (this.lastTap = r),
                this.count === this.numTaps)
              )
                return this.reset(), r;
            }
          }
        }
        class lo {
          constructor(t) {
            (this._tr = new ro(t)),
              (this._zoomIn = new so({ numTouches: 1, numTaps: 2 })),
              (this._zoomOut = new so({ numTouches: 2, numTaps: 1 })),
              this.reset();
          }
          reset() {
            (this._active = !1), this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, e, i) {
            this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);
          }
          touchmove(t, e, i) {
            this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);
          }
          touchend(t, e, i) {
            const r = this._zoomIn.touchend(t, e, i),
              n = this._zoomOut.touchend(t, e, i),
              o = this._tr;
            return r
              ? ((this._active = !0),
                t.preventDefault(),
                setTimeout(() => this.reset(), 0),
                {
                  cameraAnimation: (e) =>
                    e.easeTo(
                      {
                        duration: 300,
                        zoom: o.zoom + 1,
                        around: o.unproject(r),
                      },
                      { originalEvent: t }
                    ),
                })
              : n
              ? ((this._active = !0),
                t.preventDefault(),
                setTimeout(() => this.reset(), 0),
                {
                  cameraAnimation: (e) =>
                    e.easeTo(
                      {
                        duration: 300,
                        zoom: o.zoom - 1,
                        around: o.unproject(n),
                      },
                      { originalEvent: t }
                    ),
                })
              : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class co {
          constructor(t) {
            (this._enabled = !!t.enable),
              (this._moveStateManager = t.moveStateManager),
              (this._clickTolerance = t.clickTolerance || 1),
              (this._moveFunction = t.move),
              (this._activateOnStart = !!t.activateOnStart),
              t.assignEvents(this),
              this.reset();
          }
          reset(t) {
            (this._active = !1),
              (this._moved = !1),
              delete this._lastPoint,
              this._moveStateManager.endMove(t);
          }
          _move(...t) {
            const e = this._moveFunction(...t);
            if (
              e.bearingDelta ||
              e.pitchDelta ||
              e.rollDelta ||
              e.around ||
              e.panDelta
            )
              return (this._active = !0), e;
          }
          dragStart(t, e) {
            this.isEnabled() &&
              !this._lastPoint &&
              this._moveStateManager.isValidStartEvent(t) &&
              (this._moveStateManager.startMove(t),
              (this._lastPoint = Array.isArray(e) ? e[0] : e),
              this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(t, e) {
            if (!this.isEnabled()) return;
            const i = this._lastPoint;
            if (!i) return;
            if (
              (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t))
            )
              return void this.reset(t);
            const r = Array.isArray(e) ? e[0] : e;
            return !this._moved && r.dist(i) < this._clickTolerance
              ? void 0
              : ((this._moved = !0), (this._lastPoint = r), this._move(i, r));
          }
          dragEnd(t) {
            this.isEnabled() &&
              this._lastPoint &&
              this._moveStateManager.isValidEndEvent(t) &&
              (this._moved && c.suppressClick(), this.reset(t));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const ho = { 0: 1, 2: 2 };
        class uo {
          constructor(t) {
            this._correctEvent = t.checkCorrectEvent;
          }
          startMove(t) {
            const e = c.mouseButton(t);
            this._eventButton = e;
          }
          endMove(t) {
            delete this._eventButton;
          }
          isValidStartEvent(t) {
            return this._correctEvent(t);
          }
          isValidMoveEvent(t) {
            return !(function (t, e) {
              const i = ho[e];
              return void 0 === t.buttons || (t.buttons & i) !== i;
            })(t, this._eventButton);
          }
          isValidEndEvent(t) {
            return c.mouseButton(t) === this._eventButton;
          }
        }
        class po {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t) {
            return 1 === t.targetTouches.length;
          }
          _isSameTouchEvent(t) {
            return t.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t) {
            this._firstTouch = t.targetTouches[0].identifier;
          }
          endMove(t) {
            delete this._firstTouch;
          }
          isValidStartEvent(t) {
            return this._isOneFingerTouch(t);
          }
          isValidMoveEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
          isValidEndEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
        }
        class fo {
          constructor(
            t = new uo({ checkCorrectEvent: () => !0 }),
            e = new po()
          ) {
            (this.mouseMoveStateManager = t),
              (this.oneFingerTouchMoveStateManager = e);
          }
          _executeRelevantHandler(t, e, i) {
            return t instanceof MouseEvent
              ? e(t)
              : 'undefined' != typeof TouchEvent && t instanceof TouchEvent
              ? i(t)
              : void 0;
          }
          startMove(t) {
            this._executeRelevantHandler(
              t,
              (t) => this.mouseMoveStateManager.startMove(t),
              (t) => this.oneFingerTouchMoveStateManager.startMove(t)
            );
          }
          endMove(t) {
            this._executeRelevantHandler(
              t,
              (t) => this.mouseMoveStateManager.endMove(t),
              (t) => this.oneFingerTouchMoveStateManager.endMove(t)
            );
          }
          isValidStartEvent(t) {
            return this._executeRelevantHandler(
              t,
              (t) => this.mouseMoveStateManager.isValidStartEvent(t),
              (t) => this.oneFingerTouchMoveStateManager.isValidStartEvent(t)
            );
          }
          isValidMoveEvent(t) {
            return this._executeRelevantHandler(
              t,
              (t) => this.mouseMoveStateManager.isValidMoveEvent(t),
              (t) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(t)
            );
          }
          isValidEndEvent(t) {
            return this._executeRelevantHandler(
              t,
              (t) => this.mouseMoveStateManager.isValidEndEvent(t),
              (t) => this.oneFingerTouchMoveStateManager.isValidEndEvent(t)
            );
          }
        }
        const mo = (t) => {
          (t.mousedown = t.dragStart),
            (t.mousemoveWindow = t.dragMove),
            (t.mouseup = t.dragEnd),
            (t.contextmenu = (t) => {
              t.preventDefault();
            });
        };
        class _o {
          constructor(t, e) {
            (this._clickTolerance = t.clickTolerance || 1),
              (this._map = e),
              this.reset();
          }
          reset() {
            (this._active = !1),
              (this._touches = {}),
              (this._sum = new e.P(0, 0));
          }
          _shouldBePrevented(t) {
            return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(t, e, i) {
            return this._calculateTransform(t, e, i);
          }
          touchmove(t, e, i) {
            if (this._active) {
              if (!this._shouldBePrevented(i.length))
                return t.preventDefault(), this._calculateTransform(t, e, i);
              this._map.cooperativeGestures.notifyGestureBlocked(
                'touch_pan',
                t
              );
            }
          }
          touchend(t, e, i) {
            this._calculateTransform(t, e, i),
              this._active && this._shouldBePrevented(i.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, i, r) {
            r.length > 0 && (this._active = !0);
            const n = oo(r, i),
              o = new e.P(0, 0),
              a = new e.P(0, 0);
            let s = 0;
            for (const e in n) {
              const t = n[e],
                i = this._touches[e];
              i && (o._add(t), a._add(t.sub(i)), s++, (n[e] = t));
            }
            if (((this._touches = n), this._shouldBePrevented(s) || !a.mag()))
              return;
            const l = a.div(s);
            return (
              this._sum._add(l),
              this._sum.mag() < this._clickTolerance
                ? void 0
                : { around: o.div(s), panDelta: l }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class go {
          constructor() {
            this.reset();
          }
          reset() {
            (this._active = !1), delete this._firstTwoTouches;
          }
          touchstart(t, e, i) {
            this._firstTwoTouches ||
              i.length < 2 ||
              ((this._firstTwoTouches = [i[0].identifier, i[1].identifier]),
              this._start([e[0], e[1]]));
          }
          touchmove(t, e, i) {
            if (!this._firstTwoTouches) return;
            t.preventDefault();
            const [r, n] = this._firstTwoTouches,
              o = yo(i, e, r),
              a = yo(i, e, n);
            if (!o || !a) return;
            const s = this._aroundCenter ? null : o.add(a).div(2);
            return this._move([o, a], s, t);
          }
          touchend(t, e, i) {
            if (!this._firstTwoTouches) return;
            const [r, n] = this._firstTwoTouches,
              o = yo(i, e, r),
              a = yo(i, e, n);
            (o && a) || (this._active && c.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            (this._enabled = !0),
              (this._aroundCenter = !!t && 'center' === t.around);
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function yo(t, e, i) {
          for (let r = 0; r < t.length; r++)
            if (t[r].identifier === i) return e[r];
        }
        function xo(t, e) {
          return Math.log(t / e) / Math.LN2;
        }
        class vo extends go {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, e) {
            const i = this._distance;
            if (
              ((this._distance = t[0].dist(t[1])),
              this._active ||
                !(Math.abs(xo(this._distance, this._startDistance)) < 0.1))
            )
              return (
                (this._active = !0),
                { zoomDelta: xo(this._distance, i), pinchAround: e }
              );
          }
        }
        function bo(t, e) {
          return (180 * t.angleWith(e)) / Math.PI;
        }
        class wo extends go {
          reset() {
            super.reset(),
              delete this._minDiameter,
              delete this._startVector,
              delete this._vector;
          }
          _start(t) {
            (this._startVector = this._vector = t[0].sub(t[1])),
              (this._minDiameter = t[0].dist(t[1]));
          }
          _move(t, e, i) {
            const r = this._vector;
            if (
              ((this._vector = t[0].sub(t[1])),
              this._active || !this._isBelowThreshold(this._vector))
            )
              return (
                (this._active = !0),
                { bearingDelta: bo(this._vector, r), pinchAround: e }
              );
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const e = (25 / (Math.PI * this._minDiameter)) * 360,
              i = bo(t, this._startVector);
            return Math.abs(i) < e;
          }
        }
        function To(t) {
          return Math.abs(t.y) > Math.abs(t.x);
        }
        class Po extends go {
          constructor(t) {
            super(), (this._currentTouchCount = 0), (this._map = t);
          }
          reset() {
            super.reset(),
              (this._valid = void 0),
              delete this._firstMove,
              delete this._lastPoints;
          }
          touchstart(t, e, i) {
            super.touchstart(t, e, i), (this._currentTouchCount = i.length);
          }
          _start(t) {
            (this._lastPoints = t), To(t[0].sub(t[1])) && (this._valid = !1);
          }
          _move(t, e, i) {
            if (
              this._map.cooperativeGestures.isEnabled() &&
              this._currentTouchCount < 3
            )
              return;
            const r = t[0].sub(this._lastPoints[0]),
              n = t[1].sub(this._lastPoints[1]);
            return (
              (this._valid = this.gestureBeginsVertically(r, n, i.timeStamp)),
              this._valid
                ? ((this._lastPoints = t),
                  (this._active = !0),
                  { pitchDelta: ((r.y + n.y) / 2) * -0.5 })
                : void 0
            );
          }
          gestureBeginsVertically(t, e, i) {
            if (void 0 !== this._valid) return this._valid;
            const r = t.mag() >= 2,
              n = e.mag() >= 2;
            if (!r && !n) return;
            if (!r || !n)
              return (
                void 0 === this._firstMove && (this._firstMove = i),
                i - this._firstMove < 100 && void 0
              );
            const o = t.y > 0 == e.y > 0;
            return To(t) && To(e) && o;
          }
        }
        const So = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Mo {
          constructor(t) {
            this._tr = new ro(t);
            const e = So;
            (this._panStep = e.panStep),
              (this._bearingStep = e.bearingStep),
              (this._pitchStep = e.pitchStep),
              (this._rotationDisabled = !1);
          }
          reset() {
            this._active = !1;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let e = 0,
              i = 0,
              r = 0,
              n = 0,
              o = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e = 1;
                break;
              case 189:
              case 109:
              case 173:
                e = -1;
                break;
              case 37:
                t.shiftKey ? (i = -1) : (t.preventDefault(), (n = -1));
                break;
              case 39:
                t.shiftKey ? (i = 1) : (t.preventDefault(), (n = 1));
                break;
              case 38:
                t.shiftKey ? (r = 1) : (t.preventDefault(), (o = -1));
                break;
              case 40:
                t.shiftKey ? (r = -1) : (t.preventDefault(), (o = 1));
                break;
              default:
                return;
            }
            return (
              this._rotationDisabled && ((i = 0), (r = 0)),
              {
                cameraAnimation: (a) => {
                  const s = this._tr;
                  a.easeTo(
                    {
                      duration: 300,
                      easeId: 'keyboardHandler',
                      easing: Io,
                      zoom: e
                        ? Math.round(s.zoom) + e * (t.shiftKey ? 2 : 1)
                        : s.zoom,
                      bearing: s.bearing + i * this._bearingStep,
                      pitch: s.pitch + r * this._pitchStep,
                      offset: [-n * this._panStep, -o * this._panStep],
                      center: s.center,
                    },
                    { originalEvent: t }
                  );
                },
              }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Io(t) {
          return t * (2 - t);
        }
        const Co = 4.000244140625,
          Ao = 1 / 450;
        class Eo {
          constructor(t, e) {
            (this._onTimeout = (t) => {
              (this._type = 'wheel'),
                (this._delta -= this._lastValue),
                this._active || this._start(t);
            }),
              (this._map = t),
              (this._tr = new ro(t)),
              (this._triggerRenderFrame = e),
              (this._delta = 0),
              (this._defaultZoomRate = 0.01),
              (this._wheelZoomRate = Ao);
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() ||
              ((this._enabled = !0),
              (this._aroundCenter = !!t && 'center' === t.around));
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(t) {
            return (
              !!this._map.cooperativeGestures.isEnabled() &&
              !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t))
            );
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(t))
              return void this._map.cooperativeGestures.notifyGestureBlocked(
                'wheel_zoom',
                t
              );
            let e =
              t.deltaMode === WheelEvent.DOM_DELTA_LINE
                ? 40 * t.deltaY
                : t.deltaY;
            const i = l(),
              r = i - (this._lastWheelEventTime || 0);
            (this._lastWheelEventTime = i),
              0 !== e && e % Co == 0
                ? (this._type = 'wheel')
                : 0 !== e && Math.abs(e) < 4
                ? (this._type = 'trackpad')
                : r > 400
                ? ((this._type = null),
                  (this._lastValue = e),
                  (this._timeout = setTimeout(this._onTimeout, 40, t)))
                : this._type ||
                  ((this._type = Math.abs(r * e) < 200 ? 'trackpad' : 'wheel'),
                  this._timeout &&
                    (clearTimeout(this._timeout),
                    (this._timeout = null),
                    (e += this._lastValue))),
              t.shiftKey && e && (e /= 4),
              this._type &&
                ((this._lastWheelEvent = t),
                (this._delta -= e),
                this._active || this._start(t)),
              t.preventDefault();
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null),
              (this._active = !0),
              this.isZooming() || (this._zooming = !0),
              this._finishTimeout &&
                (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = c.mousePos(this._map.getCanvas(), t),
              r = this._tr;
            (this._aroundPoint = this._aroundCenter
              ? r.transform.locationToScreenPoint(e.U.convert(r.center))
              : i),
              this._frameId ||
                ((this._frameId = !0), this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (((this._frameId = null), !this.isActive())) return;
            const t = this._tr.transform;
            if ('number' == typeof this._lastExpectedZoom) {
              const e = t.zoom - this._lastExpectedZoom;
              'number' == typeof this._startZoom && (this._startZoom += e),
                'number' == typeof this._targetZoom && (this._targetZoom += e);
            }
            if (0 !== this._delta) {
              const i =
                'wheel' === this._type && Math.abs(this._delta) > Co
                  ? this._wheelZoomRate
                  : this._defaultZoomRate;
              let r = 2 / (1 + Math.exp(-Math.abs(this._delta * i)));
              this._delta < 0 && 0 !== r && (r = 1 / r);
              const n =
                'number' != typeof this._targetZoom
                  ? t.scale
                  : e.al(this._targetZoom);
              (this._targetZoom = t.constrain(
                t.getCameraLngLat(),
                e.ao(n * r)
              ).zoom),
                'wheel' === this._type &&
                  ((this._startZoom = t.zoom),
                  (this._easing = this._smoothOutEasing(200))),
                (this._delta = 0);
            }
            const i =
                'number' != typeof this._targetZoom ? t.zoom : this._targetZoom,
              r = this._startZoom,
              n = this._easing;
            let o,
              a = !1;
            if ('wheel' === this._type && r && n) {
              const t = l() - this._lastWheelEventTime,
                s = Math.min((t + 5) / 200, 1),
                c = n(s);
              (o = e.F.number(r, i, c)),
                s < 1 ? this._frameId || (this._frameId = !0) : (a = !0);
            } else (o = i), (a = !0);
            return (
              (this._active = !0),
              a &&
                ((this._active = !1),
                (this._finishTimeout = setTimeout(() => {
                  (this._zooming = !1),
                    this._triggerRenderFrame(),
                    delete this._targetZoom,
                    delete this._lastExpectedZoom,
                    delete this._finishTimeout;
                }, 200))),
              (this._lastExpectedZoom = o),
              {
                noInertia: !0,
                needsRenderFrame: !a,
                zoomDelta: o - t.zoom,
                around: this._aroundPoint,
                originalEvent: this._lastWheelEvent,
              }
            );
          }
          _smoothOutEasing(t) {
            let i = e.cr;
            if (this._prevEase) {
              const t = this._prevEase,
                r = (l() - t.start) / t.duration,
                n = t.easing(r + 0.01) - t.easing(r),
                o = (0.27 / Math.sqrt(n * n + 1e-4)) * 0.01,
                a = Math.sqrt(0.0729 - o * o);
              i = e.cp(o, a, 0.25, 1);
            }
            return (this._prevEase = { start: l(), duration: t, easing: i }), i;
          }
          reset() {
            (this._active = !1),
              (this._zooming = !1),
              delete this._targetZoom,
              delete this._lastExpectedZoom,
              this._finishTimeout &&
                (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class zo {
          constructor(t, e) {
            (this._clickZoom = t), (this._tapZoom = e);
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class ko {
          constructor(t) {
            (this._tr = new ro(t)), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(t, e) {
            return (
              t.preventDefault(),
              {
                cameraAnimation: (i) => {
                  i.easeTo(
                    {
                      duration: 300,
                      zoom: this._tr.zoom + (t.shiftKey ? -1 : 1),
                      around: this._tr.unproject(e),
                    },
                    { originalEvent: t }
                  );
                },
              }
            );
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Do {
          constructor() {
            (this._tap = new so({ numTouches: 1, numTaps: 1 })), this.reset();
          }
          reset() {
            (this._active = !1),
              delete this._swipePoint,
              delete this._swipeTouch,
              delete this._tapTime,
              delete this._tapPoint,
              this._tap.reset();
          }
          touchstart(t, e, i) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const r = e[0],
                  n = t.timeStamp - this._tapTime < 500,
                  o = this._tapPoint.dist(r) < 30;
                n && o
                  ? i.length > 0 &&
                    ((this._swipePoint = r),
                    (this._swipeTouch = i[0].identifier))
                  : this.reset();
              } else this._tap.touchstart(t, e, i);
          }
          touchmove(t, e, i) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i[0].identifier !== this._swipeTouch) return;
                const r = e[0],
                  n = r.y - this._swipePoint.y;
                return (
                  (this._swipePoint = r),
                  t.preventDefault(),
                  (this._active = !0),
                  { zoomDelta: n / 128 }
                );
              }
            } else this._tap.touchmove(t, e, i);
          }
          touchend(t, e, i) {
            if (this._tapTime)
              this._swipePoint && 0 === i.length && this.reset();
            else {
              const r = this._tap.touchend(t, e, i);
              r && ((this._tapTime = t.timeStamp), (this._tapPoint = r));
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            (this._enabled = !1), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ro {
          constructor(t, e, i) {
            (this._el = t), (this._mousePan = e), (this._touchPan = i);
          }
          enable(t) {
            (this._inertiaOptions = t || {}),
              this._mousePan.enable(),
              this._touchPan.enable(),
              this._el.classList.add('maplibregl-touch-drag-pan');
          }
          disable() {
            this._mousePan.disable(),
              this._touchPan.disable(),
              this._el.classList.remove('maplibregl-touch-drag-pan');
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Lo {
          constructor(t, e, i, r) {
            (this._pitchWithRotate = t.pitchWithRotate),
              (this._rollEnabled = t.rollEnabled),
              (this._mouseRotate = e),
              (this._mousePitch = i),
              (this._mouseRoll = r);
          }
          enable() {
            this._mouseRotate.enable(),
              this._pitchWithRotate && this._mousePitch.enable(),
              this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(),
              this._mousePitch.disable(),
              this._mouseRoll.disable();
          }
          isEnabled() {
            return (
              this._mouseRotate.isEnabled() &&
              (!this._pitchWithRotate || this._mousePitch.isEnabled()) &&
              (!this._rollEnabled || this._mouseRoll.isEnabled())
            );
          }
          isActive() {
            return (
              this._mouseRotate.isActive() ||
              this._mousePitch.isActive() ||
              this._mouseRoll.isActive()
            );
          }
        }
        class Fo {
          constructor(t, e, i, r) {
            (this._el = t),
              (this._touchZoom = e),
              (this._touchRotate = i),
              (this._tapDragZoom = r),
              (this._rotationDisabled = !1),
              (this._enabled = !0);
          }
          enable(t) {
            this._touchZoom.enable(t),
              this._rotationDisabled || this._touchRotate.enable(t),
              this._tapDragZoom.enable(),
              this._el.classList.add('maplibregl-touch-zoom-rotate');
          }
          disable() {
            this._touchZoom.disable(),
              this._touchRotate.disable(),
              this._tapDragZoom.disable(),
              this._el.classList.remove('maplibregl-touch-zoom-rotate');
          }
          isEnabled() {
            return (
              this._touchZoom.isEnabled() &&
              (this._rotationDisabled || this._touchRotate.isEnabled()) &&
              this._tapDragZoom.isEnabled()
            );
          }
          isActive() {
            return (
              this._touchZoom.isActive() ||
              this._touchRotate.isActive() ||
              this._tapDragZoom.isActive()
            );
          }
          disableRotation() {
            (this._rotationDisabled = !0), this._touchRotate.disable();
          }
          enableRotation() {
            (this._rotationDisabled = !1),
              this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Bo {
          constructor(t, e) {
            (this._bypassKey =
              -1 !== navigator.userAgent.indexOf('Mac')
                ? 'metaKey'
                : 'ctrlKey'),
              (this._map = t),
              (this._options = e),
              (this._enabled = !1);
          }
          isActive() {
            return !1;
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const t = this._map.getCanvasContainer();
            t.classList.add('maplibregl-cooperative-gestures'),
              (this._container = c.create(
                'div',
                'maplibregl-cooperative-gesture-screen',
                t
              ));
            let e = this._map._getUIString(
              'CooperativeGesturesHandler.WindowsHelpText'
            );
            'metaKey' === this._bypassKey &&
              (e = this._map._getUIString(
                'CooperativeGesturesHandler.MacHelpText'
              ));
            const i = this._map._getUIString(
                'CooperativeGesturesHandler.MobileHelpText'
              ),
              r = document.createElement('div');
            (r.className = 'maplibregl-desktop-message'),
              (r.textContent = e),
              this._container.appendChild(r);
            const n = document.createElement('div');
            (n.className = 'maplibregl-mobile-message'),
              (n.textContent = i),
              this._container.appendChild(n),
              this._container.setAttribute('aria-hidden', 'true');
          }
          _destroyUI() {
            this._container &&
              (c.remove(this._container),
              this._map
                .getCanvasContainer()
                .classList.remove('maplibregl-cooperative-gestures')),
              delete this._container;
          }
          enable() {
            this._setupUI(), (this._enabled = !0);
          }
          disable() {
            (this._enabled = !1), this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(t) {
            return t[this._bypassKey];
          }
          notifyGestureBlocked(t, i) {
            this._enabled &&
              (this._map.fire(
                new e.l('cooperativegestureprevented', {
                  gestureType: t,
                  originalEvent: i,
                })
              ),
              this._container.classList.add('maplibregl-show'),
              setTimeout(() => {
                this._container.classList.remove('maplibregl-show');
              }, 100));
          }
        }
        const Oo = (t) => t.zoom || t.drag || t.roll || t.pitch || t.rotate;
        class jo extends e.l {}
        function No(t) {
          return (
            (t.panDelta && t.panDelta.mag()) ||
            t.zoomDelta ||
            t.bearingDelta ||
            t.pitchDelta ||
            t.rollDelta
          );
        }
        class Vo {
          constructor(t, i) {
            (this.handleWindowEvent = (t) => {
              this.handleEvent(t, `${t.type}Window`);
            }),
              (this.handleEvent = (t, i) => {
                if ('blur' === t.type) return void this.stop(!0);
                this._updatingCamera = !0;
                const r = 'renderFrame' === t.type ? void 0 : t,
                  n = { needsRenderFrame: !1 },
                  o = {},
                  a = {};
                for (const { handlerName: h, handler: u, allowed: d } of this
                  ._handlers) {
                  if (!u.isEnabled()) continue;
                  let s;
                  if (this._blockedByActive(a, d, h)) u.reset();
                  else if (u[i || t.type]) {
                    if (e.cs(t, i || t.type)) {
                      const e = c.mousePos(this._map.getCanvas(), t);
                      s = u[i || t.type](t, e);
                    } else if (e.ct(t, i || t.type)) {
                      const e = this._getMapTouches(t.touches),
                        r = c.touchPos(this._map.getCanvas(), e);
                      s = u[i || t.type](t, r, e);
                    } else e.cu(i || t.type) || (s = u[i || t.type](t));
                    this.mergeHandlerResult(n, o, s, h, r),
                      s && s.needsRenderFrame && this._triggerRenderFrame();
                  }
                  (s || u.isActive()) && (a[h] = u);
                }
                const s = {};
                for (const e in this._previousActiveHandlers)
                  a[e] || (s[e] = r);
                (this._previousActiveHandlers = a),
                  (Object.keys(s).length || No(n)) &&
                    (this._changes.push([n, o, s]), this._triggerRenderFrame()),
                  (Object.keys(a).length || No(n)) && this._map._stop(!0),
                  (this._updatingCamera = !1);
                const { cameraAnimation: l } = n;
                l &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  l(this._map));
              }),
              (this._map = t),
              (this._el = this._map.getCanvasContainer()),
              (this._handlers = []),
              (this._handlersById = {}),
              (this._changes = []),
              (this._inertia = new Hn(t)),
              (this._bearingSnap = i.bearingSnap),
              (this._previousActiveHandlers = {}),
              (this._eventsInProgress = {}),
              this._addDefaultHandlers(i);
            const r = this._el;
            this._listeners = [
              [r, 'touchstart', { passive: !0 }],
              [r, 'touchmove', { passive: !1 }],
              [r, 'touchend', void 0],
              [r, 'touchcancel', void 0],
              [r, 'mousedown', void 0],
              [r, 'mousemove', void 0],
              [r, 'mouseup', void 0],
              [document, 'mousemove', { capture: !0 }],
              [document, 'mouseup', void 0],
              [r, 'mouseover', void 0],
              [r, 'mouseout', void 0],
              [r, 'dblclick', void 0],
              [r, 'click', void 0],
              [r, 'keydown', { capture: !1 }],
              [r, 'keyup', void 0],
              [r, 'wheel', { passive: !1 }],
              [r, 'contextmenu', void 0],
              [window, 'blur', void 0],
            ];
            for (const [e, n, o] of this._listeners)
              c.addEventListener(
                e,
                n,
                e === document ? this.handleWindowEvent : this.handleEvent,
                o
              );
          }
          destroy() {
            for (const [t, e, i] of this._listeners)
              c.removeEventListener(
                t,
                e,
                t === document ? this.handleWindowEvent : this.handleEvent,
                i
              );
          }
          _addDefaultHandlers(t) {
            const i = this._map,
              r = i.getCanvasContainer();
            this._add('mapEvent', new eo(i, t));
            const n = (i.boxZoom = new no(i, t));
            this._add('boxZoom', n), t.interactive && t.boxZoom && n.enable();
            const o = (i.cooperativeGestures = new Bo(
              i,
              t.cooperativeGestures
            ));
            this._add('cooperativeGestures', o),
              t.cooperativeGestures && o.enable();
            const a = new lo(i),
              s = new ko(i);
            (i.doubleClickZoom = new zo(s, a)),
              this._add('tapZoom', a),
              this._add('clickZoom', s),
              t.interactive && t.doubleClickZoom && i.doubleClickZoom.enable();
            const l = new Do();
            this._add('tapDragZoom', l);
            const h = (i.touchPitch = new Po(i));
            this._add('touchPitch', h),
              t.interactive &&
                t.touchPitch &&
                i.touchPitch.enable(t.touchPitch);
            const u = () => i.project(i.getCenter()),
              d = (function (
                {
                  enable: t,
                  clickTolerance: i,
                  aroundCenter: r = !0,
                  minPixelCenterThreshold: n = 100,
                  rotateDegreesPerPixelMoved: o = 0.8,
                },
                a
              ) {
                const s = new uo({
                  checkCorrectEvent: (t) =>
                    (0 === c.mouseButton(t) && t.ctrlKey) ||
                    (2 === c.mouseButton(t) && !t.ctrlKey),
                });
                return new co({
                  clickTolerance: i,
                  move: (t, i) => {
                    const s = a();
                    if (r && Math.abs(s.y - t.y) > n)
                      return { bearingDelta: e.cq(new e.P(t.x, i.y), i, s) };
                    let l = (i.x - t.x) * o;
                    return r && i.y < s.y && (l = -l), { bearingDelta: l };
                  },
                  moveStateManager: s,
                  enable: t,
                  assignEvents: mo,
                });
              })(t, u),
              p = (function ({
                enable: t,
                clickTolerance: e,
                pitchDegreesPerPixelMoved: i = -0.5,
              }) {
                const r = new uo({
                  checkCorrectEvent: (t) =>
                    (0 === c.mouseButton(t) && t.ctrlKey) ||
                    2 === c.mouseButton(t),
                });
                return new co({
                  clickTolerance: e,
                  move: (t, e) => ({ pitchDelta: (e.y - t.y) * i }),
                  moveStateManager: r,
                  enable: t,
                  assignEvents: mo,
                });
              })(t),
              f = (function (
                {
                  enable: t,
                  clickTolerance: e,
                  rollDegreesPerPixelMoved: i = 0.3,
                },
                r
              ) {
                const n = new uo({
                  checkCorrectEvent: (t) => 2 === c.mouseButton(t) && t.ctrlKey,
                });
                return new co({
                  clickTolerance: e,
                  move: (t, e) => {
                    const n = r();
                    let o = (e.x - t.x) * i;
                    return e.y < n.y && (o = -o), { rollDelta: o };
                  },
                  moveStateManager: n,
                  enable: t,
                  assignEvents: mo,
                });
              })(t, u);
            (i.dragRotate = new Lo(t, d, p, f)),
              this._add('mouseRotate', d, ['mousePitch']),
              this._add('mousePitch', p, ['mouseRotate', 'mouseRoll']),
              this._add('mouseRoll', f, ['mousePitch']),
              t.interactive && t.dragRotate && i.dragRotate.enable();
            const m = (function ({ enable: t, clickTolerance: e }) {
                const i = new uo({
                  checkCorrectEvent: (t) =>
                    0 === c.mouseButton(t) && !t.ctrlKey,
                });
                return new co({
                  clickTolerance: e,
                  move: (t, e) => ({ around: e, panDelta: e.sub(t) }),
                  activateOnStart: !0,
                  moveStateManager: i,
                  enable: t,
                  assignEvents: mo,
                });
              })(t),
              _ = new _o(t, i);
            (i.dragPan = new Ro(r, m, _)),
              this._add('mousePan', m),
              this._add('touchPan', _, ['touchZoom', 'touchRotate']),
              t.interactive && t.dragPan && i.dragPan.enable(t.dragPan);
            const g = new wo(),
              y = new vo();
            (i.touchZoomRotate = new Fo(r, y, g, l)),
              this._add('touchRotate', g, ['touchPan', 'touchZoom']),
              this._add('touchZoom', y, ['touchPan', 'touchRotate']),
              t.interactive &&
                t.touchZoomRotate &&
                i.touchZoomRotate.enable(t.touchZoomRotate),
              this._add('blockableMapEvent', new io(i));
            const x = (i.scrollZoom = new Eo(i, () =>
              this._triggerRenderFrame()
            ));
            this._add('scrollZoom', x, ['mousePan']),
              t.interactive &&
                t.scrollZoom &&
                i.scrollZoom.enable(t.scrollZoom);
            const v = (i.keyboard = new Mo(i));
            this._add('keyboard', v),
              t.interactive && t.keyboard && i.keyboard.enable();
          }
          _add(t, e, i) {
            this._handlers.push({ handlerName: t, handler: e, allowed: i }),
              (this._handlersById[t] = e);
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: t } of this._handlers) t.reset();
              this._inertia.clear(),
                this._fireEvents({}, {}, t),
                (this._changes = []);
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers)
              if (t.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return (
              !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
            );
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(Oo(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t, e, i) {
            for (const r in t)
              if (r !== i && (!e || e.indexOf(r) < 0)) return !0;
            return !1;
          }
          _getMapTouches(t) {
            const e = [];
            for (const i of t) this._el.contains(i.target) && e.push(i);
            return e;
          }
          mergeHandlerResult(t, i, r, n, o) {
            if (!r) return;
            e.e(t, r);
            const a = { handlerName: n, originalEvent: r.originalEvent || o };
            void 0 !== r.zoomDelta && (i.zoom = a),
              void 0 !== r.panDelta && (i.drag = a),
              void 0 !== r.rollDelta && (i.roll = a),
              void 0 !== r.pitchDelta && (i.pitch = a),
              void 0 !== r.bearingDelta && (i.rotate = a);
          }
          _applyChanges() {
            const t = {},
              i = {},
              r = {};
            for (const [n, o, a] of this._changes)
              n.panDelta &&
                (t.panDelta = (t.panDelta || new e.P(0, 0))._add(n.panDelta)),
                n.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + n.zoomDelta),
                n.bearingDelta &&
                  (t.bearingDelta = (t.bearingDelta || 0) + n.bearingDelta),
                n.pitchDelta &&
                  (t.pitchDelta = (t.pitchDelta || 0) + n.pitchDelta),
                n.rollDelta && (t.rollDelta = (t.rollDelta || 0) + n.rollDelta),
                void 0 !== n.around && (t.around = n.around),
                void 0 !== n.pinchAround && (t.pinchAround = n.pinchAround),
                n.noInertia && (t.noInertia = n.noInertia),
                e.e(i, o),
                e.e(r, a);
            this._updateMapTransform(t, i, r), (this._changes = []);
          }
          _updateMapTransform(t, e, i) {
            const r = this._map,
              n = r._getTransformForUpdate(),
              o = r.terrain;
            if (!(No(t) || (o && this._terrainMovement)))
              return this._fireEvents(e, i, !0);
            r._stop(!0);
            let {
              panDelta: a,
              zoomDelta: s,
              bearingDelta: l,
              pitchDelta: c,
              rollDelta: h,
              around: u,
              pinchAround: d,
            } = t;
            void 0 !== d && (u = d),
              (u = u || r.transform.centerPoint),
              o && !n.isPointOnMapSurface(u) && (u = n.centerPoint);
            const p = {
              panDelta: a,
              zoomDelta: s,
              rollDelta: h,
              pitchDelta: c,
              bearingDelta: l,
              around: u,
            };
            this._map.cameraHelper.useGlobeControls &&
              !n.isPointOnMapSurface(u) &&
              (u = n.centerPoint);
            const f =
              u.distSqr(n.centerPoint) < 0.01
                ? n.center
                : n.screenPointToLocation(a ? u.sub(a) : u);
            this._handleMapControls({
              terrain: o,
              tr: n,
              deltasForHelper: p,
              preZoomAroundLoc: f,
              combinedEventsInProgress: e,
              panDelta: a,
            }),
              r._applyUpdatedTransform(n),
              this._map._update(),
              t.noInertia || this._inertia.record(t),
              this._fireEvents(e, i, !0);
          }
          _handleMapControls({
            terrain: t,
            tr: e,
            deltasForHelper: i,
            preZoomAroundLoc: r,
            combinedEventsInProgress: n,
            panDelta: o,
          }) {
            const a = this._map.cameraHelper;
            if ((a.handleMapControlsRollPitchBearingZoom(i, e), t))
              return a.useGlobeControls
                ? (this._terrainMovement ||
                    (!n.drag && !n.zoom) ||
                    ((this._terrainMovement = !0),
                    (this._map._elevationFreeze = !0)),
                  void a.handleMapControlsPan(i, e, r))
                : this._terrainMovement || (!n.drag && !n.zoom)
                ? void (n.drag && this._terrainMovement && o
                    ? e.setCenter(e.screenPointToLocation(e.centerPoint.sub(o)))
                    : a.handleMapControlsPan(i, e, r))
                : ((this._terrainMovement = !0),
                  (this._map._elevationFreeze = !0),
                  void a.handleMapControlsPan(i, e, r));
            a.handleMapControlsPan(i, e, r);
          }
          _fireEvents(t, i, r) {
            const n = Oo(this._eventsInProgress),
              o = Oo(t),
              s = {};
            for (const e in t) {
              const { originalEvent: i } = t[e];
              this._eventsInProgress[e] || (s[`${e}start`] = i),
                (this._eventsInProgress[e] = t[e]);
            }
            !n && o && this._fireEvent('movestart', o.originalEvent);
            for (const e in s) this._fireEvent(e, s[e]);
            o && this._fireEvent('move', o.originalEvent);
            for (const e in t) {
              const { originalEvent: i } = t[e];
              this._fireEvent(e, i);
            }
            const l = {};
            let c;
            for (const e in this._eventsInProgress) {
              const { handlerName: t, originalEvent: r } =
                this._eventsInProgress[e];
              this._handlersById[t].isActive() ||
                (delete this._eventsInProgress[e],
                (c = i[t] || r),
                (l[`${e}end`] = c));
            }
            for (const e in l) this._fireEvent(e, l[e]);
            const h = Oo(this._eventsInProgress),
              u = (n || o) && !h;
            if (u && this._terrainMovement) {
              (this._map._elevationFreeze = !1), (this._terrainMovement = !1);
              const t = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() &&
                t.recalculateZoomAndCenter(this._map.terrain),
                this._map._applyUpdatedTransform(t);
            }
            if (r && u) {
              this._updatingCamera = !0;
              const t = this._inertia._onMoveEnd(
                  this._map.dragPan._inertiaOptions
                ),
                i = (t) =>
                  0 !== t && -this._bearingSnap < t && t < this._bearingSnap;
              !t || (!t.essential && a.prefersReducedMotion)
                ? (this._map.fire(new e.l('moveend', { originalEvent: c })),
                  i(this._map.getBearing()) && this._map.resetNorth())
                : (i(t.bearing || this._map.getBearing()) && (t.bearing = 0),
                  (t.freezeElevation = !0),
                  this._map.easeTo(t, { originalEvent: c })),
                (this._updatingCamera = !1);
            }
          }
          _fireEvent(t, i) {
            this._map.fire(new e.l(t, i ? { originalEvent: i } : {}));
          }
          _requestFrame() {
            return (
              this._map.triggerRepaint(),
              this._map._renderTaskQueue.add((t) => {
                delete this._frameId,
                  this.handleEvent(new jo('renderFrame', { timeStamp: t })),
                  this._applyChanges();
              })
            );
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class Uo extends e.E {
          constructor(t, e, i) {
            super(),
              (this._renderFrameCallback = () => {
                const t = Math.min(
                  (l() - this._easeStart) / this._easeOptions.duration,
                  1
                );
                this._onEaseFrame(this._easeOptions.easing(t)),
                  t < 1 && this._easeFrameId
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback
                      ))
                    : this.stop();
              }),
              (this._moving = !1),
              (this._zooming = !1),
              (this.transform = t),
              (this._bearingSnap = i.bearingSnap),
              (this.cameraHelper = e),
              this.on('moveend', () => {
                delete this._requestedCameraState;
              });
          }
          migrateProjection(t, e) {
            t.apply(this.transform),
              (this.transform = t),
              (this.cameraHelper = e);
          }
          getCenter() {
            return new e.U(
              this.transform.center.lng,
              this.transform.center.lat
            );
          }
          setCenter(t, e) {
            return this.jumpTo({ center: t }, e);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(t, e) {
            return this.jumpTo({ elevation: t }, e), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(t) {
            this._centerClampedToGround = t;
          }
          panBy(t, i, r) {
            return (
              (t = e.P.convert(t).mult(-1)),
              this.panTo(this.transform.center, e.e({ offset: t }, i), r)
            );
          }
          panTo(t, i, r) {
            return this.easeTo(e.e({ center: t }, i), r);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, e) {
            return this.jumpTo({ zoom: t }, e), this;
          }
          zoomTo(t, i, r) {
            return this.easeTo(e.e({ zoom: t }, i), r);
          }
          zoomIn(t, e) {
            return this.zoomTo(this.getZoom() + 1, t, e), this;
          }
          zoomOut(t, e) {
            return this.zoomTo(this.getZoom() - 1, t, e), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(t, i) {
            return (
              t != this.transform.fov &&
                (this.transform.setFov(t),
                this.fire(new e.l('movestart', i))
                  .fire(new e.l('move', i))
                  .fire(new e.l('moveend', i))),
              this
            );
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t, e) {
            return this.jumpTo({ bearing: t }, e), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, e) {
            return this.jumpTo({ padding: t }, e), this;
          }
          rotateTo(t, i, r) {
            return this.easeTo(e.e({ bearing: t }, i), r);
          }
          resetNorth(t, i) {
            return this.rotateTo(0, e.e({ duration: 1e3 }, t), i), this;
          }
          resetNorthPitch(t, i) {
            return (
              this.easeTo(
                e.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t),
                i
              ),
              this
            );
          }
          snapToNorth(t, e) {
            return Math.abs(this.getBearing()) < this._bearingSnap
              ? this.resetNorth(t, e)
              : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, e) {
            return this.jumpTo({ pitch: t }, e), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(t, e) {
            return this.jumpTo({ roll: t }, e), this;
          }
          cameraForBounds(t, e) {
            t = q.convert(t).adjustAntiMeridian();
            const i = (e && e.bearing) || 0;
            return this._cameraForBoxAndBearing(
              t.getNorthWest(),
              t.getSouthEast(),
              i,
              e
            );
          }
          _cameraForBoxAndBearing(t, i, r, n) {
            const o = { top: 0, bottom: 0, right: 0, left: 0 };
            if (
              'number' ==
              typeof (n = e.e(
                { padding: o, offset: [0, 0], maxZoom: this.transform.maxZoom },
                n
              )).padding
            ) {
              const t = n.padding;
              n.padding = { top: t, bottom: t, right: t, left: t };
            }
            const a = e.e(o, n.padding);
            n.padding = a;
            const s = this.transform,
              l = new q(t, i);
            return this.cameraHelper.cameraForBoxAndBearing(n, a, l, r, s);
          }
          fitBounds(t, e, i) {
            return this._fitInternal(this.cameraForBounds(t, e), e, i);
          }
          fitScreenCoordinates(t, i, r, n, o) {
            return this._fitInternal(
              this._cameraForBoxAndBearing(
                this.transform.screenPointToLocation(e.P.convert(t)),
                this.transform.screenPointToLocation(e.P.convert(i)),
                r,
                n
              ),
              n,
              o
            );
          }
          _fitInternal(t, i, r) {
            return t
              ? (delete (i = e.e(t, i)).padding,
                i.linear ? this.easeTo(i, r) : this.flyTo(i, r))
              : this;
          }
          jumpTo(t, i) {
            this.stop();
            const r = this._getTransformForUpdate();
            let n = !1,
              o = !1,
              a = !1;
            const s = r.zoom;
            this.cameraHelper.handleJumpToCenterZoom(r, t);
            const l = r.zoom !== s;
            return (
              'elevation' in t &&
                r.elevation !== +t.elevation &&
                r.setElevation(+t.elevation),
              'bearing' in t &&
                r.bearing !== +t.bearing &&
                ((n = !0), r.setBearing(+t.bearing)),
              'pitch' in t &&
                r.pitch !== +t.pitch &&
                ((o = !0), r.setPitch(+t.pitch)),
              'roll' in t &&
                r.roll !== +t.roll &&
                ((a = !0), r.setRoll(+t.roll)),
              null == t.padding ||
                r.isPaddingEqual(t.padding) ||
                r.setPadding(t.padding),
              this._applyUpdatedTransform(r),
              this.fire(new e.l('movestart', i)).fire(new e.l('move', i)),
              l &&
                this.fire(new e.l('zoomstart', i))
                  .fire(new e.l('zoom', i))
                  .fire(new e.l('zoomend', i)),
              n &&
                this.fire(new e.l('rotatestart', i))
                  .fire(new e.l('rotate', i))
                  .fire(new e.l('rotateend', i)),
              o &&
                this.fire(new e.l('pitchstart', i))
                  .fire(new e.l('pitch', i))
                  .fire(new e.l('pitchend', i)),
              a &&
                this.fire(new e.l('rollstart', i))
                  .fire(new e.l('roll', i))
                  .fire(new e.l('rollend', i)),
              this.fire(new e.l('moveend', i))
            );
          }
          calculateCameraOptionsFromTo(t, i, r, n = 0) {
            const o = e.a5.fromLngLat(t, i),
              a = e.a5.fromLngLat(r, n),
              s = a.x - o.x,
              l = a.y - o.y,
              c = a.z - o.z,
              h = Math.hypot(s, l, c);
            if (0 === h)
              throw new Error(
                "Can't calculate camera options with same From and To"
              );
            const u = Math.hypot(s, l),
              d = e.ao(
                this.transform.cameraToCenterDistance /
                  h /
                  this.transform.tileSize
              ),
              p = (180 * Math.atan2(s, -l)) / Math.PI;
            let f = (180 * Math.acos(u / h)) / Math.PI;
            return (
              (f = c < 0 ? 90 - f : 90 + f),
              {
                center: a.toLngLat(),
                elevation: n,
                zoom: d,
                pitch: f,
                bearing: p,
              }
            );
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(t, e, i, r, n) {
            const o = this.transform.calculateCenterFromCameraLngLatAlt(
              t,
              e,
              i,
              r
            );
            return {
              center: o.center,
              elevation: o.elevation,
              zoom: o.zoom,
              bearing: i,
              pitch: r,
              roll: n,
            };
          }
          easeTo(t, i) {
            this._stop(!1, t.easeId),
              (!1 ===
                (t = e.e({ offset: [0, 0], duration: 500, easing: e.cr }, t))
                  .animate ||
                (!t.essential && a.prefersReducedMotion)) &&
                (t.duration = 0);
            const r = this._getTransformForUpdate(),
              n = this.getBearing(),
              o = r.pitch,
              s = r.roll,
              l = 'bearing' in t ? this._normalizeBearing(t.bearing, n) : n,
              c = 'pitch' in t ? +t.pitch : o,
              h = 'roll' in t ? this._normalizeBearing(t.roll, s) : s,
              u = 'padding' in t ? t.padding : r.padding,
              d = e.P.convert(t.offset);
            let p, f;
            t.around &&
              ((p = e.U.convert(t.around)), (f = r.locationToScreenPoint(p)));
            const m = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling,
              },
              _ = this.cameraHelper.handleEaseTo(r, {
                bearing: l,
                pitch: c,
                roll: h,
                padding: u,
                around: p,
                aroundPoint: f,
                offsetAsPoint: d,
                offset: t.offset,
                zoom: t.zoom,
                center: t.center,
              });
            return (
              (this._rotating = this._rotating || n !== l),
              (this._pitching = this._pitching || c !== o),
              (this._rolling = this._rolling || h !== s),
              (this._padding = !r.isPaddingEqual(u)),
              (this._zooming = this._zooming || _.isZooming),
              (this._easeId = t.easeId),
              this._prepareEase(i, t.noMoveStart, m),
              this.terrain && this._prepareElevation(_.elevationCenter),
              this._ease(
                (e) => {
                  _.easeFunc(e),
                    this.terrain &&
                      !t.freezeElevation &&
                      this._updateElevation(e),
                    this._applyUpdatedTransform(r),
                    this._fireMoveEvents(i);
                },
                (e) => {
                  this.terrain &&
                    t.freezeElevation &&
                    this._finalizeElevation(),
                    this._afterEase(i, e);
                },
                t
              ),
              this
            );
          }
          _prepareEase(t, i, r = {}) {
            (this._moving = !0),
              i || r.moving || this.fire(new e.l('movestart', t)),
              this._zooming && !r.zooming && this.fire(new e.l('zoomstart', t)),
              this._rotating &&
                !r.rotating &&
                this.fire(new e.l('rotatestart', t)),
              this._pitching &&
                !r.pitching &&
                this.fire(new e.l('pitchstart', t)),
              this._rolling && !r.rolling && this.fire(new e.l('rollstart', t));
          }
          _prepareElevation(t) {
            (this._elevationCenter = t),
              (this._elevationStart = this.transform.elevation),
              (this._elevationTarget = this.terrain.getElevationForLngLatZoom(
                t,
                this.transform.tileZoom
              )),
              (this._elevationFreeze = !0);
          }
          _updateElevation(t) {
            (void 0 !== this._elevationStart &&
              void 0 !== this._elevationCenter) ||
              this._prepareElevation(this.transform.center),
              this.transform.setMinElevationForCurrentTile(
                this.terrain.getMinTileElevationForLngLatZoom(
                  this._elevationCenter,
                  this.transform.tileZoom
                )
              );
            const i = this.terrain.getElevationForLngLatZoom(
              this._elevationCenter,
              this.transform.tileZoom
            );
            if (t < 1 && i !== this._elevationTarget) {
              const e = this._elevationTarget - this._elevationStart;
              (this._elevationStart +=
                t * (e - (i - (e * t + this._elevationStart)) / (1 - t))),
                (this._elevationTarget = i);
            }
            this.transform.setElevation(
              e.F.number(this._elevationStart, this._elevationTarget, t)
            );
          }
          _finalizeElevation() {
            (this._elevationFreeze = !1),
              this.getCenterClampedToGround() &&
                this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain
              ? (this._requestedCameraState ||
                  (this._requestedCameraState = this.transform.clone()),
                this._requestedCameraState)
              : this.transform;
          }
          _elevateCameraIfInsideTerrain(t) {
            if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {};
            const e = t.getCameraLngLat(),
              i = t.getCameraAltitude(),
              r = this.terrain
                ? this.terrain.getElevationForLngLatZoom(e, t.zoom)
                : 0;
            if (i < r) {
              const i = this.calculateCameraOptionsFromTo(
                e,
                r,
                t.center,
                t.elevation
              );
              return { pitch: i.pitch, zoom: i.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(t) {
            const e = [];
            if (
              (e.push((t) => this._elevateCameraIfInsideTerrain(t)),
              this.transformCameraUpdate &&
                e.push((t) => this.transformCameraUpdate(t)),
              !e.length)
            )
              return;
            const i = t.clone();
            for (const r of e) {
              const t = i.clone(),
                {
                  center: e,
                  zoom: n,
                  roll: o,
                  pitch: a,
                  bearing: s,
                  elevation: l,
                } = r(t);
              e && t.setCenter(e),
                void 0 !== l && t.setElevation(l),
                void 0 !== n && t.setZoom(n),
                void 0 !== o && t.setRoll(o),
                void 0 !== a && t.setPitch(a),
                void 0 !== s && t.setBearing(s),
                i.apply(t);
            }
            this.transform.apply(i);
          }
          _fireMoveEvents(t) {
            this.fire(new e.l('move', t)),
              this._zooming && this.fire(new e.l('zoom', t)),
              this._rotating && this.fire(new e.l('rotate', t)),
              this._pitching && this.fire(new e.l('pitch', t)),
              this._rolling && this.fire(new e.l('roll', t));
          }
          _afterEase(t, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const r = this._zooming,
              n = this._rotating,
              o = this._pitching,
              a = this._rolling;
            (this._moving = !1),
              (this._zooming = !1),
              (this._rotating = !1),
              (this._pitching = !1),
              (this._rolling = !1),
              (this._padding = !1),
              r && this.fire(new e.l('zoomend', t)),
              n && this.fire(new e.l('rotateend', t)),
              o && this.fire(new e.l('pitchend', t)),
              a && this.fire(new e.l('rollend', t)),
              this.fire(new e.l('moveend', t));
          }
          flyTo(t, i) {
            if (!t.essential && a.prefersReducedMotion) {
              const r = e.S(t, [
                'center',
                'zoom',
                'bearing',
                'pitch',
                'roll',
                'elevation',
                'padding',
              ]);
              return this.jumpTo(r, i);
            }
            this.stop(),
              (t = e.e(
                { offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.cr },
                t
              ));
            const r = this._getTransformForUpdate(),
              n = r.bearing,
              o = r.pitch,
              s = r.roll,
              l = r.padding,
              c = 'bearing' in t ? this._normalizeBearing(t.bearing, n) : n,
              h = 'pitch' in t ? +t.pitch : o,
              u = 'roll' in t ? this._normalizeBearing(t.roll, s) : s,
              d = 'padding' in t ? t.padding : r.padding,
              p = e.P.convert(t.offset);
            let f = r.centerPoint.add(p);
            const m = r.screenPointToLocation(f),
              _ = this.cameraHelper.handleFlyTo(r, {
                bearing: c,
                pitch: h,
                roll: u,
                padding: d,
                locationAtOffset: m,
                offsetAsPoint: p,
                center: t.center,
                minZoom: t.minZoom,
                zoom: t.zoom,
              });
            let g = t.curve;
            const y = Math.max(r.width, r.height),
              x = y / _.scaleOfZoom,
              v = _.pixelPathLength;
            'number' == typeof _.scaleOfMinZoom &&
              (g = Math.sqrt((y / _.scaleOfMinZoom / v) * 2));
            const b = g * g;
            function w(t) {
              const e =
                (x * x - y * y + (t ? -1 : 1) * b * b * v * v) /
                (2 * (t ? x : y) * b * v);
              return Math.log(Math.sqrt(e * e + 1) - e);
            }
            function T(t) {
              return (Math.exp(t) - Math.exp(-t)) / 2;
            }
            function P(t) {
              return (Math.exp(t) + Math.exp(-t)) / 2;
            }
            const S = w(!1);
            let M = function (t) {
                return P(S) / P(S + g * t);
              },
              I = function (t) {
                return (
                  (y * ((P(S) * (T((e = S + g * t)) / P(e)) - T(S)) / b)) / v
                );
                var e;
              },
              C = (w(!0) - S) / g;
            if (Math.abs(v) < 2e-6 || !isFinite(C)) {
              if (Math.abs(y - x) < 1e-6) return this.easeTo(t, i);
              const e = x < y ? -1 : 1;
              (C = Math.abs(Math.log(x / y)) / g),
                (I = () => 0),
                (M = (t) => Math.exp(e * g * t));
            }
            return (
              (t.duration =
                'duration' in t
                  ? +t.duration
                  : (1e3 * C) /
                    ('screenSpeed' in t ? +t.screenSpeed / g : +t.speed)),
              t.maxDuration && t.duration > t.maxDuration && (t.duration = 0),
              (this._zooming = !0),
              (this._rotating = n !== c),
              (this._pitching = h !== o),
              (this._rolling = u !== s),
              (this._padding = !r.isPaddingEqual(d)),
              this._prepareEase(i, !1),
              this.terrain && this._prepareElevation(_.targetCenter),
              this._ease(
                (a) => {
                  const m = a * C,
                    g = 1 / M(m),
                    y = I(m);
                  this._rotating && r.setBearing(e.F.number(n, c, a)),
                    this._pitching && r.setPitch(e.F.number(o, h, a)),
                    this._rolling && r.setRoll(e.F.number(s, u, a)),
                    this._padding &&
                      (r.interpolatePadding(l, d, a),
                      (f = r.centerPoint.add(p))),
                    _.easeFunc(a, g, y, f),
                    this.terrain &&
                      !t.freezeElevation &&
                      this._updateElevation(a),
                    this._applyUpdatedTransform(r),
                    this._fireMoveEvents(i);
                },
                () => {
                  this.terrain &&
                    t.freezeElevation &&
                    this._finalizeElevation(),
                    this._afterEase(i);
                },
                t
              ),
              this
            );
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t, e) {
            var i;
            if (
              (this._easeFrameId &&
                (this._cancelRenderFrame(this._easeFrameId),
                delete this._easeFrameId,
                delete this._onEaseFrame),
              this._onEaseEnd)
            ) {
              const t = this._onEaseEnd;
              delete this._onEaseEnd, t.call(this, e);
            }
            return (
              t || null === (i = this.handlers) || void 0 === i || i.stop(!1),
              this
            );
          }
          _ease(t, e, i) {
            !1 === i.animate || 0 === i.duration
              ? (t(1), e())
              : ((this._easeStart = l()),
                (this._easeOptions = i),
                (this._onEaseFrame = t),
                (this._onEaseEnd = e),
                (this._easeFrameId = this._requestRenderFrame(
                  this._renderFrameCallback
                )));
          }
          _normalizeBearing(t, i) {
            t = e.V(t, -180, 180);
            const r = Math.abs(t - i);
            return (
              Math.abs(t - 360 - i) < r && (t -= 360),
              Math.abs(t + 360 - i) < r && (t += 360),
              t
            );
          }
          queryTerrainElevation(t) {
            return this.terrain
              ? this.terrain.getElevationForLngLatZoom(
                  e.U.convert(t),
                  this.transform.tileZoom
                )
              : null;
          }
        }
        const Go = {
          compact: !0,
          customAttribution:
            '<a href="https://maplibre.org/" target="_blank">MapLibre</a>',
        };
        class Zo {
          constructor(t = Go) {
            (this._toggleAttribution = () => {
              this._container.classList.contains('maplibregl-compact') &&
                (this._container.classList.contains('maplibregl-compact-show')
                  ? (this._container.setAttribute('open', ''),
                    this._container.classList.remove('maplibregl-compact-show'))
                  : (this._container.classList.add('maplibregl-compact-show'),
                    this._container.removeAttribute('open')));
            }),
              (this._updateData = (t) => {
                !t ||
                  ('metadata' !== t.sourceDataType &&
                    'visibility' !== t.sourceDataType &&
                    'style' !== t.dataType &&
                    'terrain' !== t.type) ||
                  this._updateAttributions();
              }),
              (this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 ||
                this._compact
                  ? !1 === this._compact
                    ? this._container.setAttribute('open', '')
                    : this._container.classList.contains(
                        'maplibregl-compact'
                      ) ||
                      this._container.classList.contains(
                        'maplibregl-attrib-empty'
                      ) ||
                      (this._container.setAttribute('open', ''),
                      this._container.classList.add(
                        'maplibregl-compact',
                        'maplibregl-compact-show'
                      ))
                  : (this._container.setAttribute('open', ''),
                    this._container.classList.contains('maplibregl-compact') &&
                      this._container.classList.remove(
                        'maplibregl-compact',
                        'maplibregl-compact-show'
                      ));
              }),
              (this._updateCompactMinimize = () => {
                this._container.classList.contains('maplibregl-compact') &&
                  this._container.classList.contains(
                    'maplibregl-compact-show'
                  ) &&
                  this._container.classList.remove('maplibregl-compact-show');
              }),
              (this.options = t);
          }
          getDefaultPosition() {
            return 'bottom-right';
          }
          onAdd(t) {
            return (
              (this._map = t),
              (this._compact = this.options.compact),
              (this._container = c.create(
                'details',
                'maplibregl-ctrl maplibregl-ctrl-attrib'
              )),
              (this._compactButton = c.create(
                'summary',
                'maplibregl-ctrl-attrib-button',
                this._container
              )),
              this._compactButton.addEventListener(
                'click',
                this._toggleAttribution
              ),
              this._setElementTitle(this._compactButton, 'ToggleAttribution'),
              (this._innerContainer = c.create(
                'div',
                'maplibregl-ctrl-attrib-inner',
                this._container
              )),
              this._updateAttributions(),
              this._updateCompact(),
              this._map.on('styledata', this._updateData),
              this._map.on('sourcedata', this._updateData),
              this._map.on('terrain', this._updateData),
              this._map.on('resize', this._updateCompact),
              this._map.on('drag', this._updateCompactMinimize),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this._map.off('styledata', this._updateData),
              this._map.off('sourcedata', this._updateData),
              this._map.off('terrain', this._updateData),
              this._map.off('resize', this._updateCompact),
              this._map.off('drag', this._updateCompactMinimize),
              (this._map = void 0),
              (this._compact = void 0),
              (this._attribHTML = void 0);
          }
          _setElementTitle(t, e) {
            const i = this._map._getUIString(`AttributionControl.${e}`);
            (t.title = i), t.setAttribute('aria-label', i);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (
              (this.options.customAttribution &&
                (Array.isArray(this.options.customAttribution)
                  ? (t = t.concat(
                      this.options.customAttribution.map((t) =>
                        'string' != typeof t ? '' : t
                      )
                    ))
                  : 'string' == typeof this.options.customAttribution &&
                    t.push(this.options.customAttribution)),
              this._map.style.stylesheet)
            ) {
              const t = this._map.style.stylesheet;
              (this.styleOwner = t.owner), (this.styleId = t.id);
            }
            const e = this._map.style.tileManagers;
            for (const r in e) {
              const i = e[r];
              if (i.used || i.usedForTerrain) {
                const e = i.getSource();
                e.attribution &&
                  t.indexOf(e.attribution) < 0 &&
                  t.push(e.attribution);
              }
            }
            (t = t.filter((t) => String(t).trim())),
              t.sort((t, e) => t.length - e.length),
              (t = t.filter((e, i) => {
                for (let r = i + 1; r < t.length; r++)
                  if (t[r].indexOf(e) >= 0) return !1;
                return !0;
              }));
            const i = t.join(' | ');
            i !== this._attribHTML &&
              ((this._attribHTML = i),
              t.length
                ? ((this._innerContainer.innerHTML = c.sanitize(i)),
                  this._container.classList.remove('maplibregl-attrib-empty'))
                : this._container.classList.add('maplibregl-attrib-empty'),
              this._updateCompact(),
              (this._editLink = null));
          }
        }
        class $o {
          constructor(t = {}) {
            (this._updateCompact = () => {
              const t = this._container.children;
              if (t.length) {
                const e = t[0];
                this._map.getCanvasContainer().offsetWidth <= 640 ||
                this._compact
                  ? !1 !== this._compact &&
                    e.classList.add('maplibregl-compact')
                  : e.classList.remove('maplibregl-compact');
              }
            }),
              (this.options = t);
          }
          getDefaultPosition() {
            return 'bottom-left';
          }
          onAdd(t) {
            (this._map = t),
              (this._compact = this.options && this.options.compact),
              (this._container = c.create('div', 'maplibregl-ctrl'));
            const e = c.create('a', 'maplibregl-ctrl-logo');
            return (
              (e.target = '_blank'),
              (e.rel = 'noopener nofollow'),
              (e.href = 'https://maplibre.org/'),
              e.setAttribute(
                'aria-label',
                this._map._getUIString('LogoControl.Title')
              ),
              e.setAttribute('rel', 'noopener nofollow'),
              this._container.appendChild(e),
              (this._container.style.display = 'block'),
              this._map.on('resize', this._updateCompact),
              this._updateCompact(),
              this._container
            );
          }
          onRemove() {
            c.remove(this._container),
              this._map.off('resize', this._updateCompact),
              (this._map = void 0),
              (this._compact = void 0);
          }
        }
        class qo {
          constructor() {
            (this._queue = []),
              (this._id = 0),
              (this._cleared = !1),
              (this._currentlyRunning = !1);
          }
          add(t) {
            const e = ++this._id;
            return this._queue.push({ callback: t, id: e, cancelled: !1 }), e;
          }
          remove(t) {
            const e = this._currentlyRunning,
              i = e ? this._queue.concat(e) : this._queue;
            for (const r of i) if (r.id === t) return void (r.cancelled = !0);
          }
          run(t = 0) {
            if (this._currentlyRunning)
              throw new Error('Attempting to run(), but is already running.');
            const e = (this._currentlyRunning = this._queue);
            this._queue = [];
            for (const i of e)
              if (!i.cancelled && (i.callback(t), this._cleared)) break;
            (this._cleared = !1), (this._currentlyRunning = !1);
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), (this._queue = []);
          }
        }
        var Wo = e.aN([{ name: 'a_pos3d', type: 'Int16', components: 3 }]);
        class Yo extends e.E {
          constructor(t) {
            super(),
              (this._lastTilesetChange = l()),
              (this.tileManager = t),
              (this._tiles = {}),
              (this._renderableTilesKeys = []),
              (this._sourceTileCache = {}),
              (this.minzoom = 0),
              (this.maxzoom = 22),
              (this.deltaZoom = 1),
              (this.tileSize = t._source.tileSize * 2 ** this.deltaZoom),
              (t.usedForTerrain = !0),
              (t.tileSize = this.tileSize);
          }
          destruct() {
            (this.tileManager.usedForTerrain = !1),
              (this.tileManager.tileSize = null);
          }
          getSource() {
            return this.tileManager._source;
          }
          update(t, i) {
            this.tileManager.update(t, i), (this._renderableTilesKeys = []);
            const r = {};
            for (const n of St(t, {
              tileSize: this.tileSize,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              reparseOverscaled: !1,
              terrain: i,
              calculateTileZoom: this.tileManager._source.calculateTileZoom,
            }))
              (r[n.key] = !0),
                this._renderableTilesKeys.push(n.key),
                this._tiles[n.key] ||
                  ((n.terrainRttPosMatrix32f = new Float64Array(16)),
                  e.c0(n.terrainRttPosMatrix32f, 0, e.a3, e.a3, 0, 0, 1),
                  (this._tiles[n.key] = new ut(n, this.tileSize)),
                  (this._lastTilesetChange = l()));
            for (const e in this._tiles) r[e] || delete this._tiles[e];
          }
          freeRtt(t) {
            for (const e in this._tiles) {
              const i = this._tiles[e];
              (!t ||
                i.tileID.equals(t) ||
                i.tileID.isChildOf(t) ||
                t.isChildOf(i.tileID)) &&
                (i.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t) => this.getTileByID(t));
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          getTerrainCoords(t, e) {
            return e
              ? this._getTerrainCoordsForTileRanges(t, e)
              : this._getTerrainCoordsForRegularTile(t);
          }
          _getTerrainCoordsForRegularTile(t) {
            const i = {};
            for (const r of this._renderableTilesKeys) {
              const n = this._tiles[r].tileID,
                o = t.clone(),
                a = e.bd();
              if (n.canonical.equals(t.canonical))
                e.c0(a, 0, e.a3, e.a3, 0, 0, 1);
              else if (n.canonical.isChildOf(t.canonical)) {
                const i = n.canonical.z - t.canonical.z,
                  r = n.canonical.x - ((n.canonical.x >> i) << i),
                  o = n.canonical.y - ((n.canonical.y >> i) << i),
                  s = e.a3 >> i;
                e.c0(a, 0, s, s, 0, 0, 1), e.N(a, a, [-r * s, -o * s, 0]);
              } else {
                if (!t.canonical.isChildOf(n.canonical)) continue;
                {
                  const i = t.canonical.z - n.canonical.z,
                    r = t.canonical.x - ((t.canonical.x >> i) << i),
                    o = t.canonical.y - ((t.canonical.y >> i) << i),
                    s = e.a3 >> i;
                  e.c0(a, 0, e.a3, e.a3, 0, 0, 1),
                    e.N(a, a, [r * s, o * s, 0]),
                    e.O(a, a, [1 / 2 ** i, 1 / 2 ** i, 0]);
                }
              }
              (o.terrainRttPosMatrix32f = new Float32Array(a)), (i[r] = o);
            }
            return i;
          }
          _getTerrainCoordsForTileRanges(t, i) {
            const r = {};
            for (const n of this._renderableTilesKeys) {
              const o = this._tiles[n].tileID;
              if (!this._isWithinTileRanges(o, i)) continue;
              const a = t.clone(),
                s = e.bd();
              if (o.canonical.z === t.canonical.z) {
                const i = t.canonical.x - o.canonical.x,
                  r = t.canonical.y - o.canonical.y;
                e.c0(s, 0, e.a3, e.a3, 0, 0, 1),
                  e.N(s, s, [i * e.a3, r * e.a3, 0]);
              } else if (o.canonical.z > t.canonical.z) {
                const i = o.canonical.z - t.canonical.z,
                  r = o.canonical.x - ((o.canonical.x >> i) << i),
                  n = o.canonical.y - ((o.canonical.y >> i) << i),
                  a = t.canonical.x - (o.canonical.x >> i),
                  l = t.canonical.y - (o.canonical.y >> i),
                  c = e.a3 >> i;
                e.c0(s, 0, c, c, 0, 0, 1),
                  e.N(s, s, [-r * c + a * e.a3, -n * c + l * e.a3, 0]);
              } else {
                const i = t.canonical.z - o.canonical.z,
                  r = t.canonical.x - ((t.canonical.x >> i) << i),
                  n = t.canonical.y - ((t.canonical.y >> i) << i),
                  a = (t.canonical.x >> i) - o.canonical.x,
                  l = (t.canonical.y >> i) - o.canonical.y,
                  c = e.a3 << i;
                e.c0(s, 0, c, c, 0, 0, 1),
                  e.N(s, s, [r * e.a3 + a * c, n * e.a3 + l * c, 0]);
              }
              (a.terrainRttPosMatrix32f = new Float32Array(s)), (r[n] = a);
            }
            return r;
          }
          getSourceTile(t, e) {
            const i = this.tileManager._source;
            let r = t.overscaledZ - this.deltaZoom;
            if ((r > i.maxzoom && (r = i.maxzoom), r < i.minzoom)) return null;
            this._sourceTileCache[t.key] ||
              (this._sourceTileCache[t.key] = t.scaledTo(r).key);
            let n = this.tileManager.getTileByID(this._sourceTileCache[t.key]);
            if ((!n || !n.dem) && e)
              for (; r >= i.minzoom && (!n || !n.dem); )
                n = this.tileManager.getTileByID(t.scaledTo(r--).key);
            return n;
          }
          anyTilesAfterTime(t = Date.now()) {
            return this._lastTilesetChange >= t;
          }
          _isWithinTileRanges(t, e) {
            return (
              e[t.canonical.z] &&
              t.canonical.x >= e[t.canonical.z].minTileX &&
              t.canonical.x <= e[t.canonical.z].maxTileX &&
              t.canonical.y >= e[t.canonical.z].minTileY &&
              t.canonical.y <= e[t.canonical.z].maxTileY
            );
          }
        }
        class Ho {
          constructor(t, e, i) {
            (this._meshCache = {}),
              (this.painter = t),
              (this.tileManager = new Yo(e)),
              (this.options = i),
              (this.exaggeration =
                'number' == typeof i.exaggeration ? i.exaggeration : 1),
              (this.qualityFactor = 2),
              (this.meshSize = 128),
              (this._demMatrixCache = {}),
              (this.coordsIndex = []),
              (this._coordsTextureSize = 1024);
          }
          getDEMElevation(t, i, r, n = e.a3) {
            var o;
            if (!(i >= 0 && i < n && r >= 0 && r < n)) return 0;
            const a = this.getTerrainData(t),
              s = null === (o = a.tile) || void 0 === o ? void 0 : o.dem;
            if (!s) return 0;
            const l = e.cv(
                [],
                [(i / n) * e.a3, (r / n) * e.a3],
                a.u_terrain_matrix
              ),
              c = [l[0] * s.dim, l[1] * s.dim],
              h = Math.floor(c[0]),
              u = Math.floor(c[1]),
              d = c[0] - h,
              p = c[1] - u;
            return (
              s.get(h, u) * (1 - d) * (1 - p) +
              s.get(h + 1, u) * d * (1 - p) +
              s.get(h, u + 1) * (1 - d) * p +
              s.get(h + 1, u + 1) * d * p
            );
          }
          getElevationForLngLatZoom(t, i) {
            if (!e.cw(i, t.wrap())) return 0;
            const {
              tileID: r,
              mercatorX: n,
              mercatorY: o,
            } = this._getOverscaledTileIDFromLngLatZoom(t, i);
            return this.getElevation(r, n % e.a3, o % e.a3, e.a3);
          }
          getElevation(t, i, r, n = e.a3) {
            return this.getDEMElevation(t, i, r, n) * this.exaggeration;
          }
          getTerrainData(t) {
            if (!this._emptyDemTexture) {
              const t = this.painter.context,
                i = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
              (this._emptyDepthTexture = new e.T(t, i, t.gl.RGBA, {
                premultiply: !1,
              })),
                (this._emptyDemUnpack = [0, 0, 0, 0]),
                (this._emptyDemTexture = new e.T(
                  t,
                  new e.R({ width: 1, height: 1 }),
                  t.gl.RGBA,
                  { premultiply: !1 }
                )),
                this._emptyDemTexture.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
                (this._emptyDemMatrix = e.am([]));
            }
            const i = this.tileManager.getSourceTile(t, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const t = this.painter.context;
              (i.demTexture = this.painter.getTileTexture(i.dem.stride)),
                i.demTexture
                  ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 })
                  : (i.demTexture = new e.T(t, i.dem.getPixels(), t.gl.RGBA, {
                      premultiply: !1,
                    })),
                i.demTexture.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
                (i.needsTerrainPrepare = !1);
            }
            const r = i && i + i.tileID.key + t.key;
            if (r && !this._demMatrixCache[r]) {
              const r = this.tileManager.getSource().maxzoom;
              let n = t.canonical.z - i.tileID.canonical.z;
              t.overscaledZ > t.canonical.z &&
                (t.canonical.z >= r
                  ? (n = t.canonical.z - r)
                  : e.w(
                      'cannot calculate elevation if elevation maxzoom > source.maxzoom'
                    ));
              const o = t.canonical.x - ((t.canonical.x >> n) << n),
                a = t.canonical.y - ((t.canonical.y >> n) << n),
                s = e.cx(new Float64Array(16), [
                  1 / (e.a3 << n),
                  1 / (e.a3 << n),
                  0,
                ]);
              e.N(s, s, [o * e.a3, a * e.a3, 0]),
                (this._demMatrixCache[t.key] = { matrix: s, coord: t });
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: (i && i.dem && i.dem.dim) || 1,
              u_terrain_matrix: r
                ? this._demMatrixCache[t.key].matrix
                : this._emptyDemMatrix,
              u_terrain_unpack:
                (i && i.dem && i.dem.getUnpackVector()) || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: ((i && i.demTexture) || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture)
                .texture,
              tile: i,
            };
          }
          getFramebuffer(t) {
            const i = this.painter,
              r = i.width / devicePixelRatio,
              n = i.height / devicePixelRatio;
            return (
              !this._fbo ||
                (this._fbo.width === r && this._fbo.height === n) ||
                (this._fbo.destroy(),
                this._fboCoordsTexture.destroy(),
                this._fboDepthTexture.destroy(),
                delete this._fbo,
                delete this._fboDepthTexture,
                delete this._fboCoordsTexture),
              this._fboCoordsTexture ||
                ((this._fboCoordsTexture = new e.T(
                  i.context,
                  { width: r, height: n, data: null },
                  i.context.gl.RGBA,
                  { premultiply: !1 }
                )),
                this._fboCoordsTexture.bind(
                  i.context.gl.NEAREST,
                  i.context.gl.CLAMP_TO_EDGE
                )),
              this._fboDepthTexture ||
                ((this._fboDepthTexture = new e.T(
                  i.context,
                  { width: r, height: n, data: null },
                  i.context.gl.RGBA,
                  { premultiply: !1 }
                )),
                this._fboDepthTexture.bind(
                  i.context.gl.NEAREST,
                  i.context.gl.CLAMP_TO_EDGE
                )),
              this._fbo ||
                ((this._fbo = i.context.createFramebuffer(r, n, !0, !1)),
                this._fbo.depthAttachment.set(
                  i.context.createRenderbuffer(
                    i.context.gl.DEPTH_COMPONENT16,
                    r,
                    n
                  )
                )),
              this._fbo.colorAttachment.set(
                'coords' === t
                  ? this._fboCoordsTexture.texture
                  : this._fboDepthTexture.texture
              ),
              this._fbo
            );
          }
          getCoordsTexture() {
            const t = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(
              this._coordsTextureSize * this._coordsTextureSize * 4
            );
            for (let e = 0, o = 0; e < this._coordsTextureSize; e++)
              for (let t = 0; t < this._coordsTextureSize; t++, o += 4)
                (i[o + 0] = 255 & t),
                  (i[o + 1] = 255 & e),
                  (i[o + 2] = ((t >> 8) << 4) | (e >> 8)),
                  (i[o + 3] = 0);
            const r = new e.R(
                {
                  width: this._coordsTextureSize,
                  height: this._coordsTextureSize,
                },
                new Uint8Array(i.buffer)
              ),
              n = new e.T(t, r, t.gl.RGBA, { premultiply: !1 });
            return (
              n.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE),
              (this._coordsTexture = n),
              n
            );
          }
          pointCoordinate(t) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4),
              r = this.painter.context,
              n = r.gl,
              o = Math.round(
                (t.x * this.painter.pixelRatio) / devicePixelRatio
              ),
              a = Math.round(
                (t.y * this.painter.pixelRatio) / devicePixelRatio
              ),
              s = Math.round(this.painter.height / devicePixelRatio);
            r.bindFramebuffer.set(this.getFramebuffer('coords').framebuffer),
              n.readPixels(o, s - a - 1, 1, 1, n.RGBA, n.UNSIGNED_BYTE, i),
              r.bindFramebuffer.set(null);
            const l = i[0] + ((i[2] >> 4) << 8),
              c = i[1] + ((15 & i[2]) << 8),
              h = this.coordsIndex[255 - i[3]],
              u = h && this.tileManager.getTileByID(h);
            if (!u) return null;
            const d = this._coordsTextureSize,
              p = (1 << u.tileID.canonical.z) * d;
            return new e.a5(
              (u.tileID.canonical.x * d + l) / p + u.tileID.wrap,
              (u.tileID.canonical.y * d + c) / p,
              this.getElevation(u.tileID, l, c, d)
            );
          }
          depthAtPoint(t) {
            const e = new Uint8Array(4),
              i = this.painter.context,
              r = i.gl;
            return (
              i.bindFramebuffer.set(this.getFramebuffer('depth').framebuffer),
              r.readPixels(
                t.x,
                this.painter.height / devicePixelRatio - t.y - 1,
                1,
                1,
                r.RGBA,
                r.UNSIGNED_BYTE,
                e
              ),
              i.bindFramebuffer.set(null),
              (e[0] / 16777216 + e[1] / 65536 + e[2] / 256 + e[3]) / 256
            );
          }
          getTerrainMesh(t) {
            var i;
            const r =
                (null === (i = this.painter.style.projection) || void 0 === i
                  ? void 0
                  : i.transitionState) > 0,
              n = r && 0 === t.canonical.y,
              o = r && t.canonical.y === (1 << t.canonical.z) - 1,
              a = `m_${n ? 'n' : ''}_${o ? 's' : ''}`;
            if (this._meshCache[a]) return this._meshCache[a];
            const s = this.painter.context,
              l = new e.cy(),
              c = new e.aR(),
              h = this.meshSize,
              u = e.a3 / h,
              d = h * h;
            for (let e = 0; e <= h; e++)
              for (let t = 0; t <= h; t++) l.emplaceBack(t * u, e * u, 0);
            for (let e = 0; e < d; e += h + 1)
              for (let t = 0; t < h; t++)
                c.emplaceBack(t + e, h + t + e + 1, h + t + e + 2),
                  c.emplaceBack(t + e, h + t + e + 2, t + e + 1);
            const p = l.length,
              f = p + (h + 1),
              m = (h + 1) * h,
              _ = n ? e.bk : 0,
              g = n ? 0 : 1,
              y = o ? e.bl : e.a3,
              x = o ? 0 : 1;
            for (let e = 0; e <= h; e++) l.emplaceBack(e * u, _, g);
            for (let e = 0; e <= h; e++) l.emplaceBack(e * u, y, x);
            for (let e = 0; e < h; e++)
              c.emplaceBack(m + e, f + e, f + e + 1),
                c.emplaceBack(m + e, f + e + 1, m + e + 1),
                c.emplaceBack(0 + e, p + e + 1, p + e),
                c.emplaceBack(0 + e, 0 + e + 1, p + e + 1);
            const v = l.length,
              b = v + 2 * (h + 1);
            for (const T of [0, 1])
              for (let t = 0; t <= h; t++)
                for (const i of [0, 1]) l.emplaceBack(T * e.a3, t * u, i);
            for (let e = 0; e < 2 * h; e += 2)
              c.emplaceBack(v + e, v + e + 1, v + e + 3),
                c.emplaceBack(v + e, v + e + 3, v + e + 2),
                c.emplaceBack(b + e, b + e + 3, b + e + 1),
                c.emplaceBack(b + e, b + e + 2, b + e + 3);
            const w = new Ae(
              s.createVertexBuffer(l, Wo.members),
              s.createIndexBuffer(c),
              e.aQ.simpleSegment(0, 0, l.length, c.length)
            );
            return (this._meshCache[a] = w), w;
          }
          getMeshFrameDelta(t) {
            return (2 * Math.PI * e.bx) / Math.pow(2, Math.max(t, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(t, e) {
            var i;
            const { tileID: r } = this._getOverscaledTileIDFromLngLatZoom(t, e);
            return null !== (i = this.getMinMaxElevation(r).minElevation) &&
              void 0 !== i
              ? i
              : 0;
          }
          getMinMaxElevation(t) {
            const e = this.getTerrainData(t).tile,
              i = { minElevation: null, maxElevation: null };
            return (
              e &&
                e.dem &&
                ((i.minElevation = e.dem.min * this.exaggeration),
                (i.maxElevation = e.dem.max * this.exaggeration)),
              i
            );
          }
          _getOverscaledTileIDFromLngLatZoom(t, i) {
            const r = e.a5.fromLngLat(t.wrap()),
              n = (1 << i) * e.a3,
              o = r.x * n,
              a = r.y * n,
              s = Math.floor(o / e.a3),
              l = Math.floor(a / e.a3);
            return {
              tileID: new e.a0(i, 0, i, s, l),
              mercatorX: o,
              mercatorY: a,
            };
          }
        }
        class Xo {
          constructor(t, e, i) {
            (this._context = t),
              (this._size = e),
              (this._tileSize = i),
              (this._objects = []),
              (this._recentlyUsed = []),
              (this._stamp = 0);
          }
          destruct() {
            for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
          }
          _createObject(t) {
            const i = this._context.createFramebuffer(
                this._tileSize,
                this._tileSize,
                !0,
                !0
              ),
              r = new e.T(
                this._context,
                { width: this._tileSize, height: this._tileSize, data: null },
                this._context.gl.RGBA
              );
            return (
              r.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
              this._context.extTextureFilterAnisotropic &&
                this._context.gl.texParameterf(
                  this._context.gl.TEXTURE_2D,
                  this._context.extTextureFilterAnisotropic
                    .TEXTURE_MAX_ANISOTROPY_EXT,
                  this._context.extTextureFilterAnisotropicMax
                ),
              i.depthAttachment.set(
                this._context.createRenderbuffer(
                  this._context.gl.DEPTH_STENCIL,
                  this._tileSize,
                  this._tileSize
                )
              ),
              i.colorAttachment.set(r.texture),
              { id: t, fbo: i, texture: r, stamp: -1, inUse: !1 }
            );
          }
          getObjectForId(t) {
            return this._objects[t];
          }
          useObject(t) {
            (t.inUse = !0),
              (this._recentlyUsed = this._recentlyUsed.filter(
                (e) => t.id !== e
              )),
              this._recentlyUsed.push(t.id);
          }
          stampObject(t) {
            t.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const e of this._recentlyUsed)
              if (!this._objects[e].inUse) return this._objects[e];
            if (this._objects.length >= this._size)
              throw new Error(
                'No free RenderPool available, call freeAllObjects() required!'
              );
            const t = this._createObject(this._objects.length);
            return this._objects.push(t), t;
          }
          freeObject(t) {
            t.inUse = !1;
          }
          freeAllObjects() {
            for (const t of this._objects) this.freeObject(t);
          }
          isFull() {
            return (
              !(this._objects.length < this._size) &&
              !1 === this._objects.some((t) => !t.inUse)
            );
          }
        }
        const Ko = {
          'background': !0,
          'fill': !0,
          'line': !0,
          'raster': !0,
          'hillshade': !0,
          'color-relief': !0,
        };
        class Jo {
          constructor(t, e) {
            (this.painter = t),
              (this.terrain = e),
              (this.pool = new Xo(
                t.context,
                30,
                e.tileManager.tileSize * e.qualityFactor
              ));
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t) {
            return this.pool.getObjectForId(
              t.rtt[this._stacks.length - 1].id
            ).texture;
          }
          prepareForRender(t, e) {
            (this._stacks = []),
              (this._prevType = null),
              (this._rttTiles = []),
              (this._renderableTiles =
                this.terrain.tileManager.getRenderableTiles()),
              (this._renderableLayerIds = t._order.filter(
                (i) => !t._layers[i].isHidden(e)
              )),
              (this._coordsAscending = {});
            for (const i in t.tileManagers) {
              this._coordsAscending[i] = {};
              const e = t.tileManagers[i].getVisibleCoordinates(),
                r = t.tileManagers[i].getSource(),
                n = r instanceof tt ? r.terrainTileRanges : null;
              for (const t of e) {
                const e = this.terrain.tileManager.getTerrainCoords(t, n);
                for (const t in e)
                  this._coordsAscending[i][t] ||
                    (this._coordsAscending[i][t] = []),
                    this._coordsAscending[i][t].push(e[t]);
              }
            }
            this._coordsAscendingStr = {};
            for (const i of t._order) {
              const e = t._layers[i],
                r = e.source;
              if (Ko[e.type] && !this._coordsAscendingStr[r]) {
                this._coordsAscendingStr[r] = {};
                for (const t in this._coordsAscending[r])
                  this._coordsAscendingStr[r][t] = this._coordsAscending[r][t]
                    .map((t) => t.key)
                    .sort()
                    .join();
              }
            }
            for (const i of this._renderableTiles)
              for (const t in this._coordsAscendingStr) {
                const e = this._coordsAscendingStr[t][i.tileID.key];
                e && e !== i.rttCoords[t] && (i.rtt = []);
              }
          }
          renderLayer(t, i) {
            if (t.isHidden(this.painter.transform.zoom)) return !1;
            const r = Object.assign(Object.assign({}, i), {
                isRenderingToTexture: !0,
              }),
              n = t.type,
              o = this.painter,
              a =
                this._renderableLayerIds[
                  this._renderableLayerIds.length - 1
                ] === t.id;
            if (
              Ko[n] &&
              ((this._prevType && Ko[this._prevType]) || this._stacks.push([]),
              (this._prevType = n),
              this._stacks[this._stacks.length - 1].push(t.id),
              !a)
            )
              return !0;
            if (Ko[this._prevType] || (Ko[n] && a)) {
              this._prevType = n;
              const t = this._stacks.length - 1,
                i = this._stacks[t] || [];
              for (const n of this._renderableTiles) {
                if (
                  (this.pool.isFull() &&
                    (On(this.painter, this.terrain, this._rttTiles, r),
                    (this._rttTiles = []),
                    this.pool.freeAllObjects()),
                  this._rttTiles.push(n),
                  n.rtt[t])
                ) {
                  const e = this.pool.getObjectForId(n.rtt[t].id);
                  if (e.stamp === n.rtt[t].stamp) {
                    this.pool.useObject(e);
                    continue;
                  }
                }
                const a = this.pool.getOrCreateFreeObject();
                this.pool.useObject(a),
                  this.pool.stampObject(a),
                  (n.rtt[t] = { id: a.id, stamp: a.stamp }),
                  o.context.bindFramebuffer.set(a.fbo.framebuffer),
                  o.context.clear({ color: e.bi.transparent, stencil: 0 }),
                  (o.currentStencilSource = void 0);
                for (let t = 0; t < i.length; t++) {
                  const e = o.style._layers[i[t]],
                    s = e.source
                      ? this._coordsAscending[e.source][n.tileID.key]
                      : [n.tileID];
                  o.context.viewport.set([0, 0, a.fbo.width, a.fbo.height]),
                    o._renderTileClippingMasks(e, s, !0),
                    o.renderLayer(o, o.style.tileManagers[e.source], e, s, r),
                    e.source &&
                      (n.rttCoords[e.source] =
                        this._coordsAscendingStr[e.source][n.tileID.key]);
                }
              }
              return (
                On(this.painter, this.terrain, this._rttTiles, r),
                (this._rttTiles = []),
                this.pool.freeAllObjects(),
                Ko[n]
              );
            }
            return !1;
          }
        }
        const Qo = {
            'AttributionControl.ToggleAttribution': 'Toggle attribution',
            'AttributionControl.MapFeedback': 'Map feedback',
            'FullscreenControl.Enter': 'Enter fullscreen',
            'FullscreenControl.Exit': 'Exit fullscreen',
            'GeolocateControl.FindMyLocation': 'Find my location',
            'GeolocateControl.LocationNotAvailable': 'Location not available',
            'LogoControl.Title': 'MapLibre logo',
            'Map.Title': 'Map',
            'Marker.Title': 'Map marker',
            'NavigationControl.ResetBearing': 'Reset bearing to north',
            'NavigationControl.ZoomIn': 'Zoom in',
            'NavigationControl.ZoomOut': 'Zoom out',
            'Popup.Close': 'Close popup',
            'ScaleControl.Feet': 'ft',
            'ScaleControl.Meters': 'm',
            'ScaleControl.Kilometers': 'km',
            'ScaleControl.Miles': 'mi',
            'ScaleControl.NauticalMiles': 'nm',
            'GlobeControl.Enable': 'Enable globe',
            'GlobeControl.Disable': 'Disable globe',
            'TerrainControl.Enable': 'Enable terrain',
            'TerrainControl.Disable': 'Disable terrain',
            'CooperativeGesturesHandler.WindowsHelpText':
              'Use Ctrl + scroll to zoom the map',
            'CooperativeGesturesHandler.MacHelpText':
              'Use  + scroll to zoom the map',
            'CooperativeGesturesHandler.MobileHelpText':
              'Use two fingers to move the map',
          },
          ta = i,
          ea = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: Go,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: 'high-performance',
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0,
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: 'sans-serif',
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0,
          },
          ia = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0,
          };
        class ra {
          constructor(t, i, r = !1) {
            (this.mousedown = (t) => {
              this.startMove(t, c.mousePos(this.element, t)),
                c.addEventListener(window, 'mousemove', this.mousemove),
                c.addEventListener(window, 'mouseup', this.mouseup);
            }),
              (this.mousemove = (t) => {
                this.move(t, c.mousePos(this.element, t));
              }),
              (this.mouseup = (t) => {
                this._rotatePitchHandler.dragEnd(t), this.offTemp();
              }),
              (this.touchstart = (t) => {
                1 !== t.targetTouches.length
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      c.touchPos(this.element, t.targetTouches)[0]),
                    this.startMove(t, this._startPos),
                    c.addEventListener(window, 'touchmove', this.touchmove, {
                      passive: !1,
                    }),
                    c.addEventListener(window, 'touchend', this.touchend));
              }),
              (this.touchmove = (t) => {
                1 !== t.targetTouches.length
                  ? this.reset()
                  : ((this._lastPos = c.touchPos(
                      this.element,
                      t.targetTouches
                    )[0]),
                    this.move(t, this._lastPos));
              }),
              (this.touchend = (t) => {
                0 === t.targetTouches.length &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }),
              (this.reset = () => {
                this._rotatePitchHandler.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }),
              (this._clickTolerance = 10),
              (this.element = i);
            const n = new fo();
            (this._rotatePitchHandler = new co({
              clickTolerance: 3,
              move: (t, n) => {
                const o = i.getBoundingClientRect(),
                  a = new e.P((o.bottom - o.top) / 2, (o.right - o.left) / 2);
                return {
                  bearingDelta: e.cq(new e.P(t.x, n.y), n, a),
                  pitchDelta: r ? -0.5 * (n.y - t.y) : void 0,
                };
              },
              moveStateManager: n,
              enable: !0,
              assignEvents: () => {},
            })),
              (this.map = t),
              c.addEventListener(i, 'mousedown', this.mousedown),
              c.addEventListener(i, 'touchstart', this.touchstart, {
                passive: !1,
              }),
              c.addEventListener(i, 'touchcancel', this.reset);
          }
          startMove(t, e) {
            this._rotatePitchHandler.dragStart(t, e), c.disableDrag();
          }
          move(t, e) {
            const i = this.map,
              { bearingDelta: r, pitchDelta: n } =
                this._rotatePitchHandler.dragMove(t, e) || {};
            r && i.setBearing(i.getBearing() + r),
              n && i.setPitch(i.getPitch() + n);
          }
          off() {
            const t = this.element;
            c.removeEventListener(t, 'mousedown', this.mousedown),
              c.removeEventListener(t, 'touchstart', this.touchstart, {
                passive: !1,
              }),
              c.removeEventListener(window, 'touchmove', this.touchmove, {
                passive: !1,
              }),
              c.removeEventListener(window, 'touchend', this.touchend),
              c.removeEventListener(t, 'touchcancel', this.reset),
              this.offTemp();
          }
          offTemp() {
            c.enableDrag(),
              c.removeEventListener(window, 'mousemove', this.mousemove),
              c.removeEventListener(window, 'mouseup', this.mouseup),
              c.removeEventListener(window, 'touchmove', this.touchmove, {
                passive: !1,
              }),
              c.removeEventListener(window, 'touchend', this.touchend);
          }
        }
        let na;
        function oa(t, i, r, n = !1) {
          if (n || !r.getCoveringTilesDetailsProvider().allowWorldCopies())
            return null == t ? void 0 : t.wrap();
          const o = new e.U(t.lng, t.lat);
          if (((t = new e.U(t.lng, t.lat)), i)) {
            const n = new e.U(t.lng - 360, t.lat),
              o = new e.U(t.lng + 360, t.lat),
              a = r.locationToScreenPoint(t).distSqr(i);
            r.locationToScreenPoint(n).distSqr(i) < a
              ? (t = n)
              : r.locationToScreenPoint(o).distSqr(i) < a && (t = o);
          }
          for (; Math.abs(t.lng - r.center.lng) > 180; ) {
            const e = r.locationToScreenPoint(t);
            if (e.x >= 0 && e.y >= 0 && e.x <= r.width && e.y <= r.height)
              break;
            t.lng > r.center.lng ? (t.lng -= 360) : (t.lng += 360);
          }
          return t.lng !== o.lng &&
            r.isPointOnMapSurface(r.locationToScreenPoint(t))
            ? t
            : o;
        }
        const aa = {
          'center': 'translate(-50%,-50%)',
          'top': 'translate(-50%,0)',
          'top-left': 'translate(0,0)',
          'top-right': 'translate(-100%,0)',
          'bottom': 'translate(-50%,-100%)',
          'bottom-left': 'translate(0,-100%)',
          'bottom-right': 'translate(-100%,-100%)',
          'left': 'translate(0,-50%)',
          'right': 'translate(-100%,-50%)',
        };
        function sa(t, e, i) {
          const r = t.classList;
          for (const n in aa) r.remove(`maplibregl-${i}-anchor-${n}`);
          r.add(`maplibregl-${i}-anchor-${e}`);
        }
        class la extends e.E {
          constructor(t) {
            if (
              (super(),
              (this._onKeyPress = (t) => {
                const e = t.code,
                  i = t.charCode || t.keyCode;
                ('Space' !== e && 'Enter' !== e && 32 !== i && 13 !== i) ||
                  this.togglePopup();
              }),
              (this._onMapClick = (t) => {
                const e = t.originalEvent.target,
                  i = this._element;
                this._popup && (e === i || i.contains(e)) && this.togglePopup();
              }),
              (this._update = (t) => {
                if (!this._map) return;
                const e = this._map.loaded() && !this._map.isMoving();
                ('terrain' === (null == t ? void 0 : t.type) ||
                  ('render' === (null == t ? void 0 : t.type) && !e)) &&
                  this._map.once('render', this._update),
                  (this._lngLat = oa(
                    this._lngLat,
                    this._flatPos,
                    this._map.transform
                  )),
                  (this._flatPos = this._pos =
                    this._map.project(this._lngLat)._add(this._offset)),
                  this._map.terrain &&
                    (this._flatPos = this._map.transform
                      .locationToScreenPoint(this._lngLat)
                      ._add(this._offset));
                let i = '';
                'viewport' === this._rotationAlignment ||
                'auto' === this._rotationAlignment
                  ? (i = `rotateZ(${this._rotation}deg)`)
                  : 'map' === this._rotationAlignment &&
                    (i = `rotateZ(${
                      this._rotation - this._map.getBearing()
                    }deg)`);
                let r = '';
                'viewport' === this._pitchAlignment ||
                'auto' === this._pitchAlignment
                  ? (r = 'rotateX(0deg)')
                  : 'map' === this._pitchAlignment &&
                    (r = `rotateX(${this._map.getPitch()}deg)`),
                  this._subpixelPositioning ||
                    (t && 'moveend' !== t.type) ||
                    (this._pos = this._pos.round()),
                  c.setTransform(
                    this._element,
                    `${aa[this._anchor]} translate(${this._pos.x}px, ${
                      this._pos.y
                    }px) ${r} ${i}`
                  ),
                  a
                    .frameAsync(new AbortController())
                    .then(() => {
                      this._updateOpacity(t && 'moveend' === t.type);
                    })
                    .catch(() => {});
              }),
              (this._onMove = (t) => {
                if (!this._isDragging) {
                  const e = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = t.point.dist(this._pointerdownPos) >= e;
                }
                this._isDragging &&
                  ((this._pos = t.point.sub(this._positionDelta)),
                  (this._lngLat = this._map.unproject(this._pos)),
                  this.setLngLat(this._lngLat),
                  (this._element.style.pointerEvents = 'none'),
                  'pending' === this._state &&
                    ((this._state = 'active'), this.fire(new e.l('dragstart'))),
                  this.fire(new e.l('drag')));
              }),
              (this._onUp = () => {
                (this._element.style.pointerEvents = 'auto'),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1),
                  this._map.off('mousemove', this._onMove),
                  this._map.off('touchmove', this._onMove),
                  'active' === this._state && this.fire(new e.l('dragend')),
                  (this._state = 'inactive');
              }),
              (this._addDragHandler = (t) => {
                this._element.contains(t.originalEvent.target) &&
                  (t.preventDefault(),
                  (this._positionDelta = t.point
                    .sub(this._pos)
                    .add(this._offset)),
                  (this._pointerdownPos = t.point),
                  (this._state = 'pending'),
                  this._map.on('mousemove', this._onMove),
                  this._map.on('touchmove', this._onMove),
                  this._map.once('mouseup', this._onUp),
                  this._map.once('touchend', this._onUp));
              }),
              (this._anchor = (t && t.anchor) || 'center'),
              (this._color = (t && t.color) || '#3FB1CE'),
              (this._scale = (t && t.scale) || 1),
              (this._draggable = (t && t.draggable) || !1),
              (this._clickTolerance = (t && t.clickTolerance) || 0),
              (this._subpixelPositioning = (t && t.subpixelPositioning) || !1),
              (this._isDragging = !1),
              (this._state = 'inactive'),
              (this._rotation = (t && t.rotation) || 0),
              (this._rotationAlignment = (t && t.rotationAlignment) || 'auto'),
              (this._pitchAlignment =
                t && t.pitchAlignment && 'auto' !== t.pitchAlignment
                  ? t.pitchAlignment
                  : this._rotationAlignment),
              this.setOpacity(
                null == t ? void 0 : t.opacity,
                null == t ? void 0 : t.opacityWhenCovered
              ),
              t && t.element)
            )
              (this._element = t.element),
                (this._offset = e.P.convert((t && t.offset) || [0, 0]));
            else {
              (this._defaultMarker = !0), (this._element = c.create('div'));
              const i = c.createNS('http://www.w3.org/2000/svg', 'svg'),
                r = 41,
                n = 27;
              i.setAttributeNS(null, 'display', 'block'),
                i.setAttributeNS(null, 'height', `${r}px`),
                i.setAttributeNS(null, 'width', `${n}px`),
                i.setAttributeNS(null, 'viewBox', `0 0 ${n} ${r}`);
              const o = c.createNS('http://www.w3.org/2000/svg', 'g');
              o.setAttributeNS(null, 'stroke', 'none'),
                o.setAttributeNS(null, 'stroke-width', '1'),
                o.setAttributeNS(null, 'fill', 'none'),
                o.setAttributeNS(null, 'fill-rule', 'evenodd');
              const a = c.createNS('http://www.w3.org/2000/svg', 'g');
              a.setAttributeNS(null, 'fill-rule', 'nonzero');
              const s = c.createNS('http://www.w3.org/2000/svg', 'g');
              s.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)'),
                s.setAttributeNS(null, 'fill', '#000000');
              const l = [
                { rx: '10.5', ry: '5.25002273' },
                { rx: '10.5', ry: '5.25002273' },
                { rx: '9.5', ry: '4.77275007' },
                { rx: '8.5', ry: '4.29549936' },
                { rx: '7.5', ry: '3.81822308' },
                { rx: '6.5', ry: '3.34094679' },
                { rx: '5.5', ry: '2.86367051' },
                { rx: '4.5', ry: '2.38636864' },
              ];
              for (const t of l) {
                const e = c.createNS('http://www.w3.org/2000/svg', 'ellipse');
                e.setAttributeNS(null, 'opacity', '0.04'),
                  e.setAttributeNS(null, 'cx', '10.5'),
                  e.setAttributeNS(null, 'cy', '5.80029008'),
                  e.setAttributeNS(null, 'rx', t.rx),
                  e.setAttributeNS(null, 'ry', t.ry),
                  s.appendChild(e);
              }
              const h = c.createNS('http://www.w3.org/2000/svg', 'g');
              h.setAttributeNS(null, 'fill', this._color);
              const u = c.createNS('http://www.w3.org/2000/svg', 'path');
              u.setAttributeNS(
                null,
                'd',
                'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z'
              ),
                h.appendChild(u);
              const d = c.createNS('http://www.w3.org/2000/svg', 'g');
              d.setAttributeNS(null, 'opacity', '0.25'),
                d.setAttributeNS(null, 'fill', '#000000');
              const p = c.createNS('http://www.w3.org/2000/svg', 'path');
              p.setAttributeNS(
                null,
                'd',
                'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z'
              ),
                d.appendChild(p);
              const f = c.createNS('http://www.w3.org/2000/svg', 'g');
              f.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)'),
                f.setAttributeNS(null, 'fill', '#FFFFFF');
              const m = c.createNS('http://www.w3.org/2000/svg', 'g');
              m.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)');
              const _ = c.createNS('http://www.w3.org/2000/svg', 'circle');
              _.setAttributeNS(null, 'fill', '#000000'),
                _.setAttributeNS(null, 'opacity', '0.25'),
                _.setAttributeNS(null, 'cx', '5.5'),
                _.setAttributeNS(null, 'cy', '5.5'),
                _.setAttributeNS(null, 'r', '5.4999962');
              const g = c.createNS('http://www.w3.org/2000/svg', 'circle');
              g.setAttributeNS(null, 'fill', '#FFFFFF'),
                g.setAttributeNS(null, 'cx', '5.5'),
                g.setAttributeNS(null, 'cy', '5.5'),
                g.setAttributeNS(null, 'r', '5.4999962'),
                m.appendChild(_),
                m.appendChild(g),
                a.appendChild(s),
                a.appendChild(h),
                a.appendChild(d),
                a.appendChild(f),
                a.appendChild(m),
                i.appendChild(a),
                i.setAttributeNS(null, 'height', r * this._scale + 'px'),
                i.setAttributeNS(null, 'width', n * this._scale + 'px'),
                this._element.appendChild(i),
                (this._offset = e.P.convert((t && t.offset) || [0, -14]));
            }
            if (
              (this._element.classList.add('maplibregl-marker'),
              this._element.addEventListener('dragstart', (t) => {
                t.preventDefault();
              }),
              this._element.addEventListener('mousedown', (t) => {
                t.preventDefault();
              }),
              sa(this._element, this._anchor, 'marker'),
              t && t.className)
            )
              for (const e of t.className.split(' '))
                this._element.classList.add(e);
            this._popup = null;
          }
          addTo(t) {
            return (
              this.remove(),
              (this._map = t),
              this._element.hasAttribute('aria-label') ||
                this._element.setAttribute(
                  'aria-label',
                  t._getUIString('Marker.Title')
                ),
              this._element.hasAttribute('role') ||
                this._element.setAttribute('role', 'button'),
              t.getCanvasContainer().appendChild(this._element),
              t.on('move', this._update),
              t.on('moveend', this._update),
              t.on('terrain', this._update),
              t.on('projectiontransition', this._update),
              this.setDraggable(this._draggable),
              this._update(),
              this._map.on('click', this._onMapClick),
              this
            );
          }
          remove() {
            return (
              this._opacityTimeout &&
                (clearTimeout(this._opacityTimeout),
                delete this._opacityTimeout),
              this._map &&
                (this._map.off('click', this._onMapClick),
                this._map.off('move', this._update),
                this._map.off('moveend', this._update),
                this._map.off('terrain', this._update),
                this._map.off('projectiontransition', this._update),
                this._map.off('mousedown', this._addDragHandler),
                this._map.off('touchstart', this._addDragHandler),
                this._map.off('mouseup', this._onUp),
                this._map.off('touchend', this._onUp),
                this._map.off('mousemove', this._onMove),
                this._map.off('touchmove', this._onMove),
                delete this._map),
              c.remove(this._element),
              this._popup && this._popup.remove(),
              this
            );
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return (
              (this._lngLat = e.U.convert(t)),
              (this._pos = null),
              this._popup && this._popup.setLngLat(this._lngLat),
              this._update(),
              this
            );
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (
              (this._popup &&
                (this._popup.remove(),
                (this._popup = null),
                this._element.removeEventListener('keypress', this._onKeyPress),
                this._originalTabIndex ||
                  this._element.removeAttribute('tabindex')),
              t)
            ) {
              if (!('offset' in t.options)) {
                const e = 38.1,
                  i = 13.5,
                  r = Math.abs(i) / Math.SQRT2;
                t.options.offset = this._defaultMarker
                  ? {
                      'top': [0, 0],
                      'top-left': [0, 0],
                      'top-right': [0, 0],
                      'bottom': [0, -e],
                      'bottom-left': [r, -1 * (e - i + r)],
                      'bottom-right': [-r, -1 * (e - i + r)],
                      'left': [i, -1 * (e - i)],
                      'right': [-i, -1 * (e - i)],
                    }
                  : this._offset;
              }
              (this._popup = t),
                (this._originalTabIndex =
                  this._element.getAttribute('tabindex')),
                this._originalTabIndex ||
                  this._element.setAttribute('tabindex', '0'),
                this._element.addEventListener('keypress', this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(t) {
            return (this._subpixelPositioning = t), this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered
              ? this
              : t
              ? (t.isOpen()
                  ? t.remove()
                  : (t.setLngLat(this._lngLat), t.addTo(this._map)),
                this)
              : this;
          }
          _updateOpacity(t = !1) {
            var i, r;
            const n =
                null === (i = this._map) || void 0 === i ? void 0 : i.terrain,
              o = this._map.transform.isLocationOccluded(this._lngLat);
            if (!n || o) {
              const t = o ? this._opacityWhenCovered : this._opacity;
              return void (
                this._element.style.opacity !== t &&
                (this._element.style.opacity = t)
              );
            }
            if (t) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const a = this._map,
              s = a.terrain.depthAtPoint(this._pos),
              l = a.terrain.getElevationForLngLatZoom(
                this._lngLat,
                a.transform.tileZoom
              );
            if (a.transform.lngLatToCameraDepth(this._lngLat, l) - s < 0.006)
              return void (this._element.style.opacity = this._opacity);
            const c = -this._offset.y / a.transform.pixelsPerMeter,
              h = Math.sin((a.getPitch() * Math.PI) / 180) * c,
              u = a.terrain.depthAtPoint(
                new e.P(this._pos.x, this._pos.y - this._offset.y)
              ),
              d =
                a.transform.lngLatToCameraDepth(this._lngLat, l + h) - u >
                0.006;
            (null === (r = this._popup) || void 0 === r
              ? void 0
              : r.isOpen()) &&
              d &&
              this._popup.remove(),
              (this._element.style.opacity = d
                ? this._opacityWhenCovered
                : this._opacity);
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return (this._offset = e.P.convert(t)), this._update(), this;
          }
          addClassName(t) {
            this._element.classList.add(t);
          }
          removeClassName(t) {
            this._element.classList.remove(t);
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          setDraggable(t) {
            return (
              (this._draggable = !!t),
              this._map &&
                (t
                  ? (this._map.on('mousedown', this._addDragHandler),
                    this._map.on('touchstart', this._addDragHandler))
                  : (this._map.off('mousedown', this._addDragHandler),
                    this._map.off('touchstart', this._addDragHandler))),
              this
            );
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return (this._rotation = t || 0), this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return (
              (this._rotationAlignment = t || 'auto'), this._update(), this
            );
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return (
              (this._pitchAlignment =
                t && 'auto' !== t ? t : this._rotationAlignment),
              this._update(),
              this
            );
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t, e) {
            return (
              (void 0 === this._opacity || (void 0 === t && void 0 === e)) &&
                ((this._opacity = '1'), (this._opacityWhenCovered = '0.2')),
              void 0 !== t && (this._opacity = t),
              void 0 !== e && (this._opacityWhenCovered = e),
              this._map && this._updateOpacity(!0),
              this
            );
          }
        }
        const ca = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3,
          },
          fitBoundsOptions: { maxZoom: 15 },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0,
        };
        let ha = 0,
          ua = !1;
        const da = { maxWidth: 100, unit: 'metric' };
        function pa(t, e, i) {
          const r = (i && i.maxWidth) || 100,
            n = t._container.clientHeight / 2,
            o = t._container.clientWidth / 2,
            a = t.unproject([o - r / 2, n]),
            s = t.unproject([o + r / 2, n]),
            l = Math.round(t.project(s).x - t.project(a).x),
            c = Math.min(r, l, t._container.clientWidth),
            h = a.distanceTo(s);
          if (i && 'imperial' === i.unit) {
            const i = 3.2808 * h;
            i > 5280
              ? fa(e, c, i / 5280, t._getUIString('ScaleControl.Miles'))
              : fa(e, c, i, t._getUIString('ScaleControl.Feet'));
          } else i && 'nautical' === i.unit ? fa(e, c, h / 1852, t._getUIString('ScaleControl.NauticalMiles')) : h >= 1e3 ? fa(e, c, h / 1e3, t._getUIString('ScaleControl.Kilometers')) : fa(e, c, h, t._getUIString('ScaleControl.Meters'));
        }
        function fa(t, e, i, r) {
          const n = (function (t) {
            const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
            let i = t / e;
            return (
              (i =
                i >= 10
                  ? 10
                  : i >= 5
                  ? 5
                  : i >= 3
                  ? 3
                  : i >= 2
                  ? 2
                  : i >= 1
                  ? 1
                  : (function (t) {
                      const e = Math.pow(
                        10,
                        Math.ceil(-Math.log(t) / Math.LN10)
                      );
                      return Math.round(t * e) / e;
                    })(i)),
              e * i
            );
          })(i);
          (t.style.width = e * (n / i) + 'px'),
            (t.innerHTML = `${n}&nbsp;${r}`);
        }
        const ma = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: '',
            maxWidth: '240px',
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0,
          },
          _a = [
            'a[href]',
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            'button:not([disabled])',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
          ].join(', ');
        function ga(t) {
          if (t) {
            if ('number' == typeof t) {
              const i = Math.round(Math.abs(t) / Math.SQRT2);
              return {
                'center': new e.P(0, 0),
                'top': new e.P(0, t),
                'top-left': new e.P(i, i),
                'top-right': new e.P(-i, i),
                'bottom': new e.P(0, -t),
                'bottom-left': new e.P(i, -i),
                'bottom-right': new e.P(-i, -i),
                'left': new e.P(t, 0),
                'right': new e.P(-t, 0),
              };
            }
            if (t instanceof e.P || Array.isArray(t)) {
              const i = e.P.convert(t);
              return {
                'center': i,
                'top': i,
                'top-left': i,
                'top-right': i,
                'bottom': i,
                'bottom-left': i,
                'bottom-right': i,
                'left': i,
                'right': i,
              };
            }
            return {
              'center': e.P.convert(t.center || [0, 0]),
              'top': e.P.convert(t.top || [0, 0]),
              'top-left': e.P.convert(t['top-left'] || [0, 0]),
              'top-right': e.P.convert(t['top-right'] || [0, 0]),
              'bottom': e.P.convert(t.bottom || [0, 0]),
              'bottom-left': e.P.convert(t['bottom-left'] || [0, 0]),
              'bottom-right': e.P.convert(t['bottom-right'] || [0, 0]),
              'left': e.P.convert(t.left || [0, 0]),
              'right': e.P.convert(t.right || [0, 0]),
            };
          }
          return ga(new e.P(0, 0));
        }
        const ya = i;
        (t.AJAXError = e.cC),
          (t.Event = e.l),
          (t.Evented = e.E),
          (t.LngLat = e.U),
          (t.MercatorCoordinate = e.a5),
          (t.Point = e.P),
          (t.addProtocol = e.cD),
          (t.config = e.a),
          (t.removeProtocol = e.cE),
          (t.AttributionControl = Zo),
          (t.BoxZoomHandler = no),
          (t.CanvasSource = it),
          (t.CooperativeGesturesHandler = Bo),
          (t.DoubleClickZoomHandler = zo),
          (t.DragPanHandler = Ro),
          (t.DragRotateHandler = Lo),
          (t.EdgeInsets = Re),
          (t.FullscreenControl = class extends e.E {
            constructor(t = {}) {
              super(),
                (this._onFullscreenChange = () => {
                  var t;
                  let e =
                    window.document.fullscreenElement ||
                    window.document.mozFullScreenElement ||
                    window.document.webkitFullscreenElement ||
                    window.document.msFullscreenElement;
                  for (
                    ;
                    null === (t = null == e ? void 0 : e.shadowRoot) ||
                    void 0 === t
                      ? void 0
                      : t.fullscreenElement;

                  )
                    e = e.shadowRoot.fullscreenElement;
                  (e === this._container) !== this._fullscreen &&
                    this._handleFullscreenChange();
                }),
                (this._onClickFullscreen = () => {
                  this._isFullscreen()
                    ? this._exitFullscreen()
                    : this._requestFullscreen();
                }),
                (this._fullscreen = !1),
                t &&
                  t.container &&
                  (t.container instanceof HTMLElement
                    ? (this._container = t.container)
                    : e.w(
                        "Full screen control 'container' must be a DOM element."
                      )),
                'onfullscreenchange' in document
                  ? (this._fullscreenchange = 'fullscreenchange')
                  : 'onmozfullscreenchange' in document
                  ? (this._fullscreenchange = 'mozfullscreenchange')
                  : 'onwebkitfullscreenchange' in document
                  ? (this._fullscreenchange = 'webkitfullscreenchange')
                  : 'onmsfullscreenchange' in document &&
                    (this._fullscreenchange = 'MSFullscreenChange');
            }
            onAdd(t) {
              return (
                (this._map = t),
                this._container || (this._container = this._map.getContainer()),
                (this._controlContainer = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-group'
                )),
                this._setupUI(),
                this._controlContainer
              );
            }
            onRemove() {
              c.remove(this._controlContainer),
                (this._map = null),
                window.document.removeEventListener(
                  this._fullscreenchange,
                  this._onFullscreenChange
                );
            }
            _setupUI() {
              const t = (this._fullscreenButton = c.create(
                'button',
                'maplibregl-ctrl-fullscreen',
                this._controlContainer
              ));
              c
                .create('span', 'maplibregl-ctrl-icon', t)
                .setAttribute('aria-hidden', 'true'),
                (t.type = 'button'),
                this._updateTitle(),
                this._fullscreenButton.addEventListener(
                  'click',
                  this._onClickFullscreen
                ),
                window.document.addEventListener(
                  this._fullscreenchange,
                  this._onFullscreenChange
                );
            }
            _updateTitle() {
              const t = this._getTitle();
              this._fullscreenButton.setAttribute('aria-label', t),
                (this._fullscreenButton.title = t);
            }
            _getTitle() {
              return this._map._getUIString(
                this._isFullscreen()
                  ? 'FullscreenControl.Exit'
                  : 'FullscreenControl.Enter'
              );
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              (this._fullscreen = !this._fullscreen),
                this._fullscreenButton.classList.toggle(
                  'maplibregl-ctrl-shrink'
                ),
                this._fullscreenButton.classList.toggle(
                  'maplibregl-ctrl-fullscreen'
                ),
                this._updateTitle(),
                this._fullscreen
                  ? (this.fire(new e.l('fullscreenstart')),
                    (this._prevCooperativeGesturesEnabled =
                      this._map.cooperativeGestures.isEnabled()),
                    this._map.cooperativeGestures.disable())
                  : (this.fire(new e.l('fullscreenend')),
                    this._prevCooperativeGesturesEnabled &&
                      this._map.cooperativeGestures.enable());
            }
            _exitFullscreen() {
              window.document.exitFullscreen
                ? window.document.exitFullscreen()
                : window.document.mozCancelFullScreen
                ? window.document.mozCancelFullScreen()
                : window.document.msExitFullscreen
                ? window.document.msExitFullscreen()
                : window.document.webkitCancelFullScreen
                ? window.document.webkitCancelFullScreen()
                : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen
                ? this._container.requestFullscreen()
                : this._container.mozRequestFullScreen
                ? this._container.mozRequestFullScreen()
                : this._container.msRequestFullscreen
                ? this._container.msRequestFullscreen()
                : this._container.webkitRequestFullscreen
                ? this._container.webkitRequestFullscreen()
                : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              this._container.classList.toggle('maplibregl-pseudo-fullscreen'),
                this._handleFullscreenChange(),
                this._map.resize();
            }
          }),
          (t.GeoJSONSource = Q),
          (t.GeolocateControl = class extends e.E {
            constructor(t) {
              super(),
                (this._onSuccess = (t) => {
                  if (this._map) {
                    if (this._isOutOfMapMaxBounds(t))
                      return (
                        this._setErrorState(),
                        this.fire(new e.l('outofmaxbounds', t)),
                        this._updateMarker(),
                        void this._finish()
                      );
                    if (this.options.trackUserLocation)
                      switch (
                        ((this._lastKnownPosition = t), this._watchState)
                      ) {
                        case 'WAITING_ACTIVE':
                        case 'ACTIVE_LOCK':
                        case 'ACTIVE_ERROR':
                          (this._watchState = 'ACTIVE_LOCK'),
                            this._geolocateButton.classList.remove(
                              'maplibregl-ctrl-geolocate-waiting'
                            ),
                            this._geolocateButton.classList.remove(
                              'maplibregl-ctrl-geolocate-active-error'
                            ),
                            this._geolocateButton.classList.add(
                              'maplibregl-ctrl-geolocate-active'
                            );
                          break;
                        case 'BACKGROUND':
                        case 'BACKGROUND_ERROR':
                          (this._watchState = 'BACKGROUND'),
                            this._geolocateButton.classList.remove(
                              'maplibregl-ctrl-geolocate-waiting'
                            ),
                            this._geolocateButton.classList.remove(
                              'maplibregl-ctrl-geolocate-background-error'
                            ),
                            this._geolocateButton.classList.add(
                              'maplibregl-ctrl-geolocate-background'
                            );
                          break;
                        default:
                          throw new Error(
                            `Unexpected watchState ${this._watchState}`
                          );
                      }
                    this.options.showUserLocation &&
                      'OFF' !== this._watchState &&
                      this._updateMarker(t),
                      (this.options.trackUserLocation &&
                        'ACTIVE_LOCK' !== this._watchState) ||
                        this._updateCamera(t),
                      this.options.showUserLocation &&
                        this._dotElement.classList.remove(
                          'maplibregl-user-location-dot-stale'
                        ),
                      this.fire(new e.l('geolocate', t)),
                      this._finish();
                  }
                }),
                (this._updateCamera = (t) => {
                  const i = new e.U(t.coords.longitude, t.coords.latitude),
                    r = t.coords.accuracy,
                    n = this._map.getBearing(),
                    o = e.e({ bearing: n }, this.options.fitBoundsOptions),
                    a = q.fromLngLat(i, r);
                  this._map.fitBounds(a, o, { geolocateSource: !0 });
                }),
                (this._updateMarker = (t) => {
                  if (t) {
                    const i = new e.U(t.coords.longitude, t.coords.latitude);
                    this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                      this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                      (this._accuracy = t.coords.accuracy),
                      this._updateCircleRadiusIfNeeded();
                  } else
                    this._userLocationDotMarker.remove(),
                      this._accuracyCircleMarker.remove();
                }),
                (this._onUpdate = () => {
                  this._updateCircleRadiusIfNeeded();
                }),
                (this._onError = (t) => {
                  if (this._map) {
                    if (1 === t.code) {
                      (this._watchState = 'OFF'),
                        this._geolocateButton.classList.remove(
                          'maplibregl-ctrl-geolocate-waiting'
                        ),
                        this._geolocateButton.classList.remove(
                          'maplibregl-ctrl-geolocate-active'
                        ),
                        this._geolocateButton.classList.remove(
                          'maplibregl-ctrl-geolocate-active-error'
                        ),
                        this._geolocateButton.classList.remove(
                          'maplibregl-ctrl-geolocate-background'
                        ),
                        this._geolocateButton.classList.remove(
                          'maplibregl-ctrl-geolocate-background-error'
                        ),
                        (this._geolocateButton.disabled = !0);
                      const t = this._map._getUIString(
                        'GeolocateControl.LocationNotAvailable'
                      );
                      (this._geolocateButton.title = t),
                        this._geolocateButton.setAttribute('aria-label', t),
                        void 0 !== this._geolocationWatchID &&
                          this._clearWatch();
                    } else {
                      if (3 === t.code && ua) return;
                      this._setErrorState();
                    }
                    'OFF' !== this._watchState &&
                      this.options.showUserLocation &&
                      this._dotElement.classList.add(
                        'maplibregl-user-location-dot-stale'
                      ),
                      this.fire(new e.l('error', t)),
                      this._finish();
                  }
                }),
                (this._finish = () => {
                  this._timeoutId && clearTimeout(this._timeoutId),
                    (this._timeoutId = void 0);
                }),
                (this._setupUI = () => {
                  this._map &&
                    (this._container.addEventListener('contextmenu', (t) =>
                      t.preventDefault()
                    ),
                    (this._geolocateButton = c.create(
                      'button',
                      'maplibregl-ctrl-geolocate',
                      this._container
                    )),
                    c
                      .create(
                        'span',
                        'maplibregl-ctrl-icon',
                        this._geolocateButton
                      )
                      .setAttribute('aria-hidden', 'true'),
                    (this._geolocateButton.type = 'button'),
                    (this._geolocateButton.disabled = !0));
                }),
                (this._finishSetupUI = (t) => {
                  if (this._map) {
                    if (!1 === t) {
                      e.w(
                        'Geolocation support is not available so the GeolocateControl will be disabled.'
                      );
                      const t = this._map._getUIString(
                        'GeolocateControl.LocationNotAvailable'
                      );
                      (this._geolocateButton.disabled = !0),
                        (this._geolocateButton.title = t),
                        this._geolocateButton.setAttribute('aria-label', t);
                    } else {
                      const t = this._map._getUIString(
                        'GeolocateControl.FindMyLocation'
                      );
                      (this._geolocateButton.disabled = !1),
                        (this._geolocateButton.title = t),
                        this._geolocateButton.setAttribute('aria-label', t);
                    }
                    this.options.trackUserLocation &&
                      (this._geolocateButton.setAttribute(
                        'aria-pressed',
                        'false'
                      ),
                      (this._watchState = 'OFF')),
                      this.options.showUserLocation &&
                        ((this._dotElement = c.create(
                          'div',
                          'maplibregl-user-location-dot'
                        )),
                        (this._userLocationDotMarker = new la({
                          element: this._dotElement,
                        })),
                        (this._circleElement = c.create(
                          'div',
                          'maplibregl-user-location-accuracy-circle'
                        )),
                        (this._accuracyCircleMarker = new la({
                          element: this._circleElement,
                          pitchAlignment: 'map',
                        })),
                        this.options.trackUserLocation &&
                          (this._watchState = 'OFF'),
                        this._map.on('zoom', this._onUpdate),
                        this._map.on('move', this._onUpdate),
                        this._map.on('rotate', this._onUpdate),
                        this._map.on('pitch', this._onUpdate)),
                      this._geolocateButton.addEventListener('click', () =>
                        this.trigger()
                      ),
                      (this._setup = !0),
                      this.options.trackUserLocation &&
                        this._map.on('movestart', (t) => {
                          const i =
                            (null == t ? void 0 : t[0]) instanceof
                            ResizeObserverEntry;
                          t.geolocateSource ||
                            'ACTIVE_LOCK' !== this._watchState ||
                            i ||
                            this._map.isZooming() ||
                            ((this._watchState = 'BACKGROUND'),
                            this._geolocateButton.classList.add(
                              'maplibregl-ctrl-geolocate-background'
                            ),
                            this._geolocateButton.classList.remove(
                              'maplibregl-ctrl-geolocate-active'
                            ),
                            this.fire(new e.l('trackuserlocationend')),
                            this.fire(new e.l('userlocationlostfocus')));
                        });
                  }
                }),
                (this.options = e.e({}, ca, t));
            }
            onAdd(t) {
              return (
                (this._map = t),
                (this._container = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-group'
                )),
                this._setupUI(),
                (function () {
                  return e._(this, arguments, void 0, function* (t = !1) {
                    if (void 0 !== na && !t) return na;
                    if (void 0 === window.navigator.permissions)
                      return (na = !!window.navigator.geolocation), na;
                    try {
                      const t = yield window.navigator.permissions.query({
                        name: 'geolocation',
                      });
                      na = 'denied' !== t.state;
                    } catch (t) {
                      na = !!window.navigator.geolocation;
                    }
                    return na;
                  });
                })().then((t) => this._finishSetupUI(t)),
                this._container
              );
            }
            onRemove() {
              void 0 !== this._geolocationWatchID &&
                (window.navigator.geolocation.clearWatch(
                  this._geolocationWatchID
                ),
                (this._geolocationWatchID = void 0)),
                this.options.showUserLocation &&
                  this._userLocationDotMarker &&
                  this._userLocationDotMarker.remove(),
                this.options.showAccuracyCircle &&
                  this._accuracyCircleMarker &&
                  this._accuracyCircleMarker.remove(),
                c.remove(this._container),
                this._map.off('zoom', this._onUpdate),
                this._map.off('move', this._onUpdate),
                this._map.off('rotate', this._onUpdate),
                this._map.off('pitch', this._onUpdate),
                (this._map = void 0),
                (ha = 0),
                (ua = !1);
            }
            _isOutOfMapMaxBounds(t) {
              const e = this._map.getMaxBounds(),
                i = t.coords;
              return (
                e &&
                (i.longitude < e.getWest() ||
                  i.longitude > e.getEast() ||
                  i.latitude < e.getSouth() ||
                  i.latitude > e.getNorth())
              );
            }
            _setErrorState() {
              switch (this._watchState) {
                case 'WAITING_ACTIVE':
                  (this._watchState = 'ACTIVE_ERROR'),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-active'
                    ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-active-error'
                    );
                  break;
                case 'ACTIVE_LOCK':
                  (this._watchState = 'ACTIVE_ERROR'),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-active'
                    ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-active-error'
                    ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-waiting'
                    );
                  break;
                case 'BACKGROUND':
                  (this._watchState = 'BACKGROUND_ERROR'),
                    this._geolocateButton.classList.remove(
                      'maplibregl-ctrl-geolocate-background'
                    ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-background-error'
                    ),
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-waiting'
                    );
                  break;
                case 'ACTIVE_ERROR':
                case 'BACKGROUND_ERROR':
                case 'OFF':
                case void 0:
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadiusIfNeeded() {
              const t = this._userLocationDotMarker.getLngLat();
              if (
                !(
                  this.options.showUserLocation &&
                  this.options.showAccuracyCircle &&
                  this._accuracy &&
                  t
                )
              )
                return;
              const e = this._map.project(t),
                i = this._map.unproject([e.x + 100, e.y]),
                r = t.distanceTo(i) / 100,
                n = (2 * this._accuracy) / r;
              (this._circleElement.style.width = `${n.toFixed(2)}px`),
                (this._circleElement.style.height = `${n.toFixed(2)}px`);
            }
            trigger() {
              if (!this._setup)
                return (
                  e.w('Geolocate control triggered before added to a map'), !1
                );
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case 'OFF':
                    (this._watchState = 'WAITING_ACTIVE'),
                      this.fire(new e.l('trackuserlocationstart'));
                    break;
                  case 'WAITING_ACTIVE':
                  case 'ACTIVE_LOCK':
                  case 'ACTIVE_ERROR':
                  case 'BACKGROUND_ERROR':
                    ha--,
                      (ua = !1),
                      (this._watchState = 'OFF'),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-waiting'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-active'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-active-error'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-background'
                      ),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-background-error'
                      ),
                      this.fire(new e.l('trackuserlocationend'));
                    break;
                  case 'BACKGROUND':
                    (this._watchState = 'ACTIVE_LOCK'),
                      this._geolocateButton.classList.remove(
                        'maplibregl-ctrl-geolocate-background'
                      ),
                      this._lastKnownPosition &&
                        this._updateCamera(this._lastKnownPosition),
                      this.fire(new e.l('trackuserlocationstart')),
                      this.fire(new e.l('userlocationfocus'));
                    break;
                  default:
                    throw new Error(
                      `Unexpected watchState ${this._watchState}`
                    );
                }
                switch (this._watchState) {
                  case 'WAITING_ACTIVE':
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-waiting'
                    ),
                      this._geolocateButton.classList.add(
                        'maplibregl-ctrl-geolocate-active'
                      );
                    break;
                  case 'ACTIVE_LOCK':
                    this._geolocateButton.classList.add(
                      'maplibregl-ctrl-geolocate-active'
                    );
                    break;
                  case 'OFF':
                    break;
                  default:
                    throw new Error(
                      `Unexpected watchState ${this._watchState}`
                    );
                }
                if (
                  'OFF' === this._watchState &&
                  void 0 !== this._geolocationWatchID
                )
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let t;
                  this._geolocateButton.classList.add(
                    'maplibregl-ctrl-geolocate-waiting'
                  ),
                    this._geolocateButton.setAttribute('aria-pressed', 'true'),
                    ha++,
                    ha > 1
                      ? ((t = { maximumAge: 6e5, timeout: 0 }), (ua = !0))
                      : ((t = this.options.positionOptions), (ua = !1)),
                    (this._geolocationWatchID =
                      window.navigator.geolocation.watchPosition(
                        this._onSuccess,
                        this._onError,
                        t
                      ));
                }
              } else
                window.navigator.geolocation.getCurrentPosition(
                  this._onSuccess,
                  this._onError,
                  this.options.positionOptions
                ),
                  (this._timeoutId = setTimeout(this._finish, 1e4));
              return !0;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                (this._geolocationWatchID = void 0),
                this._geolocateButton.classList.remove(
                  'maplibregl-ctrl-geolocate-waiting'
                ),
                this._geolocateButton.setAttribute('aria-pressed', 'false'),
                this.options.showUserLocation && this._updateMarker(null);
            }
          }),
          (t.GlobeControl = class {
            constructor() {
              (this._toggleProjection = () => {
                var t;
                const e =
                  null === (t = this._map.getProjection()) || void 0 === t
                    ? void 0
                    : t.type;
                this._map.setProjection(
                  'mercator' !== e && e
                    ? { type: 'mercator' }
                    : { type: 'globe' }
                ),
                  this._updateGlobeIcon();
              }),
                (this._updateGlobeIcon = () => {
                  var t;
                  this._globeButton.classList.remove('maplibregl-ctrl-globe'),
                    this._globeButton.classList.remove(
                      'maplibregl-ctrl-globe-enabled'
                    ),
                    'globe' ===
                    (null === (t = this._map.getProjection()) || void 0 === t
                      ? void 0
                      : t.type)
                      ? (this._globeButton.classList.add(
                          'maplibregl-ctrl-globe-enabled'
                        ),
                        (this._globeButton.title = this._map._getUIString(
                          'GlobeControl.Disable'
                        )))
                      : (this._globeButton.classList.add(
                          'maplibregl-ctrl-globe'
                        ),
                        (this._globeButton.title = this._map._getUIString(
                          'GlobeControl.Enable'
                        )));
                });
            }
            onAdd(t) {
              return (
                (this._map = t),
                (this._container = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-group'
                )),
                (this._globeButton = c.create(
                  'button',
                  'maplibregl-ctrl-globe',
                  this._container
                )),
                c
                  .create('span', 'maplibregl-ctrl-icon', this._globeButton)
                  .setAttribute('aria-hidden', 'true'),
                (this._globeButton.type = 'button'),
                this._globeButton.addEventListener(
                  'click',
                  this._toggleProjection
                ),
                this._updateGlobeIcon(),
                this._map.on('styledata', this._updateGlobeIcon),
                this._container
              );
            }
            onRemove() {
              c.remove(this._container),
                this._map.off('styledata', this._updateGlobeIcon),
                this._globeButton.removeEventListener(
                  'click',
                  this._toggleProjection
                ),
                (this._map = void 0);
            }
          }),
          (t.Hash = Un),
          (t.ImageSource = tt),
          (t.KeyboardHandler = Mo),
          (t.LngLatBounds = q),
          (t.LogoControl = $o),
          (t.Map = class extends Uo {
            constructor(t) {
              var i, r;
              e.cz.mark(e.cA.create);
              const n = Object.assign(Object.assign(Object.assign({}, ea), t), {
                canvasContextAttributes: Object.assign(
                  Object.assign({}, ea.canvasContextAttributes),
                  t.canvasContextAttributes
                ),
              });
              if (
                null != n.minZoom &&
                null != n.maxZoom &&
                n.minZoom > n.maxZoom
              )
                throw new Error(
                  'maxZoom must be greater than or equal to minZoom'
                );
              if (
                null != n.minPitch &&
                null != n.maxPitch &&
                n.minPitch > n.maxPitch
              )
                throw new Error(
                  'maxPitch must be greater than or equal to minPitch'
                );
              if (null != n.minPitch && n.minPitch < 0)
                throw new Error('minPitch must be greater than or equal to 0');
              if (null != n.maxPitch && n.maxPitch > 180)
                throw new Error('maxPitch must be less than or equal to 180');
              const o = new Ve(),
                a = new $e();
              if (
                (void 0 !== n.minZoom && o.setMinZoom(n.minZoom),
                void 0 !== n.maxZoom && o.setMaxZoom(n.maxZoom),
                void 0 !== n.minPitch && o.setMinPitch(n.minPitch),
                void 0 !== n.maxPitch && o.setMaxPitch(n.maxPitch),
                void 0 !== n.renderWorldCopies &&
                  o.setRenderWorldCopies(n.renderWorldCopies),
                null !== n.transformConstrain &&
                  o.setConstrain(n.transformConstrain),
                super(o, a, { bearingSnap: n.bearingSnap }),
                (this._idleTriggered = !1),
                (this._crossFadingFactor = 1),
                (this._renderTaskQueue = new qo()),
                (this._controls = []),
                (this._mapId = e.ab()),
                (this._contextLost = (t) => {
                  t.preventDefault(),
                    this._frameRequest &&
                      (this._frameRequest.abort(), (this._frameRequest = null)),
                    this.fire(
                      new e.l('webglcontextlost', { originalEvent: t })
                    );
                }),
                (this._contextRestored = (t) => {
                  this._setupPainter(),
                    this.resize(),
                    this._update(),
                    this.fire(
                      new e.l('webglcontextrestored', { originalEvent: t })
                    );
                }),
                (this._onMapScroll = (t) => {
                  if (t.target === this._container)
                    return (
                      (this._container.scrollTop = 0),
                      (this._container.scrollLeft = 0),
                      !1
                    );
                }),
                (this._onWindowOnline = () => {
                  this._update();
                }),
                (this._interactive = n.interactive),
                (this._maxTileCacheSize = n.maxTileCacheSize),
                (this._maxTileCacheZoomLevels = n.maxTileCacheZoomLevels),
                (this._canvasContextAttributes = Object.assign(
                  {},
                  n.canvasContextAttributes
                )),
                (this._trackResize = !0 === n.trackResize),
                (this._bearingSnap = n.bearingSnap),
                (this._centerClampedToGround = n.centerClampedToGround),
                (this._refreshExpiredTiles = !0 === n.refreshExpiredTiles),
                (this._fadeDuration = n.fadeDuration),
                (this._crossSourceCollisions = !0 === n.crossSourceCollisions),
                (this._collectResourceTiming = !0 === n.collectResourceTiming),
                (this._locale = Object.assign(Object.assign({}, Qo), n.locale)),
                (this._clickTolerance = n.clickTolerance),
                (this._overridePixelRatio = n.pixelRatio),
                (this._maxCanvasSize = n.maxCanvasSize),
                (this.transformCameraUpdate = n.transformCameraUpdate),
                (this.transformConstrain = n.transformConstrain),
                (this.cancelPendingTileRequestsWhileZooming =
                  !0 === n.cancelPendingTileRequestsWhileZooming),
                (this._imageQueueHandle = _.addThrottleControl(() =>
                  this.isMoving()
                )),
                (this._requestManager = new g(n.transformRequest)),
                'string' == typeof n.container)
              ) {
                if (
                  ((this._container = document.getElementById(n.container)),
                  !this._container)
                )
                  throw new Error(`Container '${n.container}' not found.`);
              } else {
                if (!(n.container instanceof HTMLElement))
                  throw new Error(
                    "Invalid type: 'container' must be a String or HTMLElement."
                  );
                this._container = n.container;
              }
              if (
                (n.maxBounds && this.setMaxBounds(n.maxBounds),
                this._setupContainer(),
                this._setupPainter(),
                this.on('move', () => this._update(!1)),
                this.on('moveend', () => this._update(!1)),
                this.on('zoom', () => this._update(!0)),
                this.on('terrain', () => {
                  (this.painter.terrainFacilitator.dirty = !0),
                    this._update(!0);
                }),
                this.once('idle', () => {
                  this._idleTriggered = !0;
                }),
                'undefined' != typeof window)
              ) {
                addEventListener('online', this._onWindowOnline, !1);
                let t = !1;
                const e = Vn((t) => {
                  this._trackResize &&
                    !this._removed &&
                    (this.resize(t), this.redraw());
                }, 50);
                (this._resizeObserver = new ResizeObserver((i) => {
                  t ? e(i) : (t = !0);
                })),
                  this._resizeObserver.observe(this._container);
              }
              (this.handlers = new Vo(this, n)),
                (this._hash =
                  n.hash &&
                  new Un(('string' == typeof n.hash && n.hash) || void 0).addTo(
                    this
                  )),
                (this._hash && this._hash._onHashChange()) ||
                  (this.jumpTo({
                    center: n.center,
                    elevation: n.elevation,
                    zoom: n.zoom,
                    bearing: n.bearing,
                    pitch: n.pitch,
                    roll: n.roll,
                  }),
                  n.bounds &&
                    (this.resize(),
                    this.fitBounds(
                      n.bounds,
                      e.e({}, n.fitBoundsOptions, { duration: 0 })
                    )));
              const s =
                'string' == typeof n.style ||
                !(
                  'globe' ===
                  (null ===
                    (r =
                      null === (i = n.style) || void 0 === i
                        ? void 0
                        : i.projection) || void 0 === r
                    ? void 0
                    : r.type)
                );
              this.resize(null, s),
                (this._localIdeographFontFamily = n.localIdeographFontFamily),
                (this._validateStyle = n.validateStyle),
                n.style &&
                  this.setStyle(n.style, {
                    localIdeographFontFamily: n.localIdeographFontFamily,
                  }),
                n.attributionControl &&
                  this.addControl(
                    new Zo(
                      'boolean' == typeof n.attributionControl
                        ? void 0
                        : n.attributionControl
                    )
                  ),
                n.maplibreLogo && this.addControl(new $o(), n.logoPosition),
                this.on('style.load', () => {
                  if (
                    (s || this._resizeTransform(), this.transform.unmodified)
                  ) {
                    const t = e.S(this.style.stylesheet, [
                      'center',
                      'zoom',
                      'bearing',
                      'pitch',
                      'roll',
                    ]);
                    this.jumpTo(t);
                  }
                }),
                this.on('data', (t) => {
                  this._update('style' === t.dataType),
                    this.fire(new e.l(`${t.dataType}data`, t));
                }),
                this.on('dataloading', (t) => {
                  this.fire(new e.l(`${t.dataType}dataloading`, t));
                }),
                this.on('dataabort', (t) => {
                  this.fire(new e.l('sourcedataabort', t));
                });
            }
            _getMapId() {
              return this._mapId;
            }
            setGlobalStateProperty(t, e) {
              return this.style.setGlobalStateProperty(t, e), this._update(!0);
            }
            getGlobalState() {
              return this.style.getGlobalState();
            }
            addControl(t, i) {
              if (
                (void 0 === i &&
                  (i = t.getDefaultPosition
                    ? t.getDefaultPosition()
                    : 'top-right'),
                !t || !t.onAdd)
              )
                return this.fire(
                  new e.k(
                    new Error(
                      'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.'
                    )
                  )
                );
              const r = t.onAdd(this);
              this._controls.push(t);
              const n = this._controlPositions[i];
              return (
                -1 !== i.indexOf('bottom')
                  ? n.insertBefore(r, n.firstChild)
                  : n.appendChild(r),
                this
              );
            }
            removeControl(t) {
              if (!t || !t.onRemove)
                return this.fire(
                  new e.k(
                    new Error(
                      'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.'
                    )
                  )
                );
              const i = this._controls.indexOf(t);
              return (
                i > -1 && this._controls.splice(i, 1), t.onRemove(this), this
              );
            }
            hasControl(t) {
              return this._controls.indexOf(t) > -1;
            }
            coveringTiles(t) {
              return St(this.transform, t);
            }
            calculateCameraOptionsFromTo(t, e, i, r) {
              return (
                null == r &&
                  this.terrain &&
                  (r = this.terrain.getElevationForLngLatZoom(
                    i,
                    this.transform.tileZoom
                  )),
                super.calculateCameraOptionsFromTo(t, e, i, r)
              );
            }
            resize(t, i = !0) {
              const [r, n] = this._containerDimensions(),
                o = this._getClampedPixelRatio(r, n);
              if (
                (this._resizeCanvas(r, n, o),
                this.painter.resize(r, n, o),
                this.painter.overLimit())
              ) {
                const t = this.painter.context.gl;
                this._maxCanvasSize = [
                  t.drawingBufferWidth,
                  t.drawingBufferHeight,
                ];
                const e = this._getClampedPixelRatio(r, n);
                this._resizeCanvas(r, n, e), this.painter.resize(r, n, e);
              }
              this._resizeTransform(i);
              const a = !this._moving;
              return (
                a &&
                  (this.stop(),
                  this.fire(new e.l('movestart', t)).fire(new e.l('move', t))),
                this.fire(new e.l('resize', t)),
                a && this.fire(new e.l('moveend', t)),
                this
              );
            }
            _resizeTransform(t = !0) {
              var e;
              const [i, r] = this._containerDimensions();
              this.transform.resize(i, r, t),
                null === (e = this._requestedCameraState) ||
                  void 0 === e ||
                  e.resize(i, r, t);
            }
            _getClampedPixelRatio(t, e) {
              const { 0: i, 1: r } = this._maxCanvasSize,
                n = this.getPixelRatio(),
                o = t * n,
                a = e * n;
              return Math.min(o > i ? i / o : 1, a > r ? r / a : 1) * n;
            }
            getPixelRatio() {
              var t;
              return null !== (t = this._overridePixelRatio) && void 0 !== t
                ? t
                : devicePixelRatio;
            }
            setPixelRatio(t) {
              (this._overridePixelRatio = t), this.resize();
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(t) {
              return this.transform.setMaxBounds(q.convert(t)), this._update();
            }
            setMinZoom(t) {
              if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom)
                return (
                  this.transform.setMinZoom(t),
                  this._update(),
                  this.getZoom() < t && this.setZoom(t),
                  this
                );
              throw new Error(
                'minZoom must be between -2 and the current maxZoom, inclusive'
              );
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t) {
              if ((t = null == t ? 22 : t) >= this.transform.minZoom)
                return (
                  this.transform.setMaxZoom(t),
                  this._update(),
                  this.getZoom() > t && this.setZoom(t),
                  this
                );
              throw new Error(
                'maxZoom must be greater than the current minZoom'
              );
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t) {
              if ((t = null == t ? 0 : t) < 0)
                throw new Error('minPitch must be greater than or equal to 0');
              if (t >= 0 && t <= this.transform.maxPitch)
                return (
                  this.transform.setMinPitch(t),
                  this._update(),
                  this.getPitch() < t && this.setPitch(t),
                  this
                );
              throw new Error(
                'minPitch must be between 0 and the current maxPitch, inclusive'
              );
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t) {
              if ((t = null == t ? 60 : t) > 180)
                throw new Error('maxPitch must be less than or equal to 180');
              if (t >= this.transform.minPitch)
                return (
                  this.transform.setMaxPitch(t),
                  this._update(),
                  this.getPitch() > t && this.setPitch(t),
                  this
                );
              throw new Error(
                'maxPitch must be greater than the current minPitch'
              );
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t) {
              return this.transform.setRenderWorldCopies(t), this._update();
            }
            setTransformConstrain(t) {
              return this.transform.setConstrain(t), this._update();
            }
            project(t) {
              return this.transform.locationToScreenPoint(
                e.U.convert(t),
                this.style && this.terrain
              );
            }
            unproject(t) {
              return this.transform.screenPointToLocation(
                e.P.convert(t),
                this.terrain
              );
            }
            isMoving() {
              var t;
              return (
                this._moving ||
                (null === (t = this.handlers) || void 0 === t
                  ? void 0
                  : t.isMoving())
              );
            }
            isZooming() {
              var t;
              return (
                this._zooming ||
                (null === (t = this.handlers) || void 0 === t
                  ? void 0
                  : t.isZooming())
              );
            }
            isRotating() {
              var t;
              return (
                this._rotating ||
                (null === (t = this.handlers) || void 0 === t
                  ? void 0
                  : t.isRotating())
              );
            }
            _createDelegatedListener(t, e, i) {
              if ('mouseenter' === t || 'mouseover' === t) {
                let r = !1;
                const n = (n) => {
                  const o = e.filter((t) => this.getLayer(t)),
                    a =
                      0 !== o.length
                        ? this.queryRenderedFeatures(n.point, { layers: o })
                        : [];
                  a.length
                    ? r ||
                      ((r = !0),
                      i.call(
                        this,
                        new Jn(t, this, n.originalEvent, { features: a })
                      ))
                    : (r = !1);
                };
                return {
                  layers: e,
                  listener: i,
                  delegates: {
                    mousemove: n,
                    mouseout: () => {
                      r = !1;
                    },
                  },
                };
              }
              if ('mouseleave' === t || 'mouseout' === t) {
                let r = !1;
                const n = (n) => {
                    const o = e.filter((t) => this.getLayer(t));
                    (0 !== o.length
                      ? this.queryRenderedFeatures(n.point, { layers: o })
                      : []
                    ).length
                      ? (r = !0)
                      : r &&
                        ((r = !1),
                        i.call(this, new Jn(t, this, n.originalEvent)));
                  },
                  o = (e) => {
                    r &&
                      ((r = !1),
                      i.call(this, new Jn(t, this, e.originalEvent)));
                  };
                return {
                  layers: e,
                  listener: i,
                  delegates: { mousemove: n, mouseout: o },
                };
              }
              {
                const r = (t) => {
                  const r = e.filter((t) => this.getLayer(t)),
                    n =
                      0 !== r.length
                        ? this.queryRenderedFeatures(t.point, { layers: r })
                        : [];
                  n.length &&
                    ((t.features = n), i.call(this, t), delete t.features);
                };
                return { layers: e, listener: i, delegates: { [t]: r } };
              }
            }
            _saveDelegatedListener(t, e) {
              (this._delegatedListeners = this._delegatedListeners || {}),
                (this._delegatedListeners[t] =
                  this._delegatedListeners[t] || []),
                this._delegatedListeners[t].push(e);
            }
            _removeDelegatedListener(t, e, i) {
              if (!this._delegatedListeners || !this._delegatedListeners[t])
                return;
              const r = this._delegatedListeners[t];
              for (let n = 0; n < r.length; n++) {
                const t = r[n];
                if (
                  t.listener === i &&
                  t.layers.length === e.length &&
                  t.layers.every((t) => e.includes(t))
                ) {
                  for (const e in t.delegates) this.off(e, t.delegates[e]);
                  return void r.splice(n, 1);
                }
              }
            }
            on(t, e, i) {
              if (void 0 === i) return super.on(t, e);
              const r = 'string' == typeof e ? [e] : e,
                n = this._createDelegatedListener(t, r, i);
              this._saveDelegatedListener(t, n);
              for (const o in n.delegates) this.on(o, n.delegates[o]);
              return {
                unsubscribe: () => {
                  this._removeDelegatedListener(t, r, i);
                },
              };
            }
            once(t, e, i) {
              if (void 0 === i) return super.once(t, e);
              const r = 'string' == typeof e ? [e] : e,
                n = this._createDelegatedListener(t, r, i);
              for (const o in n.delegates) {
                const e = n.delegates[o];
                n.delegates[o] = (...n) => {
                  this._removeDelegatedListener(t, r, i), e(...n);
                };
              }
              this._saveDelegatedListener(t, n);
              for (const o in n.delegates) this.once(o, n.delegates[o]);
              return this;
            }
            off(t, e, i) {
              return void 0 === i
                ? super.off(t, e)
                : (this._removeDelegatedListener(
                    t,
                    'string' == typeof e ? [e] : e,
                    i
                  ),
                  this);
            }
            queryRenderedFeatures(t, i) {
              if (!this.style) return [];
              let r;
              const n = t instanceof e.P || Array.isArray(t),
                o = n
                  ? t
                  : [
                      [0, 0],
                      [this.transform.width, this.transform.height],
                    ];
              if (
                ((i = i || (n ? {} : t) || {}),
                o instanceof e.P || 'number' == typeof o[0])
              )
                r = [e.P.convert(o)];
              else {
                const t = e.P.convert(o[0]),
                  i = e.P.convert(o[1]);
                r = [t, new e.P(i.x, t.y), i, new e.P(t.x, i.y), t];
              }
              return this.style.queryRenderedFeatures(r, i, this.transform);
            }
            querySourceFeatures(t, e) {
              return this.style.querySourceFeatures(t, e);
            }
            setStyle(t, i) {
              return !1 !==
                (i = e.e(
                  {},
                  {
                    localIdeographFontFamily: this._localIdeographFontFamily,
                    validate: this._validateStyle,
                  },
                  i
                )).diff &&
                i.localIdeographFontFamily === this._localIdeographFontFamily &&
                this.style &&
                t
                ? (this._diffStyle(t, i), this)
                : ((this._localIdeographFontFamily =
                    i.localIdeographFontFamily),
                  this._updateStyle(t, i));
            }
            setTransformRequest(t) {
              return this._requestManager.setTransformRequest(t), this;
            }
            _getUIString(t) {
              const e = this._locale[t];
              if (null == e) throw new Error(`Missing UI string '${t}'`);
              return e;
            }
            _updateStyle(t, e) {
              var i, r;
              if (e.transformStyle && this.style && !this.style._loaded)
                return void this.style.once('style.load', () =>
                  this._updateStyle(t, e)
                );
              const n =
                this.style && e.transformStyle
                  ? this.style.serialize()
                  : void 0;
              return (
                this.style &&
                  (this.style.setEventedParent(null), this.style._remove(!t)),
                t
                  ? ((this.style = new Ai(this, e || {})),
                    this.style.setEventedParent(this, { style: this.style }),
                    'string' == typeof t
                      ? this.style.loadURL(t, e, n)
                      : this.style.loadJSON(t, e, n),
                    this)
                  : (null ===
                      (r =
                        null === (i = this.style) || void 0 === i
                          ? void 0
                          : i.projection) ||
                      void 0 === r ||
                      r.destroy(),
                    delete this.style,
                    this)
              );
            }
            _lazyInitEmptyStyle() {
              this.style ||
                ((this.style = new Ai(this, {})),
                this.style.setEventedParent(this, { style: this.style }),
                this.style.loadEmpty());
            }
            _diffStyle(t, i) {
              if ('string' == typeof t) {
                const r = this._requestManager.transformRequest(t, 'Style');
                e.j(r, new AbortController())
                  .then((t) => {
                    this._updateDiff(t.data, i);
                  })
                  .catch((t) => {
                    t && this.fire(new e.k(t));
                  });
              } else 'object' == typeof t && this._updateDiff(t, i);
            }
            _updateDiff(t, i) {
              try {
                this.style.setState(t, i) && this._update(!0);
              } catch (r) {
                e.w(
                  `Unable to perform style diff: ${
                    r.message || r.error || r
                  }.  Rebuilding the style from scratch.`
                ),
                  this._updateStyle(t, i);
              }
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style
                ? this.style.loaded()
                : e.w('There is no style added to the map.');
            }
            addSource(t, e) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addSource(t, e),
                this._update(!0)
              );
            }
            isSourceLoaded(t) {
              const i = this.style && this.style.tileManagers[t];
              if (void 0 !== i) return i.loaded();
              this.fire(
                new e.k(new Error(`There is no tile manager with ID '${t}'`))
              );
            }
            setTerrain(t) {
              if (
                (this.style._checkLoaded(),
                this._terrainDataCallback &&
                  this.style.off('data', this._terrainDataCallback),
                t)
              ) {
                const i = this.style.tileManagers[t.source];
                if (!i)
                  throw new Error(
                    `cannot load terrain, because there exists no source with ID: ${t.source}`
                  );
                null === this.terrain && i.reload();
                for (const r in this.style._layers) {
                  const i = this.style._layers[r];
                  'hillshade' === i.type &&
                    i.source === t.source &&
                    e.w(
                      'You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.'
                    ),
                    'color-relief' === i.type &&
                      i.source === t.source &&
                      e.w(
                        'You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.'
                      );
                }
                (this.terrain = new Ho(this.painter, i, t)),
                  (this.painter.renderToTexture = new Jo(
                    this.painter,
                    this.terrain
                  )),
                  this.transform.setMinElevationForCurrentTile(
                    this.terrain.getMinTileElevationForLngLatZoom(
                      this.transform.center,
                      this.transform.tileZoom
                    )
                  ),
                  this.transform.setElevation(
                    this.terrain.getElevationForLngLatZoom(
                      this.transform.center,
                      this.transform.tileZoom
                    )
                  ),
                  (this._terrainDataCallback = (e) => {
                    var i;
                    'style' === e.dataType
                      ? this.terrain.tileManager.freeRtt()
                      : 'source' === e.dataType &&
                        e.tile &&
                        (e.sourceId !== t.source ||
                          this._elevationFreeze ||
                          (this.transform.setMinElevationForCurrentTile(
                            this.terrain.getMinTileElevationForLngLatZoom(
                              this.transform.center,
                              this.transform.tileZoom
                            )
                          ),
                          this._centerClampedToGround &&
                            this.transform.setElevation(
                              this.terrain.getElevationForLngLatZoom(
                                this.transform.center,
                                this.transform.tileZoom
                              )
                            )),
                        'image' ===
                        (null === (i = e.source) || void 0 === i
                          ? void 0
                          : i.type)
                          ? this.terrain.tileManager.freeRtt()
                          : this.terrain.tileManager.freeRtt(e.tile.tileID));
                  }),
                  this.style.on('data', this._terrainDataCallback);
              } else
                this.terrain && this.terrain.tileManager.destruct(),
                  (this.terrain = null),
                  this.painter.renderToTexture &&
                    this.painter.renderToTexture.destruct(),
                  (this.painter.renderToTexture = null),
                  this.transform.setMinElevationForCurrentTile(0),
                  this._centerClampedToGround && this.transform.setElevation(0);
              return this.fire(new e.l('terrain', { terrain: t })), this;
            }
            getTerrain() {
              var t, e;
              return null !==
                (e =
                  null === (t = this.terrain) || void 0 === t
                    ? void 0
                    : t.options) && void 0 !== e
                ? e
                : null;
            }
            areTilesLoaded() {
              const t = this.style && this.style.tileManagers;
              for (const e in t) {
                const i = t[e]._tiles;
                for (const t in i) {
                  const e = i[t];
                  if ('loaded' !== e.state && 'errored' !== e.state) return !1;
                }
              }
              return !0;
            }
            removeSource(t) {
              return this.style.removeSource(t), this._update(!0);
            }
            getSource(t) {
              return this.style.getSource(t);
            }
            setSourceTileLodParams(t, e, i) {
              if (i) {
                const r = this.getSource(i);
                if (!r)
                  throw new Error(
                    `There is no source with ID "${i}", cannot set LOD parameters`
                  );
                r.calculateTileZoom = wt(Math.max(1, t), Math.max(1, e));
              } else
                for (const r in this.style.tileManagers)
                  this.style.tileManagers[r].getSource().calculateTileZoom = wt(
                    Math.max(1, t),
                    Math.max(1, e)
                  );
              return this._update(!0), this;
            }
            refreshTiles(t, i) {
              const r = this.style.tileManagers[t];
              if (!r)
                throw new Error(
                  `There is no tile manager with ID "${t}", cannot refresh tile`
                );
              void 0 === i
                ? r.reload(!0)
                : r.refreshTiles(i.map((t) => new e.a8(t.z, t.x, t.y)));
            }
            addImage(t, i, r = {}) {
              const {
                pixelRatio: n = 1,
                sdf: o = !1,
                stretchX: s,
                stretchY: l,
                content: c,
                textFitWidth: h,
                textFitHeight: u,
              } = r;
              if (
                (this._lazyInitEmptyStyle(),
                !(i instanceof HTMLImageElement || e.b(i)))
              ) {
                if (void 0 === i.width || void 0 === i.height)
                  return this.fire(
                    new e.k(
                      new Error(
                        'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`'
                      )
                    )
                  );
                {
                  const { width: r, height: a, data: d } = i,
                    p = i;
                  return (
                    this.style.addImage(t, {
                      data: new e.R({ width: r, height: a }, new Uint8Array(d)),
                      pixelRatio: n,
                      stretchX: s,
                      stretchY: l,
                      content: c,
                      textFitWidth: h,
                      textFitHeight: u,
                      sdf: o,
                      version: 0,
                      userImage: p,
                    }),
                    p.onAdd && p.onAdd(this, t),
                    this
                  );
                }
              }
              {
                const { width: r, height: d, data: p } = a.getImageData(i);
                this.style.addImage(t, {
                  data: new e.R({ width: r, height: d }, p),
                  pixelRatio: n,
                  stretchX: s,
                  stretchY: l,
                  content: c,
                  textFitWidth: h,
                  textFitHeight: u,
                  sdf: o,
                  version: 0,
                });
              }
            }
            updateImage(t, i) {
              const r = this.style.getImage(t);
              if (!r)
                return this.fire(
                  new e.k(
                    new Error(
                      'The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.'
                    )
                  )
                );
              const n =
                  i instanceof HTMLImageElement || e.b(i)
                    ? a.getImageData(i)
                    : i,
                { width: o, height: s, data: l } = n;
              if (void 0 === o || void 0 === s)
                return this.fire(
                  new e.k(
                    new Error(
                      'Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`'
                    )
                  )
                );
              if (o !== r.data.width || s !== r.data.height)
                return this.fire(
                  new e.k(
                    new Error(
                      'The width and height of the updated image must be that same as the previous version of the image'
                    )
                  )
                );
              const c = !(i instanceof HTMLImageElement || e.b(i));
              return r.data.replace(l, c), this.style.updateImage(t, r), this;
            }
            getImage(t) {
              return this.style.getImage(t);
            }
            hasImage(t) {
              return t
                ? !!this.style.getImage(t)
                : (this.fire(new e.k(new Error('Missing required image id'))),
                  !1);
            }
            removeImage(t) {
              this.style.removeImage(t);
            }
            loadImage(t) {
              return _.getImage(
                this._requestManager.transformRequest(t, 'Image'),
                new AbortController()
              );
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t, e) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addLayer(t, e),
                this._update(!0)
              );
            }
            moveLayer(t, e) {
              return this.style.moveLayer(t, e), this._update(!0);
            }
            removeLayer(t) {
              return this.style.removeLayer(t), this._update(!0);
            }
            getLayer(t) {
              return this.style.getLayer(t);
            }
            getLayersOrder() {
              return this.style.getLayersOrder();
            }
            setLayerZoomRange(t, e, i) {
              return this.style.setLayerZoomRange(t, e, i), this._update(!0);
            }
            setFilter(t, e, i = {}) {
              return this.style.setFilter(t, e, i), this._update(!0);
            }
            getFilter(t) {
              return this.style.getFilter(t);
            }
            setPaintProperty(t, e, i, r = {}) {
              return this.style.setPaintProperty(t, e, i, r), this._update(!0);
            }
            getPaintProperty(t, e) {
              return this.style.getPaintProperty(t, e);
            }
            setLayoutProperty(t, e, i, r = {}) {
              return this.style.setLayoutProperty(t, e, i, r), this._update(!0);
            }
            getLayoutProperty(t, e) {
              return this.style.getLayoutProperty(t, e);
            }
            setGlyphs(t, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setGlyphs(t, e),
                this._update(!0)
              );
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(t, e, i = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.addSprite(t, e, i, (t) => {
                  t || this._update(!0);
                }),
                this
              );
            }
            removeSprite(t) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.removeSprite(t),
                this._update(!0)
              );
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(t, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setSprite(t, e, (t) => {
                  t || this._update(!0);
                }),
                this
              );
            }
            setLight(t, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setLight(t, e),
                this._update(!0)
              );
            }
            getLight() {
              return this.style.getLight();
            }
            setSky(t, e = {}) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setSky(t, e),
                this._update(!0)
              );
            }
            getSky() {
              return this.style.getSky();
            }
            setFeatureState(t, e) {
              return this.style.setFeatureState(t, e), this._update();
            }
            removeFeatureState(t, e) {
              return this.style.removeFeatureState(t, e), this._update();
            }
            getFeatureState(t) {
              return this.style.getFeatureState(t);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let t = 0,
                e = 0;
              return (
                this._container &&
                  ((t = this._container.clientWidth || 400),
                  (e = this._container.clientHeight || 300)),
                [t, e]
              );
            }
            _setupContainer() {
              const t = this._container;
              t.classList.add('maplibregl-map');
              const e = (this._canvasContainer = c.create(
                'div',
                'maplibregl-canvas-container',
                t
              ));
              this._interactive && e.classList.add('maplibregl-interactive'),
                (this._canvas = c.create('canvas', 'maplibregl-canvas', e)),
                this._canvas.addEventListener(
                  'webglcontextlost',
                  this._contextLost,
                  !1
                ),
                this._canvas.addEventListener(
                  'webglcontextrestored',
                  this._contextRestored,
                  !1
                ),
                this._canvas.setAttribute(
                  'tabindex',
                  this._interactive ? '0' : '-1'
                ),
                this._canvas.setAttribute(
                  'aria-label',
                  this._getUIString('Map.Title')
                ),
                this._canvas.setAttribute('role', 'region');
              const i = this._containerDimensions(),
                r = this._getClampedPixelRatio(i[0], i[1]);
              this._resizeCanvas(i[0], i[1], r);
              const n = (this._controlContainer = c.create(
                  'div',
                  'maplibregl-control-container',
                  t
                )),
                o = (this._controlPositions = {});
              ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(
                (t) => {
                  o[t] = c.create('div', `maplibregl-ctrl-${t} `, n);
                }
              ),
                this._container.addEventListener(
                  'scroll',
                  this._onMapScroll,
                  !1
                );
            }
            _resizeCanvas(t, e, i) {
              (this._canvas.width = Math.floor(i * t)),
                (this._canvas.height = Math.floor(i * e)),
                (this._canvas.style.width = `${t}px`),
                (this._canvas.style.height = `${e}px`);
            }
            _setupPainter() {
              const t = Object.assign(
                Object.assign({}, this._canvasContextAttributes),
                { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 }
              );
              let e = null;
              this._canvas.addEventListener(
                'webglcontextcreationerror',
                (i) => {
                  (e = { requestedAttributes: t }),
                    i &&
                      ((e.statusMessage = i.statusMessage), (e.type = i.type));
                },
                { once: !0 }
              );
              let i = null;
              if (
                ((i = this._canvasContextAttributes.contextType
                  ? this._canvas.getContext(
                      this._canvasContextAttributes.contextType,
                      t
                    )
                  : this._canvas.getContext('webgl2', t) ||
                    this._canvas.getContext('webgl', t)),
                !i)
              ) {
                const t = 'Failed to initialize WebGL';
                throw e
                  ? ((e.message = t), new Error(JSON.stringify(e)))
                  : new Error(t);
              }
              (this.painter = new Nn(i, this.transform)), h.testSupport(i);
            }
            migrateProjection(t, i) {
              super.migrateProjection(t, i),
                (this.painter.transform = t),
                this.fire(
                  new e.l('projectiontransition', {
                    newProjection: this.style.projection.name,
                  })
                );
            }
            loaded() {
              return (
                !this._styleDirty &&
                !this._sourcesDirty &&
                !!this.style &&
                this.style.loaded()
              );
            }
            _update(t) {
              return this.style && this.style._loaded
                ? ((this._styleDirty = this._styleDirty || t),
                  (this._sourcesDirty = !0),
                  this.triggerRepaint(),
                  this)
                : this;
            }
            _requestRenderFrame(t) {
              return this._update(), this._renderTaskQueue.add(t);
            }
            _cancelRenderFrame(t) {
              this._renderTaskQueue.remove(t);
            }
            _render(t) {
              var i, r, n, o, a;
              const s = this._idleTriggered ? this._fadeDuration : 0,
                c =
                  (null === (i = this.style.projection) || void 0 === i
                    ? void 0
                    : i.transitionState) > 0;
              if (
                (this.painter.context.setDirty(),
                this.painter.setBaseState(),
                this._renderTaskQueue.run(t),
                this._removed)
              )
                return;
              let h = !1;
              if (this.style && this._styleDirty) {
                this._styleDirty = !1;
                const t = this.transform.zoom,
                  i = l();
                this.style.zoomHistory.update(t, i);
                const r = new e.G(t, {
                    now: i,
                    fadeDuration: s,
                    zoomHistory: this.style.zoomHistory,
                    transition: this.style.getTransition(),
                  }),
                  n = r.crossFadingFactor();
                (1 === n && n === this._crossFadingFactor) ||
                  ((h = !0), (this._crossFadingFactor = n)),
                  this.style.update(r);
              }
              const u =
                (null === (r = this.style.projection) || void 0 === r
                  ? void 0
                  : r.transitionState) >
                  0 !==
                c;
              null === (n = this.style.projection) ||
                void 0 === n ||
                n.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                this.transform.setTransitionState(
                  null === (o = this.style.projection) || void 0 === o
                    ? void 0
                    : o.transitionState,
                  null === (a = this.style.projection) || void 0 === a
                    ? void 0
                    : a.latitudeErrorCorrectionRadians
                ),
                this.style &&
                  (this._sourcesDirty || u) &&
                  ((this._sourcesDirty = !1),
                  this.style._updateSources(this.transform)),
                this.terrain
                  ? (this.terrain.tileManager.update(
                      this.transform,
                      this.terrain
                    ),
                    this.transform.setMinElevationForCurrentTile(
                      this.terrain.getMinTileElevationForLngLatZoom(
                        this.transform.center,
                        this.transform.tileZoom
                      )
                    ),
                    !this._elevationFreeze &&
                      this._centerClampedToGround &&
                      this.transform.setElevation(
                        this.terrain.getElevationForLngLatZoom(
                          this.transform.center,
                          this.transform.tileZoom
                        )
                      ))
                  : (this.transform.setMinElevationForCurrentTile(0),
                    this._centerClampedToGround &&
                      this.transform.setElevation(0)),
                (this._placementDirty =
                  this.style &&
                  this.style._updatePlacement(
                    this.transform,
                    this.showCollisionBoxes,
                    s,
                    this._crossSourceCollisions,
                    u
                  )),
                this.painter.render(this.style, {
                  showTileBoundaries: this.showTileBoundaries,
                  showOverdrawInspector: this._showOverdrawInspector,
                  rotating: this.isRotating(),
                  zooming: this.isZooming(),
                  moving: this.isMoving(),
                  fadeDuration: s,
                  showPadding: this.showPadding,
                }),
                this.fire(new e.l('render')),
                this.loaded() &&
                  !this._loaded &&
                  ((this._loaded = !0),
                  e.cz.mark(e.cA.load),
                  this.fire(new e.l('load'))),
                this.style &&
                  (this.style.hasTransitions() || h) &&
                  (this._styleDirty = !0),
                this.style &&
                  !this._placementDirty &&
                  this.style._releaseSymbolFadeTiles();
              const d =
                this._sourcesDirty || this._styleDirty || this._placementDirty;
              return (
                d || this._repaint
                  ? this.triggerRepaint()
                  : !this.isMoving() &&
                    this.loaded() &&
                    this.fire(new e.l('idle')),
                !this._loaded ||
                  this._fullyLoaded ||
                  d ||
                  ((this._fullyLoaded = !0), e.cz.mark(e.cA.fullLoad)),
                this
              );
            }
            redraw() {
              return (
                this.style &&
                  (this._frameRequest &&
                    (this._frameRequest.abort(), (this._frameRequest = null)),
                  this._render(0)),
                this
              );
            }
            remove() {
              var t;
              this._hash && this._hash.remove();
              for (const e of this._controls) e.onRemove(this);
              (this._controls = []),
                this._frameRequest &&
                  (this._frameRequest.abort(), (this._frameRequest = null)),
                this._renderTaskQueue.clear(),
                this.painter.destroy(),
                this.handlers.destroy(),
                delete this.handlers,
                this.setStyle(null),
                'undefined' != typeof window &&
                  removeEventListener('online', this._onWindowOnline, !1),
                _.removeThrottleControl(this._imageQueueHandle),
                null === (t = this._resizeObserver) ||
                  void 0 === t ||
                  t.disconnect();
              const i =
                this.painter.context.gl.getExtension('WEBGL_lose_context');
              (null == i ? void 0 : i.loseContext) && i.loseContext(),
                this._canvas.removeEventListener(
                  'webglcontextrestored',
                  this._contextRestored,
                  !1
                ),
                this._canvas.removeEventListener(
                  'webglcontextlost',
                  this._contextLost,
                  !1
                ),
                c.remove(this._canvasContainer),
                c.remove(this._controlContainer),
                this._container.removeEventListener(
                  'scroll',
                  this._onMapScroll,
                  !1
                ),
                this._container.classList.remove('maplibregl-map'),
                e.cz.clearMetrics(),
                (this._removed = !0),
                this.fire(new e.l('remove'));
            }
            triggerRepaint() {
              this.style &&
                !this._frameRequest &&
                ((this._frameRequest = new AbortController()),
                a.frame(
                  this._frameRequest,
                  (t) => {
                    e.cz.frame(t), (this._frameRequest = null);
                    try {
                      this._render(t);
                    } catch (t) {
                      if (
                        !e.cB(t) &&
                        !(function (t) {
                          return t.message === Qr;
                        })(t)
                      )
                        throw t;
                    }
                  },
                  () => {}
                ));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t) {
              this._showTileBoundaries !== t &&
                ((this._showTileBoundaries = t), this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t) {
              this._showPadding !== t &&
                ((this._showPadding = t), this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t) {
              this._showCollisionBoxes !== t &&
                ((this._showCollisionBoxes = t),
                t ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t) {
              this._showOverdrawInspector !== t &&
                ((this._showOverdrawInspector = t), this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t) {
              this._repaint !== t &&
                ((this._repaint = t), this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t) {
              (this._vertices = t), this._update();
            }
            get version() {
              return ta;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
            getProjection() {
              return this.style.getProjection();
            }
            setProjection(t) {
              return (
                this._lazyInitEmptyStyle(),
                this.style.setProjection(t),
                this._update(!0)
              );
            }
          }),
          (t.MapMouseEvent = Jn),
          (t.MapTouchEvent = Qn),
          (t.MapWheelEvent = to),
          (t.Marker = la),
          (t.NavigationControl = class {
            constructor(t) {
              (this._updateZoomButtons = () => {
                const t = this._map.getZoom(),
                  e = t === this._map.getMaxZoom(),
                  i = t === this._map.getMinZoom();
                (this._zoomInButton.disabled = e),
                  (this._zoomOutButton.disabled = i),
                  this._zoomInButton.setAttribute(
                    'aria-disabled',
                    e.toString()
                  ),
                  this._zoomOutButton.setAttribute(
                    'aria-disabled',
                    i.toString()
                  );
              }),
                (this._rotateCompassArrow = () => {
                  this._compassIcon.style.transform =
                    this.options.visualizePitch && this.options.visualizeRoll
                      ? `scale(${
                          1 /
                          Math.pow(
                            Math.cos(this._map.transform.pitchInRadians),
                            0.5
                          )
                        }) rotateZ(${-this._map.transform.roll}deg) rotateX(${
                          this._map.transform.pitch
                        }deg) rotateZ(${-this._map.transform.bearing}deg)`
                      : this.options.visualizePitch
                      ? `scale(${
                          1 /
                          Math.pow(
                            Math.cos(this._map.transform.pitchInRadians),
                            0.5
                          )
                        }) rotateX(${
                          this._map.transform.pitch
                        }deg) rotateZ(${-this._map.transform.bearing}deg)`
                      : this.options.visualizeRoll
                      ? `rotate(${
                          -this._map.transform.bearing -
                          this._map.transform.roll
                        }deg)`
                      : `rotate(${-this._map.transform.bearing}deg)`;
                }),
                (this._setButtonTitle = (t, e) => {
                  const i = this._map._getUIString(`NavigationControl.${e}`);
                  (t.title = i), t.setAttribute('aria-label', i);
                }),
                (this.options = e.e({}, ia, t)),
                (this._container = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-group'
                )),
                this._container.addEventListener('contextmenu', (t) =>
                  t.preventDefault()
                ),
                this.options.showZoom &&
                  ((this._zoomInButton = this._createButton(
                    'maplibregl-ctrl-zoom-in',
                    (t) => this._map.zoomIn({}, { originalEvent: t })
                  )),
                  c
                    .create('span', 'maplibregl-ctrl-icon', this._zoomInButton)
                    .setAttribute('aria-hidden', 'true'),
                  (this._zoomOutButton = this._createButton(
                    'maplibregl-ctrl-zoom-out',
                    (t) => this._map.zoomOut({}, { originalEvent: t })
                  )),
                  c
                    .create('span', 'maplibregl-ctrl-icon', this._zoomOutButton)
                    .setAttribute('aria-hidden', 'true')),
                this.options.showCompass &&
                  ((this._compass = this._createButton(
                    'maplibregl-ctrl-compass',
                    (t) => {
                      this.options.visualizePitch
                        ? this._map.resetNorthPitch({}, { originalEvent: t })
                        : this._map.resetNorth({}, { originalEvent: t });
                    }
                  )),
                  (this._compassIcon = c.create(
                    'span',
                    'maplibregl-ctrl-icon',
                    this._compass
                  )),
                  this._compassIcon.setAttribute('aria-hidden', 'true'));
            }
            onAdd(t) {
              return (
                (this._map = t),
                this.options.showZoom &&
                  (this._setButtonTitle(this._zoomInButton, 'ZoomIn'),
                  this._setButtonTitle(this._zoomOutButton, 'ZoomOut'),
                  this._map.on('zoom', this._updateZoomButtons),
                  this._updateZoomButtons()),
                this.options.showCompass &&
                  (this._setButtonTitle(this._compass, 'ResetBearing'),
                  this.options.visualizePitch &&
                    this._map.on('pitch', this._rotateCompassArrow),
                  this.options.visualizeRoll &&
                    this._map.on('roll', this._rotateCompassArrow),
                  this._map.on('rotate', this._rotateCompassArrow),
                  this._rotateCompassArrow(),
                  (this._handler = new ra(
                    this._map,
                    this._compass,
                    this.options.visualizePitch
                  ))),
                this._container
              );
            }
            onRemove() {
              c.remove(this._container),
                this.options.showZoom &&
                  this._map.off('zoom', this._updateZoomButtons),
                this.options.showCompass &&
                  (this.options.visualizePitch &&
                    this._map.off('pitch', this._rotateCompassArrow),
                  this.options.visualizeRoll &&
                    this._map.off('roll', this._rotateCompassArrow),
                  this._map.off('rotate', this._rotateCompassArrow),
                  this._handler.off(),
                  delete this._handler),
                delete this._map;
            }
            _createButton(t, e) {
              const i = c.create('button', t, this._container);
              return (i.type = 'button'), i.addEventListener('click', e), i;
            }
          }),
          (t.Popup = class extends e.E {
            constructor(t) {
              super(),
                (this._updateOpacity = () => {
                  void 0 !== this.options.locationOccludedOpacity &&
                    (this._container.style.opacity =
                      this._map.transform.isLocationOccluded(this.getLngLat())
                        ? `${this.options.locationOccludedOpacity}`
                        : '');
                }),
                (this.remove = () => (
                  this._content && c.remove(this._content),
                  this._container &&
                    (c.remove(this._container), delete this._container),
                  this._map &&
                    (this._map.off('move', this._update),
                    this._map.off('move', this._onClose),
                    this._map.off('click', this._onClose),
                    this._map.off('remove', this.remove),
                    this._map.off('mousemove', this._onMouseMove),
                    this._map.off('mouseup', this._onMouseUp),
                    this._map.off('drag', this._onDrag),
                    this._map._canvasContainer.classList.remove(
                      'maplibregl-track-pointer'
                    ),
                    delete this._map,
                    this.fire(new e.l('close'))),
                  this
                )),
                (this._onMouseUp = (t) => {
                  this._update(t.point);
                }),
                (this._onMouseMove = (t) => {
                  this._update(t.point);
                }),
                (this._onDrag = (t) => {
                  this._update(t.point);
                }),
                (this._update = (t) => {
                  if (
                    !this._map ||
                    (!this._lngLat && !this._trackPointer) ||
                    !this._content
                  )
                    return;
                  if (!this._container) {
                    if (
                      ((this._container = c.create(
                        'div',
                        'maplibregl-popup',
                        this._map.getContainer()
                      )),
                      (this._tip = c.create(
                        'div',
                        'maplibregl-popup-tip',
                        this._container
                      )),
                      this._container.appendChild(this._content),
                      this.options.className)
                    )
                      for (const t of this.options.className.split(' '))
                        this._container.classList.add(t);
                    this._closeButton &&
                      this._closeButton.setAttribute(
                        'aria-label',
                        this._map._getUIString('Popup.Close')
                      ),
                      this._trackPointer &&
                        this._container.classList.add(
                          'maplibregl-popup-track-pointer'
                        );
                  }
                  if (
                    (this.options.maxWidth &&
                      this._container.style.maxWidth !==
                        this.options.maxWidth &&
                      (this._container.style.maxWidth = this.options.maxWidth),
                    (this._lngLat = oa(
                      this._lngLat,
                      this._flatPos,
                      this._map.transform,
                      this._trackPointer
                    )),
                    this._trackPointer && !t)
                  )
                    return;
                  const e =
                    (this._flatPos =
                    this._pos =
                      this._trackPointer && t
                        ? t
                        : this._map.project(this._lngLat));
                  this._map.terrain &&
                    (this._flatPos =
                      this._trackPointer && t
                        ? t
                        : this._map.transform.locationToScreenPoint(
                            this._lngLat
                          ));
                  let i = this.options.anchor;
                  const r = ga(this.options.offset);
                  if (!i) {
                    const t = this._container.offsetWidth,
                      n = this._container.offsetHeight;
                    let o;
                    (o =
                      e.y + r.bottom.y < n
                        ? ['top']
                        : e.y > this._map.transform.height - n
                        ? ['bottom']
                        : []),
                      e.x < t / 2
                        ? o.push('left')
                        : e.x > this._map.transform.width - t / 2 &&
                          o.push('right'),
                      (i = 0 === o.length ? 'bottom' : o.join('-'));
                  }
                  let n = e.add(r[i]);
                  this.options.subpixelPositioning || (n = n.round()),
                    c.setTransform(
                      this._container,
                      `${aa[i]} translate(${n.x}px,${n.y}px)`
                    ),
                    sa(this._container, i, 'popup'),
                    this._updateOpacity();
                }),
                (this._onClose = () => {
                  this.remove();
                }),
                (this.options = e.e(Object.create(ma), t));
            }
            addTo(t) {
              return (
                this._map && this.remove(),
                (this._map = t),
                this.options.closeOnClick &&
                  this._map.on('click', this._onClose),
                this.options.closeOnMove && this._map.on('move', this._onClose),
                this._map.on('remove', this.remove),
                this._update(),
                this._focusFirstElement(),
                this._trackPointer
                  ? (this._map.on('mousemove', this._onMouseMove),
                    this._map.on('mouseup', this._onMouseUp),
                    this._container &&
                      this._container.classList.add(
                        'maplibregl-popup-track-pointer'
                      ),
                    this._map._canvasContainer.classList.add(
                      'maplibregl-track-pointer'
                    ))
                  : this._map.on('move', this._update),
                this.fire(new e.l('open')),
                this
              );
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t) {
              return (
                (this._lngLat = e.U.convert(t)),
                (this._pos = null),
                (this._flatPos = null),
                (this._trackPointer = !1),
                this._update(),
                this._map &&
                  (this._map.on('move', this._update),
                  this._map.off('mousemove', this._onMouseMove),
                  this._container &&
                    this._container.classList.remove(
                      'maplibregl-popup-track-pointer'
                    ),
                  this._map._canvasContainer.classList.remove(
                    'maplibregl-track-pointer'
                  )),
                this
              );
            }
            trackPointer() {
              return (
                (this._trackPointer = !0),
                (this._pos = null),
                (this._flatPos = null),
                this._update(),
                this._map &&
                  (this._map.off('move', this._update),
                  this._map.on('mousemove', this._onMouseMove),
                  this._map.on('drag', this._onDrag),
                  this._container &&
                    this._container.classList.add(
                      'maplibregl-popup-track-pointer'
                    ),
                  this._map._canvasContainer.classList.add(
                    'maplibregl-track-pointer'
                  )),
                this
              );
            }
            getElement() {
              return this._container;
            }
            setText(t) {
              return this.setDOMContent(document.createTextNode(t));
            }
            setHTML(t) {
              const e = document.createDocumentFragment(),
                i = document.createElement('body');
              let r;
              for (i.innerHTML = t; (r = i.firstChild), r; ) e.appendChild(r);
              return this.setDOMContent(e);
            }
            getMaxWidth() {
              var t;
              return null === (t = this._container) || void 0 === t
                ? void 0
                : t.style.maxWidth;
            }
            setMaxWidth(t) {
              return (this.options.maxWidth = t), this._update(), this;
            }
            setDOMContent(t) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild &&
                    this._content.removeChild(this._content.firstChild);
              else
                this._content = c.create(
                  'div',
                  'maplibregl-popup-content',
                  this._container
                );
              return (
                this._content.appendChild(t),
                this._createCloseButton(),
                this._update(),
                this._focusFirstElement(),
                this
              );
            }
            addClassName(t) {
              return this._container && this._container.classList.add(t), this;
            }
            removeClassName(t) {
              return (
                this._container && this._container.classList.remove(t), this
              );
            }
            setOffset(t) {
              return (this.options.offset = t), this._update(), this;
            }
            toggleClassName(t) {
              if (this._container) return this._container.classList.toggle(t);
            }
            setSubpixelPositioning(t) {
              this.options.subpixelPositioning = t;
            }
            _createCloseButton() {
              this.options.closeButton &&
                ((this._closeButton = c.create(
                  'button',
                  'maplibregl-popup-close-button',
                  this._content
                )),
                (this._closeButton.type = 'button'),
                (this._closeButton.innerHTML = '&#215;'),
                this._closeButton.addEventListener('click', this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const t = this._container.querySelector(_a);
              t && t.focus();
            }
          }),
          (t.RasterDEMTileSource = X),
          (t.RasterTileSource = H),
          (t.ScaleControl = class {
            constructor(t) {
              (this._onMove = () => {
                pa(this._map, this._container, this.options);
              }),
                (this.setUnit = (t) => {
                  (this.options.unit = t),
                    pa(this._map, this._container, this.options);
                }),
                (this.options = Object.assign(Object.assign({}, da), t));
            }
            getDefaultPosition() {
              return 'bottom-left';
            }
            onAdd(t) {
              return (
                (this._map = t),
                (this._container = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-scale',
                  t.getContainer()
                )),
                this._map.on('move', this._onMove),
                this._onMove(),
                this._container
              );
            }
            onRemove() {
              c.remove(this._container),
                this._map.off('move', this._onMove),
                (this._map = void 0);
            }
          }),
          (t.ScrollZoomHandler = Eo),
          (t.Style = Ai),
          (t.TerrainControl = class {
            constructor(t) {
              (this._toggleTerrain = () => {
                this._map.getTerrain()
                  ? this._map.setTerrain(null)
                  : this._map.setTerrain(this.options),
                  this._updateTerrainIcon();
              }),
                (this._updateTerrainIcon = () => {
                  this._terrainButton.classList.remove(
                    'maplibregl-ctrl-terrain'
                  ),
                    this._terrainButton.classList.remove(
                      'maplibregl-ctrl-terrain-enabled'
                    ),
                    this._map.terrain
                      ? (this._terrainButton.classList.add(
                          'maplibregl-ctrl-terrain-enabled'
                        ),
                        (this._terrainButton.title = this._map._getUIString(
                          'TerrainControl.Disable'
                        )))
                      : (this._terrainButton.classList.add(
                          'maplibregl-ctrl-terrain'
                        ),
                        (this._terrainButton.title = this._map._getUIString(
                          'TerrainControl.Enable'
                        )));
                }),
                (this.options = t);
            }
            onAdd(t) {
              return (
                (this._map = t),
                (this._container = c.create(
                  'div',
                  'maplibregl-ctrl maplibregl-ctrl-group'
                )),
                (this._terrainButton = c.create(
                  'button',
                  'maplibregl-ctrl-terrain',
                  this._container
                )),
                c
                  .create('span', 'maplibregl-ctrl-icon', this._terrainButton)
                  .setAttribute('aria-hidden', 'true'),
                (this._terrainButton.type = 'button'),
                this._terrainButton.addEventListener(
                  'click',
                  this._toggleTerrain
                ),
                this._updateTerrainIcon(),
                this._map.on('terrain', this._updateTerrainIcon),
                this._container
              );
            }
            onRemove() {
              c.remove(this._container),
                this._map.off('terrain', this._updateTerrainIcon),
                (this._map = void 0);
            }
          }),
          (t.TwoFingersTouchPitchHandler = Po),
          (t.TwoFingersTouchRotateHandler = wo),
          (t.TwoFingersTouchZoomHandler = vo),
          (t.TwoFingersTouchZoomRotateHandler = Fo),
          (t.VectorTileSource = Y),
          (t.VideoSource = et),
          (t.addSourceType = (t, i) =>
            e._(void 0, void 0, void 0, function* () {
              if (nt(t))
                throw new Error(`A source type called "${t}" already exists.`);
              ((t, e) => {
                rt[t] = e;
              })(t, i);
            })),
          (t.clearPrewarmedResources = function () {
            const t = F;
            t &&
              (t.isPreloaded() && 1 === t.numActive()
                ? (t.release(D), (F = null))
                : console.warn(
                    'Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()'
                  ));
          }),
          (t.createTileMesh = ii),
          (t.getMaxParallelImageRequests = function () {
            return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
          }),
          (t.getRTLTextPluginStatus = function () {
            return lt().getRTLTextPluginStatus();
          }),
          (t.getVersion = function () {
            return ya;
          }),
          (t.getWorkerCount = function () {
            return R.workerCount;
          }),
          (t.getWorkerUrl = function () {
            return e.a.WORKER_URL;
          }),
          (t.importScriptInWorkers = function (t) {
            return N().broadcast('IS', t);
          }),
          (t.isTimeFrozen = function () {
            return s.isFrozen();
          }),
          (t.now = l),
          (t.prewarm = function () {
            O().acquire(D);
          }),
          (t.restoreNow = function () {
            s.restoreNow();
          }),
          (t.setMaxParallelImageRequests = function (t) {
            e.a.MAX_PARALLEL_IMAGE_REQUESTS = t;
          }),
          (t.setNow = function (t) {
            s.setNow(t);
          }),
          (t.setRTLTextPlugin = function (t, e) {
            return lt().setRTLTextPlugin(t, e);
          }),
          (t.setWorkerCount = function (t) {
            R.workerCount = t;
          }),
          (t.setWorkerUrl = function (t) {
            e.a.WORKER_URL = t;
          });
      });
    var r = t;
    return r;
  })();
  var zi = Ai(Ei.exports),
    ki = [
      { Year: 1980, NY: 0, CA: 0 },
      { Year: 1981, NY: 0, CA: 0 },
      { Year: 1982, NY: 1, CA: 0 },
      { Year: 1983, NY: 1, CA: 1 },
      { Year: 1984, NY: 1, CA: 0 },
      { Year: 1985, NY: 3, CA: 0 },
      { Year: 1986, NY: 0, CA: 1 },
      { Year: 1987, NY: 0, CA: 0 },
      { Year: 1988, NY: 0, CA: 0 },
      { Year: 1989, NY: 1, CA: 0 },
      { Year: 1990, NY: 0, CA: 2 },
      { Year: 1991, NY: 2, CA: 1 },
      { Year: 1992, NY: 1, CA: 0 },
      { Year: 1993, NY: 1, CA: 1 },
      { Year: 1994, NY: 2, CA: 1 },
      { Year: 1995, NY: 0, CA: 1 },
      { Year: 1996, NY: 1, CA: 0 },
      { Year: 1997, NY: 1, CA: 1 },
      { Year: 1998, NY: 3, CA: 2 },
      { Year: 1999, NY: 3, CA: 0 },
      { Year: 2e3, NY: 0, CA: 1 },
      { Year: 2001, NY: 0, CA: 0 },
      { Year: 2002, NY: 2, CA: 2 },
      { Year: 2003, NY: 3, CA: 1 },
      { Year: 2004, NY: 4, CA: 0 },
      { Year: 2005, NY: 0, CA: 0 },
      { Year: 2006, NY: 1, CA: 1 },
      { Year: 2007, NY: 2, CA: 3 },
      { Year: 2008, NY: 2, CA: 3 },
      { Year: 2009, NY: 0, CA: 2 },
      { Year: 2010, NY: 2, CA: 0 },
      { Year: 2011, NY: 4, CA: 0 },
      { Year: 2012, NY: 3, CA: 2 },
      { Year: 2013, NY: 2, CA: 1 },
      { Year: 2014, NY: 4, CA: 1 },
      { Year: 2015, NY: 2, CA: 2 },
      { Year: 2016, NY: 3, CA: 2 },
      { Year: 2017, NY: 3, CA: 3 },
      { Year: 2018, NY: 5, CA: 2 },
      { Year: 2019, NY: 1, CA: 1 },
      { Year: 2020, NY: 4, CA: 2 },
      { Year: 2021, NY: 6, CA: 3 },
      { Year: 2022, NY: 4, CA: 2 },
      { Year: 2023, NY: 7, CA: 1 },
      { Year: 2024, NY: 10, CA: 0 },
    ];
  console.log('Climate data:', ki);
  const Di = new zi.Map({
    container: 'map',
    style: 'https://demotiles.maplibre.org/globe.json',
    center: [-95.5795, 37.8283],
    zoom: 3.9,
    interactive: !1,
  });
  function Ri(t, e, i) {
    Di.flyTo({ center: [t, e], zoom: i, essential: !0 });
  }
  Di.on('load', () => {
    Di.setProjection('equalEarth'),
      Di.resize(),
      Di.fitBounds([
        [-125.0011, 24.9493],
        [-66.9326, 49.5904],
      ]);
  });
  document.getElementById('show').addEventListener('click', function () {
    const t = document.getElementById('birth-year').value;
    console.log(t);
    const e = document.getElementById('state').value;
    console.log(e);
    const i = ki.find((e) => e.Year == t);
    console.log(i),
      (document.getElementById('results').innerHTML = `Year: ${i.Year}<br>`);
  }),
    console.log(zi),
    console.log(Di);
  const Li = (function (t) {
    return 'string' == typeof t
      ? new Ct([document.querySelectorAll(t)], [document.documentElement])
      : new Ct([P(t)], It);
  })('.scroll');
  Li.each(function () {
    const t = (function (t) {
        return 'string' == typeof t
          ? new Ct([[document.querySelector(t)]], [document.documentElement])
          : new Ct([[t]], It);
      })(this),
      e = t.select('.scroll__graphic'),
      i = e.select('.chart'),
      r = t.select('.scroll__text').selectAll('.step'),
      n = c();
    function o() {
      const t = Math.floor(0.5 * window.innerHeight);
      r.style('height', t + 'px');
      const i = window.innerHeight / 2,
        o = (window.innerHeight - i) / 2;
      e.style('height', i + 'px').style('top', o + 'px'), n.resize();
    }
    function a(t) {
      console.log('handleStepEnter', t),
        r.classed('is-active', function (e, i) {
          return i === t.index;
        });
      const e = t.index + 1,
        n = i.attr('id');
      console.log('Chart ID:', n, 'Active Step:', e),
        i.selectAll('p').remove(),
        'chart1' === n &&
          (1 == e
            ? (console.log('DO THE STEP ONE STUFF...'),
              Ri(139.69576323910474, 35.69253813331217, 4))
            : 2 == e
            ? (console.log('DO THE STEP TWO STUFF...'),
              Ri(-95.5795, 37.8283, 4))
            : 3 == e
            ? (console.log('DO THE STEP THREE STUFF...'),
              Ri(-95.5795, 37.8283, 4))
            : 4 == e &&
              (console.log('DO THE STEP FOUR STUFF...'),
              i
                .append('p')
                .text(
                  'orange overlay for autumn, animation of leaves falling?'
                ))),
        console.log('After everything - activeStep:', e, 'chartID:', n);
    }
    !(function () {
      console.log('init'), o();
      const e = t.node();
      n
        .setup({
          container: e,
          graphic: '.scroll__graphic',
          text: '.scroll__text',
          step: e.querySelectorAll('.scroll__text .step'),
          offset: 0.5,
          debug: !1,
        })
        .onStepEnter(a),
        window.addEventListener('resize', o);
    })();
  });
})();
//# sourceMappingURL=app.99c31be7.js.map
